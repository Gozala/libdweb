;(function() {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require
          if (!f && c) return c(i, !0)
          if (u) return u(i, !0)
          var a = new Error("Cannot find module '" + i + "'")
          throw ((a.code = "MODULE_NOT_FOUND"), a)
        }
        var p = (n[i] = { exports: {} })
        e[i][0].call(
          p.exports,
          function(r) {
            var n = e[i][1][r]
            return o(n || r)
          },
          p,
          p.exports,
          r,
          e,
          n,
          t
        )
      }
      return n[i].exports
    }
    for (
      var u = "function" == typeof require && require, i = 0;
      i < t.length;
      i++
    )
      o(t[i])
    return o
  }
  return r
})()(
  {
    1: [
      function(require, module, exports) {
        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
        /* eslint-disable no-proto */

        "use strict"

        var base64 = require("base64-js")
        var ieee754 = require("ieee754")

        exports.Buffer = Buffer
        exports.SlowBuffer = SlowBuffer
        exports.INSPECT_MAX_BYTES = 50

        var K_MAX_LENGTH = 0x7fffffff
        exports.kMaxLength = K_MAX_LENGTH

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Print warning and recommend using `buffer` v4.x which has an Object
         *               implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * We report that the browser does not support typed arrays if the are not subclassable
         * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
         * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
         * for __proto__ and has a buggy typed array implementation.
         */
        Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

        if (
          !Buffer.TYPED_ARRAY_SUPPORT &&
          typeof console !== "undefined" &&
          typeof console.error === "function"
        ) {
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by " +
              "`buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          )
        }

        function typedArraySupport() {
          // Can typed array instances can be augmented?
          try {
            var arr = new Uint8Array(1)
            arr.__proto__ = {
              __proto__: Uint8Array.prototype,
              foo: function() {
                return 42
              }
            }
            return arr.foo() === 42
          } catch (e) {
            return false
          }
        }

        Object.defineProperty(Buffer.prototype, "parent", {
          get: function() {
            if (!(this instanceof Buffer)) {
              return undefined
            }
            return this.buffer
          }
        })

        Object.defineProperty(Buffer.prototype, "offset", {
          get: function() {
            if (!(this instanceof Buffer)) {
              return undefined
            }
            return this.byteOffset
          }
        })

        function createBuffer(length) {
          if (length > K_MAX_LENGTH) {
            throw new RangeError("Invalid typed array length")
          }
          // Return an augmented `Uint8Array` instance
          var buf = new Uint8Array(length)
          buf.__proto__ = Buffer.prototype
          return buf
        }

        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */

        function Buffer(arg, encodingOrOffset, length) {
          // Common case.
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string") {
              throw new Error(
                "If encoding is specified then the first argument must be a string"
              )
            }
            return allocUnsafe(arg)
          }
          return from(arg, encodingOrOffset, length)
        }

        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        if (
          typeof Symbol !== "undefined" &&
          Symbol.species &&
          Buffer[Symbol.species] === Buffer
        ) {
          Object.defineProperty(Buffer, Symbol.species, {
            value: null,
            configurable: true,
            enumerable: false,
            writable: false
          })
        }

        Buffer.poolSize = 8192 // not used by this implementation

        function from(value, encodingOrOffset, length) {
          if (typeof value === "number") {
            throw new TypeError('"value" argument must not be a number')
          }

          if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
            return fromArrayBuffer(value, encodingOrOffset, length)
          }

          if (typeof value === "string") {
            return fromString(value, encodingOrOffset)
          }

          return fromObject(value)
        }

        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/
        Buffer.from = function(value, encodingOrOffset, length) {
          return from(value, encodingOrOffset, length)
        }

        // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
        // https://github.com/feross/buffer/pull/148
        Buffer.prototype.__proto__ = Uint8Array.prototype
        Buffer.__proto__ = Uint8Array

        function assertSize(size) {
          if (typeof size !== "number") {
            throw new TypeError('"size" argument must be of type number')
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative')
          }
        }

        function alloc(size, fill, encoding) {
          assertSize(size)
          if (size <= 0) {
            return createBuffer(size)
          }
          if (fill !== undefined) {
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpretted as a start offset.
            return typeof encoding === "string"
              ? createBuffer(size).fill(fill, encoding)
              : createBuffer(size).fill(fill)
          }
          return createBuffer(size)
        }

        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/
        Buffer.alloc = function(size, fill, encoding) {
          return alloc(size, fill, encoding)
        }

        function allocUnsafe(size) {
          assertSize(size)
          return createBuffer(size < 0 ? 0 : checked(size) | 0)
        }

        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */
        Buffer.allocUnsafe = function(size) {
          return allocUnsafe(size)
        }
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */
        Buffer.allocUnsafeSlow = function(size) {
          return allocUnsafe(size)
        }

        function fromString(string, encoding) {
          if (typeof encoding !== "string" || encoding === "") {
            encoding = "utf8"
          }

          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding)
          }

          var length = byteLength(string, encoding) | 0
          var buf = createBuffer(length)

          var actual = buf.write(string, encoding)

          if (actual !== length) {
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            buf = buf.slice(0, actual)
          }

          return buf
        }

        function fromArrayLike(array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0
          var buf = createBuffer(length)
          for (var i = 0; i < length; i += 1) {
            buf[i] = array[i] & 255
          }
          return buf
        }

        function fromArrayBuffer(array, byteOffset, length) {
          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError('"offset" is outside of buffer bounds')
          }

          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('"length" is outside of buffer bounds')
          }

          var buf
          if (byteOffset === undefined && length === undefined) {
            buf = new Uint8Array(array)
          } else if (length === undefined) {
            buf = new Uint8Array(array, byteOffset)
          } else {
            buf = new Uint8Array(array, byteOffset, length)
          }

          // Return an augmented `Uint8Array` instance
          buf.__proto__ = Buffer.prototype
          return buf
        }

        function fromObject(obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0
            var buf = createBuffer(len)

            if (buf.length === 0) {
              return buf
            }

            obj.copy(buf, 0, 0, len)
            return buf
          }

          if (obj) {
            if (ArrayBuffer.isView(obj) || "length" in obj) {
              if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                return createBuffer(0)
              }
              return fromArrayLike(obj)
            }

            if (obj.type === "Buffer" && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data)
            }
          }

          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object."
          )
        }

        function checked(length) {
          // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= K_MAX_LENGTH) {
            throw new RangeError(
              "Attempt to allocate Buffer larger than maximum " +
                "size: 0x" +
                K_MAX_LENGTH.toString(16) +
                " bytes"
            )
          }
          return length | 0
        }

        function SlowBuffer(length) {
          if (+length != length) {
            // eslint-disable-line eqeqeq
            length = 0
          }
          return Buffer.alloc(+length)
        }

        Buffer.isBuffer = function isBuffer(b) {
          return b != null && b._isBuffer === true
        }

        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError("Arguments must be Buffers")
          }

          if (a === b) return 0

          var x = a.length
          var y = b.length

          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i]
              y = b[i]
              break
            }
          }

          if (x < y) return -1
          if (y < x) return 1
          return 0
        }

        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true
            default:
              return false
          }
        }

        Buffer.concat = function concat(list, length) {
          if (!Array.isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers')
          }

          if (list.length === 0) {
            return Buffer.alloc(0)
          }

          var i
          if (length === undefined) {
            length = 0
            for (i = 0; i < list.length; ++i) {
              length += list[i].length
            }
          }

          var buffer = Buffer.allocUnsafe(length)
          var pos = 0
          for (i = 0; i < list.length; ++i) {
            var buf = list[i]
            if (ArrayBuffer.isView(buf)) {
              buf = Buffer.from(buf)
            }
            if (!Buffer.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers')
            }
            buf.copy(buffer, pos)
            pos += buf.length
          }
          return buffer
        }

        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length
          }
          if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
            return string.byteLength
          }
          if (typeof string !== "string") {
            string = "" + string
          }

          var len = string.length
          if (len === 0) return 0

          // Use a for loop to avoid recursion
          var loweredCase = false
          for (;;) {
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len
              case "utf8":
              case "utf-8":
              case undefined:
                return utf8ToBytes(string).length
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2
              case "hex":
                return len >>> 1
              case "base64":
                return base64ToBytes(string).length
              default:
                if (loweredCase) return utf8ToBytes(string).length // assume utf8
                encoding = ("" + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }
        Buffer.byteLength = byteLength

        function slowToString(encoding, start, end) {
          var loweredCase = false

          // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.

          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
          if (start === undefined || start < 0) {
            start = 0
          }
          // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.
          if (start > this.length) {
            return ""
          }

          if (end === undefined || end > this.length) {
            end = this.length
          }

          if (end <= 0) {
            return ""
          }

          // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
          end >>>= 0
          start >>>= 0

          if (end <= start) {
            return ""
          }

          if (!encoding) encoding = "utf8"

          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end)

              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end)

              case "ascii":
                return asciiSlice(this, start, end)

              case "latin1":
              case "binary":
                return latin1Slice(this, start, end)

              case "base64":
                return base64Slice(this, start, end)

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end)

              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding)
                encoding = (encoding + "").toLowerCase()
                loweredCase = true
            }
          }
        }

        // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
        // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
        // reliably in a browserify context because there could be multiple different
        // copies of the 'buffer' package in use. This method works even for Buffer
        // instances that were created from another copy of the `buffer` package.
        // See: https://github.com/feross/buffer/issues/154
        Buffer.prototype._isBuffer = true

        function swap(b, n, m) {
          var i = b[n]
          b[n] = b[m]
          b[m] = i
        }

        Buffer.prototype.swap16 = function swap16() {
          var len = this.length
          if (len % 2 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 16-bits")
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1)
          }
          return this
        }

        Buffer.prototype.swap32 = function swap32() {
          var len = this.length
          if (len % 4 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 32-bits")
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3)
            swap(this, i + 1, i + 2)
          }
          return this
        }

        Buffer.prototype.swap64 = function swap64() {
          var len = this.length
          if (len % 8 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 64-bits")
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7)
            swap(this, i + 1, i + 6)
            swap(this, i + 2, i + 5)
            swap(this, i + 3, i + 4)
          }
          return this
        }

        Buffer.prototype.toString = function toString() {
          var length = this.length
          if (length === 0) return ""
          if (arguments.length === 0) return utf8Slice(this, 0, length)
          return slowToString.apply(this, arguments)
        }

        Buffer.prototype.toLocaleString = Buffer.prototype.toString

        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b))
            throw new TypeError("Argument must be a Buffer")
          if (this === b) return true
          return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.inspect = function inspect() {
          var str = ""
          var max = exports.INSPECT_MAX_BYTES
          if (this.length > 0) {
            str = this.toString("hex", 0, max)
              .match(/.{2}/g)
              .join(" ")
            if (this.length > max) str += " ... "
          }
          return "<Buffer " + str + ">"
        }

        Buffer.prototype.compare = function compare(
          target,
          start,
          end,
          thisStart,
          thisEnd
        ) {
          if (!Buffer.isBuffer(target)) {
            throw new TypeError("Argument must be a Buffer")
          }

          if (start === undefined) {
            start = 0
          }
          if (end === undefined) {
            end = target ? target.length : 0
          }
          if (thisStart === undefined) {
            thisStart = 0
          }
          if (thisEnd === undefined) {
            thisEnd = this.length
          }

          if (
            start < 0 ||
            end > target.length ||
            thisStart < 0 ||
            thisEnd > this.length
          ) {
            throw new RangeError("out of range index")
          }

          if (thisStart >= thisEnd && start >= end) {
            return 0
          }
          if (thisStart >= thisEnd) {
            return -1
          }
          if (start >= end) {
            return 1
          }

          start >>>= 0
          end >>>= 0
          thisStart >>>= 0
          thisEnd >>>= 0

          if (this === target) return 0

          var x = thisEnd - thisStart
          var y = end - start
          var len = Math.min(x, y)

          var thisCopy = this.slice(thisStart, thisEnd)
          var targetCopy = target.slice(start, end)

          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i]
              y = targetCopy[i]
              break
            }
          }

          if (x < y) return -1
          if (y < x) return 1
          return 0
        }

        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1

          // Normalize byteOffset
          if (typeof byteOffset === "string") {
            encoding = byteOffset
            byteOffset = 0
          } else if (byteOffset > 0x7fffffff) {
            byteOffset = 0x7fffffff
          } else if (byteOffset < -0x80000000) {
            byteOffset = -0x80000000
          }
          byteOffset = +byteOffset // Coerce to Number.
          if (numberIsNaN(byteOffset)) {
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : buffer.length - 1
          }

          // Normalize byteOffset: negative offsets start from the end of the buffer
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset
          if (byteOffset >= buffer.length) {
            if (dir) return -1
            else byteOffset = buffer.length - 1
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0
            else return -1
          }

          // Normalize val
          if (typeof val === "string") {
            val = Buffer.from(val, encoding)
          }

          // Finally, search either indexOf (if dir is true) or lastIndexOf
          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) {
              return -1
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
          } else if (typeof val === "number") {
            val = val & 0xff // Search for a byte value [0-255]
            if (typeof Uint8Array.prototype.indexOf === "function") {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(
                  buffer,
                  val,
                  byteOffset
                )
              } else {
                return Uint8Array.prototype.lastIndexOf.call(
                  buffer,
                  val,
                  byteOffset
                )
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
          }

          throw new TypeError("val must be string, number or Buffer")
        }

        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1
          var arrLength = arr.length
          var valLength = val.length

          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase()
            if (
              encoding === "ucs2" ||
              encoding === "ucs-2" ||
              encoding === "utf16le" ||
              encoding === "utf-16le"
            ) {
              if (arr.length < 2 || val.length < 2) {
                return -1
              }
              indexSize = 2
              arrLength /= 2
              valLength /= 2
              byteOffset /= 2
            }
          }

          function read(buf, i) {
            if (indexSize === 1) {
              return buf[i]
            } else {
              return buf.readUInt16BE(i * indexSize)
            }
          }

          var i
          if (dir) {
            var foundIndex = -1
            for (i = byteOffset; i < arrLength; i++) {
              if (
                read(arr, i) ===
                read(val, foundIndex === -1 ? 0 : i - foundIndex)
              ) {
                if (foundIndex === -1) foundIndex = i
                if (i - foundIndex + 1 === valLength)
                  return foundIndex * indexSize
              } else {
                if (foundIndex !== -1) i -= i - foundIndex
                foundIndex = -1
              }
            }
          } else {
            if (byteOffset + valLength > arrLength)
              byteOffset = arrLength - valLength
            for (i = byteOffset; i >= 0; i--) {
              var found = true
              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false
                  break
                }
              }
              if (found) return i
            }
          }

          return -1
        }

        Buffer.prototype.includes = function includes(
          val,
          byteOffset,
          encoding
        ) {
          return this.indexOf(val, byteOffset, encoding) !== -1
        }

        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
        }

        Buffer.prototype.lastIndexOf = function lastIndexOf(
          val,
          byteOffset,
          encoding
        ) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
        }

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0
          var remaining = buf.length - offset
          if (!length) {
            length = remaining
          } else {
            length = Number(length)
            if (length > remaining) {
              length = remaining
            }
          }

          var strLen = string.length

          if (length > strLen / 2) {
            length = strLen / 2
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16)
            if (numberIsNaN(parsed)) return i
            buf[offset + i] = parsed
          }
          return i
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(
            utf8ToBytes(string, buf.length - offset),
            buf,
            offset,
            length
          )
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length)
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(
            utf16leToBytes(string, buf.length - offset),
            buf,
            offset,
            length
          )
        }

        Buffer.prototype.write = function write(
          string,
          offset,
          length,
          encoding
        ) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = "utf8"
            length = this.length
            offset = 0
            // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === "string") {
            encoding = offset
            length = this.length
            offset = 0
            // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset >>> 0
            if (isFinite(length)) {
              length = length >>> 0
              if (encoding === undefined) encoding = "utf8"
            } else {
              encoding = length
              length = undefined
            }
          } else {
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            )
          }

          var remaining = this.length - offset
          if (length === undefined || length > remaining) length = remaining

          if (
            (string.length > 0 && (length < 0 || offset < 0)) ||
            offset > this.length
          ) {
            throw new RangeError("Attempt to write outside buffer bounds")
          }

          if (!encoding) encoding = "utf8"

          var loweredCase = false
          for (;;) {
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length)

              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length)

              case "ascii":
                return asciiWrite(this, string, offset, length)

              case "latin1":
              case "binary":
                return latin1Write(this, string, offset, length)

              case "base64":
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length)

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length)

              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding)
                encoding = ("" + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }

        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          }
        }

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf)
          } else {
            return base64.fromByteArray(buf.slice(start, end))
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end)
          var res = []

          var i = start
          while (i < end) {
            var firstByte = buf[i]
            var codePoint = null
            var bytesPerSequence =
              firstByte > 0xef
                ? 4
                : firstByte > 0xdf
                  ? 3
                  : firstByte > 0xbf
                    ? 2
                    : 1

            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint

              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte
                  }
                  break
                case 2:
                  secondByte = buf[i + 1]
                  if ((secondByte & 0xc0) === 0x80) {
                    tempCodePoint =
                      ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f)
                    if (tempCodePoint > 0x7f) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 3:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  if (
                    (secondByte & 0xc0) === 0x80 &&
                    (thirdByte & 0xc0) === 0x80
                  ) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0xc) |
                      ((secondByte & 0x3f) << 0x6) |
                      (thirdByte & 0x3f)
                    if (
                      tempCodePoint > 0x7ff &&
                      (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                    ) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 4:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  fourthByte = buf[i + 3]
                  if (
                    (secondByte & 0xc0) === 0x80 &&
                    (thirdByte & 0xc0) === 0x80 &&
                    (fourthByte & 0xc0) === 0x80
                  ) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0x12) |
                      ((secondByte & 0x3f) << 0xc) |
                      ((thirdByte & 0x3f) << 0x6) |
                      (fourthByte & 0x3f)
                    if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint
                    }
                  }
              }
            }

            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xfffd
              bytesPerSequence = 1
            } else if (codePoint > 0xffff) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000
              res.push(((codePoint >>> 10) & 0x3ff) | 0xd800)
              codePoint = 0xdc00 | (codePoint & 0x3ff)
            }

            res.push(codePoint)
            i += bytesPerSequence
          }

          return decodeCodePointsArray(res)
        }

        // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
          }

          // Decode in chunks to avoid "call stack size exceeded".
          var res = ""
          var i = 0
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
            )
          }
          return res
        }

        function asciiSlice(buf, start, end) {
          var ret = ""
          end = Math.min(buf.length, end)

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 0x7f)
          }
          return ret
        }

        function latin1Slice(buf, start, end) {
          var ret = ""
          end = Math.min(buf.length, end)

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i])
          }
          return ret
        }

        function hexSlice(buf, start, end) {
          var len = buf.length

          if (!start || start < 0) start = 0
          if (!end || end < 0 || end > len) end = len

          var out = ""
          for (var i = start; i < end; ++i) {
            out += toHex(buf[i])
          }
          return out
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end)
          var res = ""
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
          }
          return res
        }

        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length
          start = ~~start
          end = end === undefined ? len : ~~end

          if (start < 0) {
            start += len
            if (start < 0) start = 0
          } else if (start > len) {
            start = len
          }

          if (end < 0) {
            end += len
            if (end < 0) end = 0
          } else if (end > len) {
            end = len
          }

          if (end < start) end = start

          var newBuf = this.subarray(start, end)
          // Return an augmented `Uint8Array` instance
          newBuf.__proto__ = Buffer.prototype
          return newBuf
        }

        /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0)
            throw new RangeError("offset is not uint")
          if (offset + ext > length)
            throw new RangeError("Trying to access beyond buffer length")
        }

        Buffer.prototype.readUIntLE = function readUIntLE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }

          return val
        }

        Buffer.prototype.readUIntBE = function readUIntBE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length)
          }

          var val = this[offset + --byteLength]
          var mul = 1
          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul
          }

          return val
        }

        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 1, this.length)
          return this[offset]
        }

        Buffer.prototype.readUInt16LE = function readUInt16LE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          return this[offset] | (this[offset + 1] << 8)
        }

        Buffer.prototype.readUInt16BE = function readUInt16BE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          return (this[offset] << 8) | this[offset + 1]
        }

        Buffer.prototype.readUInt32LE = function readUInt32LE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            (this[offset] |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16)) +
            this[offset + 3] * 0x1000000
          )
        }

        Buffer.prototype.readUInt32BE = function readUInt32BE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            this[offset] * 0x1000000 +
            ((this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3])
          )
        }

        Buffer.prototype.readIntLE = function readIntLE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }
          mul *= 0x80

          if (val >= mul) val -= Math.pow(2, 8 * byteLength)

          return val
        }

        Buffer.prototype.readIntBE = function readIntBE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var i = byteLength
          var mul = 1
          var val = this[offset + --i]
          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul
          }
          mul *= 0x80

          if (val >= mul) val -= Math.pow(2, 8 * byteLength)

          return val
        }

        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 1, this.length)
          if (!(this[offset] & 0x80)) return this[offset]
          return (0xff - this[offset] + 1) * -1
        }

        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset] | (this[offset + 1] << 8)
          return val & 0x8000 ? val | 0xffff0000 : val
        }

        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset + 1] | (this[offset] << 8)
          return val & 0x8000 ? val | 0xffff0000 : val
        }

        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            this[offset] |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16) |
            (this[offset + 3] << 24)
          )
        }

        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            (this[offset] << 24) |
            (this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            this[offset + 3]
          )
        }

        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, true, 23, 4)
        }

        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, false, 23, 4)
        }

        Buffer.prototype.readDoubleLE = function readDoubleLE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, true, 52, 8)
        }

        Buffer.prototype.readDoubleBE = function readDoubleBE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf))
            throw new TypeError('"buffer" argument must be a Buffer instance')
          if (value > max || value < min)
            throw new RangeError('"value" argument is out of bounds')
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range")
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1
            checkInt(this, value, offset, byteLength, maxBytes, 0)
          }

          var mul = 1
          var i = 0
          this[offset] = value & 0xff
          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeUIntBE = function writeUIntBE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1
            checkInt(this, value, offset, byteLength, maxBytes, 0)
          }

          var i = byteLength - 1
          var mul = 1
          this[offset + i] = value & 0xff
          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeUInt8 = function writeUInt8(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
          this[offset] = value & 0xff
          return offset + 1
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          this[offset] = value & 0xff
          this[offset + 1] = value >>> 8
          return offset + 2
        }

        Buffer.prototype.writeUInt16BE = function writeUInt16BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          this[offset] = value >>> 8
          this[offset + 1] = value & 0xff
          return offset + 2
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          this[offset + 3] = value >>> 24
          this[offset + 2] = value >>> 16
          this[offset + 1] = value >>> 8
          this[offset] = value & 0xff
          return offset + 4
        }

        Buffer.prototype.writeUInt32BE = function writeUInt32BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          this[offset] = value >>> 24
          this[offset + 1] = value >>> 16
          this[offset + 2] = value >>> 8
          this[offset + 3] = value & 0xff
          return offset + 4
        }

        Buffer.prototype.writeIntLE = function writeIntLE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1)

            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }

          var i = 0
          var mul = 1
          var sub = 0
          this[offset] = value & 0xff
          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1
            }
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeIntBE = function writeIntBE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1)

            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }

          var i = byteLength - 1
          var mul = 1
          var sub = 0
          this[offset + i] = value & 0xff
          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1
            }
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeInt8 = function writeInt8(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
          if (value < 0) value = 0xff + value + 1
          this[offset] = value & 0xff
          return offset + 1
        }

        Buffer.prototype.writeInt16LE = function writeInt16LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          this[offset] = value & 0xff
          this[offset + 1] = value >>> 8
          return offset + 2
        }

        Buffer.prototype.writeInt16BE = function writeInt16BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          this[offset] = value >>> 8
          this[offset + 1] = value & 0xff
          return offset + 2
        }

        Buffer.prototype.writeInt32LE = function writeInt32LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          this[offset] = value & 0xff
          this[offset + 1] = value >>> 8
          this[offset + 2] = value >>> 16
          this[offset + 3] = value >>> 24
          return offset + 4
        }

        Buffer.prototype.writeInt32BE = function writeInt32BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          if (value < 0) value = 0xffffffff + value + 1
          this[offset] = value >>> 24
          this[offset + 1] = value >>> 16
          this[offset + 2] = value >>> 8
          this[offset + 3] = value & 0xff
          return offset + 4
        }

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range")
          if (offset < 0) throw new RangeError("Index out of range")
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            checkIEEE754(
              buf,
              value,
              offset,
              4,
              3.4028234663852886e38,
              -3.4028234663852886e38
            )
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4)
          return offset + 4
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE(
          value,
          offset,
          noAssert
        ) {
          return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function writeFloatBE(
          value,
          offset,
          noAssert
        ) {
          return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            checkIEEE754(
              buf,
              value,
              offset,
              8,
              1.7976931348623157e308,
              -1.7976931348623157e308
            )
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8)
          return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE(
          value,
          offset,
          noAssert
        ) {
          return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function writeDoubleBE(
          value,
          offset,
          noAssert
        ) {
          return writeDouble(this, value, offset, false, noAssert)
        }

        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!Buffer.isBuffer(target))
            throw new TypeError("argument should be a Buffer")
          if (!start) start = 0
          if (!end && end !== 0) end = this.length
          if (targetStart >= target.length) targetStart = target.length
          if (!targetStart) targetStart = 0
          if (end > 0 && end < start) end = start

          // Copy 0 bytes; we're done
          if (end === start) return 0
          if (target.length === 0 || this.length === 0) return 0

          // Fatal error conditions
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds")
          }
          if (start < 0 || start >= this.length)
            throw new RangeError("Index out of range")
          if (end < 0) throw new RangeError("sourceEnd out of bounds")

          // Are we oob?
          if (end > this.length) end = this.length
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start
          }

          var len = end - start

          if (
            this === target &&
            typeof Uint8Array.prototype.copyWithin === "function"
          ) {
            // Use built-in when available, missing from IE11
            this.copyWithin(targetStart, start, end)
          } else if (
            this === target &&
            start < targetStart &&
            targetStart < end
          ) {
            // descending copy from end
            for (var i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start]
            }
          } else {
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, end),
              targetStart
            )
          }

          return len
        }

        // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start
              start = 0
              end = this.length
            } else if (typeof end === "string") {
              encoding = end
              end = this.length
            }
            if (encoding !== undefined && typeof encoding !== "string") {
              throw new TypeError("encoding must be a string")
            }
            if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding)
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0)
              if (
                (encoding === "utf8" && code < 128) ||
                encoding === "latin1"
              ) {
                // Fast path: If `val` fits into a single byte, use that numeric value.
                val = code
              }
            }
          } else if (typeof val === "number") {
            val = val & 255
          }

          // Invalid ranges are not set to a default, so can range check early.
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError("Out of range index")
          }

          if (end <= start) {
            return this
          }

          start = start >>> 0
          end = end === undefined ? this.length : end >>> 0

          if (!val) val = 0

          var i
          if (typeof val === "number") {
            for (i = start; i < end; ++i) {
              this[i] = val
            }
          } else {
            var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding)
            var len = bytes.length
            if (len === 0) {
              throw new TypeError(
                'The value "' + val + '" is invalid for argument "value"'
              )
            }
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len]
            }
          }

          return this
        }

        // HELPER FUNCTIONS
        // ================

        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

        function base64clean(str) {
          // Node takes equal signs as end of the Base64 encoding
          str = str.split("=")[0]
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = str.trim().replace(INVALID_BASE64_RE, "")
          // Node converts strings with length < 2 to ''
          if (str.length < 2) return ""
          // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
          while (str.length % 4 !== 0) {
            str = str + "="
          }
          return str
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16)
          return n.toString(16)
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity
          var codePoint
          var length = string.length
          var leadSurrogate = null
          var bytes = []

          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i)

            // is surrogate component
            if (codePoint > 0xd7ff && codePoint < 0xe000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xdbff) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                  continue
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                  continue
                }

                // valid lead
                leadSurrogate = codePoint

                continue
              }

              // 2 leads in a row
              if (codePoint < 0xdc00) {
                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                leadSurrogate = codePoint
                continue
              }

              // valid surrogate pair
              codePoint =
                (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                0x10000
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
            }

            leadSurrogate = null

            // encode utf8
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break
              bytes.push(codePoint)
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break
              bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80)
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break
              bytes.push(
                (codePoint >> 0xc) | 0xe0,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80
              )
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break
              bytes.push(
                (codePoint >> 0x12) | 0xf0,
                ((codePoint >> 0xc) & 0x3f) | 0x80,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80
              )
            } else {
              throw new Error("Invalid code point")
            }
          }

          return bytes
        }

        function asciiToBytes(str) {
          var byteArray = []
          for (var i = 0; i < str.length; ++i) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xff)
          }
          return byteArray
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo
          var byteArray = []
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break

            c = str.charCodeAt(i)
            hi = c >> 8
            lo = c % 256
            byteArray.push(lo)
            byteArray.push(hi)
          }

          return byteArray
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str))
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break
            dst[i + offset] = src[i]
          }
          return i
        }

        // ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
        // but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
        function isArrayBuffer(obj) {
          return (
            obj instanceof ArrayBuffer ||
            (obj != null &&
              obj.constructor != null &&
              obj.constructor.name === "ArrayBuffer" &&
              typeof obj.byteLength === "number")
          )
        }

        function numberIsNaN(obj) {
          return obj !== obj // eslint-disable-line no-self-compare
        }
      },
      { "base64-js": 5, ieee754: 36 }
    ],
    2: [
      function(require, module, exports) {
        // crc16 impl, optimized for numeric inputs

        var TABLE = [
          0x0000,
          0x1021,
          0x2042,
          0x3063,
          0x4084,
          0x50a5,
          0x60c6,
          0x70e7,
          0x8108,
          0x9129,
          0xa14a,
          0xb16b,
          0xc18c,
          0xd1ad,
          0xe1ce,
          0xf1ef,
          0x1231,
          0x0210,
          0x3273,
          0x2252,
          0x52b5,
          0x4294,
          0x72f7,
          0x62d6,
          0x9339,
          0x8318,
          0xb37b,
          0xa35a,
          0xd3bd,
          0xc39c,
          0xf3ff,
          0xe3de,
          0x2462,
          0x3443,
          0x0420,
          0x1401,
          0x64e6,
          0x74c7,
          0x44a4,
          0x5485,
          0xa56a,
          0xb54b,
          0x8528,
          0x9509,
          0xe5ee,
          0xf5cf,
          0xc5ac,
          0xd58d,
          0x3653,
          0x2672,
          0x1611,
          0x0630,
          0x76d7,
          0x66f6,
          0x5695,
          0x46b4,
          0xb75b,
          0xa77a,
          0x9719,
          0x8738,
          0xf7df,
          0xe7fe,
          0xd79d,
          0xc7bc,
          0x48c4,
          0x58e5,
          0x6886,
          0x78a7,
          0x0840,
          0x1861,
          0x2802,
          0x3823,
          0xc9cc,
          0xd9ed,
          0xe98e,
          0xf9af,
          0x8948,
          0x9969,
          0xa90a,
          0xb92b,
          0x5af5,
          0x4ad4,
          0x7ab7,
          0x6a96,
          0x1a71,
          0x0a50,
          0x3a33,
          0x2a12,
          0xdbfd,
          0xcbdc,
          0xfbbf,
          0xeb9e,
          0x9b79,
          0x8b58,
          0xbb3b,
          0xab1a,
          0x6ca6,
          0x7c87,
          0x4ce4,
          0x5cc5,
          0x2c22,
          0x3c03,
          0x0c60,
          0x1c41,
          0xedae,
          0xfd8f,
          0xcdec,
          0xddcd,
          0xad2a,
          0xbd0b,
          0x8d68,
          0x9d49,
          0x7e97,
          0x6eb6,
          0x5ed5,
          0x4ef4,
          0x3e13,
          0x2e32,
          0x1e51,
          0x0e70,
          0xff9f,
          0xefbe,
          0xdfdd,
          0xcffc,
          0xbf1b,
          0xaf3a,
          0x9f59,
          0x8f78,
          0x9188,
          0x81a9,
          0xb1ca,
          0xa1eb,
          0xd10c,
          0xc12d,
          0xf14e,
          0xe16f,
          0x1080,
          0x00a1,
          0x30c2,
          0x20e3,
          0x5004,
          0x4025,
          0x7046,
          0x6067,
          0x83b9,
          0x9398,
          0xa3fb,
          0xb3da,
          0xc33d,
          0xd31c,
          0xe37f,
          0xf35e,
          0x02b1,
          0x1290,
          0x22f3,
          0x32d2,
          0x4235,
          0x5214,
          0x6277,
          0x7256,
          0xb5ea,
          0xa5cb,
          0x95a8,
          0x8589,
          0xf56e,
          0xe54f,
          0xd52c,
          0xc50d,
          0x34e2,
          0x24c3,
          0x14a0,
          0x0481,
          0x7466,
          0x6447,
          0x5424,
          0x4405,
          0xa7db,
          0xb7fa,
          0x8799,
          0x97b8,
          0xe75f,
          0xf77e,
          0xc71d,
          0xd73c,
          0x26d3,
          0x36f2,
          0x0691,
          0x16b0,
          0x6657,
          0x7676,
          0x4615,
          0x5634,
          0xd94c,
          0xc96d,
          0xf90e,
          0xe92f,
          0x99c8,
          0x89e9,
          0xb98a,
          0xa9ab,
          0x5844,
          0x4865,
          0x7806,
          0x6827,
          0x18c0,
          0x08e1,
          0x3882,
          0x28a3,
          0xcb7d,
          0xdb5c,
          0xeb3f,
          0xfb1e,
          0x8bf9,
          0x9bd8,
          0xabbb,
          0xbb9a,
          0x4a75,
          0x5a54,
          0x6a37,
          0x7a16,
          0x0af1,
          0x1ad0,
          0x2ab3,
          0x3a92,
          0xfd2e,
          0xed0f,
          0xdd6c,
          0xcd4d,
          0xbdaa,
          0xad8b,
          0x9de8,
          0x8dc9,
          0x7c26,
          0x6c07,
          0x5c64,
          0x4c45,
          0x3ca2,
          0x2c83,
          0x1ce0,
          0x0cc1,
          0xef1f,
          0xff3e,
          0xcf5d,
          0xdf7c,
          0xaf9b,
          0xbfba,
          0x8fd9,
          0x9ff8,
          0x6e17,
          0x7e36,
          0x4e55,
          0x5e74,
          0x2e93,
          0x3eb2,
          0x0ed1,
          0x1ef0
        ]

        module.exports = crc16

        function crc16(n) {
          var crc = 0
          var r = 0

          for (var i = 0; i < 8; i++) {
            r = n & 0xff
            n = (n - r) / 256
            crc = ((crc << 8) ^ TABLE[((crc >> 8) ^ r) & 0xff]) & 0xffff
          }

          return crc
        }
      },
      {}
    ],
    3: [
      function(require, module, exports) {
        var hash = require("./crc16")

        module.exports = LRU

        function LRU(max, opts) {
          if (!(this instanceof LRU)) return new LRU(max, opts)
          if (!opts) opts = {}

          // how many collisions before evicting (factor of two for fast modulo)
          this.collisions = factorOfTwo(opts.collisions || opts.bucketSize || 4)
          // buckets should be a factor of two for fast modulo as well
          this.buckets = factorOf(max, this.collisions) / this.collisions

          // we use 16bit hashing to bucket index must be <0xffff
          while (this.buckets > 65536) {
            this.buckets >>= 1
            this.collisions <<= 1
          }

          this.size = this.buckets * this.collisions
          this.wrap = !opts.indexedValues
          this.cache = new Array(this.size)
          this.hash =
            this.buckets === 65536 ? hash : maskedHash(this.buckets - 1)
          this.evict = opts.evict || null
        }

        LRU.prototype.set = function(index, val) {
          var pageStart = this.collisions * this.hash(index)
          var pageEnd = pageStart + this.collisions
          var ptr = pageStart
          var page = null

          while (ptr < pageEnd) {
            page = this.cache[ptr]

            if (!page) {
              // no exiting version, but we have space to store it
              page = this.cache[ptr] = this.wrap ? new Node(index, val) : val
              move(this.cache, pageStart, ptr, page)
              return
            }

            if (page.index === index) {
              // update existing version and move to head of bucket
              if (this.wrap) page.value = val
              else this.cache[ptr] = val
              move(this.cache, pageStart, ptr, page)
              return
            }

            ptr++
          }

          // bucket is full, update oldest (last element in bucket)
          if (this.wrap) {
            if (this.evict) this.evict(page.index, page.value)
            page.index = index
            page.value = val
          } else {
            if (this.evict) this.evict(page.index, page)
            this.cache[ptr - 1] = val
          }
          move(this.cache, pageStart, ptr - 1, page)
        }

        LRU.prototype.get = function(index) {
          var pageStart = this.collisions * this.hash(index)
          var pageEnd = pageStart + this.collisions
          var ptr = pageStart

          while (ptr < pageEnd) {
            var page = this.cache[ptr++]

            if (!page) return null
            if (page.index !== index) continue

            // we found it! move to head of bucket and return value
            move(this.cache, pageStart, ptr - 1, page)

            return this.wrap ? page.value : page
          }

          return null
        }

        function move(list, index, itemIndex, item) {
          while (itemIndex > index) list[itemIndex] = list[--itemIndex]
          list[index] = item
        }

        function Node(index, value) {
          this.index = index
          this.value = value
        }

        function factorOf(n, factor) {
          n = factorOfTwo(n)
          while (n & (factor - 1)) n <<= 1
          return n
        }

        function factorOfTwo(n) {
          if (n && !(n & (n - 1))) return n
          var p = 1
          while (p < n) p <<= 1
          return p
        }

        function maskedHash(mask) {
          return function(n) {
            return hash(n) & mask
          }
        }
      },
      { "./crc16": 2 }
    ],
    4: [
      function(require, module, exports) {
        module.exports = batcher

        function batcher(run) {
          var running = false
          var pendingBatch = null
          var pendingCallbacks = null
          var callbacks = null

          return append

          function done(err) {
            if (callbacks) callAll(callbacks, err)

            running = false
            callbacks = pendingCallbacks
            var nextBatch = pendingBatch

            pendingBatch = null
            pendingCallbacks = null

            if (!nextBatch || !nextBatch.length) {
              if (!callbacks || !callbacks.length) {
                callbacks = null
                return
              }
              if (!nextBatch) nextBatch = []
            }

            running = true
            run(nextBatch, done)
          }

          function append(val, cb) {
            if (running) {
              if (!pendingBatch) {
                pendingBatch = []
                pendingCallbacks = []
              }
              pushAll(pendingBatch, val)
              if (cb) pendingCallbacks.push(cb)
            } else {
              if (cb) callbacks = [cb]
              running = true
              run(Array.isArray(val) ? val : [val], done)
            }
          }
        }

        function pushAll(list, val) {
          if (Array.isArray(val)) pushArray(list, val)
          else list.push(val)
        }

        function pushArray(list, val) {
          for (var i = 0; i < val.length; i++) list.push(val[i])
        }

        function callAll(list, err) {
          for (var i = 0; i < list.length; i++) list[i](err)
        }
      },
      {}
    ],
    5: [
      function(require, module, exports) {
        "use strict"

        exports.byteLength = byteLength
        exports.toByteArray = toByteArray
        exports.fromByteArray = fromByteArray

        var lookup = []
        var revLookup = []
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array

        var code =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i]
          revLookup[code.charCodeAt(i)] = i
        }

        // Support decoding URL-safe base64 strings, as Node.js does.
        // See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup["-".charCodeAt(0)] = 62
        revLookup["_".charCodeAt(0)] = 63

        function getLens(b64) {
          var len = b64.length

          if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4")
          }

          // Trim off extra bytes after placeholder bytes are found
          // See: https://github.com/beatgammit/base64-js/issues/42
          var validLen = b64.indexOf("=")
          if (validLen === -1) validLen = len

          var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4)

          return [validLen, placeHoldersLen]
        }

        // base64 is 4/3 + up to two characters of the original data
        function byteLength(b64) {
          var lens = getLens(b64)
          var validLen = lens[0]
          var placeHoldersLen = lens[1]
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
        }

        function _byteLength(b64, validLen, placeHoldersLen) {
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
        }

        function toByteArray(b64) {
          var tmp
          var lens = getLens(b64)
          var validLen = lens[0]
          var placeHoldersLen = lens[1]

          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

          var curByte = 0

          // if there are placeholders, only get up to the last complete 4 chars
          var len = placeHoldersLen > 0 ? validLen - 4 : validLen

          for (var i = 0; i < len; i += 4) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 18) |
              (revLookup[b64.charCodeAt(i + 1)] << 12) |
              (revLookup[b64.charCodeAt(i + 2)] << 6) |
              revLookup[b64.charCodeAt(i + 3)]
            arr[curByte++] = (tmp >> 16) & 0xff
            arr[curByte++] = (tmp >> 8) & 0xff
            arr[curByte++] = tmp & 0xff
          }

          if (placeHoldersLen === 2) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 2) |
              (revLookup[b64.charCodeAt(i + 1)] >> 4)
            arr[curByte++] = tmp & 0xff
          }

          if (placeHoldersLen === 1) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 10) |
              (revLookup[b64.charCodeAt(i + 1)] << 4) |
              (revLookup[b64.charCodeAt(i + 2)] >> 2)
            arr[curByte++] = (tmp >> 8) & 0xff
            arr[curByte++] = tmp & 0xff
          }

          return arr
        }

        function tripletToBase64(num) {
          return (
            lookup[(num >> 18) & 0x3f] +
            lookup[(num >> 12) & 0x3f] +
            lookup[(num >> 6) & 0x3f] +
            lookup[num & 0x3f]
          )
        }

        function encodeChunk(uint8, start, end) {
          var tmp
          var output = []
          for (var i = start; i < end; i += 3) {
            tmp =
              ((uint8[i] << 16) & 0xff0000) +
              ((uint8[i + 1] << 8) & 0xff00) +
              (uint8[i + 2] & 0xff)
            output.push(tripletToBase64(tmp))
          }
          return output.join("")
        }

        function fromByteArray(uint8) {
          var tmp
          var len = uint8.length
          var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
          var parts = []
          var maxChunkLength = 16383 // must be multiple of 3

          // go through the array every three bytes, we'll deal with trailing stuff later
          for (
            var i = 0, len2 = len - extraBytes;
            i < len2;
            i += maxChunkLength
          ) {
            parts.push(
              encodeChunk(
                uint8,
                i,
                i + maxChunkLength > len2 ? len2 : i + maxChunkLength
              )
            )
          }

          // pad the end with zeros, but make sure to not forget the extra bytes
          if (extraBytes === 1) {
            tmp = uint8[len - 1]
            parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==")
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1]
            parts.push(
              lookup[tmp >> 10] +
                lookup[(tmp >> 4) & 0x3f] +
                lookup[(tmp << 2) & 0x3f] +
                "="
            )
          }

          return parts.join("")
        }
      },
      {}
    ],
    6: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var varint = require("varint")

          exports.encode = encode
          exports.encode.bytes = 0
          exports.encodingLength = encodingLength

          exports.decode = decode
          exports.decode.bytes = 0
          exports.decodingLength = decodingLength

          function State(input, output, offset) {
            this.inputOffset = 0
            this.inputLength = input.length
            this.input = input
            this.outputOffset = offset
            this.output = output
          }

          function encode(bitfield, buffer, offset) {
            if (!offset) offset = 0
            if (!buffer) buffer = new Buffer(encodingLength(bitfield))
            var state = new State(bitfield, buffer, offset)
            rle(state)
            encode.bytes = state.outputOffset - offset
            return buffer
          }

          function encodingLength(bitfield) {
            var state = new State(bitfield, null, 0)
            rle(state)
            return state.outputOffset
          }

          function decode(buffer, offset) {
            if (!offset) offset = 0

            var bitfield = new Buffer(decodingLength(buffer, offset))
            var ptr = 0

            while (offset < buffer.length) {
              var next = varint.decode(buffer, offset)
              var repeat = next & 1
              var len = repeat ? (next - (next & 3)) / 4 : next / 2

              offset += varint.decode.bytes

              if (repeat) {
                bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len)
              } else {
                buffer.copy(bitfield, ptr, offset, offset + len)
                offset += len
              }

              ptr += len
            }

            decode.bytes = buffer.length - offset

            return bitfield
          }

          function decodingLength(buffer, offset) {
            if (!offset) offset = 0

            var len = 0

            while (offset < buffer.length) {
              var next = varint.decode(buffer, offset)
              offset += varint.decode.bytes

              var repeat = next & 1
              var slice = repeat ? (next - (next & 3)) / 4 : next / 2

              len += slice
              if (!repeat) offset += slice
            }

            if (offset > buffer.length) throw new Error("Invalid RLE bitfield")

            return len
          }

          function rle(state) {
            var len = 0
            var bits = 0
            var input = state.input

            while (state.inputLength > 0 && !input[state.inputLength - 1])
              state.inputLength--

            for (var i = 0; i < state.inputLength; i++) {
              if (input[i] === bits) {
                len++
                continue
              }

              if (len) encodeUpdate(state, i, len, bits)

              if (input[i] === 0 || input[i] === 255) {
                bits = input[i]
                len = 1
              } else {
                len = 0
              }
            }

            if (len) encodeUpdate(state, state.inputLength, len, bits)
            encodeFinal(state)
          }

          function encodeHead(state, end) {
            var headLength = end - state.inputOffset
            varint.encode(2 * headLength, state.output, state.outputOffset)
            state.outputOffset += varint.encode.bytes
            state.input.copy(
              state.output,
              state.outputOffset,
              state.inputOffset,
              end
            )
            state.outputOffset += headLength
          }

          function encodeFinal(state) {
            var headLength = state.inputLength - state.inputOffset
            if (!headLength) return

            if (!state.output) {
              state.outputOffset +=
                headLength + varint.encodingLength(2 * headLength)
            } else {
              encodeHead(state, state.inputLength)
            }

            state.inputOffset = state.inputLength
          }

          function encodeUpdate(state, i, len, bit) {
            var headLength = i - len - state.inputOffset
            var headCost = headLength
              ? varint.encodingLength(2 * headLength) + headLength
              : 0
            var enc = 4 * len + (bit ? 2 : 0) + 1 // len << 2 | bit << 1 | 1
            var encCost = headCost + varint.encodingLength(enc)
            var baseCost =
              varint.encodingLength(2 * (i - state.inputOffset)) +
              i -
              state.inputOffset

            if (encCost >= baseCost) return

            if (!state.output) {
              state.outputOffset += encCost
              state.inputOffset = i
              return
            }

            if (headLength) encodeHead(state, i - len)

            varint.encode(enc, state.output, state.outputOffset)
            state.outputOffset += varint.encode.bytes
            state.inputOffset = i
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, varint: 9 }
    ],
    7: [
      function(require, module, exports) {
        module.exports = read

        var MSB = 0x80,
          REST = 0x7f

        function read(buf, offset) {
          var res = 0,
            offset = offset || 0,
            shift = 0,
            counter = offset,
            b,
            l = buf.length

          do {
            if (counter >= l) {
              read.bytes = 0
              read.bytesRead = 0 // DEPRECATED
              return undefined
            }
            b = buf[counter++]
            res +=
              shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift)
            shift += 7
          } while (b >= MSB)

          read.bytes = counter - offset

          return res
        }
      },
      {}
    ],
    8: [
      function(require, module, exports) {
        module.exports = encode

        var MSB = 0x80,
          REST = 0x7f,
          MSBALL = ~REST,
          INT = Math.pow(2, 31)

        function encode(num, out, offset) {
          out = out || []
          offset = offset || 0
          var oldOffset = offset

          while (num >= INT) {
            out[offset++] = (num & 0xff) | MSB
            num /= 128
          }
          while (num & MSBALL) {
            out[offset++] = (num & 0xff) | MSB
            num >>>= 7
          }
          out[offset] = num | 0

          encode.bytes = offset - oldOffset + 1

          return out
        }
      },
      {}
    ],
    9: [
      function(require, module, exports) {
        module.exports = {
          encode: require("./encode.js"),
          decode: require("./decode.js"),
          encodingLength: require("./length.js")
        }
      },
      { "./decode.js": 7, "./encode.js": 8, "./length.js": 10 }
    ],
    10: [
      function(require, module, exports) {
        var N1 = Math.pow(2, 7)
        var N2 = Math.pow(2, 14)
        var N3 = Math.pow(2, 21)
        var N4 = Math.pow(2, 28)
        var N5 = Math.pow(2, 35)
        var N6 = Math.pow(2, 42)
        var N7 = Math.pow(2, 49)
        var N8 = Math.pow(2, 56)
        var N9 = Math.pow(2, 63)

        module.exports = function(value) {
          return value < N1
            ? 1
            : value < N2
              ? 2
              : value < N3
                ? 3
                : value < N4
                  ? 4
                  : value < N5
                    ? 5
                    : value < N6
                      ? 6
                      : value < N7
                        ? 7
                        : value < N8
                          ? 8
                          : value < N9
                            ? 9
                            : 10
        }
      },
      {}
    ],
    11: [
      function(require, module, exports) {
        module.exports = loadWebAssembly

        loadWebAssembly.supported = typeof WebAssembly !== "undefined"

        function loadWebAssembly(opts) {
          if (!loadWebAssembly.supported) return null

          var imp = opts && opts.imports
          var wasm = toUint8Array(
            "AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL"
          )
          var ready = null

          var mod = {
            buffer: wasm,
            memory: null,
            exports: null,
            realloc: realloc,
            onload: onload
          }

          onload(function() {})

          return mod

          function realloc(size) {
            mod.exports.memory.grow(
              Math.ceil(Math.abs(size - mod.memory.length) / 65536)
            )
            mod.memory = new Uint8Array(mod.exports.memory.buffer)
          }

          function onload(cb) {
            if (mod.exports) return cb()

            if (ready) {
              ready.then(cb.bind(null, null)).catch(cb)
              return
            }

            try {
              if (opts && opts.async) throw new Error("async")
              setup({
                instance: new WebAssembly.Instance(
                  new WebAssembly.Module(wasm),
                  imp
                )
              })
            } catch (err) {
              ready = WebAssembly.instantiate(wasm, imp).then(setup)
            }

            onload(cb)
          }

          function setup(w) {
            mod.exports = w.instance.exports
            mod.memory =
              mod.exports.memory &&
              mod.exports.memory.buffer &&
              new Uint8Array(mod.exports.memory.buffer)
          }
        }

        function toUint8Array(s) {
          if (typeof atob === "function")
            return new Uint8Array(
              atob(s)
                .split("")
                .map(charCodeAt)
            )
          return new (require("buf" + "fer")).Buffer(s, "base64")
        }

        function charCodeAt(c) {
          return c.charCodeAt(0)
        }
      },
      {}
    ],
    12: [
      function(require, module, exports) {
        var assert = require("nanoassert")
        var wasm = require("./blake2b")()

        var head = 64
        var freeList = []

        module.exports = Blake2b
        var BYTES_MIN = (module.exports.BYTES_MIN = 16)
        var BYTES_MAX = (module.exports.BYTES_MAX = 64)
        var BYTES = (module.exports.BYTES = 32)
        var KEYBYTES_MIN = (module.exports.KEYBYTES_MIN = 16)
        var KEYBYTES_MAX = (module.exports.KEYBYTES_MAX = 64)
        var KEYBYTES = (module.exports.KEYBYTES = 32)
        var SALTBYTES = (module.exports.SALTBYTES = 16)
        var PERSONALBYTES = (module.exports.PERSONALBYTES = 16)

        function Blake2b(digestLength, key, salt, personal, noAssert) {
          if (!(this instanceof Blake2b))
            return new Blake2b(digestLength, key, salt, personal, noAssert)
          if (!(wasm && wasm.exports))
            throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)")
          if (!digestLength) digestLength = 32

          if (noAssert !== true) {
            assert(
              digestLength >= BYTES_MIN,
              "digestLength must be at least " +
                BYTES_MIN +
                ", was given " +
                digestLength
            )
            assert(
              digestLength <= BYTES_MAX,
              "digestLength must be at most " +
                BYTES_MAX +
                ", was given " +
                digestLength
            )
            if (key != null)
              assert(
                key.length >= KEYBYTES_MIN,
                "key must be at least " +
                  KEYBYTES_MIN +
                  ", was given " +
                  key.length
              )
            if (key != null)
              assert(
                key.length <= KEYBYTES_MAX,
                "key must be at least " +
                  KEYBYTES_MAX +
                  ", was given " +
                  key.length
              )
            if (salt != null)
              assert(
                salt.length === SALTBYTES,
                "salt must be exactly " +
                  SALTBYTES +
                  ", was given " +
                  salt.length
              )
            if (personal != null)
              assert(
                personal.length === PERSONALBYTES,
                "personal must be exactly " +
                  PERSONALBYTES +
                  ", was given " +
                  personal.length
              )
          }

          if (!freeList.length) {
            freeList.push(head)
            head += 216
          }

          this.digestLength = digestLength
          this.finalized = false
          this.pointer = freeList.pop()

          wasm.memory.fill(0, 0, 64)
          wasm.memory[0] = this.digestLength
          wasm.memory[1] = key ? key.length : 0
          wasm.memory[2] = 1 // fanout
          wasm.memory[3] = 1 // depth

          if (salt) wasm.memory.set(salt, 32)
          if (personal) wasm.memory.set(personal, 48)

          if (this.pointer + 216 > wasm.memory.length)
            wasm.realloc(this.pointer + 216) // we need 216 bytes for the state
          wasm.exports.blake2b_init(this.pointer, this.digestLength)

          if (key) {
            this.update(key)
            wasm.memory.fill(0, head, head + key.length) // whiteout key
            wasm.memory[this.pointer + 200] = 128
          }
        }

        Blake2b.prototype.update = function(input) {
          assert(this.finalized === false, "Hash instance finalized")
          assert(input, "input must be TypedArray or Buffer")

          if (head + input.length > wasm.memory.length)
            wasm.realloc(head + input.length)
          wasm.memory.set(input, head)
          wasm.exports.blake2b_update(this.pointer, head, head + input.length)
          return this
        }

        Blake2b.prototype.digest = function(enc) {
          assert(this.finalized === false, "Hash instance finalized")
          this.finalized = true

          freeList.push(this.pointer)
          wasm.exports.blake2b_final(this.pointer)

          if (!enc || enc === "binary") {
            return wasm.memory.slice(
              this.pointer + 128,
              this.pointer + 128 + this.digestLength
            )
          }

          if (enc === "hex") {
            return hexSlice(wasm.memory, this.pointer + 128, this.digestLength)
          }

          assert(
            enc.length >= this.digestLength,
            "input must be TypedArray or Buffer"
          )
          for (var i = 0; i < this.digestLength; i++) {
            enc[i] = wasm.memory[this.pointer + 128 + i]
          }

          return enc
        }

        // libsodium compat
        Blake2b.prototype.final = Blake2b.prototype.digest

        Blake2b.WASM = wasm && wasm.buffer
        Blake2b.SUPPORTED = typeof WebAssembly !== "undefined"

        Blake2b.ready = function(cb) {
          if (!cb) cb = noop
          if (!wasm) return cb(new Error("WebAssembly not supported"))

          // backwards compat, can be removed in a new major
          var p = new Promise(function(reject, resolve) {
            wasm.onload(function(err) {
              if (err) resolve()
              else reject()
              cb(err)
            })
          })

          return p
        }

        Blake2b.prototype.ready = Blake2b.ready

        function noop() {}

        function hexSlice(buf, start, len) {
          var str = ""
          for (var i = 0; i < len; i++) str += toHex(buf[start + i])
          return str
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16)
          return n.toString(16)
        }
      },
      { "./blake2b": 11, nanoassert: 42 }
    ],
    13: [
      function(require, module, exports) {
        var assert = require("nanoassert")
        var b2wasm = require("blake2b-wasm")

        // 64-bit unsigned addition
        // Sets v[a,a+1] += v[b,b+1]
        // v should be a Uint32Array
        function ADD64AA(v, a, b) {
          var o0 = v[a] + v[b]
          var o1 = v[a + 1] + v[b + 1]
          if (o0 >= 0x100000000) {
            o1++
          }
          v[a] = o0
          v[a + 1] = o1
        }

        // 64-bit unsigned addition
        // Sets v[a,a+1] += b
        // b0 is the low 32 bits of b, b1 represents the high 32 bits
        function ADD64AC(v, a, b0, b1) {
          var o0 = v[a] + b0
          if (b0 < 0) {
            o0 += 0x100000000
          }
          var o1 = v[a + 1] + b1
          if (o0 >= 0x100000000) {
            o1++
          }
          v[a] = o0
          v[a + 1] = o1
        }

        // Little-endian byte access
        function B2B_GET32(arr, i) {
          return (
            arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)
          )
        }

        // G Mixing function
        // The ROTRs are inlined for speed
        function B2B_G(a, b, c, d, ix, iy) {
          var x0 = m[ix]
          var x1 = m[ix + 1]
          var y0 = m[iy]
          var y1 = m[iy + 1]

          ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
          ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

          // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
          var xor0 = v[d] ^ v[a]
          var xor1 = v[d + 1] ^ v[a + 1]
          v[d] = xor1
          v[d + 1] = xor0

          ADD64AA(v, c, d)

          // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
          xor0 = v[b] ^ v[c]
          xor1 = v[b + 1] ^ v[c + 1]
          v[b] = (xor0 >>> 24) ^ (xor1 << 8)
          v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

          ADD64AA(v, a, b)
          ADD64AC(v, a, y0, y1)

          // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
          xor0 = v[d] ^ v[a]
          xor1 = v[d + 1] ^ v[a + 1]
          v[d] = (xor0 >>> 16) ^ (xor1 << 16)
          v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

          ADD64AA(v, c, d)

          // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
          xor0 = v[b] ^ v[c]
          xor1 = v[b + 1] ^ v[c + 1]
          v[b] = (xor1 >>> 31) ^ (xor0 << 1)
          v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
        }

        // Initialization Vector
        var BLAKE2B_IV32 = new Uint32Array([
          0xf3bcc908,
          0x6a09e667,
          0x84caa73b,
          0xbb67ae85,
          0xfe94f82b,
          0x3c6ef372,
          0x5f1d36f1,
          0xa54ff53a,
          0xade682d1,
          0x510e527f,
          0x2b3e6c1f,
          0x9b05688c,
          0xfb41bd6b,
          0x1f83d9ab,
          0x137e2179,
          0x5be0cd19
        ])

        var SIGMA8 = [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          14,
          10,
          4,
          8,
          9,
          15,
          13,
          6,
          1,
          12,
          0,
          2,
          11,
          7,
          5,
          3,
          11,
          8,
          12,
          0,
          5,
          2,
          15,
          13,
          10,
          14,
          3,
          6,
          7,
          1,
          9,
          4,
          7,
          9,
          3,
          1,
          13,
          12,
          11,
          14,
          2,
          6,
          5,
          10,
          4,
          0,
          15,
          8,
          9,
          0,
          5,
          7,
          2,
          4,
          10,
          15,
          14,
          1,
          11,
          12,
          6,
          8,
          3,
          13,
          2,
          12,
          6,
          10,
          0,
          11,
          8,
          3,
          4,
          13,
          7,
          5,
          15,
          14,
          1,
          9,
          12,
          5,
          1,
          15,
          14,
          13,
          4,
          10,
          0,
          7,
          6,
          3,
          9,
          2,
          8,
          11,
          13,
          11,
          7,
          14,
          12,
          1,
          3,
          9,
          5,
          0,
          15,
          4,
          8,
          6,
          2,
          10,
          6,
          15,
          14,
          9,
          11,
          3,
          0,
          8,
          12,
          2,
          13,
          7,
          1,
          4,
          10,
          5,
          10,
          2,
          8,
          4,
          7,
          6,
          1,
          5,
          15,
          11,
          9,
          14,
          3,
          12,
          13,
          0,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          14,
          10,
          4,
          8,
          9,
          15,
          13,
          6,
          1,
          12,
          0,
          2,
          11,
          7,
          5,
          3
        ]

        // These are offsets into a uint64 buffer.
        // Multiply them all by 2 to make them offsets into a uint32 buffer,
        // because this is Javascript and we don't have uint64s
        var SIGMA82 = new Uint8Array(
          SIGMA8.map(function(x) {
            return x * 2
          })
        )

        // Compression function. 'last' flag indicates last block.
        // Note we're representing 16 uint64s as 32 uint32s
        var v = new Uint32Array(32)
        var m = new Uint32Array(32)
        function blake2bCompress(ctx, last) {
          var i = 0

          // init work variables
          for (i = 0; i < 16; i++) {
            v[i] = ctx.h[i]
            v[i + 16] = BLAKE2B_IV32[i]
          }

          // low 64 bits of offset
          v[24] = v[24] ^ ctx.t
          v[25] = v[25] ^ (ctx.t / 0x100000000)
          // high 64 bits not supported, offset may not be higher than 2**53-1

          // last block flag set ?
          if (last) {
            v[28] = ~v[28]
            v[29] = ~v[29]
          }

          // get little-endian words
          for (i = 0; i < 32; i++) {
            m[i] = B2B_GET32(ctx.b, 4 * i)
          }

          // twelve rounds of mixing
          for (i = 0; i < 12; i++) {
            B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
            B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
            B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
            B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
            B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
            B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
            B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
            B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
          }

          for (i = 0; i < 16; i++) {
            ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
          }
        }

        // reusable parameter_block
        var parameter_block = new Uint8Array([
          0,
          0,
          0,
          0, //  0: outlen, keylen, fanout, depth
          0,
          0,
          0,
          0, //  4: leaf length, sequential mode
          0,
          0,
          0,
          0, //  8: node offset
          0,
          0,
          0,
          0, // 12: node offset
          0,
          0,
          0,
          0, // 16: node depth, inner length, rfu
          0,
          0,
          0,
          0, // 20: rfu
          0,
          0,
          0,
          0, // 24: rfu
          0,
          0,
          0,
          0, // 28: rfu
          0,
          0,
          0,
          0, // 32: salt
          0,
          0,
          0,
          0, // 36: salt
          0,
          0,
          0,
          0, // 40: salt
          0,
          0,
          0,
          0, // 44: salt
          0,
          0,
          0,
          0, // 48: personal
          0,
          0,
          0,
          0, // 52: personal
          0,
          0,
          0,
          0, // 56: personal
          0,
          0,
          0,
          0 // 60: personal
        ])

        // Creates a BLAKE2b hashing context
        // Requires an output length between 1 and 64 bytes
        // Takes an optional Uint8Array key
        function Blake2b(outlen, key, salt, personal) {
          // zero out parameter_block before usage
          parameter_block.fill(0)
          // state, 'param block'

          this.b = new Uint8Array(128)
          this.h = new Uint32Array(16)
          this.t = 0 // input count
          this.c = 0 // pointer within buffer
          this.outlen = outlen // output length in bytes

          parameter_block[0] = outlen
          if (key) parameter_block[1] = key.length
          parameter_block[2] = 1 // fanout
          parameter_block[3] = 1 // depth

          if (salt) parameter_block.set(salt, 32)
          if (personal) parameter_block.set(personal, 48)

          // initialize hash state
          for (var i = 0; i < 16; i++) {
            this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4)
          }

          // key the hash, if applicable
          if (key) {
            blake2bUpdate(this, key)
            // at the end
            this.c = 128
          }
        }

        Blake2b.prototype.update = function(input) {
          assert(input != null, "input must be Uint8Array or Buffer")
          blake2bUpdate(this, input)
          return this
        }

        Blake2b.prototype.digest = function(out) {
          var buf =
            !out || out === "binary" || out === "hex"
              ? new Uint8Array(this.outlen)
              : out
          assert(
            buf.length >= this.outlen,
            "out must have at least outlen bytes of space"
          )
          blake2bFinal(this, buf)
          if (out === "hex") return hexSlice(buf)
          return buf
        }

        Blake2b.prototype.final = Blake2b.prototype.digest

        Blake2b.ready = function(cb) {
          b2wasm.ready(function() {
            cb() // ignore the error
          })
        }

        // Updates a BLAKE2b streaming hash
        // Requires hash context and Uint8Array (byte array)
        function blake2bUpdate(ctx, input) {
          for (var i = 0; i < input.length; i++) {
            if (ctx.c === 128) {
              // buffer full ?
              ctx.t += ctx.c // add counters
              blake2bCompress(ctx, false) // compress (not last)
              ctx.c = 0 // counter to zero
            }
            ctx.b[ctx.c++] = input[i]
          }
        }

        // Completes a BLAKE2b streaming hash
        // Returns a Uint8Array containing the message digest
        function blake2bFinal(ctx, out) {
          ctx.t += ctx.c // mark last block offset

          while (ctx.c < 128) {
            // fill up with zeros
            ctx.b[ctx.c++] = 0
          }
          blake2bCompress(ctx, true) // final block flag = 1

          for (var i = 0; i < ctx.outlen; i++) {
            out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
          }
          return out
        }

        function hexSlice(buf) {
          var str = ""
          for (var i = 0; i < buf.length; i++) str += toHex(buf[i])
          return str
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16)
          return n.toString(16)
        }

        var Proto = Blake2b

        module.exports = function createHash(
          outlen,
          key,
          salt,
          personal,
          noAssert
        ) {
          if (noAssert !== true) {
            assert(
              outlen >= BYTES_MIN,
              "outlen must be at least " + BYTES_MIN + ", was given " + outlen
            )
            assert(
              outlen <= BYTES_MAX,
              "outlen must be at most " + BYTES_MAX + ", was given " + outlen
            )
            if (key != null)
              assert(
                key.length >= KEYBYTES_MIN,
                "key must be at least " +
                  KEYBYTES_MIN +
                  ", was given " +
                  key.length
              )
            if (key != null)
              assert(
                key.length <= KEYBYTES_MAX,
                "key must be at least " +
                  KEYBYTES_MAX +
                  ", was given " +
                  key.length
              )
            if (salt != null)
              assert(
                salt.length === SALTBYTES,
                "salt must be exactly " +
                  SALTBYTES +
                  ", was given " +
                  salt.length
              )
            if (personal != null)
              assert(
                personal.length === PERSONALBYTES,
                "personal must be exactly " +
                  PERSONALBYTES +
                  ", was given " +
                  personal.length
              )
          }

          return new Proto(outlen, key, salt, personal)
        }

        module.exports.ready = function(cb) {
          b2wasm.ready(function() {
            // ignore errors
            cb()
          })
        }

        module.exports.WASM_SUPPORTED = b2wasm.SUPPORTED
        module.exports.WASM_LOADED = false

        var BYTES_MIN = (module.exports.BYTES_MIN = 16)
        var BYTES_MAX = (module.exports.BYTES_MAX = 64)
        var BYTES = (module.exports.BYTES = 32)
        var KEYBYTES_MIN = (module.exports.KEYBYTES_MIN = 16)
        var KEYBYTES_MAX = (module.exports.KEYBYTES_MAX = 64)
        var KEYBYTES = (module.exports.KEYBYTES = 32)
        var SALTBYTES = (module.exports.SALTBYTES = 16)
        var PERSONALBYTES = (module.exports.PERSONALBYTES = 16)

        b2wasm.ready(function(err) {
          if (!err) {
            module.exports.WASM_LOADED = true
            Proto = b2wasm
          }
        })
      },
      { "blake2b-wasm": 12, nanoassert: 42 }
    ],
    14: [function(require, module, exports) {}, {}],
    15: [
      function(require, module, exports) {
        ;(function(Buffer) {
          function allocUnsafe(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be a number')
            }

            if (size < 0) {
              throw new RangeError('"size" argument must not be negative')
            }

            if (Buffer.allocUnsafe) {
              return Buffer.allocUnsafe(size)
            } else {
              return new Buffer(size)
            }
          }

          module.exports = allocUnsafe
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    16: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var bufferFill = require("buffer-fill")
          var allocUnsafe = require("buffer-alloc-unsafe")

          module.exports = function alloc(size, fill, encoding) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be a number')
            }

            if (size < 0) {
              throw new RangeError('"size" argument must not be negative')
            }

            if (Buffer.alloc) {
              return Buffer.alloc(size, fill, encoding)
            }

            var buffer = allocUnsafe(size)

            if (size === 0) {
              return buffer
            }

            if (fill === undefined) {
              return bufferFill(buffer, 0)
            }

            if (typeof encoding !== "string") {
              encoding = undefined
            }

            return bufferFill(buffer, fill, encoding)
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "buffer-alloc-unsafe": 15, "buffer-fill": 18 }
    ],
    17: [
      function(require, module, exports) {
        ;(function(Buffer) {
          "use strict"
          module.exports = function(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError("Arguments must be Buffers")
            }

            if (a === b) {
              return true
            }

            if (typeof a.equals === "function") {
              return a.equals(b)
            }

            if (a.length !== b.length) {
              return false
            }

            for (var i = 0; i < a.length; i++) {
              if (a[i] !== b[i]) {
                return false
              }
            }

            return true
          }
        }.call(this, { isBuffer: require("../is-buffer/index.js") }))
      },
      { "../is-buffer/index.js": 38 }
    ],
    18: [
      function(require, module, exports) {
        ;(function(Buffer) {
          /* Node.js 6.4.0 and up has full support */
          var hasFullSupport = (function() {
            try {
              if (!Buffer.isEncoding("latin1")) {
                return false
              }

              var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4)

              buf.fill("ab", "ucs2")

              return buf.toString("hex") === "61006200"
            } catch (_) {
              return false
            }
          })()

          function isSingleByte(val) {
            return val.length === 1 && val.charCodeAt(0) < 256
          }

          function fillWithNumber(buffer, val, start, end) {
            if (start < 0 || end > buffer.length) {
              throw new RangeError("Out of range index")
            }

            start = start >>> 0
            end = end === undefined ? buffer.length : end >>> 0

            if (end > start) {
              buffer.fill(val, start, end)
            }

            return buffer
          }

          function fillWithBuffer(buffer, val, start, end) {
            if (start < 0 || end > buffer.length) {
              throw new RangeError("Out of range index")
            }

            if (end <= start) {
              return buffer
            }

            start = start >>> 0
            end = end === undefined ? buffer.length : end >>> 0

            var pos = start
            var len = val.length
            while (pos <= end - len) {
              val.copy(buffer, pos)
              pos += len
            }

            if (pos !== end) {
              val.copy(buffer, pos, 0, end - pos)
            }

            return buffer
          }

          function fill(buffer, val, start, end, encoding) {
            if (hasFullSupport) {
              return buffer.fill(val, start, end, encoding)
            }

            if (typeof val === "number") {
              return fillWithNumber(buffer, val, start, end)
            }

            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start
                start = 0
                end = buffer.length
              } else if (typeof end === "string") {
                encoding = end
                end = buffer.length
              }

              if (encoding !== undefined && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string")
              }

              if (encoding === "latin1") {
                encoding = "binary"
              }

              if (
                typeof encoding === "string" &&
                !Buffer.isEncoding(encoding)
              ) {
                throw new TypeError("Unknown encoding: " + encoding)
              }

              if (val === "") {
                return fillWithNumber(buffer, 0, start, end)
              }

              if (isSingleByte(val)) {
                return fillWithNumber(buffer, val.charCodeAt(0), start, end)
              }

              val = new Buffer(val, encoding)
            }

            if (Buffer.isBuffer(val)) {
              return fillWithBuffer(buffer, val, start, end)
            }

            // Other values (e.g. undefined, boolean, object) results in zero-fill
            return fillWithNumber(buffer, 0, start, end)
          }

          module.exports = fill
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    19: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var toString = Object.prototype.toString

          var isModern =
            typeof Buffer.alloc === "function" &&
            typeof Buffer.allocUnsafe === "function" &&
            typeof Buffer.from === "function"

          function isArrayBuffer(input) {
            return toString.call(input).slice(8, -1) === "ArrayBuffer"
          }

          function fromArrayBuffer(obj, byteOffset, length) {
            byteOffset >>>= 0

            var maxLength = obj.byteLength - byteOffset

            if (maxLength < 0) {
              throw new RangeError("'offset' is out of bounds")
            }

            if (length === undefined) {
              length = maxLength
            } else {
              length >>>= 0

              if (length > maxLength) {
                throw new RangeError("'length' is out of bounds")
              }
            }

            return isModern
              ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
              : new Buffer(
                  new Uint8Array(obj.slice(byteOffset, byteOffset + length))
                )
          }

          function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8"
            }

            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding')
            }

            return isModern
              ? Buffer.from(string, encoding)
              : new Buffer(string, encoding)
          }

          function bufferFrom(value, encodingOrOffset, length) {
            if (typeof value === "number") {
              throw new TypeError('"value" argument must not be a number')
            }

            if (isArrayBuffer(value)) {
              return fromArrayBuffer(value, encodingOrOffset, length)
            }

            if (typeof value === "string") {
              return fromString(value, encodingOrOffset)
            }

            return isModern ? Buffer.from(value) : new Buffer(value)
          }

          module.exports = bufferFrom
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    20: [
      function(require, module, exports) {
        arguments[4][1][0].apply(exports, arguments)
      },
      { "base64-js": 5, dup: 1, ieee754: 36 }
    ],
    21: [
      function(require, module, exports) {
        var stream = require("readable-stream")
        var inherits = require("inherits")
        var bufferFrom = require("buffer-from")

        var SIGNAL_FLUSH = bufferFrom([0])

        var Bulk = function(opts, worker, flush) {
          if (!(this instanceof Bulk)) return new Bulk(opts, worker, flush)

          if (typeof opts === "function") {
            flush = worker
            worker = opts
            opts = {}
          }

          stream.Writable.call(this, opts)
          this._worker = worker
          this._flush = flush
          this.destroyed = false
        }

        inherits(Bulk, stream.Writable)

        Bulk.obj = function(opts, worker, flush) {
          if (typeof opts === "function") return Bulk.obj(null, opts, worker)
          if (!opts) opts = {}
          opts.objectMode = true
          return new Bulk(opts, worker, flush)
        }

        Bulk.prototype.end = function(data, enc, cb) {
          if (!this._flush)
            return stream.Writable.prototype.end.apply(this, arguments)
          if (typeof data === "function") return this.end(null, null, data)
          if (typeof enc === "function") return this.end(data, null, enc)
          if (data) this.write(data)
          if (!this._writableState.ending) this.write(SIGNAL_FLUSH)
          return stream.Writable.prototype.end.call(this, cb)
        }

        Bulk.prototype.destroy = function(err) {
          if (this.destroyed) return
          this.destroyed = true
          if (err) this.emit("error")
          this.emit("close")
        }

        Bulk.prototype._write = function(data, enc, cb) {
          if (data === SIGNAL_FLUSH) this._flush(cb)
          else this._worker([data], cb)
        }

        Bulk.prototype._writev = function(batch, cb) {
          var len = batch.length
          if (batch[batch.length - 1].chunk === SIGNAL_FLUSH) {
            cb = this._flusher(cb)
            if (!--len) return cb()
          }
          var arr = new Array(len)
          for (var i = 0; i < len; i++) arr[i] = batch[i].chunk
          this._worker(arr, cb)
        }

        Bulk.prototype._flusher = function(cb) {
          var self = this
          return function(err) {
            if (err) return cb(err)
            self._flush(cb)
          }
        }

        module.exports = Bulk
      },
      { "buffer-from": 19, inherits: 37, "readable-stream": 58 }
    ],
    22: [
      function(require, module, exports) {
        ;(function(Buffer) {
          module.exports = codecs

          var fromBuffer =
            Buffer.from && Buffer.from !== Uint8Array.from
              ? Buffer.from
              : Buffer

          codecs.ascii = createString("ascii")
          codecs.utf8 = createString("utf-8")
          codecs.hex = createString("hex")
          codecs.base64 = createString("base64")
          codecs.ucs2 = createString("ucs2")
          codecs.utf16le = createString("utf16le")
          codecs.ndjson = createJSON(true)
          codecs.json = createJSON(false)
          codecs.binary = {
            encode: function encodeBinary(obj) {
              return typeof obj === "string" ? fromBuffer(obj, "utf-8") : obj
            },
            decode: function decodeBinary(buf) {
              return buf
            }
          }

          function codecs(fmt) {
            if (typeof fmt === "object" && fmt && fmt.encode && fmt.decode)
              return fmt

            switch (fmt) {
              case "ndjson":
                return codecs.ndjson
              case "json":
                return codecs.json
              case "ascii":
                return codecs.ascii
              case "utf-8":
              case "utf8":
                return codecs.utf8
              case "hex":
                return codecs.hex
              case "base64":
                return codecs.base64
              case "ucs-2":
              case "ucs2":
                return codecs.ucs2
              case "utf16-le":
              case "utf16le":
                return codecs.utf16le
            }

            return codecs.binary
          }

          function createJSON(newline) {
            return {
              encode: newline ? encodeNDJSON : encodeJSON,
              decode: function decodeJSON(buf) {
                return JSON.parse(buf.toString())
              }
            }

            function encodeJSON(val) {
              return new Buffer(JSON.stringify(val))
            }

            function encodeNDJSON(val) {
              return new Buffer(JSON.stringify(val) + "\n")
            }
          }

          function createString(type) {
            return {
              encode: function encodeString(val) {
                if (typeof val !== "string") val = val.toString()
                return fromBuffer(val, type)
              },
              decode: function decodeString(buf) {
                return buf.toString(type)
              }
            }
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    23: [
      function(require, module, exports) {
        ;(function(Buffer) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.

          function isArray(arg) {
            if (Array.isArray) {
              return Array.isArray(arg)
            }
            return objectToString(arg) === "[object Array]"
          }
          exports.isArray = isArray

          function isBoolean(arg) {
            return typeof arg === "boolean"
          }
          exports.isBoolean = isBoolean

          function isNull(arg) {
            return arg === null
          }
          exports.isNull = isNull

          function isNullOrUndefined(arg) {
            return arg == null
          }
          exports.isNullOrUndefined = isNullOrUndefined

          function isNumber(arg) {
            return typeof arg === "number"
          }
          exports.isNumber = isNumber

          function isString(arg) {
            return typeof arg === "string"
          }
          exports.isString = isString

          function isSymbol(arg) {
            return typeof arg === "symbol"
          }
          exports.isSymbol = isSymbol

          function isUndefined(arg) {
            return arg === void 0
          }
          exports.isUndefined = isUndefined

          function isRegExp(re) {
            return objectToString(re) === "[object RegExp]"
          }
          exports.isRegExp = isRegExp

          function isObject(arg) {
            return typeof arg === "object" && arg !== null
          }
          exports.isObject = isObject

          function isDate(d) {
            return objectToString(d) === "[object Date]"
          }
          exports.isDate = isDate

          function isError(e) {
            return objectToString(e) === "[object Error]" || e instanceof Error
          }
          exports.isError = isError

          function isFunction(arg) {
            return typeof arg === "function"
          }
          exports.isFunction = isFunction

          function isPrimitive(arg) {
            return (
              arg === null ||
              typeof arg === "boolean" ||
              typeof arg === "number" ||
              typeof arg === "string" ||
              typeof arg === "symbol" || // ES6 symbol
              typeof arg === "undefined"
            )
          }
          exports.isPrimitive = isPrimitive

          exports.isBuffer = Buffer.isBuffer

          function objectToString(o) {
            return Object.prototype.toString.call(o)
          }
        }.call(this, { isBuffer: require("../../is-buffer/index.js") }))
      },
      { "../../is-buffer/index.js": 38 }
    ],
    24: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var objectCreate = Object.create || objectCreatePolyfill
        var objectKeys = Object.keys || objectKeysPolyfill
        var bind = Function.prototype.bind || functionBindPolyfill

        function EventEmitter() {
          if (
            !this._events ||
            !Object.prototype.hasOwnProperty.call(this, "_events")
          ) {
            this._events = objectCreate(null)
            this._eventsCount = 0
          }

          this._maxListeners = this._maxListeners || undefined
        }
        module.exports = EventEmitter

        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter

        EventEmitter.prototype._events = undefined
        EventEmitter.prototype._maxListeners = undefined

        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        var defaultMaxListeners = 10

        var hasDefineProperty
        try {
          var o = {}
          if (Object.defineProperty) Object.defineProperty(o, "x", { value: 0 })
          hasDefineProperty = o.x === 0
        } catch (err) {
          hasDefineProperty = false
        }
        if (hasDefineProperty) {
          Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: true,
            get: function() {
              return defaultMaxListeners
            },
            set: function(arg) {
              // check whether the input is a positive number (whose value is zero or
              // greater and not a NaN).
              if (typeof arg !== "number" || arg < 0 || arg !== arg)
                throw new TypeError(
                  '"defaultMaxListeners" must be a positive number'
                )
              defaultMaxListeners = arg
            }
          })
        } else {
          EventEmitter.defaultMaxListeners = defaultMaxListeners
        }

        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== "number" || n < 0 || isNaN(n))
            throw new TypeError('"n" argument must be a positive number')
          this._maxListeners = n
          return this
        }

        function $getMaxListeners(that) {
          if (that._maxListeners === undefined)
            return EventEmitter.defaultMaxListeners
          return that._maxListeners
        }

        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return $getMaxListeners(this)
        }

        // These standalone emit* functions are used to optimize calling of event
        // handlers for fast cases because emit() itself often has a variable number of
        // arguments and can be deoptimized because of that. These functions always have
        // the same number of arguments and thus do not get deoptimized, so the code
        // inside them can execute faster.
        function emitNone(handler, isFn, self) {
          if (isFn) handler.call(self)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].call(self)
          }
        }
        function emitOne(handler, isFn, self, arg1) {
          if (isFn) handler.call(self, arg1)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1)
          }
        }
        function emitTwo(handler, isFn, self, arg1, arg2) {
          if (isFn) handler.call(self, arg1, arg2)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2)
          }
        }
        function emitThree(handler, isFn, self, arg1, arg2, arg3) {
          if (isFn) handler.call(self, arg1, arg2, arg3)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i)
              listeners[i].call(self, arg1, arg2, arg3)
          }
        }

        function emitMany(handler, isFn, self, args) {
          if (isFn) handler.apply(self, args)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].apply(self, args)
          }
        }

        EventEmitter.prototype.emit = function emit(type) {
          var er, handler, len, args, i, events
          var doError = type === "error"

          events = this._events
          if (events) doError = doError && events.error == null
          else if (!doError) return false

          // If there is no 'error' event listener then throw.
          if (doError) {
            if (arguments.length > 1) er = arguments[1]
            if (er instanceof Error) {
              throw er // Unhandled 'error' event
            } else {
              // At least give some kind of context to the user
              var err = new Error('Unhandled "error" event. (' + er + ")")
              err.context = er
              throw err
            }
            return false
          }

          handler = events[type]

          if (!handler) return false

          var isFn = typeof handler === "function"
          len = arguments.length
          switch (len) {
            // fast cases
            case 1:
              emitNone(handler, isFn, this)
              break
            case 2:
              emitOne(handler, isFn, this, arguments[1])
              break
            case 3:
              emitTwo(handler, isFn, this, arguments[1], arguments[2])
              break
            case 4:
              emitThree(
                handler,
                isFn,
                this,
                arguments[1],
                arguments[2],
                arguments[3]
              )
              break
            // slower
            default:
              args = new Array(len - 1)
              for (i = 1; i < len; i++) args[i - 1] = arguments[i]
              emitMany(handler, isFn, this, args)
          }

          return true
        }

        function _addListener(target, type, listener, prepend) {
          var m
          var events
          var existing

          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')

          events = target._events
          if (!events) {
            events = target._events = objectCreate(null)
            target._eventsCount = 0
          } else {
            // To avoid recursion in the case that type === "newListener"! Before
            // adding it to the listeners, first emit "newListener".
            if (events.newListener) {
              target.emit(
                "newListener",
                type,
                listener.listener ? listener.listener : listener
              )

              // Re-assign `events` because a newListener handler could have caused the
              // this._events to be assigned to a new object
              events = target._events
            }
            existing = events[type]
          }

          if (!existing) {
            // Optimize the case of one listener. Don't need the extra array object.
            existing = events[type] = listener
            ++target._eventsCount
          } else {
            if (typeof existing === "function") {
              // Adding the second element, need to change to array.
              existing = events[type] = prepend
                ? [listener, existing]
                : [existing, listener]
            } else {
              // If we've already got an array, just append.
              if (prepend) {
                existing.unshift(listener)
              } else {
                existing.push(listener)
              }
            }

            // Check for listener leak
            if (!existing.warned) {
              m = $getMaxListeners(target)
              if (m && m > 0 && existing.length > m) {
                existing.warned = true
                var w = new Error(
                  "Possible EventEmitter memory leak detected. " +
                    existing.length +
                    ' "' +
                    String(type) +
                    '" listeners ' +
                    "added. Use emitter.setMaxListeners() to " +
                    "increase limit."
                )
                w.name = "MaxListenersExceededWarning"
                w.emitter = target
                w.type = type
                w.count = existing.length
                if (typeof console === "object" && console.warn) {
                  console.warn("%s: %s", w.name, w.message)
                }
              }
            }
          }

          return target
        }

        EventEmitter.prototype.addListener = function addListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, false)
        }

        EventEmitter.prototype.on = EventEmitter.prototype.addListener

        EventEmitter.prototype.prependListener = function prependListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, true)
        }

        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn)
            this.fired = true
            switch (arguments.length) {
              case 0:
                return this.listener.call(this.target)
              case 1:
                return this.listener.call(this.target, arguments[0])
              case 2:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1]
                )
              case 3:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1],
                  arguments[2]
                )
              default:
                var args = new Array(arguments.length)
                for (var i = 0; i < args.length; ++i) args[i] = arguments[i]
                this.listener.apply(this.target, args)
            }
          }
        }

        function _onceWrap(target, type, listener) {
          var state = {
            fired: false,
            wrapFn: undefined,
            target: target,
            type: type,
            listener: listener
          }
          var wrapped = bind.call(onceWrapper, state)
          wrapped.listener = listener
          state.wrapFn = wrapped
          return wrapped
        }

        EventEmitter.prototype.once = function once(type, listener) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')
          this.on(type, _onceWrap(this, type, listener))
          return this
        }

        EventEmitter.prototype.prependOnceListener = function prependOnceListener(
          type,
          listener
        ) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')
          this.prependListener(type, _onceWrap(this, type, listener))
          return this
        }

        // Emits a 'removeListener' event if and only if the listener was removed.
        EventEmitter.prototype.removeListener = function removeListener(
          type,
          listener
        ) {
          var list, events, position, i, originalListener

          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')

          events = this._events
          if (!events) return this

          list = events[type]
          if (!list) return this

          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0) this._events = objectCreate(null)
            else {
              delete events[type]
              if (events.removeListener)
                this.emit("removeListener", type, list.listener || listener)
            }
          } else if (typeof list !== "function") {
            position = -1

            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener
                position = i
                break
              }
            }

            if (position < 0) return this

            if (position === 0) list.shift()
            else spliceOne(list, position)

            if (list.length === 1) events[type] = list[0]

            if (events.removeListener)
              this.emit("removeListener", type, originalListener || listener)
          }

          return this
        }

        EventEmitter.prototype.removeAllListeners = function removeAllListeners(
          type
        ) {
          var listeners, events, i

          events = this._events
          if (!events) return this

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = objectCreate(null)
              this._eventsCount = 0
            } else if (events[type]) {
              if (--this._eventsCount === 0) this._events = objectCreate(null)
              else delete events[type]
            }
            return this
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = objectKeys(events)
            var key
            for (i = 0; i < keys.length; ++i) {
              key = keys[i]
              if (key === "removeListener") continue
              this.removeAllListeners(key)
            }
            this.removeAllListeners("removeListener")
            this._events = objectCreate(null)
            this._eventsCount = 0
            return this
          }

          listeners = events[type]

          if (typeof listeners === "function") {
            this.removeListener(type, listeners)
          } else if (listeners) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i])
            }
          }

          return this
        }

        function _listeners(target, type, unwrap) {
          var events = target._events

          if (!events) return []

          var evlistener = events[type]
          if (!evlistener) return []

          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener]

          return unwrap
            ? unwrapListeners(evlistener)
            : arrayClone(evlistener, evlistener.length)
        }

        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true)
        }

        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false)
        }

        EventEmitter.listenerCount = function(emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type)
          } else {
            return listenerCount.call(emitter, type)
          }
        }

        EventEmitter.prototype.listenerCount = listenerCount
        function listenerCount(type) {
          var events = this._events

          if (events) {
            var evlistener = events[type]

            if (typeof evlistener === "function") {
              return 1
            } else if (evlistener) {
              return evlistener.length
            }
          }

          return 0
        }

        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : []
        }

        // About 1.5x faster than the two-arg version of Array#splice().
        function spliceOne(list, index) {
          for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
            list[i] = list[k]
          list.pop()
        }

        function arrayClone(arr, n) {
          var copy = new Array(n)
          for (var i = 0; i < n; ++i) copy[i] = arr[i]
          return copy
        }

        function unwrapListeners(arr) {
          var ret = new Array(arr.length)
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i]
          }
          return ret
        }

        function objectCreatePolyfill(proto) {
          var F = function() {}
          F.prototype = proto
          return new F()
        }
        function objectKeysPolyfill(obj) {
          var keys = []
          for (var k in obj)
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
              keys.push(k)
            }
          return k
        }
        function functionBindPolyfill(context) {
          var fn = this
          return function() {
            return fn.apply(context, arguments)
          }
        }
      },
      {}
    ],
    25: [
      function(require, module, exports) {
        exports.fullRoots = function(index, result) {
          if (index & 1)
            throw new Error("You can only look up roots for depth(0) blocks")
          if (!result) result = []

          index /= 2

          var offset = 0
          var factor = 1

          while (true) {
            if (!index) return result
            while (factor * 2 <= index) factor *= 2
            result.push(offset + factor - 1)
            offset = offset + 2 * factor
            index -= factor
            factor = 1
          }
        }

        exports.depth = function(index) {
          var depth = 0

          index += 1
          while (!(index & 1)) {
            depth++
            index = rightShift(index)
          }

          return depth
        }

        exports.sibling = function(index, depth) {
          if (!depth) depth = exports.depth(index)
          var offset = exports.offset(index, depth)

          return exports.index(depth, offset & 1 ? offset - 1 : offset + 1)
        }

        exports.parent = function(index, depth) {
          if (!depth) depth = exports.depth(index)
          var offset = exports.offset(index, depth)

          return exports.index(depth + 1, rightShift(offset))
        }

        exports.leftChild = function(index, depth) {
          if (!(index & 1)) return -1
          if (!depth) depth = exports.depth(index)
          return exports.index(depth - 1, exports.offset(index, depth) * 2)
        }

        exports.rightChild = function(index, depth) {
          if (!(index & 1)) return -1
          if (!depth) depth = exports.depth(index)
          return exports.index(depth - 1, 1 + exports.offset(index, depth) * 2)
        }

        exports.children = function(index, depth) {
          if (!(index & 1)) return null

          if (!depth) depth = exports.depth(index)
          var offset = exports.offset(index, depth) * 2

          return [
            exports.index(depth - 1, offset),
            exports.index(depth - 1, offset + 1)
          ]
        }

        exports.leftSpan = function(index, depth) {
          if (!(index & 1)) return index
          if (!depth) depth = exports.depth(index)
          return exports.offset(index, depth) * twoPow(depth + 1)
        }

        exports.rightSpan = function(index, depth) {
          if (!(index & 1)) return index
          if (!depth) depth = exports.depth(index)
          return (exports.offset(index, depth) + 1) * twoPow(depth + 1) - 2
        }

        exports.count = function(index, depth) {
          if (!(index & 1)) return 1
          if (!depth) depth = exports.depth(index)
          return twoPow(depth + 1) - 1
        }

        exports.spans = function(index, depth) {
          if (!(index & 1)) return [index, index]
          if (!depth) depth = exports.depth(index)

          var offset = exports.offset(index, depth)
          var width = twoPow(depth + 1)

          return [offset * width, (offset + 1) * width - 2]
        }

        exports.index = function(depth, offset) {
          return (1 + 2 * offset) * twoPow(depth) - 1
        }

        exports.offset = function(index, depth) {
          if (!(index & 1)) return index / 2
          if (!depth) depth = exports.depth(index)

          return ((index + 1) / twoPow(depth) - 1) / 2
        }

        exports.iterator = function(index) {
          var ite = new Iterator()
          ite.seek(index || 0)
          return ite
        }

        function twoPow(n) {
          return n < 31 ? 1 << n : (1 << 30) * (1 << (n - 30))
        }

        function rightShift(n) {
          return (n - (n & 1)) / 2
        }

        function Iterator(index) {
          this.index = 0
          this.offset = 0
          this.factor = 0
        }

        Iterator.prototype.seek = function(index) {
          this.index = index
          if (this.index & 1) {
            this.offset = exports.offset(index)
            this.factor = twoPow(exports.depth(index) + 1)
          } else {
            this.offset = index / 2
            this.factor = 2
          }
        }

        Iterator.prototype.isLeft = function() {
          return !(this.offset & 1)
        }

        Iterator.prototype.isRight = function() {
          return !this.isLeft()
        }

        Iterator.prototype.prev = function() {
          if (!this.offset) return this.index
          this.offset--
          this.index -= this.factor
          return this.index
        }

        Iterator.prototype.next = function() {
          this.offset++
          this.index += this.factor
          return this.index
        }

        Iterator.prototype.sibling = function() {
          return this.isLeft() ? this.next() : this.prev()
        }

        Iterator.prototype.parent = function() {
          if (this.offset & 1) {
            this.index -= this.factor / 2
            this.offset = (this.offset - 1) / 2
          } else {
            this.index += this.factor / 2
            this.offset /= 2
          }
          this.factor *= 2
          return this.index
        }

        Iterator.prototype.leftSpan = function() {
          this.index = this.index - this.factor / 2 + 1
          this.offset = this.index / 2
          this.factor = 2
          return this.index
        }

        Iterator.prototype.rightSpan = function() {
          this.index = this.index + this.factor / 2 - 1
          this.offset = this.index / 2
          this.factor = 2
          return this.index
        }

        Iterator.prototype.leftChild = function() {
          if (this.factor === 2) return this.index
          this.factor /= 2
          this.index -= this.factor / 2
          this.offset *= 2
          return this.index
        }

        Iterator.prototype.rightChild = function() {
          if (this.factor === 2) return this.index
          this.factor /= 2
          this.index += this.factor / 2
          this.offset = 2 * this.offset + 1
          return this.index
        }
      },
      {}
    ],
    26: [
      function(require, module, exports) {
        ;(function(process) {
          var Readable = require("readable-stream").Readable
          var inherits = require("inherits")

          module.exports = from2

          from2.ctor = ctor
          from2.obj = obj

          var Proto = ctor()

          function toFunction(list) {
            list = list.slice()
            return function(_, cb) {
              var err = null
              var item = list.length ? list.shift() : null
              if (item instanceof Error) {
                err = item
                item = null
              }

              cb(err, item)
            }
          }

          function from2(opts, read) {
            if (typeof opts !== "object" || Array.isArray(opts)) {
              read = opts
              opts = {}
            }

            var rs = new Proto(opts)
            rs._from = Array.isArray(read) ? toFunction(read) : read || noop
            return rs
          }

          function ctor(opts, read) {
            if (typeof opts === "function") {
              read = opts
              opts = {}
            }

            opts = defaults(opts)

            inherits(Class, Readable)
            function Class(override) {
              if (!(this instanceof Class)) return new Class(override)
              this._reading = false
              this._callback = check
              this.destroyed = false
              Readable.call(this, override || opts)

              var self = this
              var hwm = this._readableState.highWaterMark

              function check(err, data) {
                if (self.destroyed) return
                if (err) return self.destroy(err)
                if (data === null) return self.push(null)
                self._reading = false
                if (self.push(data)) self._read(hwm)
              }
            }

            Class.prototype._from = read || noop
            Class.prototype._read = function(size) {
              if (this._reading || this.destroyed) return
              this._reading = true
              this._from(size, this._callback)
            }

            Class.prototype.destroy = function(err) {
              if (this.destroyed) return
              this.destroyed = true

              var self = this
              process.nextTick(function() {
                if (err) self.emit("error", err)
                self.emit("close")
              })
            }

            return Class
          }

          function obj(opts, read) {
            if (typeof opts === "function" || Array.isArray(opts)) {
              read = opts
              opts = {}
            }

            opts = defaults(opts)
            opts.objectMode = true
            opts.highWaterMark = 16

            return from2(opts, read)
          }

          function noop() {}

          function defaults(opts) {
            opts = opts || {}
            return opts
          }
        }.call(this, require("_process")))
      },
      { _process: 44, inherits: 37, "readable-stream": 58 }
    ],
    27: [
      function(require, module, exports) {
        ;(function(process) {
          var events = require("events")
          var inherits = require("inherits")
          var varint = require("varint")
          var messages = require("./messages")
          var bufferAlloc = require("buffer-alloc-unsafe")

          module.exports = Feed

          function Feed(stream) {
            if (!(this instanceof Feed)) return new Feed(stream)
            events.EventEmitter.call(this)

            this.key = null
            this.discoveryKey = null
            this.stream = stream
            this.peer = null // support a peer object to avoid event emitter + closures overhead

            this.id = -1
            this.remoteId = -1
            this.header = 0
            this.headerLength = 0
            this.closed = false

            this._buffer = []
          }

          inherits(Feed, events.EventEmitter)

          Feed.prototype.handshake = function(message) {
            return this._send(1, messages.Handshake, message)
          }

          Feed.prototype.info = function(message) {
            return this._send(2, messages.Info, message)
          }

          Feed.prototype.have = function(message) {
            return this._send(3, messages.Have, message)
          }

          Feed.prototype.unhave = function(message) {
            return this._send(4, messages.Unhave, message)
          }

          Feed.prototype.want = function(message) {
            return this._send(5, messages.Want, message)
          }

          Feed.prototype.unwant = function(message) {
            return this._send(6, messages.Unwant, message)
          }

          Feed.prototype.request = function(message) {
            return this._send(7, messages.Request, message)
          }

          Feed.prototype.cancel = function(message) {
            return this._send(8, messages.Cancel, message)
          }

          Feed.prototype.data = function(message) {
            return this._send(9, messages.Data, message)
          }

          Feed.prototype.extension = function(type, message) {
            var id = this.stream.extensions.indexOf(type)
            if (id === -1) return false

            var header = this.header | 15
            var len =
              this.headerLength + varint.encodingLength(id) + message.length
            var box = bufferAlloc(varint.encodingLength(len) + len)
            var offset = 0

            varint.encode(len, box, offset)
            offset += varint.encode.bytes

            varint.encode(header, box, offset)
            offset += varint.encode.bytes

            varint.encode(id, box, offset)
            offset += varint.encode.bytes

            message.copy(box, offset)
            return this.stream._push(box)
          }

          Feed.prototype.remoteSupports = function(name) {
            return this.stream.remoteSupports(name)
          }

          Feed.prototype.destroy = function(err) {
            this.stream.destroy(err)
          }

          Feed.prototype.close = function() {
            var i = this.stream.feeds.indexOf(this)

            if (i > -1) {
              this.stream.feeds[i] = this.stream.feeds[
                this.stream.feeds.length - 1
              ]
              this.stream.feeds.pop()
              this.stream._localFeeds[this.id] = null
              this.id = -1

              if (this.stream.destroyed) return
              if (this.stream.expectedFeeds <= 0 || --this.stream.expectedFeeds)
                return

              this.stream._prefinalize()
            }
          }

          Feed.prototype._onclose = function() {
            if (this.closed) return
            this.closed = true

            if (!this.stream.destroyed) {
              this.close()
              if (this.remoteId > -1)
                this.stream._remoteFeeds[this.remoteId] = null
              var hex = this.discoveryKey.toString("hex")
              if (this.stream._feeds[hex] === this)
                delete this.stream._feeds[hex]
            }

            if (this.peer) this.peer.onclose()
            else this.emit("close")
          }

          Feed.prototype._resume = function() {
            var self = this
            process.nextTick(resume)

            function resume() {
              while (self._buffer.length) {
                var next = self._buffer.shift()
                self._emit(next.type, next.message)
              }
              self._buffer = null
            }
          }

          Feed.prototype._onextension = function(data, start, end) {
            if (end <= start) return

            var id = varint.decode(data, start)
            var r = this.stream.remoteExtensions
            var localId = !r || id >= r.length ? -1 : r[id]

            if (localId === -1) return

            var message = data.slice(start + varint.decode.bytes, end)
            var name = this.stream.extensions[localId]

            if (this.peer && this.peer.onextension)
              this.peer.onextension(name, message)
            else this.emit("extension", name, message)
          }

          Feed.prototype._onmessage = function(type, data, start, end) {
            var message = decodeMessage(type, data, start, end)
            if (!message || this.closed) return

            if (type === 1) return this.stream._onhandshake(message)

            if (!this._buffer) {
              this._emit(type, message)
              return
            }

            if (this._buffer.length > 16) {
              this.destroy(
                new Error("Remote sent too many messages on an unopened feed")
              )
              return
            }

            this._buffer.push({ type: type, message: message })
          }

          Feed.prototype._emit = function(type, message) {
            if (this.peer) {
              switch (type) {
                case 2:
                  return this.peer.oninfo(message)
                case 3:
                  return this.peer.onhave(message)
                case 4:
                  return this.peer.onunhave(message)
                case 5:
                  return this.peer.onwant(message)
                case 6:
                  return this.peer.onunwant(message)
                case 7:
                  return this.peer.onrequest(message)
                case 8:
                  return this.peer.oncancel(message)
                case 9:
                  return this.peer.ondata(message)
              }
            } else {
              switch (type) {
                case 2:
                  return this.emit("info", message)
                case 3:
                  return this.emit("have", message)
                case 4:
                  return this.emit("unhave", message)
                case 5:
                  return this.emit("want", message)
                case 6:
                  return this.emit("unwant", message)
                case 7:
                  return this.emit("request", message)
                case 8:
                  return this.emit("cancel", message)
                case 9:
                  return this.emit("data", message)
              }
            }
          }

          Feed.prototype._send = function(type, enc, message) {
            var header = this.header | type
            var len = this.headerLength + enc.encodingLength(message)
            var box = bufferAlloc(varint.encodingLength(len) + len)
            var offset = 0

            varint.encode(len, box, offset)
            offset += varint.encode.bytes

            varint.encode(header, box, offset)
            offset += varint.encode.bytes

            enc.encode(message, box, offset)

            return this.stream._push(box)
          }

          function decodeMessage(type, data, start, end) {
            switch (type) {
              case 1:
                return decode(messages.Handshake, data, start, end)
              case 2:
                return decode(messages.Info, data, start, end)
              case 3:
                return decode(messages.Have, data, start, end)
              case 4:
                return decode(messages.Unhave, data, start, end)
              case 5:
                return decode(messages.Want, data, start, end)
              case 6:
                return decode(messages.Unwant, data, start, end)
              case 7:
                return decode(messages.Request, data, start, end)
              case 8:
                return decode(messages.Cancel, data, start, end)
              case 9:
                return decode(messages.Data, data, start, end)
            }
          }

          function decode(enc, data, start, end) {
            try {
              return enc.decode(data, start, end)
            } catch (err) {
              return null
            }
          }
        }.call(this, require("_process")))
      },
      {
        "./messages": 29,
        _process: 44,
        "buffer-alloc-unsafe": 15,
        events: 24,
        inherits: 37,
        varint: 82
      }
    ],
    28: [
      function(require, module, exports) {
        ;(function(process) {
          var stream = require("readable-stream")
          var inherits = require("inherits")
          var varint = require("varint")
          var sodium = require("sodium-universal")
          var indexOf = require("sorted-indexof")
          var feed = require("./feed")
          var messages = require("./messages")
          var bufferAlloc = require("buffer-alloc-unsafe")
          var bufferFrom = require("buffer-from")

          module.exports = Protocol

          function Protocol(opts) {
            if (!(this instanceof Protocol)) return new Protocol(opts)
            if (!opts) opts = {}

            stream.Duplex.call(this)
            var self = this

            this.id = opts.id || randomBytes(32)
            this.live = !!opts.live
            this.ack = !!opts.ack
            this.userData = opts.userData || null
            this.remoteId = null
            this.remoteLive = false
            this.remoteUserData = null

            this.destroyed = false
            this.encrypted = opts.encrypt !== false
            this.key = null
            this.discoveryKey = null
            this.remoteDiscoveryKey = null
            this.feeds = []
            this.expectedFeeds = opts.expectedFeeds || 0
            this.extensions = opts.extensions || []
            this.remoteExtensions = null

            this._localFeeds = []
            this._remoteFeeds = []
            this._feeds = {}

            this._nonce = null
            this._remoteNonce = null
            this._xor = null
            this._remoteXor = null
            this._needsKey = false
            this._length = bufferAlloc(varint.encodingLength(8388608))
            this._missing = 0
            this._buf = null
            this._pointer = 0
            this._data = null
            this._start = 0
            this._cb = null
            this._interval = null
            this._keepAlive = 0
            this._remoteKeepAlive = 0
            this._maybeFinalize = maybeFinalize

            if (opts.timeout !== 0 && opts.timeout !== false)
              this.setTimeout(opts.timeout || 5000, this._ontimeout)
            this.on("finish", this.finalize)

            function maybeFinalize(err) {
              if (err) return self.destroy(err)
              if (!self.expectedFeeds) self.finalize()
            }
          }

          inherits(Protocol, stream.Duplex)

          Protocol.prototype._prefinalize = function() {
            if (!this.emit("prefinalize", this._maybeFinalize)) this.finalize()
          }

          Protocol.prototype.setTimeout = function(ms, ontimeout) {
            if (this.destroyed) return
            if (ontimeout) this.once("timeout", ontimeout)

            var self = this

            this._keepAlive = 0
            this._remoteKeepAlive = 0

            clearInterval(this._interval)
            if (!ms) return

            this._interval = setInterval(kick, (ms / 4) | 0)
            if (this._interval.unref) this._interval.unref()

            function kick() {
              self._kick()
            }
          }

          Protocol.prototype.feed = function(key, opts) {
            if (this.destroyed) return null
            if (!opts) opts = {}

            var dk = opts.discoveryKey || discoveryKey(key)
            var ch = this._feed(dk)

            if (ch.id > -1) {
              if (opts.peer) ch.peer = opts.peer
              return ch
            }

            if (this._localFeeds.length >= 128) {
              this._tooManyFeeds()
              return null
            }

            ch.id = this._localFeeds.push(ch) - 1
            ch.header = ch.id << 4
            ch.headerLength = varint.encodingLength(ch.header)
            ch.key = key
            ch.discoveryKey = dk
            if (opts.peer) ch.peer = opts.peer

            this.feeds.push(ch)

            var first = !this.key
            var feed = {
              discoveryKey: dk,
              nonce: null
            }

            if (first) {
              this.key = key
              this.discoveryKey = dk

              if (!this._sameKey()) return null

              if (this.encrypted) {
                feed.nonce = this._nonce = randomBytes(24)
                this._xor = sodium.crypto_stream_xor_instance(
                  this._nonce,
                  this.key
                )
                if (this._remoteNonce) {
                  this._remoteXor = sodium.crypto_stream_xor_instance(
                    this._remoteNonce,
                    this.key
                  )
                }
              }

              if (this._needsKey) {
                this._needsKey = false
                this._resume()
              }
            }

            var box = encodeFeed(feed, ch.id)
            if (!feed.nonce && this.encrypted) this._xor.update(box, box)
            this._keepAlive = 0
            this.push(box)

            if (this.destroyed) return null

            if (first) {
              ch.handshake({
                id: this.id,
                live: this.live,
                userData: this.userData,
                extensions: this.extensions,
                ack: this.ack
              })
            }

            if (ch._buffer.length) ch._resume()
            else ch._buffer = null

            return ch
          }

          Protocol.prototype._resume = function() {
            var self = this
            process.nextTick(resume)

            function resume() {
              if (!self._data) return

              var data = self._data
              var start = self._start
              var cb = self._cb

              self._data = null
              self._start = 0
              self._cb = null
              self._parse(data, start, cb)
            }
          }

          Protocol.prototype._kick = function() {
            if (this._remoteKeepAlive > 4) {
              clearInterval(this._interval)
              this.emit("timeout")
              return
            }

            for (var i = 0; i < this.feeds.length; i++) {
              var ch = this.feeds[i]
              if (ch.peer) ch.peer.ontick()
              else ch.emit("tick")
            }

            this._remoteKeepAlive++

            if (this._keepAlive > 2) {
              this.ping()
              this._keepAlive = 0
            } else {
              this._keepAlive++
            }
          }

          Protocol.prototype.ping = function() {
            if (!this.key) return true
            var ping = bufferFrom([0])
            if (this._xor) this._xor.update(ping, ping)
            return this.push(ping)
          }

          Protocol.prototype.destroy = function(err) {
            if (this.destroyed) return
            this.destroyed = true
            if (err) this.emit("error", err)
            this._close()
            this.emit("close")
          }

          Protocol.prototype.finalize = function() {
            if (this.destroyed) return
            this.destroyed = true
            this._close()
            this.push(null)
          }

          Protocol.prototype._close = function() {
            clearInterval(this._interval)

            var feeds = this.feeds
            this.feeds = []
            for (var i = 0; i < feeds.length; i++) feeds[i]._onclose()

            if (this._xor) {
              this._xor.final()
              this._xor = null
            }
          }

          Protocol.prototype._read = function() {
            // do nothing, user back-pressures
          }

          Protocol.prototype._push = function(data) {
            if (this.destroyed) return
            this._keepAlive = 0
            if (this._xor) this._xor.update(data, data)
            return this.push(data)
          }

          Protocol.prototype._write = function(data, enc, cb) {
            this._remoteKeepAlive = 0
            this._parse(data, 0, cb)
          }

          Protocol.prototype._feed = function(dk) {
            var hex = dk.toString("hex")
            var ch = this._feeds[hex]
            if (ch) return ch
            ch = this._feeds[hex] = feed(this)
            return ch
          }

          Protocol.prototype.remoteSupports = function(name) {
            var i = this.extensions.indexOf(name)
            return (
              i > -1 &&
              !!this.remoteExtensions &&
              this.remoteExtensions.indexOf(i) > -1
            )
          }

          Protocol.prototype._onhandshake = function(handshake) {
            if (this.remoteId) return

            this.remoteId = handshake.id || randomBytes(32)
            this.remoteLive = handshake.live
            this.remoteUserData = handshake.userData
            this.remoteExtensions = indexOf(
              this.extensions,
              handshake.extensions
            )
            this.remoteAck = handshake.ack

            this.emit("handshake")
          }

          Protocol.prototype._onopen = function(id, data, start, end) {
            var feed = decodeFeed(data, start, end)

            if (!feed) return this._badFeed()

            if (!this.remoteDiscoveryKey) {
              this.remoteDiscoveryKey = feed.discoveryKey
              if (!this._sameKey()) return

              if (this.encrypted && !this._remoteNonce) {
                if (!feed.nonce) {
                  this.destroy(new Error("Remote did not include a nonce"))
                  return
                }
                this._remoteNonce = feed.nonce
              }

              if (this.encrypted && this.key && !this._remoteXor) {
                this._remoteXor = sodium.crypto_stream_xor_instance(
                  this._remoteNonce,
                  this.key
                )
              }
            }

            this._remoteFeeds[id] = this._feed(feed.discoveryKey)
            feed.remoteId = id

            this.emit("feed", feed.discoveryKey)
          }

          Protocol.prototype._onmessage = function(data, start, end) {
            if (end - start < 2) return

            var header = decodeHeader(data, start)
            if (header === -1)
              return this.destroy(new Error("Remote sent invalid header"))

            start += varint.decode.bytes

            var id = header >> 4
            var type = header & 15

            if (id >= 128) return this._tooManyFeeds()
            while (this._remoteFeeds.length < id) this._remoteFeeds.push(null)

            var ch = this._remoteFeeds[id]

            if (type === 0) {
              if (ch) ch._onclose()
              return this._onopen(id, data, start, end)
            }

            if (!ch) return this._badFeed()
            if (type === 15) return ch._onextension(data, start, end)
            ch._onmessage(type, data, start, end)
          }

          Protocol.prototype._parse = function(data, start, cb) {
            var decrypted = !!this._remoteXor

            if (start) {
              data = data.slice(start)
              start = 0
            }

            if (this._remoteXor) this._remoteXor.update(data, data)

            while (start < data.length && !this.destroyed) {
              if (this._missing) start = this._parseMessage(data, start)
              else start = this._parseLength(data, start)

              if (this._needsKey) {
                this._data = data
                this._start = start
                this._cb = cb
                return
              }

              if (!decrypted && this._remoteXor) {
                return this._parse(data, start, cb)
              }
            }

            cb()
          }

          Protocol.prototype._parseMessage = function(data, start) {
            var end = start + this._missing

            if (end <= data.length) {
              var ret = end

              if (this._buf) {
                data.copy(this._buf, this._pointer, start)
                data = this._buf
                start = 0
                end = data.length
                this._buf = null
              }

              this._missing = 0
              this._pointer = 0
              if (this.encrypted && !this.key) this._needsKey = true
              this._onmessage(data, start, end)

              return ret
            }

            if (!this._buf) {
              this._buf = bufferAlloc(this._missing)
              this._pointer = 0
            }

            var rem = data.length - start

            data.copy(this._buf, this._pointer, start)
            this._pointer += rem
            this._missing -= rem

            return data.length
          }

          Protocol.prototype._parseLength = function(data, start) {
            while (!this._missing && start < data.length) {
              var byte = (this._length[this._pointer++] = data[start++])

              if (!(byte & 0x80)) {
                this._missing = varint.decode(this._length)
                this._pointer = 0
                if (this._missing > 8388608) return this._tooBig(data.length)
                return start
              }

              if (this._pointer >= this._length.length)
                return this._tooBig(data.length)
            }

            return start
          }

          Protocol.prototype._sameKey = function() {
            if (!this.discoveryKey || !this.remoteDiscoveryKey) return true
            if (
              this.remoteDiscoveryKey.toString("hex") ===
              this.discoveryKey.toString("hex")
            )
              return true
            this.destroy(new Error("First shared hypercore must be the same"))
            return false
          }

          Protocol.prototype._tooManyFeeds = function() {
            this.destroy(
              new Error(
                "Only 128 feeds currently supported. Open a Github issue if you need more"
              )
            )
          }

          Protocol.prototype._tooBig = function(len) {
            this.destroy(
              new Error("Remote message is larger than 8MB (max allowed)")
            )
            return len
          }

          Protocol.prototype._badFeed = function() {
            this.destroy(new Error("Remote sent invalid feed message"))
          }

          Protocol.prototype._ontimeout = function() {
            this.destroy(new Error("Remote timed out"))
          }

          function decodeHeader(data, start) {
            try {
              return varint.decode(data, start)
            } catch (err) {
              return -1
            }
          }

          function decodeFeed(data, start, end) {
            var feed = null

            try {
              feed = messages.Feed.decode(data, start, end)
            } catch (err) {
              return null
            }

            if (feed.discoveryKey.length !== 32) return null
            if (feed.nonce && feed.nonce.length !== 24) return null

            return feed
          }

          function encodeFeed(feed, id) {
            var header = id << 4
            var len =
              varint.encodingLength(header) + messages.Feed.encodingLength(feed)
            var box = bufferAlloc(varint.encodingLength(len) + len)
            var offset = 0

            varint.encode(len, box, offset)
            offset += varint.encode.bytes

            varint.encode(header, box, offset)
            offset += varint.encode.bytes

            messages.Feed.encode(feed, box, offset)
            return box
          }

          function discoveryKey(key) {
            var buf = bufferAlloc(32)
            sodium.crypto_generichash(buf, bufferFrom("hypercore"), key)
            return buf
          }

          function randomBytes(n) {
            var buf = bufferAlloc(n)
            sodium.randombytes_buf(buf)
            return buf
          }
        }.call(this, require("_process")))
      },
      {
        "./feed": 27,
        "./messages": 29,
        _process: 44,
        "buffer-alloc-unsafe": 15,
        "buffer-from": 19,
        inherits: 37,
        "readable-stream": 58,
        "sodium-universal": 70,
        "sorted-indexof": 71,
        varint: 82
      }
    ],
    29: [
      function(require, module, exports) {
        ;(function(Buffer) {
          // This file is auto generated by the protocol-buffers cli tool

          /* eslint-disable quotes */
          /* eslint-disable indent */
          /* eslint-disable no-redeclare */

          // Remember to `npm install --save protocol-buffers-encodings`
          var encodings = require("protocol-buffers-encodings")
          var varint = encodings.varint
          var skip = encodings.skip

          var Feed = (exports.Feed = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Handshake = (exports.Handshake = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Info = (exports.Info = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Have = (exports.Have = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Unhave = (exports.Unhave = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Want = (exports.Want = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Unwant = (exports.Unwant = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Request = (exports.Request = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Cancel = (exports.Cancel = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Data = (exports.Data = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          defineFeed()
          defineHandshake()
          defineInfo()
          defineHave()
          defineUnhave()
          defineWant()
          defineUnwant()
          defineRequest()
          defineCancel()
          defineData()

          function defineFeed() {
            var enc = [encodings.bytes]

            Feed.encodingLength = encodingLength
            Feed.encode = encode
            Feed.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.discoveryKey))
                throw new Error("discoveryKey is required")
              var len = enc[0].encodingLength(obj.discoveryKey)
              length += 1 + len
              if (defined(obj.nonce)) {
                var len = enc[0].encodingLength(obj.nonce)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.discoveryKey))
                throw new Error("discoveryKey is required")
              buf[offset++] = 10
              enc[0].encode(obj.discoveryKey, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.nonce)) {
                buf[offset++] = 18
                enc[0].encode(obj.nonce, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                discoveryKey: null,
                nonce: null
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.discoveryKey = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.nonce = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineHandshake() {
            var enc = [encodings.bytes, encodings.bool, encodings.string]

            Handshake.encodingLength = encodingLength
            Handshake.encode = encode
            Handshake.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (defined(obj.id)) {
                var len = enc[0].encodingLength(obj.id)
                length += 1 + len
              }
              if (defined(obj.live)) {
                var len = enc[1].encodingLength(obj.live)
                length += 1 + len
              }
              if (defined(obj.userData)) {
                var len = enc[0].encodingLength(obj.userData)
                length += 1 + len
              }
              if (defined(obj.extensions)) {
                for (var i = 0; i < obj.extensions.length; i++) {
                  if (!defined(obj.extensions[i])) continue
                  var len = enc[2].encodingLength(obj.extensions[i])
                  length += 1 + len
                }
              }
              if (defined(obj.ack)) {
                var len = enc[1].encodingLength(obj.ack)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (defined(obj.id)) {
                buf[offset++] = 10
                enc[0].encode(obj.id, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.live)) {
                buf[offset++] = 16
                enc[1].encode(obj.live, buf, offset)
                offset += enc[1].encode.bytes
              }
              if (defined(obj.userData)) {
                buf[offset++] = 26
                enc[0].encode(obj.userData, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.extensions)) {
                for (var i = 0; i < obj.extensions.length; i++) {
                  if (!defined(obj.extensions[i])) continue
                  buf[offset++] = 34
                  enc[2].encode(obj.extensions[i], buf, offset)
                  offset += enc[2].encode.bytes
                }
              }
              if (defined(obj.ack)) {
                buf[offset++] = 40
                enc[1].encode(obj.ack, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                id: null,
                live: false,
                userData: null,
                extensions: [],
                ack: false
              }
              while (true) {
                if (end <= offset) {
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.id = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 2:
                    obj.live = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  case 3:
                    obj.userData = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 4:
                    obj.extensions.push(enc[2].decode(buf, offset))
                    offset += enc[2].decode.bytes
                    break
                  case 5:
                    obj.ack = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineInfo() {
            var enc = [encodings.bool]

            Info.encodingLength = encodingLength
            Info.encode = encode
            Info.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (defined(obj.uploading)) {
                var len = enc[0].encodingLength(obj.uploading)
                length += 1 + len
              }
              if (defined(obj.downloading)) {
                var len = enc[0].encodingLength(obj.downloading)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (defined(obj.uploading)) {
                buf[offset++] = 8
                enc[0].encode(obj.uploading, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.downloading)) {
                buf[offset++] = 16
                enc[0].encode(obj.downloading, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                uploading: false,
                downloading: false
              }
              while (true) {
                if (end <= offset) {
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.uploading = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 2:
                    obj.downloading = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineHave() {
            var enc = [encodings.varint, encodings.bytes]

            Have.encodingLength = encodingLength
            Have.encode = encode
            Have.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              if (defined(obj.bitfield)) {
                var len = enc[1].encodingLength(obj.bitfield)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.bitfield)) {
                buf[offset++] = 26
                enc[1].encode(obj.bitfield, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 1,
                bitfield: null
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 3:
                    obj.bitfield = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineUnhave() {
            var enc = [encodings.varint]

            Unhave.encodingLength = encodingLength
            Unhave.encode = encode
            Unhave.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 1
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineWant() {
            var enc = [encodings.varint]

            Want.encodingLength = encodingLength
            Want.encode = encode
            Want.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 0
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineUnwant() {
            var enc = [encodings.varint]

            Unwant.encodingLength = encodingLength
            Unwant.encode = encode
            Unwant.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 0
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineRequest() {
            var enc = [encodings.varint, encodings.bool]

            Request.encodingLength = encodingLength
            Request.encode = encode
            Request.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.index)) throw new Error("index is required")
              var len = enc[0].encodingLength(obj.index)
              length += 1 + len
              if (defined(obj.bytes)) {
                var len = enc[0].encodingLength(obj.bytes)
                length += 1 + len
              }
              if (defined(obj.hash)) {
                var len = enc[1].encodingLength(obj.hash)
                length += 1 + len
              }
              if (defined(obj.nodes)) {
                var len = enc[0].encodingLength(obj.nodes)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.index)) throw new Error("index is required")
              buf[offset++] = 8
              enc[0].encode(obj.index, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.bytes)) {
                buf[offset++] = 16
                enc[0].encode(obj.bytes, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.hash)) {
                buf[offset++] = 24
                enc[1].encode(obj.hash, buf, offset)
                offset += enc[1].encode.bytes
              }
              if (defined(obj.nodes)) {
                buf[offset++] = 32
                enc[0].encode(obj.nodes, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                index: 0,
                bytes: 0,
                hash: false,
                nodes: 0
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.bytes = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 3:
                    obj.hash = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  case 4:
                    obj.nodes = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineCancel() {
            var enc = [encodings.varint, encodings.bool]

            Cancel.encodingLength = encodingLength
            Cancel.encode = encode
            Cancel.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.index)) throw new Error("index is required")
              var len = enc[0].encodingLength(obj.index)
              length += 1 + len
              if (defined(obj.bytes)) {
                var len = enc[0].encodingLength(obj.bytes)
                length += 1 + len
              }
              if (defined(obj.hash)) {
                var len = enc[1].encodingLength(obj.hash)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.index)) throw new Error("index is required")
              buf[offset++] = 8
              enc[0].encode(obj.index, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.bytes)) {
                buf[offset++] = 16
                enc[0].encode(obj.bytes, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.hash)) {
                buf[offset++] = 24
                enc[1].encode(obj.hash, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                index: 0,
                bytes: 0,
                hash: false
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.bytes = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 3:
                    obj.hash = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineData() {
            var Node = (Data.Node = {
              buffer: true,
              encodingLength: null,
              encode: null,
              decode: null
            })

            defineNode()

            function defineNode() {
              var enc = [encodings.varint, encodings.bytes]

              Node.encodingLength = encodingLength
              Node.encode = encode
              Node.decode = decode

              function encodingLength(obj) {
                var length = 0
                if (!defined(obj.index)) throw new Error("index is required")
                var len = enc[0].encodingLength(obj.index)
                length += 1 + len
                if (!defined(obj.hash)) throw new Error("hash is required")
                var len = enc[1].encodingLength(obj.hash)
                length += 1 + len
                if (!defined(obj.size)) throw new Error("size is required")
                var len = enc[0].encodingLength(obj.size)
                length += 1 + len
                return length
              }

              function encode(obj, buf, offset) {
                if (!offset) offset = 0
                if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
                var oldOffset = offset
                if (!defined(obj.index)) throw new Error("index is required")
                buf[offset++] = 8
                enc[0].encode(obj.index, buf, offset)
                offset += enc[0].encode.bytes
                if (!defined(obj.hash)) throw new Error("hash is required")
                buf[offset++] = 18
                enc[1].encode(obj.hash, buf, offset)
                offset += enc[1].encode.bytes
                if (!defined(obj.size)) throw new Error("size is required")
                buf[offset++] = 24
                enc[0].encode(obj.size, buf, offset)
                offset += enc[0].encode.bytes
                encode.bytes = offset - oldOffset
                return buf
              }

              function decode(buf, offset, end) {
                if (!offset) offset = 0
                if (!end) end = buf.length
                if (!(end <= buf.length && offset <= buf.length))
                  throw new Error("Decoded message is not valid")
                var oldOffset = offset
                var obj = {
                  index: 0,
                  hash: null,
                  size: 0
                }
                var found0 = false
                var found1 = false
                var found2 = false
                while (true) {
                  if (end <= offset) {
                    if (!found0 || !found1 || !found2)
                      throw new Error("Decoded message is not valid")
                    decode.bytes = offset - oldOffset
                    return obj
                  }
                  var prefix = varint.decode(buf, offset)
                  offset += varint.decode.bytes
                  var tag = prefix >> 3
                  switch (tag) {
                    case 1:
                      obj.index = enc[0].decode(buf, offset)
                      offset += enc[0].decode.bytes
                      found0 = true
                      break
                    case 2:
                      obj.hash = enc[1].decode(buf, offset)
                      offset += enc[1].decode.bytes
                      found1 = true
                      break
                    case 3:
                      obj.size = enc[0].decode(buf, offset)
                      offset += enc[0].decode.bytes
                      found2 = true
                      break
                    default:
                      offset = skip(prefix & 7, buf, offset)
                  }
                }
              }
            }

            var enc = [encodings.varint, encodings.bytes, Node]

            Data.encodingLength = encodingLength
            Data.encode = encode
            Data.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.index)) throw new Error("index is required")
              var len = enc[0].encodingLength(obj.index)
              length += 1 + len
              if (defined(obj.value)) {
                var len = enc[1].encodingLength(obj.value)
                length += 1 + len
              }
              if (defined(obj.nodes)) {
                for (var i = 0; i < obj.nodes.length; i++) {
                  if (!defined(obj.nodes[i])) continue
                  var len = enc[2].encodingLength(obj.nodes[i])
                  length += varint.encodingLength(len)
                  length += 1 + len
                }
              }
              if (defined(obj.signature)) {
                var len = enc[1].encodingLength(obj.signature)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.index)) throw new Error("index is required")
              buf[offset++] = 8
              enc[0].encode(obj.index, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.value)) {
                buf[offset++] = 18
                enc[1].encode(obj.value, buf, offset)
                offset += enc[1].encode.bytes
              }
              if (defined(obj.nodes)) {
                for (var i = 0; i < obj.nodes.length; i++) {
                  if (!defined(obj.nodes[i])) continue
                  buf[offset++] = 26
                  varint.encode(
                    enc[2].encodingLength(obj.nodes[i]),
                    buf,
                    offset
                  )
                  offset += varint.encode.bytes
                  enc[2].encode(obj.nodes[i], buf, offset)
                  offset += enc[2].encode.bytes
                }
              }
              if (defined(obj.signature)) {
                buf[offset++] = 34
                enc[1].encode(obj.signature, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                index: 0,
                value: null,
                nodes: [],
                signature: null
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.value = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  case 3:
                    var len = varint.decode(buf, offset)
                    offset += varint.decode.bytes
                    obj.nodes.push(enc[2].decode(buf, offset, offset + len))
                    offset += enc[2].decode.bytes
                    break
                  case 4:
                    obj.signature = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defined(val) {
            return (
              val !== null &&
              val !== undefined &&
              (typeof val !== "number" || !isNaN(val))
            )
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "protocol-buffers-encodings": 45 }
    ],
    30: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var equals = require("buffer-equals")
          var low = require("last-one-wins")
          var remove = require("unordered-array-remove")
          var set = require("unordered-set")
          var merkle = require("merkle-tree-stream/generator")
          var flat = require("flat-tree")
          var bulk = require("bulk-write-stream")
          var from = require("from2")
          var codecs = require("codecs")
          var thunky = require("thunky")
          var batcher = require("atomic-batcher")
          var inherits = require("inherits")
          var events = require("events")
          var raf = require("random-access-file")
          var bitfield = require("./lib/bitfield")
          var sparseBitfield = require("sparse-bitfield")
          var treeIndex = require("./lib/tree-index")
          var storage = require("./lib/storage")
          var crypto = require("./lib/crypto")
          var nextTick = require("process-nextick-args")
          var bufferFrom = require("buffer-from")
          var bufferAlloc = require("buffer-alloc-unsafe")
          var replicate = null

          module.exports = Feed

          function Feed(createStorage, key, opts) {
            if (!(this instanceof Feed))
              return new Feed(createStorage, key, opts)
            events.EventEmitter.call(this)

            if (typeof createStorage === "string")
              createStorage = defaultStorage(createStorage)
            if (typeof createStorage !== "function")
              throw new Error("Storage should be a function or string")

            if (typeof key === "string") key = bufferFrom(key, "hex")

            if (!Buffer.isBuffer(key) && !opts) {
              opts = key
              key = null
            }

            if (!opts) opts = {}

            var self = this

            var secretKey = opts.secretKey || null
            if (typeof secretKey === "string")
              secretKey = bufferFrom(secretKey, "hex")

            this.id = opts.id || crypto.randomBytes(32)
            this.live = opts.live !== false
            this.sparse = !!opts.sparse
            this.length = 0
            this.byteLength = 0
            this.maxRequests = opts.maxRequests || 16
            this.key = key || null
            this.discoveryKey = this.key && crypto.discoveryKey(this.key)
            this.secretKey = secretKey
            this.bitfield = null
            this.tree = null
            this.writable = !!opts.writable
            this.readable = true
            this.opened = false
            this.closed = false
            this.allowPush = !!opts.allowPush
            this.peers = []

            // hooks
            this._onwrite = opts.onwrite || null

            this._ready = thunky(open) // TODO: if open fails, do not reopen next time
            this._indexing = !!opts.indexing
            this._createIfMissing = opts.createIfMissing !== false
            this._overwrite = !!opts.overwrite
            this._storeSecretKey = opts.storeSecretKey !== false
            this._merkle = null
            this._storage = storage(createStorage, opts.storageCacheSize)
            this._batch = batcher(this._onwrite ? workHook : work)

            this._waiting = []
            this._selections = []
            this._reserved = sparseBitfield()
            this._synced = null

            this._codec = toCodec(opts.valueEncoding)
            this._sync = low(sync)
            if (!this.sparse) this.download({ start: 0, end: -1 })

            // open it right away. TODO: do not reopen (i.e, set a flag not to retry)
            this._ready(onerror)

            function onerror(err) {
              if (err) self.emit("error", err)
            }

            function workHook(values, cb) {
              self._appendHook(values, cb)
            }

            function work(values, cb) {
              self._append(values, cb)
            }

            function sync(_, cb) {
              self._syncBitfield(cb)
            }

            function open(cb) {
              self._open(cb)
            }
          }

          inherits(Feed, events.EventEmitter)

          Feed.discoveryKey = crypto.discoveryKey

          // TODO: instead of using a getter, update on remote-update/add/remove
          Object.defineProperty(Feed.prototype, "remoteLength", {
            enumerable: true,
            get: function() {
              var len = 0
              for (var i = 0; i < this.peers.length; i++) {
                var remoteLength = this.peers[i].remoteLength
                if (remoteLength > len) len = remoteLength
              }
              return len
            }
          })

          Feed.prototype.replicate = function(opts) {
            // Lazy load replication deps
            if (!replicate) replicate = require("./lib/replicate")

            if (
              (!this._selections.length || this._selections[0].end !== -1) &&
              !this.sparse &&
              !(opts && opts.live)
            ) {
              // hack!! proper fix is to refactor ./replicate to *not* clear our non-sparse selection
              this.download({ start: 0, end: -1 })
            }

            return replicate(this, opts || {})
          }

          Feed.prototype.ready = function(onready) {
            this._ready(function(err) {
              if (!err) onready()
            })
          }

          Feed.prototype.update = function(len, cb) {
            if (typeof len === "function") return this.update(-1, len)
            if (typeof len !== "number") len = -1
            if (!cb) cb = noop

            var self = this

            this.ready(function(err) {
              if (err) return cb(err)
              if (len === -1) len = self.length + 1
              if (self.length >= len) return cb(null)

              if (self.writable) cb = self._writeStateReloader(cb)

              self._waiting.push({
                hash: true,
                bytes: 0,
                index: len - 1,
                update: true,
                callback: cb
              })

              self._updatePeers()
            })
          }

          // will reload the writable state. used by .update on a writable peer
          Feed.prototype._writeStateReloader = function(cb) {
            var self = this
            return function(err) {
              if (err) return cb(err)

              self._roots(self.length, function(err, roots) {
                if (err) return cb(err)
                self._merkle = merkle(crypto, roots)
                cb(null)
              })
            }
          }

          Feed.prototype._open = function(cb) {
            var self = this
            var generatedKey = false

            // TODO: clean up the duplicate code below ...

            this._storage.openKey(function(_, key) {
              if (key && !self._overwrite && !self.key) self.key = key

              if (!self.key && self.live) {
                var keyPair = crypto.keyPair()
                self.secretKey = keyPair.secretKey
                self.key = keyPair.publicKey
                generatedKey = true
              }

              self.discoveryKey = self.key && crypto.discoveryKey(self.key)
              self._storage.open(
                { key: self.key, discoveryKey: self.discoveryKey },
                onopen
              )
            })

            function onopen(err, state) {
              if (err) return cb(err)

              // if no key but we have data do a bitfield reset since we cannot verify the data.
              if (!state.key && state.bitfield.length) {
                self._overwrite = true
              }

              if (self._overwrite) {
                state.bitfield.fill(0)
                state.key = state.secretKey = null
              }

              self.bitfield = bitfield(state.bitfield)
              self.tree = treeIndex(self.bitfield.tree)
              self.length = self.tree.blocks()

              if (state.key && self.key && !equals(state.key, self.key)) {
                return cb(new Error("Another hypercore is stored here"))
              }

              if (state.key) self.key = state.key
              if (state.secretKey) self.secretKey = state.secretKey

              // verify key and secretKey go together
              if (self.key && self.secretKey) {
                var challenge = bufferAlloc(0)
                if (
                  !crypto.verify(
                    challenge,
                    crypto.sign(challenge, self.secretKey),
                    self.key
                  )
                ) {
                  return cb(new Error("Key and secret do not match"))
                }
              }

              if (!self.length) return onsignature(null, null)
              self._storage.getSignature(self.length - 1, onsignature)

              function onsignature(_, sig) {
                if (self.length) self.live = !!sig

                if ((generatedKey || !self.key) && !self._createIfMissing) {
                  return cb(new Error("No hypercore is stored here"))
                }

                if (!self.key && self.live) {
                  var keyPair = crypto.keyPair()
                  self.secretKey = keyPair.secretKey
                  self.key = keyPair.publicKey
                }

                var writable = !!self.secretKey || self.key === null

                if (!writable && self.writable)
                  return cb(new Error("Feed is not writable"))
                self.writable = writable
                self.discoveryKey = self.key && crypto.discoveryKey(self.key)

                if (self._storeSecretKey && !self.secretKey) {
                  self._storeSecretKey = false
                }

                var shouldWriteKey =
                  generatedKey || !safeBufferEquals(self.key, state.key)
                var shouldWriteSecretKey =
                  self._storeSecretKey &&
                  (generatedKey ||
                    !safeBufferEquals(self.secretKey, state.secretKey))

                var missing =
                  1 +
                  (shouldWriteKey ? 1 : 0) +
                  (shouldWriteSecretKey ? 1 : 0) +
                  (self._overwrite ? 1 : 0)
                var error = null

                if (shouldWriteKey) self._storage.key.write(0, self.key, done)
                if (shouldWriteSecretKey)
                  self._storage.secretKey.write(0, self.secretKey, done)

                if (self._overwrite) {
                  // TODO: support storage.resize for this instead
                  self._storage.putBitfield(0, state.bitfield, done)
                }

                done(null)

                function done(err) {
                  if (err) error = err
                  if (--missing) return
                  if (error) return cb(error)
                  self._roots(self.length, onroots)
                }

                function onroots(err, roots) {
                  if (err) return cb(err)

                  self._merkle = merkle(crypto, roots)
                  self.byteLength = roots.reduce(addSize, 0)
                  self.opened = true
                  self.emit("ready")

                  cb(null)
                }
              }
            }
          }

          Feed.prototype.download = function(range, cb) {
            if (typeof range === "function") return this.download(null, range)
            if (typeof range === "number")
              range = { start: range, end: range + 1 }
            if (!range) range = {}

            // TODO: if no peers, check if range is already satisfied and nextTick(cb) if so
            // this._updatePeers does this for us when there is a peer though, so not critical

            var sel = {
              _index: this._selections.length,
              hash: !!range.hash,
              iterator: null,
              start: range.start || 0,
              end: range.end || -1,
              linear: !!range.linear,
              callback: cb || noop
            }

            this._selections.push(sel)
            this._updatePeers()

            return sel
          }

          Feed.prototype.undownload = function(range) {
            if (typeof range === "number")
              range = { start: range, end: range + 1 }
            if (!range) range = {}

            if (range.callback && range._index > -1) {
              set.remove(this._selections, range)
              nextTick(range.callback, new Error("Download was cancelled"))
              return
            }

            var start = range.start || 0
            var end = range.end || -1
            var hash = !!range.hash
            var linear = !!range.linear

            for (var i = 0; i < this._selections.length; i++) {
              var s = this._selections[i]

              if (
                s.start === start &&
                s.end === end &&
                s.hash === hash &&
                s.linear === linear
              ) {
                set.remove(this._selections, s)
                nextTick(s.callback, new Error("Download was cancelled"))
                return
              }
            }
          }

          Feed.prototype.digest = function(index) {
            return this.tree.digest(2 * index)
          }

          Feed.prototype.proof = function(index, opts, cb) {
            if (typeof opts === "function") return this.proof(index, null, opts)
            if (!this.opened) return this._readyAndProof(index, opts, cb)
            if (!opts) opts = {}

            var proof = this.tree.proof(2 * index, opts)
            if (!proof)
              return cb(new Error("No proof available for this index"))

            var needsSig = this.live && !!proof.verifiedBy
            var pending = proof.nodes.length + (needsSig ? 1 : 0)
            var error = null
            var signature = null
            var nodes = new Array(proof.nodes.length)

            if (!pending) return cb(null, { nodes: nodes, signature: null })

            for (var i = 0; i < proof.nodes.length; i++) {
              this._storage.getNode(proof.nodes[i], onnode)
            }
            if (needsSig) {
              this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature)
            }

            function onsignature(err, sig) {
              if (sig) signature = sig
              onnode(err, null)
            }

            function onnode(err, node) {
              if (err) error = err

              if (node) {
                nodes[proof.nodes.indexOf(node.index)] = node
              }

              if (--pending) return
              if (error) return cb(error)
              cb(null, { nodes: nodes, signature: signature })
            }
          }

          Feed.prototype._readyAndProof = function(index, opts, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.proof(index, opts, cb)
            })
          }

          Feed.prototype.put = function(index, data, proof, cb) {
            if (!this.opened) return this._readyAndPut(index, data, proof, cb)
            this._putBuffer(index, this._codec.encode(data), proof, null, cb)
          }

          Feed.prototype.cancel = function(start, end) {
            // TODO: use same argument scheme as download
            if (!end) end = start + 1

            // cancel these right away as .download does not wait for ready
            for (var i = this._selections.length - 1; i >= 0; i--) {
              var sel = this._selections[i]
              if (start <= sel.start && sel.end <= end) {
                this.undownload(sel)
              }
            }

            // defer the last part until after ready as .get does that as well
            if (this.opened) this._cancel(start, end)
            else this._readyAndCancel(start, end)
          }

          Feed.prototype._cancel = function(start, end) {
            var i = 0

            for (i = start; i < end; i++) {
              this._reserved.set(i, false) // TODO: send cancel message if set returns true
            }

            for (i = this._waiting.length - 1; i >= 0; i--) {
              var w = this._waiting[i]
              if (
                (start <= w.start && w.end <= end) ||
                (start <= w.index && w.index < end)
              ) {
                remove(this._waiting, i)
                if (w.callback)
                  nextTick(w.callback, new Error("Request cancelled"))
              }
            }
          }

          Feed.prototype.clear = function(start, end, opts, cb) {
            // TODO: use same argument scheme as download
            if (typeof end === "function")
              return this.clear(start, start + 1, null, end)
            if (typeof opts === "function")
              return this.clear(start, end, null, opts)
            if (!opts) opts = {}
            if (!end) end = start + 1
            if (!cb) cb = noop

            // TODO: this needs some work. fx we can only calc byte offset for blocks we know about
            // so internally we should make sure to only do that. We should use the merkle tree for this

            var self = this
            var byteOffset =
              start === 0
                ? 0
                : typeof opts.byteOffset === "number"
                  ? opts.byteOffset
                  : -1
            var byteLength =
              typeof opts.byteLength === "number" ? opts.byteLength : -1

            this._ready(function(err) {
              if (err) return cb(err)

              var modified = false

              // TODO: use a buffer.fill thing here to speed this up!

              for (var i = start; i < end; i++) {
                if (self.bitfield.set(i, false)) modified = true
              }

              if (!modified) return nextTick(cb)

              // TODO: write to a tmp/update file that we want to del this incase it crashes will del'ing

              self._unannounce({ start: start, length: end - start })
              if (opts.delete === false || self._indexing) return sync()
              if (byteOffset > -1) return onstartbytes(null, byteOffset)
              self._storage.dataOffset(start, [], onstartbytes)

              function sync() {
                self.emit("clear", start, end)
                self._sync(null, cb)
              }

              function onstartbytes(err, offset) {
                if (err) return cb(err)
                byteOffset = offset
                if (byteLength > -1)
                  return onendbytes(null, byteLength + byteOffset)
                if (end === self.length)
                  return onendbytes(null, self.byteLength)
                self._storage.dataOffset(end, [], onendbytes)
              }

              function onendbytes(err, end) {
                if (err) return cb(err)
                if (!self._storage.data.del) return sync() // Not all data storage impls del
                self._storage.data.del(byteOffset, end - byteOffset, sync)
              }
            })
          }

          Feed.prototype.signature = function(index, cb) {
            if (typeof index === "function")
              return this.signature(this.length - 1, index)

            if (index < 0 || index >= this.length)
              return cb(new Error("No signature available for this index"))

            this._storage.nextSignature(index, cb)
          }

          Feed.prototype.verify = function(index, signature, cb) {
            var self = this

            this.rootHashes(index, function(err, roots) {
              if (err) return cb(err)

              var checksum = crypto.tree(roots)

              if (!crypto.verify(checksum, signature, self.key)) {
                cb(new Error("Signature verification failed"))
              } else {
                cb(null, true)
              }
            })
          }

          Feed.prototype.rootHashes = function(index, cb) {
            this._getRootsToVerify(index * 2 + 2, {}, [], cb)
          }

          Feed.prototype.seek = function(bytes, opts, cb) {
            if (typeof opts === "function") return this.seek(bytes, null, opts)
            if (!opts) opts = {}
            if (!this.opened) return this._readyAndSeek(bytes, opts, cb)

            var self = this

            this._seek(bytes, function(err, index, offset) {
              if (!err && isBlock(index)) return done(index / 2, offset)
              if (opts.wait === false)
                return cb(err || new Error("Unable to seek to this offset"))

              var start = opts.start || 0
              var end = opts.end || -1

              if (!err) {
                var left = flat.leftSpan(index) / 2
                var right = flat.rightSpan(index) / 2 + 1

                if (left > start) start = left
                if (right < end || end === -1) end = right
              }

              if (end > -1 && end <= start)
                return cb(new Error("Unable to seek to this offset"))

              self._waiting.push({
                hash: opts.hash !== false,
                bytes: bytes,
                index: -1,
                start: start,
                end: end,
                callback: cb || noop
              })

              self._updatePeers()
            })

            function done(index, offset) {
              for (var i = 0; i < self.peers.length; i++) {
                self.peers[i].haveBytes(bytes)
              }
              cb(null, index, offset)
            }
          }

          Feed.prototype._seek = function(offset, cb) {
            if (offset === 0) return cb(null, 0, 0)

            var self = this
            var roots = flat.fullRoots(this.length * 2)
            var nearestRoot = 0

            loop(null, null)

            function onroot(top) {
              if (isBlock(top)) return cb(null, top, offset)

              var left = flat.leftChild(top)
              while (!self.tree.get(left)) {
                if (isBlock(left)) return cb(null, nearestRoot, offset)
                left = flat.leftChild(left)
              }

              self._storage.getNode(left, onleftchild)
            }

            function onleftchild(err, node) {
              if (err) return cb(err)

              if (node.size > offset) {
                nearestRoot = node.index
                onroot(node.index)
              } else {
                offset -= node.size
                onroot(flat.sibling(node.index))
              }
            }

            function loop(err, node) {
              if (err) return cb(err)

              if (node) {
                if (node.size > offset) {
                  nearestRoot = node.index
                  return onroot(node.index)
                }
                offset -= node.size
              }

              if (!roots.length) return cb(new Error("Out of bounds"))
              self._storage.getNode(roots.shift(), loop)
            }
          }

          Feed.prototype._readyAndSeek = function(bytes, opts, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.seek(bytes, opts, cb)
            })
          }

          Feed.prototype._getBuffer = function(index, cb) {
            this._storage.getData(index, cb)
          }

          Feed.prototype._putBuffer = function(index, data, proof, from, cb) {
            // TODO: this nodes in proof are not instances of our Node prototype
            // but just similar. Check if this has any v8 perf implications.

            // TODO: if the proof contains a valid signature BUT fails, emit a critical error
            // --> feed should be considered dead

            var self = this
            var trusted = -1
            var missing = []
            var next = 2 * index
            var i = data ? 0 : 1

            while (true) {
              if (this.tree.get(next)) {
                trusted = next
                break
              }

              var sib = flat.sibling(next)
              next = flat.parent(next)

              if (i < proof.nodes.length && proof.nodes[i].index === sib) {
                i++
                continue
              }

              if (!this.tree.get(sib)) break
              missing.push(sib)
            }

            if (trusted === -1 && this.tree.get(next)) trusted = next

            var error = null
            var trustedNode = null
            var missingNodes = new Array(missing.length)
            var pending = missing.length + (trusted > -1 ? 1 : 0)

            for (i = 0; i < missing.length; i++)
              this._storage.getNode(missing[i], onmissing)
            if (trusted > -1) this._storage.getNode(trusted, ontrusted)
            if (!missing.length && trusted === -1) onmissingloaded(null)

            function ontrusted(err, node) {
              if (err) error = err
              if (node) trustedNode = node
              if (!--pending) onmissingloaded(error)
            }

            function onmissing(err, node) {
              if (err) error = err
              if (node) missingNodes[missing.indexOf(node.index)] = node
              if (!--pending) onmissingloaded(error)
            }

            function onmissingloaded(err) {
              if (err) return cb(err)
              self._verifyAndWrite(
                index,
                data,
                proof,
                missingNodes,
                trustedNode,
                from,
                cb
              )
            }
          }

          Feed.prototype._readyAndPut = function(index, data, proof, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.put(index, data, proof, cb)
            })
          }

          Feed.prototype._write = function(index, data, nodes, sig, from, cb) {
            if (!this._onwrite)
              return this._writeAfterHook(index, data, nodes, sig, from, cb)
            this._onwrite(
              index,
              data,
              from,
              writeHookDone(this, index, data, nodes, sig, from, cb)
            )
          }

          function writeHookDone(self, index, data, nodes, sig, from, cb) {
            return function(err) {
              if (err) return cb(err)
              self._writeAfterHook(index, data, nodes, sig, from, cb)
            }
          }

          Feed.prototype._writeAfterHook = function(
            index,
            data,
            nodes,
            sig,
            from,
            cb
          ) {
            var self = this
            var pending = nodes.length + 1 + (sig ? 1 : 0)
            var error = null

            for (var i = 0; i < nodes.length; i++)
              this._storage.putNode(nodes[i].index, nodes[i], ondone)
            if (data) this._storage.putData(index, data, nodes, ondone)
            else ondone()
            if (sig)
              this._storage.putSignature(sig.index, sig.signature, ondone)

            function ondone(err) {
              if (err) error = err
              if (--pending) return
              if (error) return cb(error)
              self._writeDone(index, data, nodes, from, cb)
            }
          }

          Feed.prototype._writeDone = function(index, data, nodes, from, cb) {
            for (var i = 0; i < nodes.length; i++) this.tree.set(nodes[i].index)
            this.tree.set(2 * index)

            if (data) {
              if (this.bitfield.set(index, true))
                this.emit("download", index, data, from)
              if (this.peers.length) this._announce({ start: index }, from)

              if (!this.writable) {
                if (!this._synced)
                  this._synced = this.bitfield.iterator(0, this.length)
                if (this._synced.next() === -1) {
                  this._synced.range(0, this.length)
                  this._synced.seek(0)
                  if (this._synced.next() === -1) {
                    this.emit("sync")
                  }
                }
              }
            }

            this._sync(null, cb)
          }

          Feed.prototype._verifyAndWrite = function(
            index,
            data,
            proof,
            localNodes,
            trustedNode,
            from,
            cb
          ) {
            var visited = []
            var remoteNodes = proof.nodes
            var top = data
              ? new storage.Node(2 * index, crypto.data(data), data.length)
              : remoteNodes.shift()

            // check if we already have the hash for this node
            if (verifyNode(trustedNode, top)) {
              this._write(index, data, visited, null, from, cb)
              return
            }

            // keep hashing with siblings until we reach or trusted node
            while (true) {
              var node = null
              var next = flat.sibling(top.index)

              if (remoteNodes.length && remoteNodes[0].index === next) {
                node = remoteNodes.shift()
                visited.push(node)
              } else if (localNodes.length && localNodes[0].index === next) {
                node = localNodes.shift()
              } else {
                // we cannot create another parent, i.e. these nodes must be roots in the tree
                this._verifyRootsAndWrite(
                  index,
                  data,
                  top,
                  proof,
                  visited,
                  from,
                  cb
                )
                return
              }

              visited.push(top)
              top = new storage.Node(
                flat.parent(top.index),
                crypto.parent(top, node),
                top.size + node.size
              )

              // the tree checks out, write the data and the visited nodes
              if (verifyNode(trustedNode, top)) {
                this._write(index, data, visited, null, from, cb)
                return
              }
            }
          }

          Feed.prototype._verifyRootsAndWrite = function(
            index,
            data,
            top,
            proof,
            nodes,
            from,
            cb
          ) {
            var remoteNodes = proof.nodes
            var lastNode = remoteNodes.length
              ? remoteNodes[remoteNodes.length - 1].index
              : top.index
            var verifiedBy =
              Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2
            var self = this

            this._getRootsToVerify(verifiedBy, top, remoteNodes, function(
              err,
              roots,
              extraNodes
            ) {
              if (err) return cb(err)

              var checksum = crypto.tree(roots)
              var signature = null

              if (self.length && self.live && !proof.signature) {
                return cb(new Error("Remote did not include a signature"))
              }

              if (proof.signature) {
                // check signaturex
                if (!crypto.verify(checksum, proof.signature, self.key)) {
                  return cb(new Error("Remote signature could not be verified"))
                }

                signature = {
                  index: verifiedBy / 2 - 1,
                  signature: proof.signature
                }
              } else {
                // check tree root
                if (!equals(checksum, self.key)) {
                  return cb(new Error("Remote checksum failed"))
                }
              }

              self.live = !!signature

              var length = verifiedBy / 2
              if (length > self.length) {
                // TODO: only emit this after the info has been flushed to storage
                self.length = length
                self.byteLength = roots.reduce(addSize, 0)
                if (self._synced) self._synced.seek(0, self.length)
                self.emit("append")
              }

              self._write(
                index,
                data,
                nodes.concat(extraNodes),
                signature,
                from,
                cb
              )
            })
          }

          Feed.prototype._getRootsToVerify = function(
            verifiedBy,
            top,
            remoteNodes,
            cb
          ) {
            var indexes = flat.fullRoots(verifiedBy)
            var roots = new Array(indexes.length)
            var nodes = []
            var error = null
            var pending = roots.length

            for (var i = 0; i < indexes.length; i++) {
              if (indexes[i] === top.index) {
                nodes.push(top)
                onnode(null, top)
              } else if (
                remoteNodes.length &&
                indexes[i] === remoteNodes[0].index
              ) {
                nodes.push(remoteNodes[0])
                onnode(null, remoteNodes.shift())
              } else if (this.tree.get(indexes[i])) {
                this._storage.getNode(indexes[i], onnode)
              } else {
                onnode(new Error("Missing tree roots needed for verify"))
              }
            }

            function onnode(err, node) {
              if (err) error = err
              if (node) roots[indexes.indexOf(node.index)] = node
              if (!--pending) done(error)
            }

            function done(err) {
              if (err) return cb(err)

              cb(null, roots, nodes)
            }
          }

          Feed.prototype._announce = function(message, from) {
            for (var i = 0; i < this.peers.length; i++) {
              var peer = this.peers[i]
              if (peer !== from) peer.have(message)
            }
          }

          Feed.prototype._unannounce = function(message) {
            for (var i = 0; i < this.peers.length; i++)
              this.peers[i].unhave(message)
          }

          Feed.prototype.downloaded = function(start, end) {
            return this.bitfield.total(start, end)
          }

          Feed.prototype.has = function(start, end) {
            if (end === undefined) return this.bitfield.get(start)
            var total = end - start
            return total === this.bitfield.total(start, end)
          }

          Feed.prototype.head = function(opts, cb) {
            if (typeof opts === "function") return this.head({}, opts)
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              if (self.length === 0) cb(new Error("feed is empty"))
              else self.get(self.length - 1, cb)
            })
          }

          Feed.prototype.get = function(index, opts, cb) {
            if (typeof opts === "function") return this.get(index, null, opts)
            if (!this.opened) return this._readyAndGet(index, opts, cb)

            if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout)

            if (!this.bitfield.get(index)) {
              if (opts && opts.wait === false)
                return cb(new Error("Block not downloaded"))

              this._waiting.push({
                bytes: 0,
                hash: false,
                index: index,
                options: opts,
                callback: cb
              })
              this._updatePeers()
              return
            }

            if (opts && opts.valueEncoding)
              cb = wrapCodec(toCodec(opts.valueEncoding), cb)
            else if (this._codec !== codecs.binary)
              cb = wrapCodec(this._codec, cb)

            this._getBuffer(index, cb)
          }

          Feed.prototype._readyAndGet = function(index, opts, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.get(index, opts, cb)
            })
          }

          Feed.prototype._updatePeers = function() {
            for (var i = 0; i < this.peers.length; i++) this.peers[i].update()
          }

          Feed.prototype.createWriteStream = function() {
            var self = this
            return bulk.obj(write)

            function write(batch, cb) {
              self._batch(batch, cb)
            }
          }

          Feed.prototype.createReadStream = function(opts) {
            if (!opts) opts = {}

            var self = this
            var start = opts.start || 0
            var end = typeof opts.end === "number" ? opts.end : -1
            var live = !!opts.live
            var snapshot = opts.snapshot !== false
            var first = true
            var range = this.download({ start: start, end: end, linear: true })

            return from
              .obj(read)
              .on("end", cleanup)
              .on("close", cleanup)

            function read(size, cb) {
              if (!self.opened) return open(size, cb)

              if (first) {
                if (end === -1) {
                  if (live) end = Infinity
                  else if (snapshot) end = self.length
                }
                if (opts.tail) start = self.length
                first = false
              }

              if (start === end || (end === -1 && start === self.length))
                return cb(null, null)
              self.get(start++, opts, cb)
            }

            function cleanup() {
              if (!range) return
              self.undownload(range)
              range = null
            }

            function open(size, cb) {
              self._ready(function(err) {
                if (err) return cb(err)
                read(size, cb)
              })
            }
          }

          // TODO: when calling finalize on a live feed write an END_OF_FEED block (length === 0?)
          Feed.prototype.finalize = function(cb) {
            if (!this.key) {
              this.key = crypto.tree(this._merkle.roots)
              this.discoveryKey = crypto.discoveryKey(this.key)
            }
            this._storage.key.write(0, this.key, cb)
          }

          Feed.prototype.append = function(batch, cb) {
            this._batch(Array.isArray(batch) ? batch : [batch], cb || noop)
          }

          Feed.prototype.flush = function(cb) {
            this._batch([], cb)
          }

          Feed.prototype.close = function(cb) {
            var self = this

            this._ready(function() {
              self.writable = false
              self.readable = false
              self._storage.close(function(err) {
                if (!self.closed && !err) {
                  self.closed = true
                  self.emit("close")
                }
                if (cb) cb(err)
              })
            })
          }

          Feed.prototype._appendHook = function(batch, cb) {
            var self = this
            var missing = batch.length
            var error = null

            if (!missing) return this._append(batch, cb)
            for (var i = 0; i < batch.length; i++) {
              this._onwrite(i + this.length, batch[i], null, done)
            }

            function done(err) {
              if (err) error = err
              if (--missing) return
              if (error) return cb(error)
              self._append(batch, cb)
            }
          }

          Feed.prototype._append = function(batch, cb) {
            if (!this.opened) return this._readyAndAppend(batch, cb)
            if (!this.writable)
              return cb(
                new Error("This feed is not writable. Did you create it?")
              )

            var self = this
            var pending =
              this.live && batch.length ? 1 + batch.length : batch.length
            var offset = 0
            var error = null

            if (!pending) return cb()

            for (var i = 0; i < batch.length; i++) {
              var data = this._codec.encode(batch[i])
              var nodes = this._merkle.next(data)

              if (this._indexing) done(null)
              else
                this._storage.data.write(this.byteLength + offset, data, done)

              if (this.live && i === batch.length - 1) {
                var sig = crypto.sign(
                  crypto.tree(this._merkle.roots),
                  this.secretKey
                )
                this._storage.putSignature(this.length + i, sig, done)
              }

              pending += nodes.length
              offset += data.length

              for (var j = 0; j < nodes.length; j++) {
                var node = nodes[j]
                this._storage.putNode(node.index, node, done)
              }
            }

            function done(err) {
              if (err) error = err
              if (--pending) return
              if (error) return cb(error)

              var start = self.length

              // TODO: only emit append and update length / byteLength after the info has been flushed to storage
              self.byteLength += offset
              for (var i = 0; i < batch.length; i++) {
                self.bitfield.set(self.length, true)
                self.tree.set(2 * self.length++)
              }
              self.emit("append")

              var message =
                self.length - start > 1
                  ? { start: start, length: self.length - start }
                  : { start: start }
              if (self.peers.length) self._announce(message)

              self._sync(null, cb)
            }
          }

          Feed.prototype._readyAndAppend = function(batch, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self._append(batch, cb)
            })
          }

          Feed.prototype._readyAndCancel = function(start, end) {
            var self = this
            this.ready(function() {
              self._cancel(start, end)
            })
          }

          Feed.prototype._pollWaiting = function() {
            var len = this._waiting.length
            for (var i = 0; i < len; i++) {
              var next = this._waiting[i]
              if (!next.bytes && !this.bitfield.get(next.index)) continue

              remove(this._waiting, i--)
              len--

              if (next.bytes) this.seek(next.bytes, next, next.callback)
              else if (next.update) this.update(next.index + 1, next.callback)
              else this.get(next.index, next.options, next.callback)
            }
          }

          Feed.prototype._syncBitfield = function(cb) {
            var missing = this.bitfield.pages.updates.length
            var next = null
            var error = null

            // All data / nodes have been written now. We still need to update the bitfields though

            // TODO 1: if the program fails during this write the bitfield might not have been fully written
            // HOWEVER, we can easily recover from this by traversing the tree and checking if the nodes exists
            // on disk. So if a get fails, it should try and recover once.

            // TODO 2: if .writable append bitfield updates into a single buffer for extra perf
            // Added benefit is that if the program exits while flushing the bitfield the feed will only get
            // truncated and not have missing chunks which is what you expect.

            if (!missing) {
              this._pollWaiting()
              return cb(null)
            }

            while ((next = this.bitfield.pages.lastUpdate()) !== null) {
              this._storage.putBitfield(next.offset, next.buffer, ondone)
            }

            this._pollWaiting()

            function ondone(err) {
              if (err) error = err
              if (--missing) return
              cb(error)
            }
          }

          Feed.prototype._roots = function(index, cb) {
            var roots = flat.fullRoots(2 * index)
            var result = new Array(roots.length)
            var pending = roots.length
            var error = null

            if (!pending) return cb(null, result)

            for (var i = 0; i < roots.length; i++) {
              this._storage.getNode(roots[i], onnode)
            }

            function onnode(err, node) {
              if (err) error = err
              if (node) result[roots.indexOf(node.index)] = node
              if (--pending) return
              if (error) return cb(error)
              cb(null, result)
            }
          }

          function noop() {}

          function verifyNode(trusted, node) {
            return (
              trusted &&
              trusted.index === node.index &&
              equals(trusted.hash, node.hash)
            )
          }

          function addSize(size, node) {
            return size + node.size
          }

          function isBlock(index) {
            return (index & 1) === 0
          }

          function defaultStorage(dir) {
            return function(name) {
              return raf(name, { directory: dir })
            }
          }

          function toCodec(enc) {
            // Switch to ndjson encoding if JSON is used. That way data files parse like ndjson \o/
            return codecs(enc === "json" ? "ndjson" : enc)
          }

          function wrapCodec(enc, cb) {
            return function(err, buf) {
              if (err) return cb(err)
              try {
                buf = enc.decode(buf)
              } catch (err) {
                return cb(err)
              }
              cb(null, buf)
            }
          }

          function timeoutCallback(cb, timeout) {
            var failed = false
            var id = setTimeout(ontimeout, timeout)
            return done

            function ontimeout() {
              failed = true
              // TODO: make libs/errors for all this stuff
              var err = new Error("ETIMEDOUT")
              err.code = "ETIMEDOUT"
              cb(err)
            }

            function done(err, val) {
              if (failed) return
              clearTimeout(id)
              cb(err, val)
            }
          }

          // buffer-equals, but handle 'null' buffer parameters.
          function safeBufferEquals(a, b) {
            if (!a) return !b
            if (!b) return !a
            return equals(a, b)
          }
        }.call(this, { isBuffer: require("../is-buffer/index.js") }))
      },
      {
        "../is-buffer/index.js": 38,
        "./lib/bitfield": 31,
        "./lib/crypto": 32,
        "./lib/replicate": 33,
        "./lib/storage": 34,
        "./lib/tree-index": 35,
        "atomic-batcher": 4,
        "buffer-alloc-unsafe": 15,
        "buffer-equals": 17,
        "buffer-from": 19,
        "bulk-write-stream": 21,
        codecs: 22,
        events: 24,
        "flat-tree": 25,
        from2: 26,
        inherits: 37,
        "last-one-wins": 39,
        "merkle-tree-stream/generator": 41,
        "process-nextick-args": 43,
        "random-access-file": 46,
        "sparse-bitfield": 72,
        thunky: 74,
        "unordered-array-remove": 77,
        "unordered-set": 78
      }
    ],
    31: [
      function(require, module, exports) {
        var flat = require("flat-tree")
        var rle = require("bitfield-rle")
        var pager = require("memory-pager")
        var bitfield = require("sparse-bitfield")

        var INDEX_UPDATE_MASK = [63, 207, 243, 252]
        var INDEX_ITERATE_MASK = [0, 192, 240, 252]
        var DATA_ITERATE_MASK = [128, 192, 224, 240, 248, 252, 254, 255]
        var DATA_UPDATE_MASK = [127, 191, 223, 239, 247, 251, 253, 254]
        var MAP_PARENT_RIGHT = new Array(256)
        var MAP_PARENT_LEFT = new Array(256)
        var NEXT_DATA_0_BIT = new Array(256)
        var NEXT_INDEX_0_BIT = new Array(256)
        var TOTAL_1_BITS = new Array(256)

        for (var i = 0; i < 256; i++) {
          var a = (i & (15 << 4)) >> 4
          var b = i & 15
          var nibble = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]
          MAP_PARENT_RIGHT[i] =
            ((a === 15 ? 3 : a === 0 ? 0 : 1) << 2) |
            (b === 15 ? 3 : b === 0 ? 0 : 1)
          MAP_PARENT_LEFT[i] = MAP_PARENT_RIGHT[i] << 4
          NEXT_DATA_0_BIT[i] =
            i === 255 ? -1 : 8 - Math.ceil(Math.log(256 - i) / Math.log(2))
          NEXT_INDEX_0_BIT[i] =
            i === 255 ? -1 : Math.floor(NEXT_DATA_0_BIT[i] / 2)
          TOTAL_1_BITS[i] = nibble[i >> 4] + nibble[i & 0x0f]
        }

        module.exports = Bitfield

        function Bitfield(buffer) {
          if (!(this instanceof Bitfield)) return new Bitfield(buffer)

          this.pages = pager(3328)

          if (buffer) {
            for (var i = 0; i < buffer.length; i += 3328) {
              this.pages.set(i / 3328, buffer.slice(i, i + 3328))
            }
          }

          this.data = bitfield({
            pageSize: 1024,
            pageOffset: 0,
            pages: this.pages,
            trackUpdates: true
          })

          this.tree = bitfield({
            pageSize: 2048,
            pageOffset: 1024,
            pages: this.pages,
            trackUpdates: true
          })

          this.index = bitfield({
            pageSize: 256,
            pageOffset: 1024 + 2048,
            pages: this.pages,
            trackUpdates: true
          })

          this.length = this.data.length
          this._iterator = flat.iterator(0)
        }

        Bitfield.prototype.set = function(i, value) {
          var o = i & 7
          i = (i - o) / 8
          var v = value
            ? this.data.getByte(i) | (128 >> o)
            : this.data.getByte(i) & DATA_UPDATE_MASK[o]

          if (!this.data.setByte(i, v)) return false
          this.length = this.data.length
          this._setIndex(i, v)
          return true
        }

        Bitfield.prototype.get = function(i) {
          return this.data.get(i)
        }

        Bitfield.prototype.total = function(start, end) {
          if (!start || start < 0) start = 0
          if (!end) end = this.data.length
          if (end < start) return 0
          if (end > this.data.length) {
            this._expand(end)
          }
          var o = start & 7
          var e = end & 7
          var pos = (start - o) / 8
          var last = (end - e) / 8
          var leftMask = 255 - (o ? DATA_ITERATE_MASK[o - 1] : 0)
          var rightMask = e ? DATA_ITERATE_MASK[e - 1] : 0
          var byte = this.data.getByte(pos)
          if (pos === last) {
            return TOTAL_1_BITS[byte & leftMask & rightMask]
          }
          var total = TOTAL_1_BITS[byte & leftMask]
          for (var i = pos + 1; i < last; i++) {
            total += TOTAL_1_BITS[this.data.getByte(i)]
          }
          total += TOTAL_1_BITS[this.data.getByte(last) & rightMask]
          return total
        }

        // TODO: use the index to speed this up *a lot*
        Bitfield.prototype.compress = function() {
          return rle.encode(this.data.toBuffer())
        }

        Bitfield.prototype._setIndex = function(i, value) {
          //                    (a + b | c + d | e + f | g + h)
          // -> (a | b | c | d)                                (e | f | g | h)
          //

          var o = i & 3
          i = (i - o) / 4

          var bitfield = this.index
          var ite = this._iterator
          var start = 2 * i
          var byte =
            (bitfield.getByte(start) & INDEX_UPDATE_MASK[o]) |
            (getIndexValue(value) >> (2 * o))
          var len = bitfield.length
          var maxLength = this.pages.length * 256

          ite.seek(start)

          while (ite.index < maxLength && bitfield.setByte(ite.index, byte)) {
            if (ite.isLeft()) {
              byte =
                MAP_PARENT_LEFT[byte] |
                MAP_PARENT_RIGHT[bitfield.getByte(ite.sibling())]
            } else {
              byte =
                MAP_PARENT_RIGHT[byte] |
                MAP_PARENT_LEFT[bitfield.getByte(ite.sibling())]
            }
            ite.parent()
          }

          if (len !== bitfield.length) this._expand(len)

          return ite.index !== start
        }

        Bitfield.prototype._expand = function(len) {
          var roots = flat.fullRoots(2 * len)
          var bitfield = this.index
          var ite = this._iterator
          var byte = 0

          for (var i = 0; i < roots.length; i++) {
            ite.seek(roots[i])
            byte = bitfield.getByte(ite.index)

            do {
              if (ite.isLeft()) {
                byte =
                  MAP_PARENT_LEFT[byte] |
                  MAP_PARENT_RIGHT[bitfield.getByte(ite.sibling())]
              } else {
                byte =
                  MAP_PARENT_RIGHT[byte] |
                  MAP_PARENT_LEFT[bitfield.getByte(ite.sibling())]
              }
            } while (setByteNoAlloc(bitfield, ite.parent(), byte))
          }
        }

        function setByteNoAlloc(bitfield, i, b) {
          if (8 * i >= bitfield.length) return false
          return bitfield.setByte(i, b)
        }

        Bitfield.prototype.iterator = function(start, end) {
          var ite = new Iterator(this)

          ite.range(start || 0, end || this.length)
          ite.seek(0)

          return ite
        }

        function Iterator(bitfield) {
          this.start = 0
          this.end = 0

          this._indexEnd = 0
          this._pos = 0
          this._byte = 0
          this._bitfield = bitfield
        }

        Iterator.prototype.range = function(start, end) {
          this.start = start
          this.end = end
          this._indexEnd = 2 * Math.ceil(end / 32)

          if (this.end > this._bitfield.length) {
            this._bitfield._expand(this.end)
          }

          return this
        }

        Iterator.prototype.seek = function(offset) {
          offset += this.start
          if (offset < this.start) offset = this.start

          if (offset >= this.end) {
            this._pos = -1
            return this
          }

          var o = offset & 7

          this._pos = (offset - o) / 8
          this._byte =
            this._bitfield.data.getByte(this._pos) |
            (o ? DATA_ITERATE_MASK[o - 1] : 0)

          return this
        }

        Iterator.prototype.random = function() {
          var i = this.seek(
            Math.floor(Math.random() * (this.end - this.start))
          ).next()
          return i === -1 ? this.seek(0).next() : i
        }

        Iterator.prototype.next = function() {
          if (this._pos === -1) return -1

          var dataBitfield = this._bitfield.data
          var free = NEXT_DATA_0_BIT[this._byte]

          while (free === -1) {
            this._byte = dataBitfield.getByte(++this._pos)
            free = NEXT_DATA_0_BIT[this._byte]

            if (free === -1) {
              this._pos = this._skipAhead(this._pos)
              if (this._pos === -1) return -1

              this._byte = dataBitfield.getByte(this._pos)
              free = NEXT_DATA_0_BIT[this._byte]
            }
          }

          this._byte |= DATA_ITERATE_MASK[free]

          var n = 8 * this._pos + free
          return n < this.end ? n : -1
        }

        Iterator.prototype.peek = function() {
          if (this._pos === -1) return -1

          var free = NEXT_DATA_0_BIT[this._byte]
          var n = 8 * this._pos + free
          return n < this.end ? n : -1
        }

        Iterator.prototype._skipAhead = function(start) {
          var indexBitfield = this._bitfield.index
          var treeEnd = this._indexEnd
          var ite = this._bitfield._iterator
          var o = start & 3

          ite.seek(2 * ((start - o) / 4))

          var treeByte =
            indexBitfield.getByte(ite.index) | INDEX_ITERATE_MASK[o]

          while (NEXT_INDEX_0_BIT[treeByte] === -1) {
            if (ite.isLeft()) {
              ite.next()
            } else {
              ite.next()
              ite.parent()
            }

            if (rightSpan(ite) >= treeEnd) {
              while (rightSpan(ite) >= treeEnd && isParent(ite)) ite.leftChild()
              if (rightSpan(ite) >= treeEnd) return -1
            }

            treeByte = indexBitfield.getByte(ite.index)
          }

          while (ite.factor > 2) {
            if (NEXT_INDEX_0_BIT[treeByte] < 2) ite.leftChild()
            else ite.rightChild()

            treeByte = indexBitfield.getByte(ite.index)
          }

          var free = NEXT_INDEX_0_BIT[treeByte]
          if (free === -1) free = 4

          var next = ite.index * 2 + free

          return next <= start ? start + 1 : next
        }

        function rightSpan(ite) {
          return ite.index + ite.factor / 2 - 1
        }

        function isParent(ite) {
          return ite.index & 1
        }

        function getIndexValue(n) {
          switch (n) {
            case 255:
              return 192
            case 0:
              return 0
            default:
              return 64
          }
        }
      },
      {
        "bitfield-rle": 6,
        "flat-tree": 25,
        "memory-pager": 40,
        "sparse-bitfield": 72
      }
    ],
    32: [
      function(require, module, exports) {
        var sodium = require("sodium-universal")
        var uint64be = require("uint64be")
        var bufferFrom = require("buffer-from")
        var bufferAlloc = require("buffer-alloc-unsafe")

        // https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack
        var LEAF_TYPE = bufferFrom([0])
        var PARENT_TYPE = bufferFrom([1])
        var ROOT_TYPE = bufferFrom([2])
        var HYPERCORE = bufferFrom("hypercore")

        exports.keyPair = function(seed) {
          var publicKey = bufferAlloc(sodium.crypto_sign_PUBLICKEYBYTES)
          var secretKey = bufferAlloc(sodium.crypto_sign_SECRETKEYBYTES)

          if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)
          else sodium.crypto_sign_keypair(publicKey, secretKey)

          return {
            publicKey: publicKey,
            secretKey: secretKey
          }
        }

        exports.sign = function(message, secretKey) {
          var signature = bufferAlloc(sodium.crypto_sign_BYTES)
          sodium.crypto_sign_detached(signature, message, secretKey)
          return signature
        }

        exports.verify = function(message, signature, publicKey) {
          return sodium.crypto_sign_verify_detached(
            signature,
            message,
            publicKey
          )
        }

        exports.data = function(data) {
          return blake2b([LEAF_TYPE, encodeUInt64(data.length), data])
        }

        exports.leaf = function(leaf) {
          return exports.data(leaf.data)
        }

        exports.parent = function(a, b) {
          if (a.index > b.index) {
            var tmp = a
            a = b
            b = tmp
          }

          return blake2b([
            PARENT_TYPE,
            encodeUInt64(a.size + b.size),
            a.hash,
            b.hash
          ])
        }

        exports.tree = function(roots) {
          var buffers = new Array(3 * roots.length + 1)
          var j = 0

          buffers[j++] = ROOT_TYPE

          for (var i = 0; i < roots.length; i++) {
            var r = roots[i]
            buffers[j++] = r.hash
            buffers[j++] = encodeUInt64(r.index)
            buffers[j++] = encodeUInt64(r.size)
          }

          return blake2b(buffers)
        }

        exports.randomBytes = function(n) {
          var buf = bufferAlloc(n)
          sodium.randombytes_buf(buf)
          return buf
        }

        exports.discoveryKey = function(tree) {
          var digest = bufferAlloc(32)
          sodium.crypto_generichash(digest, HYPERCORE, tree)
          return digest
        }

        function encodeUInt64(n) {
          return uint64be.encode(n, bufferAlloc(8))
        }

        function blake2b(buffers) {
          var digest = bufferAlloc(32)
          sodium.crypto_generichash_batch(digest, buffers)
          return digest
        }
      },
      {
        "buffer-alloc-unsafe": 15,
        "buffer-from": 19,
        "sodium-universal": 70,
        uint64be: 76
      }
    ],
    33: [
      function(require, module, exports) {
        var protocol = require("hypercore-protocol")
        var bitfield = require("sparse-bitfield")
        var set = require("unordered-set")
        var rle = require("bitfield-rle")

        module.exports = replicate

        function replicate(feed, opts) {
          var stream = opts.stream

          if (!stream) {
            if (!opts.expectedFeeds) opts.expectedFeeds = 1
            if (!opts.id) opts.id = feed.id
            stream = protocol(opts)
          }

          feed.ready(function(err) {
            if (err) return stream.destroy(err)
            if (stream.destroyed) return

            var peer = new Peer(feed, opts)
            peer.feed = feed
            peer.stream = stream.feed(feed.key, { peer: peer })

            peer.remoteId = stream.remoteId
            stream.setMaxListeners(0)
            stream.on("handshake", function() {
              peer.remoteId = stream.remoteId
            })

            // stream might get destroyed on feed init in case of conf errors
            if (stream.destroyed) return

            peer.ready()
          })

          return stream
        }

        function Peer(feed, opts) {
          this.feed = feed
          this.stream = null // set by replicate just after creation
          this.remoteId = null
          this.remoteBitfield = null
          this.remoteLength = 0
          this.remoteWant = false
          this.live = !!opts.live
          this.sparse = feed.sparse

          this.remoteDownloading = true
          this.downloading =
            typeof opts.download === "boolean" ? opts.download : !feed.writable
          this.uploading = true

          this.maxRequests = opts.maxRequests || feed.maxRequests || 16
          this.inflightRequests = []

          this._index = -1
          this._lastBytes = 0
          this._first = true
          this._closed = false
          this._destroyed = false
          this._defaultDownloading = this.downloading
        }

        Peer.prototype.onwant = function() {
          // TODO: reply to the actual want context
          this.remoteWant = true
          var rle = this.feed.bitfield.compress()
          this.stream.have({ start: 0, bitfield: rle })
        }

        Peer.prototype.ondata = function(data) {
          var self = this

          // Ignore unrequested messages unless we allow push
          // TODO: would be better to check if the byte range was requested instead, but this works fine
          var allowPush = this.feed.allowPush || !data.value
          if (!allowPush && !this.feed._reserved.get(data.index)) {
            // If we do not have this block, send back unhave message for this index,
            // to let the remote know we rejected it.
            // TODO: we might want to have some "unwanted push" threshold to punish spammers
            if (!self.feed.bitfield.get(data.index))
              self.unhave({ start: data.index })
            self._clear(data.index, !data.value)
            return
          }

          this.feed._putBuffer(data.index, data.value, data, this, function(
            err
          ) {
            if (err) return self.destroy(err)
            self._clear(data.index, !data.value)
          })
        }

        Peer.prototype._clear = function(index, hash) {
          // TODO: optimize me (no splice and do not run through all ...)
          for (var i = 0; i < this.inflightRequests.length; i++) {
            if (this.inflightRequests[i].index === index) {
              this.inflightRequests.splice(i, 1)
              i--
            }
          }

          this.feed._reserved.set(index, false)
          // TODO: only update all if we have overlapping selections
          this.feed._updatePeers()
        }

        Peer.prototype.onrequest = function(request) {
          if (request.bytes) return this._onbytes(request)

          var self = this
          var opts = { digest: request.nodes, hash: request.hash }

          this.feed.proof(request.index, opts, onproof)

          function onproof(err, proof) {
            if (err) return self.destroy(err)
            if (request.hash) onvalue(null, null)
            else if (self.feed.bitfield.get(request.index))
              self.feed._getBuffer(request.index, onvalue)

            function onvalue(err, value) {
              if (err) return self.destroy(err)

              if (!self.remoteBitfield) self.remoteBitfield = bitfield()

              if (value) {
                if (!self.remoteBitfield.set(request.index, true)) return
                self.feed.emit("upload", request.index, value, self)
              } else {
                if (self.remoteBitfield.get(request.index)) return
              }

              if (request.index + 1 > self.remoteLength) {
                self.remoteLength = request.index + 1
                self._updateEnd()
              }

              self.stream.data({
                index: request.index,
                value: value,
                nodes: proof.nodes,
                signature: proof.signature
              })
            }
          }
        }

        Peer.prototype._onbytes = function(request) {
          var self = this

          this.feed.seek(request.bytes, { wait: false }, function(err, index) {
            if (err) {
              request.bytes = 0
              self.onrequest(request)
              return
            }

            // quick'n'dirty filter for parallel bytes requests
            // it does not matter that this doesn't catch ALL parallel requests - just a bandwidth optimization
            if (self._lastBytes === request.bytes) return
            self._lastBytes = request.bytes

            request.bytes = 0
            request.index = index
            request.nodes = 0

            self.onrequest(request)
          })
        }

        Peer.prototype.ontick = function() {
          if (!this.inflightRequests.length) return

          var first = this.inflightRequests[0]
          if (--first.tick) return

          if (
            first.hash
              ? this.feed.tree.get(2 * first.index)
              : this.feed.bitfield.get(first.index)
          ) {
            // prob a bytes response
            this.inflightRequests.shift()
            this.feed._reserved.set(first.index, false)
            return
          }

          this.destroy(new Error("Request timeout"))
        }

        Peer.prototype.onhave = function(have) {
          var updated = this._first
          if (this._first) this._first = false

          if (have.bitfield) {
            // TODO: handle start !== 0
            this.remoteBitfield = bitfield(rle.decode(have.bitfield))
            if (this.remoteBitfield.length > this.remoteLength) {
              this.remoteLength = this.remoteBitfield.length
              while (
                this.remoteLength &&
                !this.remoteBitfield.get(this.remoteLength - 1)
              )
                this.remoteLength--
              updated = true
            }
          } else {
            if (!this.remoteBitfield) this.remoteBitfield = bitfield()
            // TODO: if len > something simply copy a 0b1111... buffer to the bitfield

            var start = have.start
            var len = have.length || 1

            while (len--) this.remoteBitfield.set(start++, true)
            if (start > this.remoteLength) {
              this.remoteLength = start
              updated = true
            }
          }

          if (updated) {
            this.feed.emit("remote-update", this)
          }

          this._updateEnd()
          this.update()
        }

        Peer.prototype._updateEnd = function() {
          if (this.live || this.feed.sparse || !this.feed._selections.length)
            return

          var sel = this.feed._selections[0]
          var remoteLength = this.feed.length || -1

          for (var i = 0; i < this.feed.peers.length; i++) {
            if (this.feed.peers[i].remoteLength > remoteLength) {
              remoteLength = this.feed.peers[i].remoteLength
            }
          }

          sel.end = remoteLength
        }

        Peer.prototype.oninfo = function(info) {
          this.remoteDownloading = info.downloading
          if (info.downloading || this.live) return
          this.update()
          if (this.feed._selections.length && this.downloading) return
          this.end()
        }

        Peer.prototype.onunhave = function(unhave) {
          if (!this.remoteBitfield) return

          var start = unhave.start
          var len = unhave.length || 1

          while (len--) this.remoteBitfield.set(start++, false)
        }

        Peer.prototype.onunwant = Peer.prototype.oncancel = function() {
          // TODO: impl all of me
        }

        Peer.prototype.onclose = function() {
          this.destroy()
        }

        Peer.prototype.have = function(have) {
          // called by feed
          if (this.stream && this.remoteWant) this.stream.have(have)
        }

        Peer.prototype.unhave = function(unhave) {
          // called by feed
          if (this.stream && this.remoteWant) this.stream.unhave(unhave)
        }

        Peer.prototype.haveBytes = function(bytes) {
          // called by feed
          for (var i = 0; i < this.inflightRequests.length; i++) {
            if (this.inflightRequests[i].bytes === bytes) {
              this.feed._reserved.set(this.inflightRequests[i].index, false)
              this.inflightRequests.splice(i, 1)
              i--
            }
          }

          this.update()
        }

        Peer.prototype.update = function() {
          // do nothing
          while (this._update()) {}
        }

        Peer.prototype._update = function() {
          // should return true if mutated false if not
          if (!this.downloading || !this.remoteBitfield) return false

          var selections = this.feed._selections
          var waiting = this.feed._waiting
          var wlen = waiting.length
          var slen = selections.length
          var inflight = this.inflightRequests.length
          var offset = 0
          var i = 0

          // TODO: less duplicate code here
          // TODO: re-add priority levels

          while (inflight < this.maxRequests) {
            offset = Math.floor(Math.random() * waiting.length)

            for (i = 0; i < waiting.length; i++) {
              var w = waiting[offset++]
              if (offset === waiting.length) offset = 0

              this._downloadWaiting(w)
              if (waiting.length !== wlen) return true // mutated
              if (this.inflightRequests.length >= this.maxRequests) return false
            }
            if (inflight === this.inflightRequests.length) break
            inflight = this.inflightRequests.length
          }

          while (inflight < this.maxRequests) {
            offset = Math.floor(Math.random() * selections.length)

            for (i = 0; i < selections.length; i++) {
              var s = selections[offset++]
              if (offset === selections.length) offset = 0

              if (!s.iterator)
                s.iterator = this.feed.bitfield.iterator(s.start, s.end)
              this._downloadRange(s)
              if (selections.length !== slen) return true // mutated
              if (this.inflightRequests.length >= this.maxRequests) return false
            }

            if (inflight === this.inflightRequests.length) return false
            inflight = this.inflightRequests.length
          }

          return false
        }

        Peer.prototype.ready = function() {
          set.add(this.feed.peers, this)
          this.stream.want({ start: 0 }) // TODO: don't just subscribe to *EVERYTHING* hehe
          this.feed.emit("peer-add", this)
        }

        Peer.prototype.end = function() {
          if (!this.downloading && !this.remoteDownloading && !this.live) {
            if (!this._defaultDownloading) {
              this.stream.info({ downloading: false, uploading: false })
            }
            this._close()
            return
          }
          if (!this._closed) {
            this._closed = true
            this.downloading = false
            this.stream.info({ downloading: false, uploading: true })
          } else {
            if (!this.live) this._close()
          }
        }

        Peer.prototype._close = function() {
          if (this._index === -1) return
          if (!this._destroyed) {
            this.stream.close()
            this._destroyed = true
          }
          set.remove(this.feed.peers, this)
          this._index = -1
          for (var i = 0; i < this.inflightRequests.length; i++) {
            this.feed._reserved.set(this.inflightRequests[i].index, false)
          }
          this._updateEnd()
          this.remoteWant = false
          this.feed._updatePeers()
          this.feed.emit("peer-remove", this)
        }

        Peer.prototype.destroy = function(err) {
          if (this._index === -1 || this._destroyed) return
          this.stream.destroy(err)
          this._destroyed = true
          this._close()
        }

        Peer.prototype._downloadWaiting = function(wait) {
          if (!wait.bytes) {
            if (
              !this.remoteBitfield.get(wait.index) ||
              !this.feed._reserved.set(wait.index, true)
            )
              return
            this._request(wait.index, 0, false)
            return
          }

          this._downloadRange(wait)
        }

        Peer.prototype._downloadRange = function(range) {
          if (!range.iterator)
            range.iterator = this.feed.bitfield.iterator(range.start, range.end)

          var reserved = this.feed._reserved
          var ite = range.iterator
          var wantedEnd = Math.min(
            range.end === -1 ? this.remoteLength : range.end,
            this.remoteLength
          )

          if (ite.end !== wantedEnd) ite.range(range.start, wantedEnd)

          var i = range.linear ? ite.next() : ite.random()
          var reset = false
          var start = i

          if (i === -1) {
            if (
              !range.bytes &&
              ite.seek(0).next() === -1 &&
              (range.end > -1 && this.remoteLength >= range.end)
            ) {
              set.remove(this.feed._selections, range)
              range.callback(null)
              if (!this.live && !this.sparse && !this.feed._selections.length)
                this.end()
            }
            return
          }

          while (
            !this.remoteBitfield.get(i) ||
            (range.hash && this.feed.tree.get(2 * i)) ||
            !reserved.set(i, true)
          ) {
            i = ite.next()
            reset = true

            if (i > -1) {
              // check this index
              continue
            }

            if (!range.linear && start !== 0) {
              // retry from the beginning since we are iterating randomly and started !== 0
              i = ite.seek(0).next()
              start = 0
              continue
            }

            // we have checked all indexes.
            // if we are looking for hashes we should check if we have all now (first check only checks blocks)
            if (range.hash) {
              // quick'n'dirty check if have all hashes - can be optimized be checking only tree roots
              // but we don't really request long ranges of hashes so yolo
              for (var j = range.start; j < wantedEnd; j++) {
                if (!this.feed.tree.get(2 * j)) return
              }
              if (!range.bytes) {
                set.remove(this.feed._selections, range)
                range.callback(null)
              }
            }

            // exit the update loop - nothing to do
            return
          }

          if (reset) ite.seek(0)

          this._request(i, range.bytes || 0, range.hash)
        }

        Peer.prototype._request = function(index, bytes, hash) {
          var request = {
            tick: 6,
            bytes: bytes,
            index: index,
            hash: hash,
            nodes: this.feed.digest(index)
          }

          this.inflightRequests.push(request)
          this.stream.request(request)
        }
      },
      {
        "bitfield-rle": 6,
        "hypercore-protocol": 28,
        "sparse-bitfield": 72,
        "unordered-set": 78
      }
    ],
    34: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var uint64be = require("uint64be")
          var flat = require("flat-tree")
          var alru = require("array-lru")
          var bufferAlloc = require("buffer-alloc-unsafe")

          module.exports = Storage

          var noarr = []

          function Storage(create, cacheSize) {
            if (!(this instanceof Storage))
              return new Storage(create, cacheSize)
            cacheSize = typeof cacheSize === "undefined" ? 65536 : cacheSize

            this.cache =
              cacheSize > 0 ? alru(cacheSize, { indexedValues: true }) : null
            this.key = null
            this.secretKey = null
            this.tree = null
            this.data = null
            this.bitfield = null
            this.signatures = null
            this.create = create
          }

          Storage.prototype.putData = function(index, data, nodes, cb) {
            if (!cb) cb = noop
            var self = this
            if (!data.length) return cb(null)
            this.dataOffset(index, nodes, function(err, offset, size) {
              if (err) return cb(err)
              if (size !== data.length)
                return cb(new Error("Unexpected data size"))
              self.data.write(offset, data, cb)
            })
          }

          Storage.prototype.getData = function(index, cb) {
            var self = this
            this.dataOffset(index, noarr, function(err, offset, size) {
              if (err) return cb(err)
              self.data.read(offset, size, cb)
            })
          }

          Storage.prototype.nextSignature = function(index, cb) {
            var self = this

            this._getSignature(index, function(err, signature) {
              if (err) return cb(err)
              if (isBlank(signature)) return self.nextSignature(index + 1, cb)
              cb(null, { index: index, signature: signature })
            })
          }

          Storage.prototype.getSignature = function(index, cb) {
            this._getSignature(index, function(err, signature) {
              if (err) return cb(err)
              if (isBlank(signature)) return cb(new Error("No signature found"))
              cb(null, signature)
            })
          }

          Storage.prototype._getSignature = function(index, cb) {
            this.signatures.read(32 + 64 * index, 64, cb)
          }

          Storage.prototype.putSignature = function(index, signature, cb) {
            this.signatures.write(32 + 64 * index, signature, cb)
          }

          Storage.prototype.dataOffset = function(index, cachedNodes, cb) {
            var roots = flat.fullRoots(2 * index)
            var self = this
            var offset = 0
            var pending = roots.length
            var error = null
            var blk = 2 * index

            if (!pending) {
              pending = 1
              onnode(null, null)
              return
            }

            for (var i = 0; i < roots.length; i++) {
              var node = findNode(cachedNodes, roots[i])
              if (node) onnode(null, node)
              else this.getNode(roots[i], onnode)
            }

            function onlast(err, node) {
              if (err) return cb(err)
              cb(null, offset, node.size)
            }

            function onnode(err, node) {
              if (err) error = err
              if (node) offset += node.size
              if (--pending) return

              if (error) return cb(error)

              var last = findNode(cachedNodes, blk)
              if (last) onlast(null, last)
              else self.getNode(blk, onlast)
            }
          }

          Storage.prototype.getNode = function(index, cb) {
            if (this.cache) {
              var cached = this.cache.get(index)
              if (cached) return cb(null, cached)
            }

            var self = this

            this.tree.read(32 + 40 * index, 40, function(err, buf) {
              if (err) return cb(err)

              var hash = buf.slice(0, 32)
              var size = uint64be.decode(buf, 32)

              if (!size && isBlank(hash)) return cb(new Error("No node found"))

              var val = new Node(index, hash, size, null)
              if (self.cache) self.cache.set(index, val)
              cb(null, val)
            })
          }

          Storage.prototype.putNode = function(index, node, cb) {
            if (!cb) cb = noop

            // TODO: re-enable put cache. currently this causes a memleak
            // because node.hash is a slice of the big data buffer on replicate
            // if (this.cache) this.cache.set(index, node)

            var buf = bufferAlloc(40)

            node.hash.copy(buf, 0)
            uint64be.encode(node.size, buf, 32)
            this.tree.write(32 + 40 * index, buf, cb)
          }

          Storage.prototype.putBitfield = function(offset, data, cb) {
            this.bitfield.write(32 + offset, data, cb)
          }

          Storage.prototype.close = function(cb) {
            if (!cb) cb = noop
            var missing = 6
            var error = null

            close(this.bitfield, done)
            close(this.tree, done)
            close(this.data, done)
            close(this.key, done)
            close(this.secretKey, done)
            close(this.signatures, done)

            function done(err) {
              if (err) error = err
              if (--missing) return
              cb(error)
            }
          }

          Storage.prototype.openKey = function(opts, cb) {
            if (typeof opts === "function") return this.openKey({}, opts)
            if (!this.key) this.key = this.create("key", opts)
            this.key.read(0, 32, cb)
          }

          Storage.prototype.open = function(opts, cb) {
            if (typeof opts === "function") return this.open({}, opts)

            var self = this
            var error = null
            var missing = 5

            if (!this.key) this.key = this.create("key", opts)
            if (!this.secretKey)
              this.secretKey = this.create("secret_key", opts)
            if (!this.tree) this.tree = this.create("tree", opts)
            if (!this.data) this.data = this.create("data", opts)
            if (!this.bitfield) this.bitfield = this.create("bitfield", opts)
            if (!this.signatures)
              this.signatures = this.create("signatures", opts)

            var result = {
              bitfield: bufferAlloc(0),
              secretKey: null,
              key: null
            }

            this.bitfield.write(0, header(0, 3328, null), function(err) {
              if (err) return cb(err)
              readAll(self.bitfield, 32, 3328, function(err, data) {
                if (data) result.bitfield = data
                done(err)
              })
            })

            this.signatures.write(0, header(1, 64, "Ed25519"), done)
            this.tree.write(0, header(2, 40, "BLAKE2b"), done)

            // TODO: Improve the error handling here.
            // I.e. if secretKey length === 64 and it fails, error

            this.secretKey.read(0, 64, function(_, data) {
              if (data) result.secretKey = data
              done(null)
            })

            this.key.read(0, 32, function(_, data) {
              if (data) result.key = data
              done(null)
            })

            function done(err) {
              if (err) error = err
              if (--missing) return
              if (error) cb(error)
              else cb(null, result)
            }
          }

          Storage.Node = Node

          function noop() {}

          function header(type, size, name) {
            var buf = bufferAlloc(32)
            buf.fill(0)

            // magic number
            buf[0] = 5
            buf[1] = 2
            buf[2] = 87
            buf[3] = type

            // version
            buf[4] = 0

            // block size
            buf.writeUInt16BE(size, 5)

            if (name) {
              // algo name
              buf[7] = name.length
              buf.write(name, 8)
            }

            return buf
          }

          function Node(index, hash, size) {
            this.index = index
            this.hash = hash
            this.size = size
          }

          function findNode(nodes, index) {
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].index === index) return nodes[i]
            }
            return null
          }

          function isBlank(buf) {
            for (var i = 0; i < buf.length; i++) {
              if (buf[i]) return false
            }
            return true
          }

          function close(st, cb) {
            if (st.close) st.close(cb)
            else cb()
          }

          function statAndReadAll(st, offset, cb) {
            st.stat(function(err, stat) {
              if (err) return cb(null, bufferAlloc(0))
              st.read(offset, stat.size - offset, cb)
            })
          }

          function readAll(st, offset, pageSize, cb) {
            if (typeof st.length === "number" && st.length > -1)
              return st.read(offset, st.length - offset, cb)
            if (st.statable === true) return statAndReadAll(st, offset, cb)

            var bufs = []

            st.read(offset, pageSize, loop)

            function loop(err, buf) {
              if (err) return cb(null, Buffer.concat(bufs))
              bufs.push(buf)
              st.read(offset + bufs.length * pageSize, pageSize, loop)
            }
          }
        }.call(this, require("buffer").Buffer))
      },
      {
        "array-lru": 3,
        buffer: 20,
        "buffer-alloc-unsafe": 15,
        "flat-tree": 25,
        uint64be: 76
      }
    ],
    35: [
      function(require, module, exports) {
        var flat = require("flat-tree")
        var bitfield = require("sparse-bitfield")

        module.exports = TreeIndex

        function TreeIndex(bits) {
          if (!(this instanceof TreeIndex)) return new TreeIndex(bits)
          this.bitfield = bits || bitfield()
        }

        TreeIndex.prototype.proof = function(index, opts) {
          if (!opts) opts = {}

          var nodes = []
          var remoteTree = opts.tree || new TreeIndex()
          var digest = opts.digest || 0

          if (!this.get(index)) return null
          if (opts.hash) nodes.push(index) // always return hash - no matter what the digest says
          if (digest === 1) return { nodes: nodes, verifiedBy: 0 }

          var roots = null
          var sibling = index
          var next = index
          var hasRoot = digest & 1
          digest = rightShift(digest)

          while (digest) {
            if (digest === 1 && hasRoot) {
              if (this.get(next)) remoteTree.set(next)

              // having a root implies having prev roots as well
              // TODO: this can be optimized away be only sending "newer" roots,
              // when sending roots
              if (flat.sibling(next) < next) next = flat.sibling(next)
              roots = flat.fullRoots(flat.rightSpan(next) + 2)
              for (var i = 0; i < roots.length; i++) {
                if (this.get(roots[i])) remoteTree.set(roots[i])
              }
              break
            }

            sibling = flat.sibling(next)
            if (digest & 1) {
              if (this.get(sibling)) remoteTree.set(sibling)
            }
            next = flat.parent(next)
            digest = rightShift(digest)
          }

          next = index

          while (!remoteTree.get(next)) {
            sibling = flat.sibling(next)
            if (!this.get(sibling)) {
              // next is a local root
              var verifiedBy = this.verifiedBy(next)
              addFullRoots(verifiedBy, nodes, next, remoteTree)
              return { nodes: nodes, verifiedBy: verifiedBy }
            } else {
              if (!remoteTree.get(sibling)) nodes.push(sibling)
            }

            next = flat.parent(next)
          }

          return { nodes: nodes, verifiedBy: 0 }
        }

        TreeIndex.prototype.digest = function(index) {
          if (this.get(index)) return 1

          var digest = 0
          var next = flat.sibling(index)
          var max = Math.max(next + 2, this.bitfield.length) // TODO: make this less ... hacky

          var bit = 2
          var depth = flat.depth(index)
          var parent = flat.parent(next, depth++)

          while (flat.rightSpan(next) < max || flat.leftSpan(parent) > 0) {
            if (this.get(next)) {
              digest |= bit
            }
            if (this.get(parent)) {
              digest |= 2 * bit + 1
              if (digest + 1 === 4 * bit) return 1
              return digest
            }
            next = flat.sibling(parent)
            parent = flat.parent(next, depth++)
            bit *= 2
          }

          return digest
        }

        TreeIndex.prototype.blocks = function() {
          var top = 0
          var next = 0
          var max = this.bitfield.length

          while (flat.rightSpan(next) < max) {
            next = flat.parent(next)
            if (this.get(next)) top = next
          }

          return (this.get(top) ? this.verifiedBy(top) : 0) / 2
        }

        TreeIndex.prototype.roots = function() {
          return flat.fullRoots(2 * this.blocks())
        }

        TreeIndex.prototype.verifiedBy = function(index, nodes) {
          var hasIndex = this.get(index)
          if (!hasIndex) return 0

          // find root of current tree

          var depth = flat.depth(index)
          var top = index
          var parent = flat.parent(top, depth++)
          while (this.get(parent) && this.get(flat.sibling(top))) {
            top = parent
            parent = flat.parent(top, depth++)
          }

          // expand right down

          depth--
          while (depth) {
            top = flat.leftChild(
              flat.index(depth, flat.offset(top, depth) + 1),
              depth
            )
            depth--

            while (!this.get(top) && depth) top = flat.leftChild(top, depth--)
            if (nodes && this.get(top)) nodes.push(top)
          }

          return this.get(top) ? top + 2 : top
        }

        TreeIndex.prototype.get = function(index) {
          return this.bitfield.get(index)
        }

        TreeIndex.prototype.set = function(index) {
          if (!this.bitfield.set(index, true)) return false
          while (this.bitfield.get(flat.sibling(index))) {
            index = flat.parent(index)
            if (!this.bitfield.set(index, true)) break
          }
          return true
        }

        function rightShift(n) {
          return (n - (n & 1)) / 2
        }

        function addFullRoots(verifiedBy, nodes, root, remoteTree) {
          var roots = flat.fullRoots(verifiedBy)
          for (var i = 0; i < roots.length; i++) {
            if (roots[i] !== root && !remoteTree.get(roots[i]))
              nodes.push(roots[i])
          }
        }
      },
      { "flat-tree": 25, "sparse-bitfield": 72 }
    ],
    36: [
      function(require, module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m
          var eLen = nBytes * 8 - mLen - 1
          var eMax = (1 << eLen) - 1
          var eBias = eMax >> 1
          var nBits = -7
          var i = isLE ? nBytes - 1 : 0
          var d = isLE ? -1 : 1
          var s = buffer[offset + i]

          i += d

          e = s & ((1 << -nBits) - 1)
          s >>= -nBits
          nBits += eLen
          for (
            ;
            nBits > 0;
            e = e * 256 + buffer[offset + i], i += d, nBits -= 8
          ) {}

          m = e & ((1 << -nBits) - 1)
          e >>= -nBits
          nBits += mLen
          for (
            ;
            nBits > 0;
            m = m * 256 + buffer[offset + i], i += d, nBits -= 8
          ) {}

          if (e === 0) {
            e = 1 - eBias
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity
          } else {
            m = m + Math.pow(2, mLen)
            e = e - eBias
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }

        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c
          var eLen = nBytes * 8 - mLen - 1
          var eMax = (1 << eLen) - 1
          var eBias = eMax >> 1
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0
          var i = isLE ? 0 : nBytes - 1
          var d = isLE ? 1 : -1
          var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

          value = Math.abs(value)

          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0
            e = eMax
          } else {
            e = Math.floor(Math.log(value) / Math.LN2)
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--
              c *= 2
            }
            if (e + eBias >= 1) {
              value += rt / c
            } else {
              value += rt * Math.pow(2, 1 - eBias)
            }
            if (value * c >= 2) {
              e++
              c /= 2
            }

            if (e + eBias >= eMax) {
              m = 0
              e = eMax
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen)
              e = e + eBias
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
              e = 0
            }
          }

          for (
            ;
            mLen >= 8;
            buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
          ) {}

          e = (e << mLen) | m
          eLen += mLen
          for (
            ;
            eLen > 0;
            buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
          ) {}

          buffer[offset + i - d] |= s * 128
        }
      },
      {}
    ],
    37: [
      function(require, module, exports) {
        if (typeof Object.create === "function") {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            })
          }
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function() {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
          }
        }
      },
      {}
    ],
    38: [
      function(require, module, exports) {
        /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

        // The _isBuffer check is for Safari 5-7 support, because it's missing
        // Object.prototype.constructor. Remove this eventually
        module.exports = function(obj) {
          return (
            obj != null &&
            (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
          )
        }

        function isBuffer(obj) {
          return (
            !!obj.constructor &&
            typeof obj.constructor.isBuffer === "function" &&
            obj.constructor.isBuffer(obj)
          )
        }

        // For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
          return (
            typeof obj.readFloatLE === "function" &&
            typeof obj.slice === "function" &&
            isBuffer(obj.slice(0, 0))
          )
        }
      },
      {}
    ],
    39: [
      function(require, module, exports) {
        module.exports = function(work) {
          var pending = null
          var callback = null
          var callbacks = null
          var next = null

          return function(val, cb) {
            next = val
            update(cb || noop)
          }

          function update(cb) {
            if (callback) {
              if (!pending) pending = []
              pending.push(cb)
              return
            }

            var val = next
            next = null
            callback = cb
            work(val, done)
          }

          function done(err) {
            var cb = callback
            var cbs = callbacks
            callbacks = null
            callback = null

            if (pending) {
              callbacks = pending
              pending = null
              update(noop)
            }

            if (cbs) {
              for (var i = 0; i < cbs.length; i++) cbs[i](err)
            }
            cb(err)
          }
        }

        function noop(_) {}
      },
      {}
    ],
    40: [
      function(require, module, exports) {
        ;(function(Buffer) {
          module.exports = Pager

          function Pager(pageSize) {
            if (!(this instanceof Pager)) return new Pager(pageSize)

            this.length = 0
            this.updates = []
            this.pages = new Array(16)
            this.pageSize = pageSize || 1024
          }

          Pager.prototype.updated = function(page) {
            if (page.updated || !this.updates) return
            page.updated = true
            this.updates.push(page)
          }

          Pager.prototype.lastUpdate = function() {
            if (!this.updates || !this.updates.length) return null
            var page = this.updates.pop()
            page.updated = false
            return page
          }

          Pager.prototype.get = function(i, noAllocate) {
            if (i >= this.pages.length) {
              if (noAllocate) return
              this.pages = grow(this.pages, i, this.length)
            }

            var page = this.pages[i]

            if (!page && !noAllocate) {
              page = this.pages[i] = new Page(i, alloc(this.pageSize))
              if (i >= this.length) this.length = i + 1
            }

            return page
          }

          Pager.prototype.set = function(i, buf) {
            if (i >= this.pages.length)
              this.pages = grow(this.pages, i, this.length)
            if (i >= this.length) this.length = i + 1

            if (!buf) {
              this.pages[i] = undefined
              return
            }

            var page = this.pages[i]
            var b = truncate(buf, this.pageSize)

            if (page) page.buffer = b
            else this.pages[i] = new Page(i, b)
          }

          Pager.prototype.toBuffer = function() {
            var list = new Array(this.length)
            var empty = alloc(this.pageSize)

            for (var i = 0; i < list.length; i++) {
              list[i] = this.pages[i] ? this.pages[i].buffer : empty
            }

            return Buffer.concat(list)
          }

          function grow(list, index, len) {
            var nlen = list.length * 2
            while (nlen <= index) nlen *= 2

            var twice = new Array(nlen)
            for (var i = 0; i < len; i++) twice[i] = list[i]
            return twice
          }

          function truncate(buf, len) {
            if (buf.length === len) return buf
            if (buf.length > len) return buf.slice(0, len)
            var cpy = alloc(len)
            buf.copy(cpy)
            return cpy
          }

          function alloc(size) {
            if (Buffer.alloc) return Buffer.alloc(size)
            var buf = new Buffer(size)
            buf.fill(0)
            return buf
          }

          function Page(i, buf) {
            this.offset = i * buf.length
            this.buffer = buf
            this.updated = false
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    41: [
      function(require, module, exports) {
        ;(function(Buffer) {
          // a more low level interface to the merkle tree stream.
          // useful for certain applications the require non-streamy access to the algos.
          // versioned by the same semver as the stream interface.

          var flat = require("flat-tree")

          module.exports = MerkleGenerator

          function MerkleGenerator(opts, roots) {
            if (!(this instanceof MerkleGenerator))
              return new MerkleGenerator(opts, roots)
            if (!opts || !opts.leaf || !opts.parent)
              throw new Error("opts.leaf and opts.parent required")

            this.roots = roots || opts.roots || []
            this.blocks = this.roots.length
              ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2
              : 0

            for (var i = 0; i < this.roots.length; i++) {
              var r = this.roots[i]
              if (r && !r.parent) r.parent = flat.parent(r.index)
            }

            this._leaf = opts.leaf
            this._parent = opts.parent
          }

          MerkleGenerator.prototype.next = function(data, nodes) {
            if (!Buffer.isBuffer(data)) data = new Buffer(data)
            if (!nodes) nodes = []

            var index = 2 * this.blocks++

            var leaf = {
              index: index,
              parent: flat.parent(index),
              hash: null,
              size: data.length,
              data: data
            }

            leaf.hash = this._leaf(leaf, this.roots)
            this.roots.push(leaf)
            nodes.push(leaf)

            while (this.roots.length > 1) {
              var left = this.roots[this.roots.length - 2]
              var right = this.roots[this.roots.length - 1]

              if (left.parent !== right.parent) break

              this.roots.pop()
              this.roots[this.roots.length - 1] = leaf = {
                index: left.parent,
                parent: flat.parent(left.parent),
                hash: this._parent(left, right),
                size: left.size + right.size,
                data: null
              }
              nodes.push(leaf)
            }

            return nodes
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "flat-tree": 25 }
    ],
    42: [
      function(require, module, exports) {
        assert.notEqual = notEqual
        assert.notOk = notOk
        assert.equal = equal
        assert.ok = assert

        module.exports = assert

        function equal(a, b, m) {
          assert(a == b, m) // eslint-disable-line eqeqeq
        }

        function notEqual(a, b, m) {
          assert(a != b, m) // eslint-disable-line eqeqeq
        }

        function notOk(t, m) {
          assert(!t, m)
        }

        function assert(t, m) {
          if (!t) throw new Error(m || "AssertionError")
        }
      },
      {}
    ],
    43: [
      function(require, module, exports) {
        ;(function(process) {
          "use strict"

          if (
            !process.version ||
            process.version.indexOf("v0.") === 0 ||
            (process.version.indexOf("v1.") === 0 &&
              process.version.indexOf("v1.8.") !== 0)
          ) {
            module.exports = nextTick
          } else {
            module.exports = process.nextTick
          }

          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
              throw new TypeError('"callback" argument must be a function')
            }
            var len = arguments.length
            var args, i
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn)
              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1)
                })
              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2)
                })
              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3)
                })
              default:
                args = new Array(len - 1)
                i = 0
                while (i < args.length) {
                  args[i++] = arguments[i]
                }
                return process.nextTick(function afterTick() {
                  fn.apply(null, args)
                })
            }
          }
        }.call(this, require("_process")))
      },
      { _process: 44 }
    ],
    44: [
      function(require, module, exports) {
        // shim for using process in browser
        var process = (module.exports = {})

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout
        var cachedClearTimeout

        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined")
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined")
        }
        ;(function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout
            } else {
              cachedSetTimeout = defaultSetTimout
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout
            } else {
              cachedClearTimeout = defaultClearTimeout
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout
          }
        })()
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0)
          }
          // if setTimeout wasn't available but was latter defined
          if (
            (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
            setTimeout
          ) {
            cachedSetTimeout = setTimeout
            return setTimeout(fun, 0)
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0)
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0)
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0)
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker)
          }
          // if clearTimeout wasn't available but was latter defined
          if (
            (cachedClearTimeout === defaultClearTimeout ||
              !cachedClearTimeout) &&
            clearTimeout
          ) {
            cachedClearTimeout = clearTimeout
            return clearTimeout(marker)
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker)
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker)
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker)
            }
          }
        }
        var queue = []
        var draining = false
        var currentQueue
        var queueIndex = -1

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return
          }
          draining = false
          if (currentQueue.length) {
            queue = currentQueue.concat(queue)
          } else {
            queueIndex = -1
          }
          if (queue.length) {
            drainQueue()
          }
        }

        function drainQueue() {
          if (draining) {
            return
          }
          var timeout = runTimeout(cleanUpNextTick)
          draining = true

          var len = queue.length
          while (len) {
            currentQueue = queue
            queue = []
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run()
              }
            }
            queueIndex = -1
            len = queue.length
          }
          currentQueue = null
          draining = false
          runClearTimeout(timeout)
        }

        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1)
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i]
            }
          }
          queue.push(new Item(fun, args))
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue)
          }
        }

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun
          this.array = array
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array)
        }
        process.title = "browser"
        process.browser = true
        process.env = {}
        process.argv = []
        process.version = "" // empty string to avoid regexp issues
        process.versions = {}

        function noop() {}

        process.on = noop
        process.addListener = noop
        process.once = noop
        process.off = noop
        process.removeListener = noop
        process.removeAllListeners = noop
        process.emit = noop
        process.prependListener = noop
        process.prependOnceListener = noop

        process.listeners = function(name) {
          return []
        }

        process.binding = function(name) {
          throw new Error("process.binding is not supported")
        }

        process.cwd = function() {
          return "/"
        }
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported")
        }
        process.umask = function() {
          return 0
        }
      },
      {}
    ],
    45: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var varint = require("varint")
          var svarint = require("signed-varint")

          exports.make = encoder

          exports.name = function(enc) {
            var keys = Object.keys(exports)
            for (var i = 0; i < keys.length; i++) {
              if (exports[keys[i]] === enc) return keys[i]
            }
            return null
          }

          exports.skip = function(type, buffer, offset) {
            switch (type) {
              case 0:
                varint.decode(buffer, offset)
                return offset + varint.decode.bytes

              case 1:
                return offset + 8

              case 2:
                var len = varint.decode(buffer, offset)
                return offset + varint.decode.bytes + len

              case 3:
              case 4:
                throw new Error("Groups are not supported")

              case 5:
                return offset + 4
            }

            throw new Error("Unknown wire type: " + type)
          }

          exports.bytes = encoder(
            2,
            function encode(val, buffer, offset) {
              var oldOffset = offset
              var len = bufferLength(val)

              varint.encode(len, buffer, offset)
              offset += varint.encode.bytes

              if (Buffer.isBuffer(val)) val.copy(buffer, offset)
              else buffer.write(val, offset, len)
              offset += len

              encode.bytes = offset - oldOffset
              return buffer
            },
            function decode(buffer, offset) {
              var oldOffset = offset

              var len = varint.decode(buffer, offset)
              offset += varint.decode.bytes

              var val = buffer.slice(offset, offset + len)
              offset += val.length

              decode.bytes = offset - oldOffset
              return val
            },
            function encodingLength(val) {
              var len = bufferLength(val)
              return varint.encodingLength(len) + len
            }
          )

          exports.string = encoder(
            2,
            function encode(val, buffer, offset) {
              var oldOffset = offset
              var len = Buffer.byteLength(val)

              varint.encode(len, buffer, offset, "utf-8")
              offset += varint.encode.bytes

              buffer.write(val, offset, len)
              offset += len

              encode.bytes = offset - oldOffset
              return buffer
            },
            function decode(buffer, offset) {
              var oldOffset = offset

              var len = varint.decode(buffer, offset)
              offset += varint.decode.bytes

              var val = buffer.toString("utf-8", offset, offset + len)
              offset += len

              decode.bytes = offset - oldOffset
              return val
            },
            function encodingLength(val) {
              var len = Buffer.byteLength(val)
              return varint.encodingLength(len) + len
            }
          )

          exports.bool = encoder(
            0,
            function encode(val, buffer, offset) {
              buffer[offset] = val ? 1 : 0
              encode.bytes = 1
              return buffer
            },
            function decode(buffer, offset) {
              var bool = buffer[offset] > 0
              decode.bytes = 1
              return bool
            },
            function encodingLength() {
              return 1
            }
          )

          exports.int32 = encoder(
            0,
            function encode(val, buffer, offset) {
              varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)
              encode.bytes = varint.encode.bytes
              return buffer
            },
            function decode(buffer, offset) {
              var val = varint.decode(buffer, offset)
              decode.bytes = varint.decode.bytes
              return val > 2147483647 ? val - 4294967296 : val
            },
            function encodingLength(val) {
              return varint.encodingLength(val < 0 ? val + 4294967296 : val)
            }
          )

          exports.int64 = encoder(
            0,
            function encode(val, buffer, offset) {
              if (val < 0) {
                var last = offset + 9
                varint.encode(val * -1, buffer, offset)
                offset += varint.encode.bytes - 1
                buffer[offset] = buffer[offset] | 0x80
                while (offset < last - 1) {
                  offset++
                  buffer[offset] = 0xff
                }
                buffer[last] = 0x01
                encode.bytes = 10
              } else {
                varint.encode(val, buffer, offset)
                encode.bytes = varint.encode.bytes
              }
              return buffer
            },
            function decode(buffer, offset) {
              var val = varint.decode(buffer, offset)
              if (val >= Math.pow(2, 63)) {
                var limit = 9
                while (buffer[offset + limit - 1] === 0xff) limit--
                limit = limit || 9
                var subset = Buffer.allocUnsafe(limit)
                buffer.copy(subset, 0, offset, offset + limit)
                subset[limit - 1] = subset[limit - 1] & 0x7f
                val = -1 * varint.decode(subset, 0)
                decode.bytes = 10
              } else {
                decode.bytes = varint.decode.bytes
              }
              return val
            },
            function encodingLength(val) {
              return val < 0 ? 10 : varint.encodingLength(val)
            }
          )

          exports.sint32 = exports.sint64 = encoder(
            0,
            svarint.encode,
            svarint.decode,
            svarint.encodingLength
          )

          exports.uint32 = exports.uint64 = exports.enum = exports.varint = encoder(
            0,
            varint.encode,
            varint.decode,
            varint.encodingLength
          )

          // we cannot represent these in javascript so we just use buffers
          exports.fixed64 = exports.sfixed64 = encoder(
            1,
            function encode(val, buffer, offset) {
              val.copy(buffer, offset)
              encode.bytes = 8
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.slice(offset, offset + 8)
              decode.bytes = 8
              return val
            },
            function encodingLength() {
              return 8
            }
          )

          exports.double = encoder(
            1,
            function encode(val, buffer, offset) {
              buffer.writeDoubleLE(val, offset)
              encode.bytes = 8
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readDoubleLE(offset)
              decode.bytes = 8
              return val
            },
            function encodingLength() {
              return 8
            }
          )

          exports.fixed32 = encoder(
            5,
            function encode(val, buffer, offset) {
              buffer.writeUInt32LE(val, offset)
              encode.bytes = 4
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readUInt32LE(offset)
              decode.bytes = 4
              return val
            },
            function encodingLength() {
              return 4
            }
          )

          exports.sfixed32 = encoder(
            5,
            function encode(val, buffer, offset) {
              buffer.writeInt32LE(val, offset)
              encode.bytes = 4
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readInt32LE(offset)
              decode.bytes = 4
              return val
            },
            function encodingLength() {
              return 4
            }
          )

          exports.float = encoder(
            5,
            function encode(val, buffer, offset) {
              buffer.writeFloatLE(val, offset)
              encode.bytes = 4
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readFloatLE(offset)
              decode.bytes = 4
              return val
            },
            function encodingLength() {
              return 4
            }
          )

          function encoder(type, encode, decode, encodingLength) {
            encode.bytes = decode.bytes = 0

            return {
              type: type,
              encode: encode,
              decode: decode,
              encodingLength: encodingLength
            }
          }

          function bufferLength(val) {
            return Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val)
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "signed-varint": 60, varint: 82 }
    ],
    46: [
      function(require, module, exports) {
        module.exports = function() {
          throw new Error("random-access-file is not supported in the browser")
        }
      },
      {}
    ],
    47: [
      function(require, module, exports) {
        ;(function(process) {
          var events = require("events")
          var inherits = require("inherits")

          var NOT_READABLE = defaultImpl(new Error("Not readable"))
          var NOT_WRITABLE = defaultImpl(new Error("Not writable"))
          var NOT_DELETABLE = defaultImpl(new Error("Not deletable"))
          var NOT_STATABLE = defaultImpl(new Error("Not statable"))
          var NO_OPEN_READABLE = defaultImpl(new Error("No readonly open"))

          module.exports = RandomAccess

          function RandomAccess(opts) {
            if (!(this instanceof RandomAccess)) return new RandomAccess(opts)
            events.EventEmitter.call(this)

            this._queued = []
            this._pending = 0
            this._needsOpen = true

            this.opened = false
            this.closed = false
            this.destroyed = false

            if (opts) {
              if (opts.openReadonly) this._openReadonly = opts.openReadonly
              if (opts.open) this._open = opts.open
              if (opts.read) this._read = opts.read
              if (opts.write) this._write = opts.write
              if (opts.del) this._del = opts.del
              if (opts.stat) this._stat = opts.stat
              if (opts.close) this._close = opts.close
              if (opts.destroy) this._destroy = opts.destroy
            }

            this.preferReadonly = this._openReadonly !== NO_OPEN_READABLE
            this.readable = this._read !== NOT_READABLE
            this.writable = this._write !== NOT_WRITABLE
            this.deletable = this._del !== NOT_DELETABLE
            this.statable = this._stat !== NOT_STATABLE
          }

          inherits(RandomAccess, events.EventEmitter)

          RandomAccess.prototype.open = function(cb) {
            if (!cb) cb = noop
            if (this.opened && !this._needsOpen)
              return process.nextTick(cb, null)
            queueAndRun(this, new Request(this, 0, 0, 0, null, cb))
          }

          RandomAccess.prototype._open = defaultImpl(null)
          RandomAccess.prototype._openReadonly = NO_OPEN_READABLE

          RandomAccess.prototype.read = function(offset, size, cb) {
            this.run(new Request(this, 1, offset, size, null, cb))
          }

          RandomAccess.prototype._read = NOT_READABLE

          RandomAccess.prototype.write = function(offset, data, cb) {
            if (!cb) cb = noop
            openWritable(this)
            this.run(new Request(this, 2, offset, data.length, data, cb))
          }

          RandomAccess.prototype._write = NOT_WRITABLE

          RandomAccess.prototype.del = function(offset, size, cb) {
            if (!cb) cb = noop
            openWritable(this)
            this.run(new Request(this, 3, offset, size, null, cb))
          }

          RandomAccess.prototype._del = NOT_DELETABLE

          RandomAccess.prototype.stat = function(cb) {
            this.run(new Request(this, 4, 0, 0, null, cb))
          }

          RandomAccess.prototype._stat = NOT_STATABLE

          RandomAccess.prototype.close = function(cb) {
            if (!cb) cb = noop
            if (this.closed) return process.nextTick(cb, null)
            queueAndRun(this, new Request(this, 5, 0, 0, null, cb))
          }

          RandomAccess.prototype._close = defaultImpl(null)

          RandomAccess.prototype.destroy = function(cb) {
            if (!cb) cb = noop
            if (!this.closed) this.close(noop)
            queueAndRun(this, new Request(this, 6, 0, 0, null, cb))
          }

          RandomAccess.prototype._destroy = defaultImpl(null)

          RandomAccess.prototype.run = function(req) {
            if (this._needsOpen) this.open(noop)
            if (this._queued.length) this._queued.push(req)
            else req._run()
          }

          function noop() {}

          function Request(self, type, offset, size, data, cb) {
            this.type = type
            this.offset = offset
            this.data = data
            this.size = size
            this.storage = self

            this._sync = false
            this._callback = cb
          }

          Request.prototype._unqueue = function(err) {
            var ra = this.storage
            var queued = ra._queued

            if (!err) {
              switch (this.type) {
                case 0:
                  if (!ra.opened) {
                    ra.opened = true
                    ra.emit("open")
                  }
                  break

                case 5:
                  if (!ra.closed) {
                    ra.closed = true
                    ra.emit("close")
                  }
                  break

                case 6:
                  if (!ra.destroyed) {
                    ra.destroyed = true
                    ra.emit("destroy")
                  }
                  break
              }
            }

            if (queued.length && queued[0] === this) queued.shift()
            if (!--ra._pending && queued.length) queued[0]._run()
          }

          Request.prototype.callback = function(err, val) {
            if (this._sync) return nextTick(this, err, val)
            this._unqueue(err)
            this._callback(err, val)
          }

          Request.prototype._openAndNotClosed = function() {
            var ra = this.storage
            if (ra.opened && !ra.closed) return true
            if (!ra.opened) nextTick(this, new Error("Not opened"))
            else if (ra.closed) nextTick(this, new Error("Closed"))
            return false
          }

          Request.prototype._open = function() {
            var ra = this.storage

            if (ra.opened && !ra._needsOpen) return nextTick(this, null)
            if (ra.closed) return nextTick(this, new Error("Closed"))

            ra._needsOpen = false
            if (ra.preferReadonly) ra._openReadonly(this)
            else ra._open(this)
          }

          Request.prototype._run = function() {
            var ra = this.storage
            ra._pending++

            this._sync = true

            switch (this.type) {
              case 0:
                this._open()
                break

              case 1:
                if (this._openAndNotClosed()) ra._read(this)
                break

              case 2:
                if (this._openAndNotClosed()) ra._write(this)
                break

              case 3:
                if (this._openAndNotClosed()) ra._del(this)
                break

              case 4:
                if (this._openAndNotClosed()) ra._stat(this)
                break

              case 5:
                if (ra.closed || !ra.opened) nextTick(this, null)
                else ra._close(this)
                break

              case 6:
                if (ra.destroyed) nextTick(this, null)
                else ra._destroy(this)
                break
            }

            this._sync = false
          }

          function queueAndRun(self, req) {
            self._queued.push(req)
            if (!self._pending) req._run()
          }

          function openWritable(self) {
            if (self.preferReadonly) {
              self._needsOpen = true
              self.preferReadonly = false
            }
          }

          function defaultImpl(err) {
            return overridable

            function overridable(req) {
              nextTick(req, err)
            }
          }

          function nextTick(req, err, val) {
            process.nextTick(nextTickCallback, req, err, val)
          }

          function nextTickCallback(req, err, val) {
            req.callback(err, val)
          }
        }.call(this, require("_process")))
      },
      { _process: 44, events: 24, inherits: 37 }
    ],
    48: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a duplex stream is just a stream that is both readable and writable.
        // Since JS doesn't have multiple prototypal inheritance, this class
        // prototypally inherits from Readable, and then parasitically from
        // Writable.

        "use strict"

        /*<replacement>*/

        var pna = require("process-nextick-args")
        /*</replacement>*/

        /*<replacement>*/
        var objectKeys =
          Object.keys ||
          function(obj) {
            var keys = []
            for (var key in obj) {
              keys.push(key)
            }
            return keys
          }
        /*</replacement>*/

        module.exports = Duplex

        /*<replacement>*/
        var util = require("core-util-is")
        util.inherits = require("inherits")
        /*</replacement>*/

        var Readable = require("./_stream_readable")
        var Writable = require("./_stream_writable")

        util.inherits(Duplex, Readable)

        {
          // avoid scope creep, the keys array can then be collected
          var keys = objectKeys(Writable.prototype)
          for (var v = 0; v < keys.length; v++) {
            var method = keys[v]
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method]
          }
        }

        function Duplex(options) {
          if (!(this instanceof Duplex)) return new Duplex(options)

          Readable.call(this, options)
          Writable.call(this, options)

          if (options && options.readable === false) this.readable = false

          if (options && options.writable === false) this.writable = false

          this.allowHalfOpen = true
          if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false

          this.once("end", onend)
        }

        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function() {
            return this._writableState.highWaterMark
          }
        })

        // the no-half-open enforcer
        function onend() {
          // if we allow half-open state, or if the writable side ended,
          // then we're ok.
          if (this.allowHalfOpen || this._writableState.ended) return

          // no more data can be written.
          // But allow more writes to happen in this tick.
          pna.nextTick(onEndNT, this)
        }

        function onEndNT(self) {
          self.end()
        }

        Object.defineProperty(Duplex.prototype, "destroyed", {
          get: function() {
            if (
              this._readableState === undefined ||
              this._writableState === undefined
            ) {
              return false
            }
            return (
              this._readableState.destroyed && this._writableState.destroyed
            )
          },
          set: function(value) {
            // we ignore the value if the stream
            // has not been initialized yet
            if (
              this._readableState === undefined ||
              this._writableState === undefined
            ) {
              return
            }

            // backward compatibility, the user is explicitly
            // managing destroyed
            this._readableState.destroyed = value
            this._writableState.destroyed = value
          }
        })

        Duplex.prototype._destroy = function(err, cb) {
          this.push(null)
          this.end()

          pna.nextTick(cb, err)
        }
      },
      {
        "./_stream_readable": 50,
        "./_stream_writable": 52,
        "core-util-is": 23,
        inherits: 37,
        "process-nextick-args": 57
      }
    ],
    49: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a passthrough stream.
        // basically just the most minimal sort of Transform stream.
        // Every written chunk gets output as-is.

        "use strict"

        module.exports = PassThrough

        var Transform = require("./_stream_transform")

        /*<replacement>*/
        var util = require("core-util-is")
        util.inherits = require("inherits")
        /*</replacement>*/

        util.inherits(PassThrough, Transform)

        function PassThrough(options) {
          if (!(this instanceof PassThrough)) return new PassThrough(options)

          Transform.call(this, options)
        }

        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk)
        }
      },
      { "./_stream_transform": 51, "core-util-is": 23, inherits: 37 }
    ],
    50: [
      function(require, module, exports) {
        ;(function(process, global) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          "use strict"

          /*<replacement>*/

          var pna = require("process-nextick-args")
          /*</replacement>*/

          module.exports = Readable

          /*<replacement>*/
          var isArray = require("isarray")
          /*</replacement>*/

          /*<replacement>*/
          var Duplex
          /*</replacement>*/

          Readable.ReadableState = ReadableState

          /*<replacement>*/
          var EE = require("events").EventEmitter

          var EElistenerCount = function(emitter, type) {
            return emitter.listeners(type).length
          }
          /*</replacement>*/

          /*<replacement>*/
          var Stream = require("./internal/streams/stream")
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = require("safe-buffer").Buffer
          var OurUint8Array = global.Uint8Array || function() {}
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk)
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
          }

          /*</replacement>*/

          /*<replacement>*/
          var util = require("core-util-is")
          util.inherits = require("inherits")
          /*</replacement>*/

          /*<replacement>*/
          var debugUtil = require("util")
          var debug = void 0
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream")
          } else {
            debug = function() {}
          }
          /*</replacement>*/

          var BufferList = require("./internal/streams/BufferList")
          var destroyImpl = require("./internal/streams/destroy")
          var StringDecoder

          util.inherits(Readable, Stream)

          var kProxyEvents = ["error", "close", "destroy", "pause", "resume"]

          function prependListener(emitter, event, fn) {
            // Sadly this is not cacheable as some libraries bundle their own
            // event emitter implementation with them.
            if (typeof emitter.prependListener === "function")
              return emitter.prependListener(event, fn)

            // This is a hack to make sure that our error handler is attached before any
            // userland ones.  NEVER DO THIS. This is here only because this code needs
            // to continue to work with older versions of Node.js that do not include
            // the prependListener() method. The goal is to eventually remove this hack.
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn)
            else if (isArray(emitter._events[event]))
              emitter._events[event].unshift(fn)
            else emitter._events[event] = [fn, emitter._events[event]]
          }

          function ReadableState(options, stream) {
            Duplex = Duplex || require("./_stream_duplex")

            options = options || {}

            // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.
            var isDuplex = stream instanceof Duplex

            // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away
            this.objectMode = !!options.objectMode

            if (isDuplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode

            // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"
            var hwm = options.highWaterMark
            var readableHwm = options.readableHighWaterMark
            var defaultHwm = this.objectMode ? 16 : 16 * 1024

            if (hwm || hwm === 0) this.highWaterMark = hwm
            else if (isDuplex && (readableHwm || readableHwm === 0))
              this.highWaterMark = readableHwm
            else this.highWaterMark = defaultHwm

            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark)

            // A linked list is used to store data chunks instead of an array because the
            // linked list can remove elements from the beginning faster than
            // array.shift()
            this.buffer = new BufferList()
            this.length = 0
            this.pipes = null
            this.pipesCount = 0
            this.flowing = null
            this.ended = false
            this.endEmitted = false
            this.reading = false

            // a flag to be able to tell if the event 'readable'/'data' is emitted
            // immediately, or on a later tick.  We set this to true at first, because
            // any actions that shouldn't happen until "later" should generally also
            // not happen before the first read call.
            this.sync = true

            // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.
            this.needReadable = false
            this.emittedReadable = false
            this.readableListening = false
            this.resumeScheduled = false

            // has it been destroyed
            this.destroyed = false

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || "utf8"

            // the number of writers that are awaiting a drain event in .pipe()s
            this.awaitDrain = 0

            // if true, a maybeReadMore has been scheduled
            this.readingMore = false

            this.decoder = null
            this.encoding = null
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require("string_decoder/").StringDecoder
              this.decoder = new StringDecoder(options.encoding)
              this.encoding = options.encoding
            }
          }

          function Readable(options) {
            Duplex = Duplex || require("./_stream_duplex")

            if (!(this instanceof Readable)) return new Readable(options)

            this._readableState = new ReadableState(options, this)

            // legacy
            this.readable = true

            if (options) {
              if (typeof options.read === "function") this._read = options.read

              if (typeof options.destroy === "function")
                this._destroy = options.destroy
            }

            Stream.call(this)
          }

          Object.defineProperty(Readable.prototype, "destroyed", {
            get: function() {
              if (this._readableState === undefined) {
                return false
              }
              return this._readableState.destroyed
            },
            set: function(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._readableState) {
                return
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._readableState.destroyed = value
            }
          })

          Readable.prototype.destroy = destroyImpl.destroy
          Readable.prototype._undestroy = destroyImpl.undestroy
          Readable.prototype._destroy = function(err, cb) {
            this.push(null)
            cb(err)
          }

          // Manually shove something into the read() buffer.
          // This returns true if the highWaterMark has not been hit yet,
          // similar to how Writable.write() returns true if you should
          // write() some more.
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState
            var skipChunkCheck

            if (!state.objectMode) {
              if (typeof chunk === "string") {
                encoding = encoding || state.defaultEncoding
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding)
                  encoding = ""
                }
                skipChunkCheck = true
              }
            } else {
              skipChunkCheck = true
            }

            return readableAddChunk(
              this,
              chunk,
              encoding,
              false,
              skipChunkCheck
            )
          }

          // Unshift should *always* be something directly out of read()
          Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false)
          }

          function readableAddChunk(
            stream,
            chunk,
            encoding,
            addToFront,
            skipChunkCheck
          ) {
            var state = stream._readableState
            if (chunk === null) {
              state.reading = false
              onEofChunk(stream, state)
            } else {
              var er
              if (!skipChunkCheck) er = chunkInvalid(state, chunk)
              if (er) {
                stream.emit("error", er)
              } else if (state.objectMode || (chunk && chunk.length > 0)) {
                if (
                  typeof chunk !== "string" &&
                  !state.objectMode &&
                  Object.getPrototypeOf(chunk) !== Buffer.prototype
                ) {
                  chunk = _uint8ArrayToBuffer(chunk)
                }

                if (addToFront) {
                  if (state.endEmitted)
                    stream.emit(
                      "error",
                      new Error("stream.unshift() after end event")
                    )
                  else addChunk(stream, state, chunk, true)
                } else if (state.ended) {
                  stream.emit("error", new Error("stream.push() after EOF"))
                } else {
                  state.reading = false
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk)
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false)
                    else maybeReadMore(stream, state)
                  } else {
                    addChunk(stream, state, chunk, false)
                  }
                }
              } else if (!addToFront) {
                state.reading = false
              }
            }

            return needMoreData(state)
          }

          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit("data", chunk)
              stream.read(0)
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length
              if (addToFront) state.buffer.unshift(chunk)
              else state.buffer.push(chunk)

              if (state.needReadable) emitReadable(stream)
            }
            maybeReadMore(stream, state)
          }

          function chunkInvalid(state, chunk) {
            var er
            if (
              !_isUint8Array(chunk) &&
              typeof chunk !== "string" &&
              chunk !== undefined &&
              !state.objectMode
            ) {
              er = new TypeError("Invalid non-string/buffer chunk")
            }
            return er
          }

          // if it's past the high water mark, we can push in some more.
          // Also, if we have no data yet, we can stand some
          // more bytes.  This is to work around cases where hwm=0,
          // such as the repl.  Also, if the push() triggered a
          // readable event, and the user called read(largeNumber) such that
          // needReadable was set, then we ought to push more, so that another
          // 'readable' event will be triggered.
          function needMoreData(state) {
            return (
              !state.ended &&
              (state.needReadable ||
                state.length < state.highWaterMark ||
                state.length === 0)
            )
          }

          Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false
          }

          // backwards compatibility.
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require("string_decoder/").StringDecoder
            this._readableState.decoder = new StringDecoder(enc)
            this._readableState.encoding = enc
            return this
          }

          // Don't raise the hwm > 8MB
          var MAX_HWM = 0x800000
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM
            } else {
              // Get the next highest power of 2 to prevent increasing hwm excessively in
              // tiny amounts
              n--
              n |= n >>> 1
              n |= n >>> 2
              n |= n >>> 4
              n |= n >>> 8
              n |= n >>> 16
              n++
            }
            return n
          }

          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function howMuchToRead(n, state) {
            if (n <= 0 || (state.length === 0 && state.ended)) return 0
            if (state.objectMode) return 1
            if (n !== n) {
              // Only flow one buffer at a time
              if (state.flowing && state.length)
                return state.buffer.head.data.length
              else return state.length
            }
            // If we're asking for more than the current hwm, then raise the hwm.
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n)
            if (n <= state.length) return n
            // Don't have enough
            if (!state.ended) {
              state.needReadable = true
              return 0
            }
            return state.length
          }

          // you can override either this method, or the async _read(n) below.
          Readable.prototype.read = function(n) {
            debug("read", n)
            n = parseInt(n, 10)
            var state = this._readableState
            var nOrig = n

            if (n !== 0) state.emittedReadable = false

            // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.
            if (
              n === 0 &&
              state.needReadable &&
              (state.length >= state.highWaterMark || state.ended)
            ) {
              debug("read: emitReadable", state.length, state.ended)
              if (state.length === 0 && state.ended) endReadable(this)
              else emitReadable(this)
              return null
            }

            n = howMuchToRead(n, state)

            // if we've ended, and we're now clear, then finish it up.
            if (n === 0 && state.ended) {
              if (state.length === 0) endReadable(this)
              return null
            }

            // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.

            // if we need a readable event, then we need to do some reading.
            var doRead = state.needReadable
            debug("need readable", doRead)

            // if we currently have less than the highWaterMark, then also read some
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true
              debug("length less than watermark", doRead)
            }

            // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.
            if (state.ended || state.reading) {
              doRead = false
              debug("reading or ended", doRead)
            } else if (doRead) {
              debug("do read")
              state.reading = true
              state.sync = true
              // if the length is currently zero, then we *need* a readable event.
              if (state.length === 0) state.needReadable = true
              // call internal read method
              this._read(state.highWaterMark)
              state.sync = false
              // If _read pushed data synchronously, then `reading` will be false,
              // and we need to re-evaluate how much data we can return to the user.
              if (!state.reading) n = howMuchToRead(nOrig, state)
            }

            var ret
            if (n > 0) ret = fromList(n, state)
            else ret = null

            if (ret === null) {
              state.needReadable = true
              n = 0
            } else {
              state.length -= n
            }

            if (state.length === 0) {
              // If we have nothing in the buffer, then we want to know
              // as soon as we *do* get something into the buffer.
              if (!state.ended) state.needReadable = true

              // If we tried to read() past the EOF, then emit end on the next tick.
              if (nOrig !== n && state.ended) endReadable(this)
            }

            if (ret !== null) this.emit("data", ret)

            return ret
          }

          function onEofChunk(stream, state) {
            if (state.ended) return
            if (state.decoder) {
              var chunk = state.decoder.end()
              if (chunk && chunk.length) {
                state.buffer.push(chunk)
                state.length += state.objectMode ? 1 : chunk.length
              }
            }
            state.ended = true

            // emit 'readable' now to make sure it gets picked up.
            emitReadable(stream)
          }

          // Don't emit readable right away in sync mode, because this can trigger
          // another read() call => stack overflow.  This way, it might trigger
          // a nextTick recursion warning, but that's not so bad.
          function emitReadable(stream) {
            var state = stream._readableState
            state.needReadable = false
            if (!state.emittedReadable) {
              debug("emitReadable", state.flowing)
              state.emittedReadable = true
              if (state.sync) pna.nextTick(emitReadable_, stream)
              else emitReadable_(stream)
            }
          }

          function emitReadable_(stream) {
            debug("emit readable")
            stream.emit("readable")
            flow(stream)
          }

          // at this point, the user has presumably seen the 'readable' event,
          // and called read() to consume some data.  that may have triggered
          // in turn another _read(n) call, in which case reading = true if
          // it's in progress.
          // However, if we're not ended, or reading, and the length < hwm,
          // then go ahead and try to read some more preemptively.
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true
              pna.nextTick(maybeReadMore_, stream, state)
            }
          }

          function maybeReadMore_(stream, state) {
            var len = state.length
            while (
              !state.reading &&
              !state.flowing &&
              !state.ended &&
              state.length < state.highWaterMark
            ) {
              debug("maybeReadMore read 0")
              stream.read(0)
              if (len === state.length)
                // didn't get any data, stop spinning.
                break
              else len = state.length
            }
            state.readingMore = false
          }

          // abstract method.  to be overridden in specific implementation classes.
          // call cb(er, data) where data is <= n in length.
          // for virtual (non-string, non-buffer) streams, "length" is somewhat
          // arbitrary, and perhaps not very meaningful.
          Readable.prototype._read = function(n) {
            this.emit("error", new Error("_read() is not implemented"))
          }

          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this
            var state = this._readableState

            switch (state.pipesCount) {
              case 0:
                state.pipes = dest
                break
              case 1:
                state.pipes = [state.pipes, dest]
                break
              default:
                state.pipes.push(dest)
                break
            }
            state.pipesCount += 1
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts)

            var doEnd =
              (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr

            var endFn = doEnd ? onend : unpipe
            if (state.endEmitted) pna.nextTick(endFn)
            else src.once("end", endFn)

            dest.on("unpipe", onunpipe)
            function onunpipe(readable, unpipeInfo) {
              debug("onunpipe")
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true
                  cleanup()
                }
              }
            }

            function onend() {
              debug("onend")
              dest.end()
            }

            // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            var ondrain = pipeOnDrain(src)
            dest.on("drain", ondrain)

            var cleanedUp = false
            function cleanup() {
              debug("cleanup")
              // cleanup event handlers once the pipe is broken
              dest.removeListener("close", onclose)
              dest.removeListener("finish", onfinish)
              dest.removeListener("drain", ondrain)
              dest.removeListener("error", onerror)
              dest.removeListener("unpipe", onunpipe)
              src.removeListener("end", onend)
              src.removeListener("end", unpipe)
              src.removeListener("data", ondata)

              cleanedUp = true

              // if the reader is waiting for a drain event from this
              // specific writer, then it would cause it to never start
              // flowing again.
              // So, if this is awaiting a drain, then we just call it now.
              // If we don't know, then assume that we are waiting for one.
              if (
                state.awaitDrain &&
                (!dest._writableState || dest._writableState.needDrain)
              )
                ondrain()
            }

            // If the user pushes more data while we're writing to dest then we'll end up
            // in ondata again. However, we only want to increase awaitDrain once because
            // dest will only emit one 'drain' event for the multiple writes.
            // => Introduce a guard on increasing awaitDrain.
            var increasedAwaitDrain = false
            src.on("data", ondata)
            function ondata(chunk) {
              debug("ondata")
              increasedAwaitDrain = false
              var ret = dest.write(chunk)
              if (false === ret && !increasedAwaitDrain) {
                // If the user unpiped during `dest.write()`, it is possible
                // to get stuck in a permanently paused state if that write
                // also returned false.
                // => Check whether `dest` is still a piping destination.
                if (
                  ((state.pipesCount === 1 && state.pipes === dest) ||
                    (state.pipesCount > 1 &&
                      indexOf(state.pipes, dest) !== -1)) &&
                  !cleanedUp
                ) {
                  debug(
                    "false write response, pause",
                    src._readableState.awaitDrain
                  )
                  src._readableState.awaitDrain++
                  increasedAwaitDrain = true
                }
                src.pause()
              }
            }

            // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.
            function onerror(er) {
              debug("onerror", er)
              unpipe()
              dest.removeListener("error", onerror)
              if (EElistenerCount(dest, "error") === 0) dest.emit("error", er)
            }

            // Make sure our error handler is attached before userland ones.
            prependListener(dest, "error", onerror)

            // Both close and finish should trigger unpipe, but only once.
            function onclose() {
              dest.removeListener("finish", onfinish)
              unpipe()
            }
            dest.once("close", onclose)
            function onfinish() {
              debug("onfinish")
              dest.removeListener("close", onclose)
              unpipe()
            }
            dest.once("finish", onfinish)

            function unpipe() {
              debug("unpipe")
              src.unpipe(dest)
            }

            // tell the dest that it's being piped to
            dest.emit("pipe", src)

            // start the flow if it hasn't been started already.
            if (!state.flowing) {
              debug("pipe resume")
              src.resume()
            }

            return dest
          }

          function pipeOnDrain(src) {
            return function() {
              var state = src._readableState
              debug("pipeOnDrain", state.awaitDrain)
              if (state.awaitDrain) state.awaitDrain--
              if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                state.flowing = true
                flow(src)
              }
            }
          }

          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState
            var unpipeInfo = { hasUnpiped: false }

            // if we're not piping anywhere, then do nothing.
            if (state.pipesCount === 0) return this

            // just one destination.  most common case.
            if (state.pipesCount === 1) {
              // passed in one, but it's not the right one.
              if (dest && dest !== state.pipes) return this

              if (!dest) dest = state.pipes

              // got a match.
              state.pipes = null
              state.pipesCount = 0
              state.flowing = false
              if (dest) dest.emit("unpipe", this, unpipeInfo)
              return this
            }

            // slow case. multiple pipe destinations.

            if (!dest) {
              // remove all.
              var dests = state.pipes
              var len = state.pipesCount
              state.pipes = null
              state.pipesCount = 0
              state.flowing = false

              for (var i = 0; i < len; i++) {
                dests[i].emit("unpipe", this, unpipeInfo)
              }
              return this
            }

            // try to find the right one.
            var index = indexOf(state.pipes, dest)
            if (index === -1) return this

            state.pipes.splice(index, 1)
            state.pipesCount -= 1
            if (state.pipesCount === 1) state.pipes = state.pipes[0]

            dest.emit("unpipe", this, unpipeInfo)

            return this
          }

          // set up data events if they are asked for
          // Ensure readable listeners eventually get something
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn)

            if (ev === "data") {
              // Start flowing on next tick if stream isn't explicitly paused
              if (this._readableState.flowing !== false) this.resume()
            } else if (ev === "readable") {
              var state = this._readableState
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true
                state.emittedReadable = false
                if (!state.reading) {
                  pna.nextTick(nReadingNextTick, this)
                } else if (state.length) {
                  emitReadable(this)
                }
              }
            }

            return res
          }
          Readable.prototype.addListener = Readable.prototype.on

          function nReadingNextTick(self) {
            debug("readable nexttick read 0")
            self.read(0)
          }

          // pause() and resume() are remnants of the legacy readable stream API
          // If the user uses them, then switch into old mode.
          Readable.prototype.resume = function() {
            var state = this._readableState
            if (!state.flowing) {
              debug("resume")
              state.flowing = true
              resume(this, state)
            }
            return this
          }

          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true
              pna.nextTick(resume_, stream, state)
            }
          }

          function resume_(stream, state) {
            if (!state.reading) {
              debug("resume read 0")
              stream.read(0)
            }

            state.resumeScheduled = false
            state.awaitDrain = 0
            stream.emit("resume")
            flow(stream)
            if (state.flowing && !state.reading) stream.read(0)
          }

          Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing)
            if (false !== this._readableState.flowing) {
              debug("pause")
              this._readableState.flowing = false
              this.emit("pause")
            }
            return this
          }

          function flow(stream) {
            var state = stream._readableState
            debug("flow", state.flowing)
            while (state.flowing && stream.read() !== null) {}
          }

          // wrap an old-style stream as the async data source.
          // This is *not* part of the readable stream interface.
          // It is an ugly unfortunate mess of history.
          Readable.prototype.wrap = function(stream) {
            var _this = this

            var state = this._readableState
            var paused = false

            stream.on("end", function() {
              debug("wrapped end")
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end()
                if (chunk && chunk.length) _this.push(chunk)
              }

              _this.push(null)
            })

            stream.on("data", function(chunk) {
              debug("wrapped data")
              if (state.decoder) chunk = state.decoder.write(chunk)

              // don't skip over falsy values in objectMode
              if (state.objectMode && (chunk === null || chunk === undefined))
                return
              else if (!state.objectMode && (!chunk || !chunk.length)) return

              var ret = _this.push(chunk)
              if (!ret) {
                paused = true
                stream.pause()
              }
            })

            // proxy all the other methods.
            // important when wrapping filters and duplexes.
            for (var i in stream) {
              if (this[i] === undefined && typeof stream[i] === "function") {
                this[i] = (function(method) {
                  return function() {
                    return stream[method].apply(stream, arguments)
                  }
                })(i)
              }
            }

            // proxy certain important events.
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]))
            }

            // when we try to consume some more bytes, simply unpause the
            // underlying stream.
            this._read = function(n) {
              debug("wrapped _read", n)
              if (paused) {
                paused = false
                stream.resume()
              }
            }

            return this
          }

          Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function() {
              return this._readableState.highWaterMark
            }
          })

          // exposed for testing purposes only.
          Readable._fromList = fromList

          // Pluck off n bytes from an array of buffers.
          // Length is the combined lengths of all the buffers in the list.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromList(n, state) {
            // nothing buffered
            if (state.length === 0) return null

            var ret
            if (state.objectMode) ret = state.buffer.shift()
            else if (!n || n >= state.length) {
              // read it all, truncate the list
              if (state.decoder) ret = state.buffer.join("")
              else if (state.buffer.length === 1) ret = state.buffer.head.data
              else ret = state.buffer.concat(state.length)
              state.buffer.clear()
            } else {
              // read part of list
              ret = fromListPartial(n, state.buffer, state.decoder)
            }

            return ret
          }

          // Extracts only enough buffered data to satisfy the amount requested.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromListPartial(n, list, hasStrings) {
            var ret
            if (n < list.head.data.length) {
              // slice is the same for buffers and strings
              ret = list.head.data.slice(0, n)
              list.head.data = list.head.data.slice(n)
            } else if (n === list.head.data.length) {
              // first chunk is a perfect match
              ret = list.shift()
            } else {
              // result spans more than one buffer
              ret = hasStrings
                ? copyFromBufferString(n, list)
                : copyFromBuffer(n, list)
            }
            return ret
          }

          // Copies a specified amount of characters from the list of buffered data
          // chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBufferString(n, list) {
            var p = list.head
            var c = 1
            var ret = p.data
            n -= ret.length
            while ((p = p.next)) {
              var str = p.data
              var nb = n > str.length ? str.length : n
              if (nb === str.length) ret += str
              else ret += str.slice(0, n)
              n -= nb
              if (n === 0) {
                if (nb === str.length) {
                  ++c
                  if (p.next) list.head = p.next
                  else list.head = list.tail = null
                } else {
                  list.head = p
                  p.data = str.slice(nb)
                }
                break
              }
              ++c
            }
            list.length -= c
            return ret
          }

          // Copies a specified amount of bytes from the list of buffered data chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n)
            var p = list.head
            var c = 1
            p.data.copy(ret)
            n -= p.data.length
            while ((p = p.next)) {
              var buf = p.data
              var nb = n > buf.length ? buf.length : n
              buf.copy(ret, ret.length - n, 0, nb)
              n -= nb
              if (n === 0) {
                if (nb === buf.length) {
                  ++c
                  if (p.next) list.head = p.next
                  else list.head = list.tail = null
                } else {
                  list.head = p
                  p.data = buf.slice(nb)
                }
                break
              }
              ++c
            }
            list.length -= c
            return ret
          }

          function endReadable(stream) {
            var state = stream._readableState

            // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.
            if (state.length > 0)
              throw new Error('"endReadable()" called on non-empty stream')

            if (!state.endEmitted) {
              state.ended = true
              pna.nextTick(endReadableNT, state, stream)
            }
          }

          function endReadableNT(state, stream) {
            // Check that we didn't get one last unshift.
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true
              stream.readable = false
              stream.emit("end")
            }
          }

          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x) return i
            }
            return -1
          }
        }.call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {}
        ))
      },
      {
        "./_stream_duplex": 48,
        "./internal/streams/BufferList": 53,
        "./internal/streams/destroy": 54,
        "./internal/streams/stream": 55,
        _process: 44,
        "core-util-is": 23,
        events: 24,
        inherits: 37,
        isarray: 56,
        "process-nextick-args": 57,
        "safe-buffer": 59,
        "string_decoder/": 73,
        util: 14
      }
    ],
    51: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a transform stream is a readable/writable stream where you do
        // something with the data.  Sometimes it's called a "filter",
        // but that's not a great name for it, since that implies a thing where
        // some bits pass through, and others are simply ignored.  (That would
        // be a valid example of a transform, of course.)
        //
        // While the output is causally related to the input, it's not a
        // necessarily symmetric or synchronous transformation.  For example,
        // a zlib stream might take multiple plain-text writes(), and then
        // emit a single compressed chunk some time in the future.
        //
        // Here's how this works:
        //
        // The Transform stream has all the aspects of the readable and writable
        // stream classes.  When you write(chunk), that calls _write(chunk,cb)
        // internally, and returns false if there's a lot of pending writes
        // buffered up.  When you call read(), that calls _read(n) until
        // there's enough pending readable data buffered up.
        //
        // In a transform stream, the written data is placed in a buffer.  When
        // _read(n) is called, it transforms the queued up data, calling the
        // buffered _write cb's as it consumes chunks.  If consuming a single
        // written chunk would result in multiple output chunks, then the first
        // outputted bit calls the readcb, and subsequent chunks just go into
        // the read buffer, and will cause it to emit 'readable' if necessary.
        //
        // This way, back-pressure is actually determined by the reading side,
        // since _read has to be called to start processing a new chunk.  However,
        // a pathological inflate type of transform can cause excessive buffering
        // here.  For example, imagine a stream where every byte of input is
        // interpreted as an integer from 0-255, and then results in that many
        // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
        // 1kb of data being output.  In this case, you could write a very small
        // amount of input, and end up with a very large amount of output.  In
        // such a pathological inflating mechanism, there'd be no way to tell
        // the system to stop doing the transform.  A single 4MB write could
        // cause the system to run out of memory.
        //
        // However, even in such a pathological case, only a single written chunk
        // would be consumed, and then the rest would wait (un-transformed) until
        // the results of the previous transformed chunk were consumed.

        "use strict"

        module.exports = Transform

        var Duplex = require("./_stream_duplex")

        /*<replacement>*/
        var util = require("core-util-is")
        util.inherits = require("inherits")
        /*</replacement>*/

        util.inherits(Transform, Duplex)

        function afterTransform(er, data) {
          var ts = this._transformState
          ts.transforming = false

          var cb = ts.writecb

          if (!cb) {
            return this.emit(
              "error",
              new Error("write callback called multiple times")
            )
          }

          ts.writechunk = null
          ts.writecb = null

          if (data != null)
            // single equals check for both `null` and `undefined`
            this.push(data)

          cb(er)

          var rs = this._readableState
          rs.reading = false
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark)
          }
        }

        function Transform(options) {
          if (!(this instanceof Transform)) return new Transform(options)

          Duplex.call(this, options)

          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }

          // start out asking for a readable event once data is transformed.
          this._readableState.needReadable = true

          // we have implemented the _read method, and done the other things
          // that Readable wants before the first _read call, so unset the
          // sync guard flag.
          this._readableState.sync = false

          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform

            if (typeof options.flush === "function") this._flush = options.flush
          }

          // When the writable side finishes, then flush out anything remaining.
          this.on("prefinish", prefinish)
        }

        function prefinish() {
          var _this = this

          if (typeof this._flush === "function") {
            this._flush(function(er, data) {
              done(_this, er, data)
            })
          } else {
            done(this, null, null)
          }
        }

        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false
          return Duplex.prototype.push.call(this, chunk, encoding)
        }

        // This is the part where you do stuff!
        // override this function in implementation classes.
        // 'chunk' is an input chunk.
        //
        // Call `push(newChunk)` to pass along transformed output
        // to the readable side.  You may call 'push' zero or more times.
        //
        // Call `cb(err)` when you are done with this chunk.  If you pass
        // an error, then that'll put the hurt on the whole operation.  If you
        // never call cb(), then you'll never get another chunk.
        Transform.prototype._transform = function(chunk, encoding, cb) {
          throw new Error("_transform() is not implemented")
        }

        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState
          ts.writecb = cb
          ts.writechunk = chunk
          ts.writeencoding = encoding
          if (!ts.transforming) {
            var rs = this._readableState
            if (
              ts.needTransform ||
              rs.needReadable ||
              rs.length < rs.highWaterMark
            )
              this._read(rs.highWaterMark)
          }
        }

        // Doesn't matter what the args are here.
        // _transform does all the work.
        // That we got here means that the readable side wants more data.
        Transform.prototype._read = function(n) {
          var ts = this._transformState

          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)
          } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that we've asked for it.
            ts.needTransform = true
          }
        }

        Transform.prototype._destroy = function(err, cb) {
          var _this2 = this

          Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2)
            _this2.emit("close")
          })
        }

        function done(stream, er, data) {
          if (er) return stream.emit("error", er)

          if (data != null)
            // single equals check for both `null` and `undefined`
            stream.push(data)

          // if there's nothing in the write buffer, then that means
          // that nothing more will ever be provided
          if (stream._writableState.length)
            throw new Error("Calling transform done when ws.length != 0")

          if (stream._transformState.transforming)
            throw new Error("Calling transform done when still transforming")

          return stream.push(null)
        }
      },
      { "./_stream_duplex": 48, "core-util-is": 23, inherits: 37 }
    ],
    52: [
      function(require, module, exports) {
        ;(function(process, global, setImmediate) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // A bit simpler than readable streams.
          // Implement an async ._write(chunk, encoding, cb), and it'll handle all
          // the drain event emission and buffering.

          "use strict"

          /*<replacement>*/

          var pna = require("process-nextick-args")
          /*</replacement>*/

          module.exports = Writable

          /* <replacement> */
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk
            this.encoding = encoding
            this.callback = cb
            this.next = null
          }

          // It seems a linked list but it is not
          // there will be only 2 of these for each stream
          function CorkedRequest(state) {
            var _this = this

            this.next = null
            this.entry = null
            this.finish = function() {
              onCorkedFinish(_this, state)
            }
          }
          /* </replacement> */

          /*<replacement>*/
          var asyncWrite =
            !process.browser &&
            ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1
              ? setImmediate
              : pna.nextTick
          /*</replacement>*/

          /*<replacement>*/
          var Duplex
          /*</replacement>*/

          Writable.WritableState = WritableState

          /*<replacement>*/
          var util = require("core-util-is")
          util.inherits = require("inherits")
          /*</replacement>*/

          /*<replacement>*/
          var internalUtil = {
            deprecate: require("util-deprecate")
          }
          /*</replacement>*/

          /*<replacement>*/
          var Stream = require("./internal/streams/stream")
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = require("safe-buffer").Buffer
          var OurUint8Array = global.Uint8Array || function() {}
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk)
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
          }

          /*</replacement>*/

          var destroyImpl = require("./internal/streams/destroy")

          util.inherits(Writable, Stream)

          function nop() {}

          function WritableState(options, stream) {
            Duplex = Duplex || require("./_stream_duplex")

            options = options || {}

            // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.
            var isDuplex = stream instanceof Duplex

            // object stream flag to indicate whether or not this stream
            // contains buffers or objects.
            this.objectMode = !!options.objectMode

            if (isDuplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode

            // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()
            var hwm = options.highWaterMark
            var writableHwm = options.writableHighWaterMark
            var defaultHwm = this.objectMode ? 16 : 16 * 1024

            if (hwm || hwm === 0) this.highWaterMark = hwm
            else if (isDuplex && (writableHwm || writableHwm === 0))
              this.highWaterMark = writableHwm
            else this.highWaterMark = defaultHwm

            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark)

            // if _final has been called
            this.finalCalled = false

            // drain event flag.
            this.needDrain = false
            // at the start of calling end()
            this.ending = false
            // when end() has been called, and returned
            this.ended = false
            // when 'finish' is emitted
            this.finished = false

            // has it been destroyed
            this.destroyed = false

            // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.
            var noDecode = options.decodeStrings === false
            this.decodeStrings = !noDecode

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || "utf8"

            // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.
            this.length = 0

            // a flag to see when we're in the middle of a write.
            this.writing = false

            // when true all writes will be buffered until .uncork() call
            this.corked = 0

            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true

            // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.
            this.bufferProcessing = false

            // the callback that's passed to _write(chunk,cb)
            this.onwrite = function(er) {
              onwrite(stream, er)
            }

            // the callback that the user supplies to write(chunk,encoding,cb)
            this.writecb = null

            // the amount that is being written when _write is called.
            this.writelen = 0

            this.bufferedRequest = null
            this.lastBufferedRequest = null

            // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted
            this.pendingcb = 0

            // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams
            this.prefinished = false

            // True if the error was already emitted and should not be thrown again
            this.errorEmitted = false

            // count buffered requests
            this.bufferedRequestCount = 0

            // allocate the first CorkedRequest, there is always
            // one allocated and free to use, and we maintain at most two
            this.corkedRequestsFree = new CorkedRequest(this)
          }

          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest
            var out = []
            while (current) {
              out.push(current)
              current = current.next
            }
            return out
          }

          ;(function() {
            try {
              Object.defineProperty(WritableState.prototype, "buffer", {
                get: internalUtil.deprecate(
                  function() {
                    return this.getBuffer()
                  },
                  "_writableState.buffer is deprecated. Use _writableState.getBuffer " +
                    "instead.",
                  "DEP0003"
                )
              })
            } catch (_) {}
          })()

          // Test _writableState for inheritance to account for Duplex streams,
          // whose prototype chain only points to Readable.
          var realHasInstance
          if (
            typeof Symbol === "function" &&
            Symbol.hasInstance &&
            typeof Function.prototype[Symbol.hasInstance] === "function"
          ) {
            realHasInstance = Function.prototype[Symbol.hasInstance]
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function(object) {
                if (realHasInstance.call(this, object)) return true
                if (this !== Writable) return false

                return object && object._writableState instanceof WritableState
              }
            })
          } else {
            realHasInstance = function(object) {
              return object instanceof this
            }
          }

          function Writable(options) {
            Duplex = Duplex || require("./_stream_duplex")

            // Writable ctor is applied to Duplexes, too.
            // `realHasInstance` is necessary because using plain `instanceof`
            // would return false, as no `_writableState` property is attached.

            // Trying to use the custom `instanceof` for Writable here will also break the
            // Node.js LazyTransform implementation, which has a non-trivial getter for
            // `_writableState` that would lead to infinite recursion.
            if (
              !realHasInstance.call(Writable, this) &&
              !(this instanceof Duplex)
            ) {
              return new Writable(options)
            }

            this._writableState = new WritableState(options, this)

            // legacy.
            this.writable = true

            if (options) {
              if (typeof options.write === "function")
                this._write = options.write

              if (typeof options.writev === "function")
                this._writev = options.writev

              if (typeof options.destroy === "function")
                this._destroy = options.destroy

              if (typeof options.final === "function")
                this._final = options.final
            }

            Stream.call(this)
          }

          // Otherwise people can pipe Writable streams, which is just wrong.
          Writable.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"))
          }

          function writeAfterEnd(stream, cb) {
            var er = new Error("write after end")
            // TODO: defer error events consistently everywhere, not just the cb
            stream.emit("error", er)
            pna.nextTick(cb, er)
          }

          // Checks that a user-supplied chunk is valid, especially for the particular
          // mode the stream is in. Currently this means that `null` is never accepted
          // and undefined/non-string values are only allowed in object mode.
          function validChunk(stream, state, chunk, cb) {
            var valid = true
            var er = false

            if (chunk === null) {
              er = new TypeError("May not write null values to stream")
            } else if (
              typeof chunk !== "string" &&
              chunk !== undefined &&
              !state.objectMode
            ) {
              er = new TypeError("Invalid non-string/buffer chunk")
            }
            if (er) {
              stream.emit("error", er)
              pna.nextTick(cb, er)
              valid = false
            }
            return valid
          }

          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState
            var ret = false
            var isBuf = !state.objectMode && _isUint8Array(chunk)

            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk)
            }

            if (typeof encoding === "function") {
              cb = encoding
              encoding = null
            }

            if (isBuf) encoding = "buffer"
            else if (!encoding) encoding = state.defaultEncoding

            if (typeof cb !== "function") cb = nop

            if (state.ended) writeAfterEnd(this, cb)
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb)
            }

            return ret
          }

          Writable.prototype.cork = function() {
            var state = this._writableState

            state.corked++
          }

          Writable.prototype.uncork = function() {
            var state = this._writableState

            if (state.corked) {
              state.corked--

              if (
                !state.writing &&
                !state.corked &&
                !state.finished &&
                !state.bufferProcessing &&
                state.bufferedRequest
              )
                clearBuffer(this, state)
            }
          }

          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(
            encoding
          ) {
            // node::ParseEncoding() requires lower case.
            if (typeof encoding === "string") encoding = encoding.toLowerCase()
            if (
              !(
                [
                  "hex",
                  "utf8",
                  "utf-8",
                  "ascii",
                  "binary",
                  "base64",
                  "ucs2",
                  "ucs-2",
                  "utf16le",
                  "utf-16le",
                  "raw"
                ].indexOf((encoding + "").toLowerCase()) > -1
              )
            )
              throw new TypeError("Unknown encoding: " + encoding)
            this._writableState.defaultEncoding = encoding
            return this
          }

          function decodeChunk(state, chunk, encoding) {
            if (
              !state.objectMode &&
              state.decodeStrings !== false &&
              typeof chunk === "string"
            ) {
              chunk = Buffer.from(chunk, encoding)
            }
            return chunk
          }

          Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function() {
              return this._writableState.highWaterMark
            }
          })

          // if we're already writing something, then just put this
          // in the queue, and wait our turn.  Otherwise, call _write
          // If we return false, then we need a drain event, so set that flag.
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding)
              if (chunk !== newChunk) {
                isBuf = true
                encoding = "buffer"
                chunk = newChunk
              }
            }
            var len = state.objectMode ? 1 : chunk.length

            state.length += len

            var ret = state.length < state.highWaterMark
            // we must ensure that previous needDrain will not be reset to false.
            if (!ret) state.needDrain = true

            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest
              state.lastBufferedRequest = {
                chunk: chunk,
                encoding: encoding,
                isBuf: isBuf,
                callback: cb,
                next: null
              }
              if (last) {
                last.next = state.lastBufferedRequest
              } else {
                state.bufferedRequest = state.lastBufferedRequest
              }
              state.bufferedRequestCount += 1
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb)
            }

            return ret
          }

          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len
            state.writecb = cb
            state.writing = true
            state.sync = true
            if (writev) stream._writev(chunk, state.onwrite)
            else stream._write(chunk, encoding, state.onwrite)
            state.sync = false
          }

          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb

            if (sync) {
              // defer the callback if we are being called synchronously
              // to avoid piling up things on the stack
              pna.nextTick(cb, er)
              // this can emit finish, and it will always happen
              // after error
              pna.nextTick(finishMaybe, stream, state)
              stream._writableState.errorEmitted = true
              stream.emit("error", er)
            } else {
              // the caller expect this to happen before if
              // it is async
              cb(er)
              stream._writableState.errorEmitted = true
              stream.emit("error", er)
              // this can emit finish, but finish must
              // always follow error
              finishMaybe(stream, state)
            }
          }

          function onwriteStateUpdate(state) {
            state.writing = false
            state.writecb = null
            state.length -= state.writelen
            state.writelen = 0
          }

          function onwrite(stream, er) {
            var state = stream._writableState
            var sync = state.sync
            var cb = state.writecb

            onwriteStateUpdate(state)

            if (er) onwriteError(stream, state, sync, er, cb)
            else {
              // Check if we're actually ready to finish, but don't emit yet
              var finished = needFinish(state)

              if (
                !finished &&
                !state.corked &&
                !state.bufferProcessing &&
                state.bufferedRequest
              ) {
                clearBuffer(stream, state)
              }

              if (sync) {
                /*<replacement>*/
                asyncWrite(afterWrite, stream, state, finished, cb)
                /*</replacement>*/
              } else {
                afterWrite(stream, state, finished, cb)
              }
            }
          }

          function afterWrite(stream, state, finished, cb) {
            if (!finished) onwriteDrain(stream, state)
            state.pendingcb--
            cb()
            finishMaybe(stream, state)
          }

          // Must force callback to be called on nextTick, so that we don't
          // emit 'drain' before the write() consumer gets the 'false' return
          // value, and has a chance to attach a 'drain' listener.
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false
              stream.emit("drain")
            }
          }

          // if there's something in the buffer waiting, then process it
          function clearBuffer(stream, state) {
            state.bufferProcessing = true
            var entry = state.bufferedRequest

            if (stream._writev && entry && entry.next) {
              // Fast case, write everything using _writev()
              var l = state.bufferedRequestCount
              var buffer = new Array(l)
              var holder = state.corkedRequestsFree
              holder.entry = entry

              var count = 0
              var allBuffers = true
              while (entry) {
                buffer[count] = entry
                if (!entry.isBuf) allBuffers = false
                entry = entry.next
                count += 1
              }
              buffer.allBuffers = allBuffers

              doWrite(
                stream,
                state,
                true,
                state.length,
                buffer,
                "",
                holder.finish
              )

              // doWrite is almost always async, defer these to save a bit of time
              // as the hot path ends with doWrite
              state.pendingcb++
              state.lastBufferedRequest = null
              if (holder.next) {
                state.corkedRequestsFree = holder.next
                holder.next = null
              } else {
                state.corkedRequestsFree = new CorkedRequest(state)
              }
              state.bufferedRequestCount = 0
            } else {
              // Slow case, write chunks one-by-one
              while (entry) {
                var chunk = entry.chunk
                var encoding = entry.encoding
                var cb = entry.callback
                var len = state.objectMode ? 1 : chunk.length

                doWrite(stream, state, false, len, chunk, encoding, cb)
                entry = entry.next
                state.bufferedRequestCount--
                // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.
                if (state.writing) {
                  break
                }
              }

              if (entry === null) state.lastBufferedRequest = null
            }

            state.bufferedRequest = entry
            state.bufferProcessing = false
          }

          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error("_write() is not implemented"))
          }

          Writable.prototype._writev = null

          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState

            if (typeof chunk === "function") {
              cb = chunk
              chunk = null
              encoding = null
            } else if (typeof encoding === "function") {
              cb = encoding
              encoding = null
            }

            if (chunk !== null && chunk !== undefined)
              this.write(chunk, encoding)

            // .end() fully uncorks
            if (state.corked) {
              state.corked = 1
              this.uncork()
            }

            // ignore unnecessary end() calls.
            if (!state.ending && !state.finished) endWritable(this, state, cb)
          }

          function needFinish(state) {
            return (
              state.ending &&
              state.length === 0 &&
              state.bufferedRequest === null &&
              !state.finished &&
              !state.writing
            )
          }
          function callFinal(stream, state) {
            stream._final(function(err) {
              state.pendingcb--
              if (err) {
                stream.emit("error", err)
              }
              state.prefinished = true
              stream.emit("prefinish")
              finishMaybe(stream, state)
            })
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === "function") {
                state.pendingcb++
                state.finalCalled = true
                pna.nextTick(callFinal, stream, state)
              } else {
                state.prefinished = true
                stream.emit("prefinish")
              }
            }
          }

          function finishMaybe(stream, state) {
            var need = needFinish(state)
            if (need) {
              prefinish(stream, state)
              if (state.pendingcb === 0) {
                state.finished = true
                stream.emit("finish")
              }
            }
            return need
          }

          function endWritable(stream, state, cb) {
            state.ending = true
            finishMaybe(stream, state)
            if (cb) {
              if (state.finished) pna.nextTick(cb)
              else stream.once("finish", cb)
            }
            state.ended = true
            stream.writable = false
          }

          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry
            corkReq.entry = null
            while (entry) {
              var cb = entry.callback
              state.pendingcb--
              cb(err)
              entry = entry.next
            }
            if (state.corkedRequestsFree) {
              state.corkedRequestsFree.next = corkReq
            } else {
              state.corkedRequestsFree = corkReq
            }
          }

          Object.defineProperty(Writable.prototype, "destroyed", {
            get: function() {
              if (this._writableState === undefined) {
                return false
              }
              return this._writableState.destroyed
            },
            set: function(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._writableState) {
                return
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._writableState.destroyed = value
            }
          })

          Writable.prototype.destroy = destroyImpl.destroy
          Writable.prototype._undestroy = destroyImpl.undestroy
          Writable.prototype._destroy = function(err, cb) {
            this.end()
            cb(err)
          }
        }.call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
          require("timers").setImmediate
        ))
      },
      {
        "./_stream_duplex": 48,
        "./internal/streams/destroy": 54,
        "./internal/streams/stream": 55,
        _process: 44,
        "core-util-is": 23,
        inherits: 37,
        "process-nextick-args": 57,
        "safe-buffer": 59,
        timers: 75,
        "util-deprecate": 79
      }
    ],
    53: [
      function(require, module, exports) {
        "use strict"

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
          }
        }

        var Buffer = require("safe-buffer").Buffer
        var util = require("util")

        function copyBuffer(src, target, offset) {
          src.copy(target, offset)
        }

        module.exports = (function() {
          function BufferList() {
            _classCallCheck(this, BufferList)

            this.head = null
            this.tail = null
            this.length = 0
          }

          BufferList.prototype.push = function push(v) {
            var entry = { data: v, next: null }
            if (this.length > 0) this.tail.next = entry
            else this.head = entry
            this.tail = entry
            ++this.length
          }

          BufferList.prototype.unshift = function unshift(v) {
            var entry = { data: v, next: this.head }
            if (this.length === 0) this.tail = entry
            this.head = entry
            ++this.length
          }

          BufferList.prototype.shift = function shift() {
            if (this.length === 0) return
            var ret = this.head.data
            if (this.length === 1) this.head = this.tail = null
            else this.head = this.head.next
            --this.length
            return ret
          }

          BufferList.prototype.clear = function clear() {
            this.head = this.tail = null
            this.length = 0
          }

          BufferList.prototype.join = function join(s) {
            if (this.length === 0) return ""
            var p = this.head
            var ret = "" + p.data
            while ((p = p.next)) {
              ret += s + p.data
            }
            return ret
          }

          BufferList.prototype.concat = function concat(n) {
            if (this.length === 0) return Buffer.alloc(0)
            if (this.length === 1) return this.head.data
            var ret = Buffer.allocUnsafe(n >>> 0)
            var p = this.head
            var i = 0
            while (p) {
              copyBuffer(p.data, ret, i)
              i += p.data.length
              p = p.next
            }
            return ret
          }

          return BufferList
        })()

        if (util && util.inspect && util.inspect.custom) {
          module.exports.prototype[util.inspect.custom] = function() {
            var obj = util.inspect({ length: this.length })
            return this.constructor.name + " " + obj
          }
        }
      },
      { "safe-buffer": 59, util: 14 }
    ],
    54: [
      function(require, module, exports) {
        "use strict"

        /*<replacement>*/

        var pna = require("process-nextick-args")
        /*</replacement>*/

        // undocumented cb() API, needed for core, not for public API
        function destroy(err, cb) {
          var _this = this

          var readableDestroyed =
            this._readableState && this._readableState.destroyed
          var writableDestroyed =
            this._writableState && this._writableState.destroyed

          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err)
            } else if (
              err &&
              (!this._writableState || !this._writableState.errorEmitted)
            ) {
              pna.nextTick(emitErrorNT, this, err)
            }
            return this
          }

          // we set destroyed to true before firing error callbacks in order
          // to make it re-entrance safe in case destroy() is called within callbacks

          if (this._readableState) {
            this._readableState.destroyed = true
          }

          // if this is a duplex stream mark the writable part as destroyed as well
          if (this._writableState) {
            this._writableState.destroyed = true
          }

          this._destroy(err || null, function(err) {
            if (!cb && err) {
              pna.nextTick(emitErrorNT, _this, err)
              if (_this._writableState) {
                _this._writableState.errorEmitted = true
              }
            } else if (cb) {
              cb(err)
            }
          })

          return this
        }

        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false
            this._readableState.reading = false
            this._readableState.ended = false
            this._readableState.endEmitted = false
          }

          if (this._writableState) {
            this._writableState.destroyed = false
            this._writableState.ended = false
            this._writableState.ending = false
            this._writableState.finished = false
            this._writableState.errorEmitted = false
          }
        }

        function emitErrorNT(self, err) {
          self.emit("error", err)
        }

        module.exports = {
          destroy: destroy,
          undestroy: undestroy
        }
      },
      { "process-nextick-args": 57 }
    ],
    55: [
      function(require, module, exports) {
        module.exports = require("events").EventEmitter
      },
      { events: 24 }
    ],
    56: [
      function(require, module, exports) {
        var toString = {}.toString

        module.exports =
          Array.isArray ||
          function(arr) {
            return toString.call(arr) == "[object Array]"
          }
      },
      {}
    ],
    57: [
      function(require, module, exports) {
        ;(function(process) {
          "use strict"

          if (
            !process.version ||
            process.version.indexOf("v0.") === 0 ||
            (process.version.indexOf("v1.") === 0 &&
              process.version.indexOf("v1.8.") !== 0)
          ) {
            module.exports = { nextTick: nextTick }
          } else {
            module.exports = process
          }

          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
              throw new TypeError('"callback" argument must be a function')
            }
            var len = arguments.length
            var args, i
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn)
              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1)
                })
              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2)
                })
              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3)
                })
              default:
                args = new Array(len - 1)
                i = 0
                while (i < args.length) {
                  args[i++] = arguments[i]
                }
                return process.nextTick(function afterTick() {
                  fn.apply(null, args)
                })
            }
          }
        }.call(this, require("_process")))
      },
      { _process: 44 }
    ],
    58: [
      function(require, module, exports) {
        exports = module.exports = require("./lib/_stream_readable.js")
        exports.Stream = exports
        exports.Readable = exports
        exports.Writable = require("./lib/_stream_writable.js")
        exports.Duplex = require("./lib/_stream_duplex.js")
        exports.Transform = require("./lib/_stream_transform.js")
        exports.PassThrough = require("./lib/_stream_passthrough.js")
      },
      {
        "./lib/_stream_duplex.js": 48,
        "./lib/_stream_passthrough.js": 49,
        "./lib/_stream_readable.js": 50,
        "./lib/_stream_transform.js": 51,
        "./lib/_stream_writable.js": 52
      }
    ],
    59: [
      function(require, module, exports) {
        /* eslint-disable node/no-deprecated-api */
        var buffer = require("buffer")
        var Buffer = buffer.Buffer

        // alternative to using Object.keys for old browsers
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key]
          }
        }
        if (
          Buffer.from &&
          Buffer.alloc &&
          Buffer.allocUnsafe &&
          Buffer.allocUnsafeSlow
        ) {
          module.exports = buffer
        } else {
          // Copy properties from require('buffer')
          copyProps(buffer, exports)
          exports.Buffer = SafeBuffer
        }

        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length)
        }

        // Copy static methods from Buffer
        copyProps(Buffer, SafeBuffer)

        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number")
          }
          return Buffer(arg, encodingOrOffset, length)
        }

        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number")
          }
          var buf = Buffer(size)
          if (fill !== undefined) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding)
            } else {
              buf.fill(fill)
            }
          } else {
            buf.fill(0)
          }
          return buf
        }

        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number")
          }
          return Buffer(size)
        }

        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number")
          }
          return buffer.SlowBuffer(size)
        }
      },
      { buffer: 20 }
    ],
    60: [
      function(require, module, exports) {
        var varint = require("varint")
        exports.encode = function encode(v, b, o) {
          v = v >= 0 ? v * 2 : v * -2 - 1
          var r = varint.encode(v, b, o)
          encode.bytes = varint.encode.bytes
          return r
        }
        exports.decode = function decode(b, o) {
          var v = varint.decode(b, o)
          decode.bytes = varint.decode.bytes
          return v & 1 ? (v + 1) / -2 : v / 2
        }

        exports.encodingLength = function(v) {
          return varint.encodingLength(v >= 0 ? v * 2 : v * -2 - 1)
        }
      },
      { varint: 82 }
    ],
    61: [
      function(require, module, exports) {
        module.exports = fallback

        function _add(a, b) {
          var rl = a.l + b.l
          var a2 = {
            h: (a.h + b.h + ((rl / 2) >>> 31)) >>> 0,
            l: rl >>> 0
          }
          a.h = a2.h
          a.l = a2.l
        }

        function _xor(a, b) {
          a.h ^= b.h
          a.h >>>= 0
          a.l ^= b.l
          a.l >>>= 0
        }

        function _rotl(a, n) {
          var a2 = {
            h: (a.h << n) | (a.l >>> (32 - n)),
            l: (a.l << n) | (a.h >>> (32 - n))
          }
          a.h = a2.h
          a.l = a2.l
        }

        function _rotl32(a) {
          var al = a.l
          a.l = a.h
          a.h = al
        }

        function _compress(v0, v1, v2, v3) {
          _add(v0, v1)
          _add(v2, v3)
          _rotl(v1, 13)
          _rotl(v3, 16)
          _xor(v1, v0)
          _xor(v3, v2)
          _rotl32(v0)
          _add(v2, v1)
          _add(v0, v3)
          _rotl(v1, 17)
          _rotl(v3, 21)
          _xor(v1, v2)
          _xor(v3, v0)
          _rotl32(v2)
        }

        function _get_int(a, offset) {
          return (
            (a[offset + 3] << 24) |
            (a[offset + 2] << 16) |
            (a[offset + 1] << 8) |
            a[offset]
          )
        }

        function fallback(out, m, key) {
          // modified from https://github.com/jedisct1/siphash-js to use uint8arrays
          var k0 = { h: _get_int(key, 4), l: _get_int(key, 0) }
          var k1 = { h: _get_int(key, 12), l: _get_int(key, 8) }
          var v0 = { h: k0.h, l: k0.l }
          var v2 = k0
          var v1 = { h: k1.h, l: k1.l }
          var v3 = k1
          var mi
          var mp = 0
          var ml = m.length
          var ml7 = ml - 7
          var buf = new Uint8Array(new ArrayBuffer(8))

          _xor(v0, { h: 0x736f6d65, l: 0x70736575 })
          _xor(v1, { h: 0x646f7261, l: 0x6e646f6d })
          _xor(v2, { h: 0x6c796765, l: 0x6e657261 })
          _xor(v3, { h: 0x74656462, l: 0x79746573 })

          while (mp < ml7) {
            mi = { h: _get_int(m, mp + 4), l: _get_int(m, mp) }
            _xor(v3, mi)
            _compress(v0, v1, v2, v3)
            _compress(v0, v1, v2, v3)
            _xor(v0, mi)
            mp += 8
          }

          buf[7] = ml
          var ic = 0
          while (mp < ml) {
            buf[ic++] = m[mp++]
          }
          while (ic < 7) {
            buf[ic++] = 0
          }

          mi = {
            h: (buf[7] << 24) | (buf[6] << 16) | (buf[5] << 8) | buf[4],
            l: (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0]
          }

          _xor(v3, mi)
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)
          _xor(v0, mi)
          _xor(v2, { h: 0, l: 0xff })
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)

          var h = v0
          _xor(h, v1)
          _xor(h, v2)
          _xor(h, v3)

          out[0] = h.l & 0xff
          out[1] = (h.l >> 8) & 0xff
          out[2] = (h.l >> 16) & 0xff
          out[3] = (h.l >> 24) & 0xff
          out[4] = h.h & 0xff
          out[5] = (h.h >> 8) & 0xff
          out[6] = (h.h >> 16) & 0xff
          out[7] = (h.h >> 24) & 0xff
        }
      },
      {}
    ],
    62: [
      function(require, module, exports) {
        var wasm = require("./siphash24")
        var fallback = require("./fallback")
        var assert = require("nanoassert")

        module.exports = siphash24

        var BYTES = (siphash24.BYTES = 8)
        var KEYBYTES = (siphash24.KEYBYTES = 16)
        var mod = wasm()

        siphash24.WASM_SUPPORTED = typeof WebAssembly !== "undefined"
        siphash24.WASM_LOADED = false

        if (mod) {
          mod.onload(function(err) {
            siphash24.WASM_LOADED = !err
          })
        }

        function siphash24(data, key, out, noAssert) {
          if (!out) out = new Uint8Array(8)

          if (noAssert !== true) {
            assert(out.length >= BYTES, "output must be at least " + BYTES)
            assert(key.length >= KEYBYTES, "key must be at least " + KEYBYTES)
          }

          if (mod && mod.exports) {
            if (data.length + 24 > mod.memory.length)
              mod.realloc(data.length + 24)
            mod.memory.set(key, 8)
            mod.memory.set(data, 24)
            mod.exports.siphash(24, data.length)
            out.set(mod.memory.subarray(0, 8))
          } else {
            fallback(out, data, key)
          }

          return out
        }
      },
      { "./fallback": 61, "./siphash24": 63, nanoassert: 42 }
    ],
    63: [
      function(require, module, exports) {
        module.exports = loadWebAssembly

        loadWebAssembly.supported = typeof WebAssembly !== "undefined"

        function loadWebAssembly(opts) {
          if (!loadWebAssembly.supported) return null

          var imp = opts && opts.imports
          var wasm = toUint8Array(
            "AGFzbQEAAAABBgFgAn9/AAMCAQAFBQEBCpBOBxQCBm1lbW9yeQIAB3NpcGhhc2gAAArdCAHaCAIIfgJ/QvXKzYPXrNu38wAhAkLt3pHzlszct+QAIQNC4eSV89bs2bzsACEEQvPK0cunjNmy9AAhBUEIKQMAIQdBECkDACEIIAGtQjiGIQYgAUEHcSELIAAgAWogC2shCiAFIAiFIQUgBCAHhSEEIAMgCIUhAyACIAeFIQICQANAIAAgCkYNASAAKQMAIQkgBSAJhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAmFIQIgAEEIaiEADAALCwJAAkACQAJAAkACQAJAAkAgCw4HBwYFBAMCAQALIAYgADEABkIwhoQhBgsgBiAAMQAFQiiGhCEGCyAGIAAxAARCIIaEIQYLIAYgADEAA0IYhoQhBgsgBiAAMQACQhCGhCEGCyAGIAAxAAFCCIaEIQYLIAYgADEAAIQhBgsgBSAGhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAaFIQIgBEL/AYUhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEQQAgAiADIAQgBYWFhTcDAAs="
          )
          var ready = null

          var mod = {
            buffer: wasm,
            memory: null,
            exports: null,
            realloc: realloc,
            onload: onload
          }

          onload(function() {})

          return mod

          function realloc(size) {
            mod.exports.memory.grow(
              Math.max(0, Math.ceil(Math.abs(size - mod.memory.length) / 65536))
            )
            mod.memory = new Uint8Array(mod.exports.memory.buffer)
          }

          function onload(cb) {
            if (mod.exports) return cb()

            if (ready) {
              ready.then(cb.bind(null, null)).catch(cb)
              return
            }

            try {
              if (opts && opts.async) throw new Error("async")
              setup({
                instance: new WebAssembly.Instance(
                  new WebAssembly.Module(wasm),
                  imp
                )
              })
            } catch (err) {
              ready = WebAssembly.instantiate(wasm, imp).then(setup)
            }

            onload(cb)
          }

          function setup(w) {
            mod.exports = w.instance.exports
            mod.memory =
              mod.exports.memory &&
              mod.exports.memory.buffer &&
              new Uint8Array(mod.exports.memory.buffer)
          }
        }

        function toUint8Array(s) {
          if (typeof atob === "function")
            return new Uint8Array(
              atob(s)
                .split("")
                .map(charCodeAt)
            )
          return new (require("buf" + "fer")).Buffer(s, "base64")
        }

        function charCodeAt(c) {
          return c.charCodeAt(0)
        }
      },
      {}
    ],
    64: [
      function(require, module, exports) {
        var blake2b = require("blake2b")

        module.exports.crypto_generichash_PRIMITIVE = "blake2b"
        module.exports.crypto_generichash_BYTES_MIN = blake2b.BYTES_MIN
        module.exports.crypto_generichash_BYTES_MAX = blake2b.BYTES_MAX
        module.exports.crypto_generichash_BYTES = blake2b.BYTES
        module.exports.crypto_generichash_KEYBYTES_MIN = blake2b.KEYBYTES_MIN
        module.exports.crypto_generichash_KEYBYTES_MAX = blake2b.KEYBYTES_MAX
        module.exports.crypto_generichash_KEYBYTES = blake2b.KEYBYTES
        module.exports.crypto_generichash_WASM_SUPPORTED =
          blake2b.WASM_SUPPORTED
        module.exports.crypto_generichash_WASM_LOADED = false

        module.exports.crypto_generichash = function(output, input, key) {
          blake2b(output.length, key)
            .update(input)
            .final(output)
        }

        module.exports.crypto_generichash_ready = blake2b.ready

        module.exports.crypto_generichash_batch = function(
          output,
          inputArray,
          key
        ) {
          var ctx = blake2b(output.length, key)
          for (var i = 0; i < inputArray.length; i++) {
            ctx.update(inputArray[i])
          }
          ctx.final(output)
        }

        module.exports.crypto_generichash_instance = function(key, outlen) {
          if (outlen == null) outlen = module.exports.crypto_generichash_BYTES
          return blake2b(outlen, key)
        }

        blake2b.ready(function(err) {
          module.exports.crypto_generichash_WASM_LOADED = blake2b.WASM_LOADED
        })
      },
      { blake2b: 13 }
    ],
    65: [
      function(require, module, exports) {
        var assert = require("nanoassert")
        var randombytes_buf = require("./randombytes").randombytes_buf
        var blake2b = require("blake2b")

        module.exports.crypto_kdf_PRIMITIVE = "blake2b"
        module.exports.crypto_kdf_BYTES_MIN = 16
        module.exports.crypto_kdf_BYTES_MAX = 64
        module.exports.crypto_kdf_CONTEXTBYTES = 8
        module.exports.crypto_kdf_KEYBYTES = 32

        function STORE64_LE(dest, int) {
          var mul = 1
          var i = 0
          dest[0] = int & 0xff
          while (++i < 8 && (mul *= 0x100)) {
            dest[i] = (int / mul) & 0xff
          }
        }

        module.exports.crypto_kdf_derive_from_key = function crypto_kdf_derive_from_key(
          subkey,
          subkey_id,
          ctx,
          key
        ) {
          assert(
            subkey.length >= module.exports.crypto_kdf_BYTES_MIN,
            "subkey must be at least crypto_kdf_BYTES_MIN"
          )
          assert(
            subkey_id >= 0 && subkey_id <= 0x1fffffffffffff,
            "subkey_id must be safe integer"
          )
          assert(
            ctx.length >= module.exports.crypto_kdf_CONTEXTBYTES,
            "context must be at least crypto_kdf_CONTEXTBYTES"
          )

          var ctx_padded = new Uint8Array(blake2b.PERSONALBYTES)
          var salt = new Uint8Array(blake2b.SALTBYTES)

          ctx_padded.set(ctx, 0, module.exports.crypto_kdf_CONTEXTBYTES)
          STORE64_LE(salt, subkey_id)

          var outlen = Math.min(
            subkey.length,
            module.exports.crypto_kdf_BYTES_MAX
          )
          blake2b(
            outlen,
            key.subarray(0, module.exports.crypto_kdf_KEYBYTES),
            salt,
            ctx_padded,
            true
          ).final(subkey)
        }

        module.exports.crypto_kdf_keygen = function crypto_kdf_keygen(out) {
          assert(
            out.length >= module.exports.crypto_kdf_KEYBYTES,
            "out.length must be crypto_kdf_KEYBYTES"
          )
          randombytes_buf(out.subarray(0, module.exports.crypto_kdf_KEYBYTES))
        }
      },
      { "./randombytes": 69, blake2b: 13, nanoassert: 42 }
    ],
    66: [
      function(require, module, exports) {
        var siphash = require("siphash24")

        exports.crypto_shorthash_PRIMITIVE = "siphash24"
        exports.crypto_shorthash_BYTES = siphash.BYTES
        exports.crypto_shorthash_KEYBYTES = siphash.KEYBYTES
        exports.crypto_shorthash_WASM_SUPPORTED = siphash.WASM_SUPPORTED
        exports.crypto_shorthash_WASM_LOADED = siphash.WASM_LOADED
        exports.crypto_shorthash = shorthash

        function shorthash(out, data, key, noAssert) {
          siphash(data, key, out, noAssert)
        }
      },
      { siphash24: 62 }
    ],
    67: [
      function(require, module, exports) {
        var xsalsa20 = require("xsalsa20")

        exports.crypto_stream_KEYBYTES = 32
        exports.crypto_stream_NONCEBYTES = 24
        exports.crypto_stream_PRIMITIVE = "xsalsa20"

        exports.crypto_stream = function(out, nonce, key) {
          out.fill(0)
          exports.crypto_stream_xor(out, out, nonce, key)
        }

        exports.crypto_stream_xor = function(out, inp, nonce, key) {
          var xor = xsalsa20(nonce, key)
          xor.update(inp, out)
          xor.final()
        }

        exports.crypto_stream_xor_instance = function(nonce, key) {
          return new XOR(nonce, key)
        }

        function XOR(nonce, key) {
          this._instance = xsalsa20(nonce, key)
        }

        XOR.prototype.update = function(out, inp) {
          this._instance.update(inp, out)
        }

        XOR.prototype.final = function() {
          this._instance.finalize()
          this._instance = null
        }
      },
      { xsalsa20: 84 }
    ],
    68: [
      function(require, module, exports) {
        "use strict"

        // Based on https://github.com/dchest/tweetnacl-js/blob/6dcbcaf5f5cbfd313f2dcfe763db35c828c8ff5b/nacl-fast.js.

        var sodium = module.exports
        var cs = require("./crypto_stream")

        // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
        // Public domain.
        //
        // Implementation derived from TweetNaCl version 20140427.
        // See for details: http://tweetnacl.cr.yp.to/

        var gf = function(init) {
          var i,
            r = new Float64Array(16)
          if (init) for (i = 0; i < init.length; i++) r[i] = init[i]
          return r
        }

        // also forwarded at the bottom but randombytes is non-enumerable
        var randombytes = require("./randombytes").randombytes

        var _0 = new Uint8Array(16)
        var _9 = new Uint8Array(32)
        _9[0] = 9

        var gf0 = gf(),
          gf1 = gf([1]),
          _121665 = gf([0xdb41, 1]),
          D = gf([
            0x78a3,
            0x1359,
            0x4dca,
            0x75eb,
            0xd8ab,
            0x4141,
            0x0a4d,
            0x0070,
            0xe898,
            0x7779,
            0x4079,
            0x8cc7,
            0xfe73,
            0x2b6f,
            0x6cee,
            0x5203
          ]),
          D2 = gf([
            0xf159,
            0x26b2,
            0x9b94,
            0xebd6,
            0xb156,
            0x8283,
            0x149a,
            0x00e0,
            0xd130,
            0xeef3,
            0x80f2,
            0x198e,
            0xfce7,
            0x56df,
            0xd9dc,
            0x2406
          ]),
          X = gf([
            0xd51a,
            0x8f25,
            0x2d60,
            0xc956,
            0xa7b2,
            0x9525,
            0xc760,
            0x692c,
            0xdc5c,
            0xfdd6,
            0xe231,
            0xc0a4,
            0x53fe,
            0xcd6e,
            0x36d3,
            0x2169
          ]),
          Y = gf([
            0x6658,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666
          ]),
          I = gf([
            0xa0b0,
            0x4a0e,
            0x1b27,
            0xc4ee,
            0xe478,
            0xad2f,
            0x1806,
            0x2f43,
            0xd7a7,
            0x3dfb,
            0x0099,
            0x2b4d,
            0xdf0b,
            0x4fc1,
            0x2480,
            0x2b83
          ])

        function ts64(x, i, h, l) {
          x[i] = (h >> 24) & 0xff
          x[i + 1] = (h >> 16) & 0xff
          x[i + 2] = (h >> 8) & 0xff
          x[i + 3] = h & 0xff
          x[i + 4] = (l >> 24) & 0xff
          x[i + 5] = (l >> 16) & 0xff
          x[i + 6] = (l >> 8) & 0xff
          x[i + 7] = l & 0xff
        }

        function vn(x, xi, y, yi, n) {
          var i,
            d = 0
          for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i]
          return (1 & ((d - 1) >>> 8)) - 1
        }

        function crypto_verify_16(x, xi, y, yi) {
          return vn(x, xi, y, yi, 16)
        }

        function crypto_verify_32(x, xi, y, yi) {
          return vn(x, xi, y, yi, 32)
        }

        /*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

        var poly1305 = function(key) {
          this.buffer = new Uint8Array(16)
          this.r = new Uint16Array(10)
          this.h = new Uint16Array(10)
          this.pad = new Uint16Array(8)
          this.leftover = 0
          this.fin = 0

          var t0, t1, t2, t3, t4, t5, t6, t7

          t0 = (key[0] & 0xff) | ((key[1] & 0xff) << 8)
          this.r[0] = t0 & 0x1fff
          t1 = (key[2] & 0xff) | ((key[3] & 0xff) << 8)
          this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff
          t2 = (key[4] & 0xff) | ((key[5] & 0xff) << 8)
          this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03
          t3 = (key[6] & 0xff) | ((key[7] & 0xff) << 8)
          this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff
          t4 = (key[8] & 0xff) | ((key[9] & 0xff) << 8)
          this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff
          this.r[5] = (t4 >>> 1) & 0x1ffe
          t5 = (key[10] & 0xff) | ((key[11] & 0xff) << 8)
          this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff
          t6 = (key[12] & 0xff) | ((key[13] & 0xff) << 8)
          this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81
          t7 = (key[14] & 0xff) | ((key[15] & 0xff) << 8)
          this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff
          this.r[9] = (t7 >>> 5) & 0x007f

          this.pad[0] = (key[16] & 0xff) | ((key[17] & 0xff) << 8)
          this.pad[1] = (key[18] & 0xff) | ((key[19] & 0xff) << 8)
          this.pad[2] = (key[20] & 0xff) | ((key[21] & 0xff) << 8)
          this.pad[3] = (key[22] & 0xff) | ((key[23] & 0xff) << 8)
          this.pad[4] = (key[24] & 0xff) | ((key[25] & 0xff) << 8)
          this.pad[5] = (key[26] & 0xff) | ((key[27] & 0xff) << 8)
          this.pad[6] = (key[28] & 0xff) | ((key[29] & 0xff) << 8)
          this.pad[7] = (key[30] & 0xff) | ((key[31] & 0xff) << 8)
        }

        poly1305.prototype.blocks = function(m, mpos, bytes) {
          var hibit = this.fin ? 0 : 1 << 11
          var t0, t1, t2, t3, t4, t5, t6, t7, c
          var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9

          var h0 = this.h[0],
            h1 = this.h[1],
            h2 = this.h[2],
            h3 = this.h[3],
            h4 = this.h[4],
            h5 = this.h[5],
            h6 = this.h[6],
            h7 = this.h[7],
            h8 = this.h[8],
            h9 = this.h[9]

          var r0 = this.r[0],
            r1 = this.r[1],
            r2 = this.r[2],
            r3 = this.r[3],
            r4 = this.r[4],
            r5 = this.r[5],
            r6 = this.r[6],
            r7 = this.r[7],
            r8 = this.r[8],
            r9 = this.r[9]

          while (bytes >= 16) {
            t0 = (m[mpos + 0] & 0xff) | ((m[mpos + 1] & 0xff) << 8)
            h0 += t0 & 0x1fff
            t1 = (m[mpos + 2] & 0xff) | ((m[mpos + 3] & 0xff) << 8)
            h1 += ((t0 >>> 13) | (t1 << 3)) & 0x1fff
            t2 = (m[mpos + 4] & 0xff) | ((m[mpos + 5] & 0xff) << 8)
            h2 += ((t1 >>> 10) | (t2 << 6)) & 0x1fff
            t3 = (m[mpos + 6] & 0xff) | ((m[mpos + 7] & 0xff) << 8)
            h3 += ((t2 >>> 7) | (t3 << 9)) & 0x1fff
            t4 = (m[mpos + 8] & 0xff) | ((m[mpos + 9] & 0xff) << 8)
            h4 += ((t3 >>> 4) | (t4 << 12)) & 0x1fff
            h5 += (t4 >>> 1) & 0x1fff
            t5 = (m[mpos + 10] & 0xff) | ((m[mpos + 11] & 0xff) << 8)
            h6 += ((t4 >>> 14) | (t5 << 2)) & 0x1fff
            t6 = (m[mpos + 12] & 0xff) | ((m[mpos + 13] & 0xff) << 8)
            h7 += ((t5 >>> 11) | (t6 << 5)) & 0x1fff
            t7 = (m[mpos + 14] & 0xff) | ((m[mpos + 15] & 0xff) << 8)
            h8 += ((t6 >>> 8) | (t7 << 8)) & 0x1fff
            h9 += (t7 >>> 5) | hibit

            c = 0

            d0 = c
            d0 += h0 * r0
            d0 += h1 * (5 * r9)
            d0 += h2 * (5 * r8)
            d0 += h3 * (5 * r7)
            d0 += h4 * (5 * r6)
            c = d0 >>> 13
            d0 &= 0x1fff
            d0 += h5 * (5 * r5)
            d0 += h6 * (5 * r4)
            d0 += h7 * (5 * r3)
            d0 += h8 * (5 * r2)
            d0 += h9 * (5 * r1)
            c += d0 >>> 13
            d0 &= 0x1fff

            d1 = c
            d1 += h0 * r1
            d1 += h1 * r0
            d1 += h2 * (5 * r9)
            d1 += h3 * (5 * r8)
            d1 += h4 * (5 * r7)
            c = d1 >>> 13
            d1 &= 0x1fff
            d1 += h5 * (5 * r6)
            d1 += h6 * (5 * r5)
            d1 += h7 * (5 * r4)
            d1 += h8 * (5 * r3)
            d1 += h9 * (5 * r2)
            c += d1 >>> 13
            d1 &= 0x1fff

            d2 = c
            d2 += h0 * r2
            d2 += h1 * r1
            d2 += h2 * r0
            d2 += h3 * (5 * r9)
            d2 += h4 * (5 * r8)
            c = d2 >>> 13
            d2 &= 0x1fff
            d2 += h5 * (5 * r7)
            d2 += h6 * (5 * r6)
            d2 += h7 * (5 * r5)
            d2 += h8 * (5 * r4)
            d2 += h9 * (5 * r3)
            c += d2 >>> 13
            d2 &= 0x1fff

            d3 = c
            d3 += h0 * r3
            d3 += h1 * r2
            d3 += h2 * r1
            d3 += h3 * r0
            d3 += h4 * (5 * r9)
            c = d3 >>> 13
            d3 &= 0x1fff
            d3 += h5 * (5 * r8)
            d3 += h6 * (5 * r7)
            d3 += h7 * (5 * r6)
            d3 += h8 * (5 * r5)
            d3 += h9 * (5 * r4)
            c += d3 >>> 13
            d3 &= 0x1fff

            d4 = c
            d4 += h0 * r4
            d4 += h1 * r3
            d4 += h2 * r2
            d4 += h3 * r1
            d4 += h4 * r0
            c = d4 >>> 13
            d4 &= 0x1fff
            d4 += h5 * (5 * r9)
            d4 += h6 * (5 * r8)
            d4 += h7 * (5 * r7)
            d4 += h8 * (5 * r6)
            d4 += h9 * (5 * r5)
            c += d4 >>> 13
            d4 &= 0x1fff

            d5 = c
            d5 += h0 * r5
            d5 += h1 * r4
            d5 += h2 * r3
            d5 += h3 * r2
            d5 += h4 * r1
            c = d5 >>> 13
            d5 &= 0x1fff
            d5 += h5 * r0
            d5 += h6 * (5 * r9)
            d5 += h7 * (5 * r8)
            d5 += h8 * (5 * r7)
            d5 += h9 * (5 * r6)
            c += d5 >>> 13
            d5 &= 0x1fff

            d6 = c
            d6 += h0 * r6
            d6 += h1 * r5
            d6 += h2 * r4
            d6 += h3 * r3
            d6 += h4 * r2
            c = d6 >>> 13
            d6 &= 0x1fff
            d6 += h5 * r1
            d6 += h6 * r0
            d6 += h7 * (5 * r9)
            d6 += h8 * (5 * r8)
            d6 += h9 * (5 * r7)
            c += d6 >>> 13
            d6 &= 0x1fff

            d7 = c
            d7 += h0 * r7
            d7 += h1 * r6
            d7 += h2 * r5
            d7 += h3 * r4
            d7 += h4 * r3
            c = d7 >>> 13
            d7 &= 0x1fff
            d7 += h5 * r2
            d7 += h6 * r1
            d7 += h7 * r0
            d7 += h8 * (5 * r9)
            d7 += h9 * (5 * r8)
            c += d7 >>> 13
            d7 &= 0x1fff

            d8 = c
            d8 += h0 * r8
            d8 += h1 * r7
            d8 += h2 * r6
            d8 += h3 * r5
            d8 += h4 * r4
            c = d8 >>> 13
            d8 &= 0x1fff
            d8 += h5 * r3
            d8 += h6 * r2
            d8 += h7 * r1
            d8 += h8 * r0
            d8 += h9 * (5 * r9)
            c += d8 >>> 13
            d8 &= 0x1fff

            d9 = c
            d9 += h0 * r9
            d9 += h1 * r8
            d9 += h2 * r7
            d9 += h3 * r6
            d9 += h4 * r5
            c = d9 >>> 13
            d9 &= 0x1fff
            d9 += h5 * r4
            d9 += h6 * r3
            d9 += h7 * r2
            d9 += h8 * r1
            d9 += h9 * r0
            c += d9 >>> 13
            d9 &= 0x1fff

            c = ((c << 2) + c) | 0
            c = (c + d0) | 0
            d0 = c & 0x1fff
            c = c >>> 13
            d1 += c

            h0 = d0
            h1 = d1
            h2 = d2
            h3 = d3
            h4 = d4
            h5 = d5
            h6 = d6
            h7 = d7
            h8 = d8
            h9 = d9

            mpos += 16
            bytes -= 16
          }
          this.h[0] = h0
          this.h[1] = h1
          this.h[2] = h2
          this.h[3] = h3
          this.h[4] = h4
          this.h[5] = h5
          this.h[6] = h6
          this.h[7] = h7
          this.h[8] = h8
          this.h[9] = h9
        }

        poly1305.prototype.finish = function(mac, macpos) {
          var g = new Uint16Array(10)
          var c, mask, f, i

          if (this.leftover) {
            i = this.leftover
            this.buffer[i++] = 1
            for (; i < 16; i++) this.buffer[i] = 0
            this.fin = 1
            this.blocks(this.buffer, 0, 16)
          }

          c = this.h[1] >>> 13
          this.h[1] &= 0x1fff
          for (i = 2; i < 10; i++) {
            this.h[i] += c
            c = this.h[i] >>> 13
            this.h[i] &= 0x1fff
          }
          this.h[0] += c * 5
          c = this.h[0] >>> 13
          this.h[0] &= 0x1fff
          this.h[1] += c
          c = this.h[1] >>> 13
          this.h[1] &= 0x1fff
          this.h[2] += c

          g[0] = this.h[0] + 5
          c = g[0] >>> 13
          g[0] &= 0x1fff
          for (i = 1; i < 10; i++) {
            g[i] = this.h[i] + c
            c = g[i] >>> 13
            g[i] &= 0x1fff
          }
          g[9] -= 1 << 13

          mask = (c ^ 1) - 1
          for (i = 0; i < 10; i++) g[i] &= mask
          mask = ~mask
          for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i]

          this.h[0] = (this.h[0] | (this.h[1] << 13)) & 0xffff
          this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 0xffff
          this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 0xffff
          this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 0xffff
          this.h[4] =
            ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) & 0xffff
          this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 0xffff
          this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 0xffff
          this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 0xffff

          f = this.h[0] + this.pad[0]
          this.h[0] = f & 0xffff
          for (i = 1; i < 8; i++) {
            f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0
            this.h[i] = f & 0xffff
          }

          mac[macpos + 0] = (this.h[0] >>> 0) & 0xff
          mac[macpos + 1] = (this.h[0] >>> 8) & 0xff
          mac[macpos + 2] = (this.h[1] >>> 0) & 0xff
          mac[macpos + 3] = (this.h[1] >>> 8) & 0xff
          mac[macpos + 4] = (this.h[2] >>> 0) & 0xff
          mac[macpos + 5] = (this.h[2] >>> 8) & 0xff
          mac[macpos + 6] = (this.h[3] >>> 0) & 0xff
          mac[macpos + 7] = (this.h[3] >>> 8) & 0xff
          mac[macpos + 8] = (this.h[4] >>> 0) & 0xff
          mac[macpos + 9] = (this.h[4] >>> 8) & 0xff
          mac[macpos + 10] = (this.h[5] >>> 0) & 0xff
          mac[macpos + 11] = (this.h[5] >>> 8) & 0xff
          mac[macpos + 12] = (this.h[6] >>> 0) & 0xff
          mac[macpos + 13] = (this.h[6] >>> 8) & 0xff
          mac[macpos + 14] = (this.h[7] >>> 0) & 0xff
          mac[macpos + 15] = (this.h[7] >>> 8) & 0xff
        }

        poly1305.prototype.update = function(m, mpos, bytes) {
          var i, want

          if (this.leftover) {
            want = 16 - this.leftover
            if (want > bytes) want = bytes
            for (i = 0; i < want; i++)
              this.buffer[this.leftover + i] = m[mpos + i]
            bytes -= want
            mpos += want
            this.leftover += want
            if (this.leftover < 16) return
            this.blocks(this.buffer, 0, 16)
            this.leftover = 0
          }

          if (bytes >= 16) {
            want = bytes - (bytes % 16)
            this.blocks(m, mpos, want)
            mpos += want
            bytes -= want
          }

          if (bytes) {
            for (i = 0; i < bytes; i++)
              this.buffer[this.leftover + i] = m[mpos + i]
            this.leftover += bytes
          }
        }

        function crypto_stream_xor(c, cpos, m, mpos, clen, n, k) {
          cs.crypto_stream_xor(c, m, n, k)
        }

        function crypto_stream(c, cpos, clen, n, k) {
          cs.crypto_stream(c, n, k)
        }

        function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
          var s = new poly1305(k)
          s.update(m, mpos, n)
          s.finish(out, outpos)
          return 0
        }

        function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
          var x = new Uint8Array(16)
          crypto_onetimeauth(x, 0, m, mpos, n, k)
          return crypto_verify_16(h, hpos, x, 0)
        }

        function crypto_secretbox(c, m, d, n, k) {
          var i
          if (d < 32) return -1
          crypto_stream_xor(c, 0, m, 0, d, n, k)
          crypto_onetimeauth(c, 16, c, 32, d - 32, c)
          for (i = 0; i < 16; i++) c[i] = 0
          return 0
        }

        function crypto_secretbox_open(m, c, d, n, k) {
          var i
          var x = new Uint8Array(32)
          if (d < 32) return -1
          crypto_stream(x, 0, 32, n, k)
          if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
            return -1
          crypto_stream_xor(m, 0, c, 0, d, n, k)
          for (i = 0; i < 32; i++) m[i] = 0
          return 0
        }

        function set25519(r, a) {
          var i
          for (i = 0; i < 16; i++) r[i] = a[i] | 0
        }

        function car25519(o) {
          var i,
            v,
            c = 1
          for (i = 0; i < 16; i++) {
            v = o[i] + c + 65535
            c = Math.floor(v / 65536)
            o[i] = v - c * 65536
          }
          o[0] += c - 1 + 37 * (c - 1)
        }

        function sel25519(p, q, b) {
          var t,
            c = ~(b - 1)
          for (var i = 0; i < 16; i++) {
            t = c & (p[i] ^ q[i])
            p[i] ^= t
            q[i] ^= t
          }
        }

        function pack25519(o, n) {
          var i, j, b
          var m = gf(),
            t = gf()
          for (i = 0; i < 16; i++) t[i] = n[i]
          car25519(t)
          car25519(t)
          car25519(t)
          for (j = 0; j < 2; j++) {
            m[0] = t[0] - 0xffed
            for (i = 1; i < 15; i++) {
              m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1)
              m[i - 1] &= 0xffff
            }
            m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1)
            b = (m[15] >> 16) & 1
            m[14] &= 0xffff
            sel25519(t, m, 1 - b)
          }
          for (i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 0xff
            o[2 * i + 1] = t[i] >> 8
          }
        }

        function neq25519(a, b) {
          var c = new Uint8Array(32),
            d = new Uint8Array(32)
          pack25519(c, a)
          pack25519(d, b)
          return crypto_verify_32(c, 0, d, 0)
        }

        function par25519(a) {
          var d = new Uint8Array(32)
          pack25519(d, a)
          return d[0] & 1
        }

        function unpack25519(o, n) {
          var i
          for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8)
          o[15] &= 0x7fff
        }

        function A(o, a, b) {
          for (var i = 0; i < 16; i++) o[i] = a[i] + b[i]
        }

        function Z(o, a, b) {
          for (var i = 0; i < 16; i++) o[i] = a[i] - b[i]
        }

        function M(o, a, b) {
          var v,
            c,
            t0 = 0,
            t1 = 0,
            t2 = 0,
            t3 = 0,
            t4 = 0,
            t5 = 0,
            t6 = 0,
            t7 = 0,
            t8 = 0,
            t9 = 0,
            t10 = 0,
            t11 = 0,
            t12 = 0,
            t13 = 0,
            t14 = 0,
            t15 = 0,
            t16 = 0,
            t17 = 0,
            t18 = 0,
            t19 = 0,
            t20 = 0,
            t21 = 0,
            t22 = 0,
            t23 = 0,
            t24 = 0,
            t25 = 0,
            t26 = 0,
            t27 = 0,
            t28 = 0,
            t29 = 0,
            t30 = 0,
            b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3],
            b4 = b[4],
            b5 = b[5],
            b6 = b[6],
            b7 = b[7],
            b8 = b[8],
            b9 = b[9],
            b10 = b[10],
            b11 = b[11],
            b12 = b[12],
            b13 = b[13],
            b14 = b[14],
            b15 = b[15]

          v = a[0]
          t0 += v * b0
          t1 += v * b1
          t2 += v * b2
          t3 += v * b3
          t4 += v * b4
          t5 += v * b5
          t6 += v * b6
          t7 += v * b7
          t8 += v * b8
          t9 += v * b9
          t10 += v * b10
          t11 += v * b11
          t12 += v * b12
          t13 += v * b13
          t14 += v * b14
          t15 += v * b15
          v = a[1]
          t1 += v * b0
          t2 += v * b1
          t3 += v * b2
          t4 += v * b3
          t5 += v * b4
          t6 += v * b5
          t7 += v * b6
          t8 += v * b7
          t9 += v * b8
          t10 += v * b9
          t11 += v * b10
          t12 += v * b11
          t13 += v * b12
          t14 += v * b13
          t15 += v * b14
          t16 += v * b15
          v = a[2]
          t2 += v * b0
          t3 += v * b1
          t4 += v * b2
          t5 += v * b3
          t6 += v * b4
          t7 += v * b5
          t8 += v * b6
          t9 += v * b7
          t10 += v * b8
          t11 += v * b9
          t12 += v * b10
          t13 += v * b11
          t14 += v * b12
          t15 += v * b13
          t16 += v * b14
          t17 += v * b15
          v = a[3]
          t3 += v * b0
          t4 += v * b1
          t5 += v * b2
          t6 += v * b3
          t7 += v * b4
          t8 += v * b5
          t9 += v * b6
          t10 += v * b7
          t11 += v * b8
          t12 += v * b9
          t13 += v * b10
          t14 += v * b11
          t15 += v * b12
          t16 += v * b13
          t17 += v * b14
          t18 += v * b15
          v = a[4]
          t4 += v * b0
          t5 += v * b1
          t6 += v * b2
          t7 += v * b3
          t8 += v * b4
          t9 += v * b5
          t10 += v * b6
          t11 += v * b7
          t12 += v * b8
          t13 += v * b9
          t14 += v * b10
          t15 += v * b11
          t16 += v * b12
          t17 += v * b13
          t18 += v * b14
          t19 += v * b15
          v = a[5]
          t5 += v * b0
          t6 += v * b1
          t7 += v * b2
          t8 += v * b3
          t9 += v * b4
          t10 += v * b5
          t11 += v * b6
          t12 += v * b7
          t13 += v * b8
          t14 += v * b9
          t15 += v * b10
          t16 += v * b11
          t17 += v * b12
          t18 += v * b13
          t19 += v * b14
          t20 += v * b15
          v = a[6]
          t6 += v * b0
          t7 += v * b1
          t8 += v * b2
          t9 += v * b3
          t10 += v * b4
          t11 += v * b5
          t12 += v * b6
          t13 += v * b7
          t14 += v * b8
          t15 += v * b9
          t16 += v * b10
          t17 += v * b11
          t18 += v * b12
          t19 += v * b13
          t20 += v * b14
          t21 += v * b15
          v = a[7]
          t7 += v * b0
          t8 += v * b1
          t9 += v * b2
          t10 += v * b3
          t11 += v * b4
          t12 += v * b5
          t13 += v * b6
          t14 += v * b7
          t15 += v * b8
          t16 += v * b9
          t17 += v * b10
          t18 += v * b11
          t19 += v * b12
          t20 += v * b13
          t21 += v * b14
          t22 += v * b15
          v = a[8]
          t8 += v * b0
          t9 += v * b1
          t10 += v * b2
          t11 += v * b3
          t12 += v * b4
          t13 += v * b5
          t14 += v * b6
          t15 += v * b7
          t16 += v * b8
          t17 += v * b9
          t18 += v * b10
          t19 += v * b11
          t20 += v * b12
          t21 += v * b13
          t22 += v * b14
          t23 += v * b15
          v = a[9]
          t9 += v * b0
          t10 += v * b1
          t11 += v * b2
          t12 += v * b3
          t13 += v * b4
          t14 += v * b5
          t15 += v * b6
          t16 += v * b7
          t17 += v * b8
          t18 += v * b9
          t19 += v * b10
          t20 += v * b11
          t21 += v * b12
          t22 += v * b13
          t23 += v * b14
          t24 += v * b15
          v = a[10]
          t10 += v * b0
          t11 += v * b1
          t12 += v * b2
          t13 += v * b3
          t14 += v * b4
          t15 += v * b5
          t16 += v * b6
          t17 += v * b7
          t18 += v * b8
          t19 += v * b9
          t20 += v * b10
          t21 += v * b11
          t22 += v * b12
          t23 += v * b13
          t24 += v * b14
          t25 += v * b15
          v = a[11]
          t11 += v * b0
          t12 += v * b1
          t13 += v * b2
          t14 += v * b3
          t15 += v * b4
          t16 += v * b5
          t17 += v * b6
          t18 += v * b7
          t19 += v * b8
          t20 += v * b9
          t21 += v * b10
          t22 += v * b11
          t23 += v * b12
          t24 += v * b13
          t25 += v * b14
          t26 += v * b15
          v = a[12]
          t12 += v * b0
          t13 += v * b1
          t14 += v * b2
          t15 += v * b3
          t16 += v * b4
          t17 += v * b5
          t18 += v * b6
          t19 += v * b7
          t20 += v * b8
          t21 += v * b9
          t22 += v * b10
          t23 += v * b11
          t24 += v * b12
          t25 += v * b13
          t26 += v * b14
          t27 += v * b15
          v = a[13]
          t13 += v * b0
          t14 += v * b1
          t15 += v * b2
          t16 += v * b3
          t17 += v * b4
          t18 += v * b5
          t19 += v * b6
          t20 += v * b7
          t21 += v * b8
          t22 += v * b9
          t23 += v * b10
          t24 += v * b11
          t25 += v * b12
          t26 += v * b13
          t27 += v * b14
          t28 += v * b15
          v = a[14]
          t14 += v * b0
          t15 += v * b1
          t16 += v * b2
          t17 += v * b3
          t18 += v * b4
          t19 += v * b5
          t20 += v * b6
          t21 += v * b7
          t22 += v * b8
          t23 += v * b9
          t24 += v * b10
          t25 += v * b11
          t26 += v * b12
          t27 += v * b13
          t28 += v * b14
          t29 += v * b15
          v = a[15]
          t15 += v * b0
          t16 += v * b1
          t17 += v * b2
          t18 += v * b3
          t19 += v * b4
          t20 += v * b5
          t21 += v * b6
          t22 += v * b7
          t23 += v * b8
          t24 += v * b9
          t25 += v * b10
          t26 += v * b11
          t27 += v * b12
          t28 += v * b13
          t29 += v * b14
          t30 += v * b15

          t0 += 38 * t16
          t1 += 38 * t17
          t2 += 38 * t18
          t3 += 38 * t19
          t4 += 38 * t20
          t5 += 38 * t21
          t6 += 38 * t22
          t7 += 38 * t23
          t8 += 38 * t24
          t9 += 38 * t25
          t10 += 38 * t26
          t11 += 38 * t27
          t12 += 38 * t28
          t13 += 38 * t29
          t14 += 38 * t30
          // t15 left as is

          // first car
          c = 1
          v = t0 + c + 65535
          c = Math.floor(v / 65536)
          t0 = v - c * 65536
          v = t1 + c + 65535
          c = Math.floor(v / 65536)
          t1 = v - c * 65536
          v = t2 + c + 65535
          c = Math.floor(v / 65536)
          t2 = v - c * 65536
          v = t3 + c + 65535
          c = Math.floor(v / 65536)
          t3 = v - c * 65536
          v = t4 + c + 65535
          c = Math.floor(v / 65536)
          t4 = v - c * 65536
          v = t5 + c + 65535
          c = Math.floor(v / 65536)
          t5 = v - c * 65536
          v = t6 + c + 65535
          c = Math.floor(v / 65536)
          t6 = v - c * 65536
          v = t7 + c + 65535
          c = Math.floor(v / 65536)
          t7 = v - c * 65536
          v = t8 + c + 65535
          c = Math.floor(v / 65536)
          t8 = v - c * 65536
          v = t9 + c + 65535
          c = Math.floor(v / 65536)
          t9 = v - c * 65536
          v = t10 + c + 65535
          c = Math.floor(v / 65536)
          t10 = v - c * 65536
          v = t11 + c + 65535
          c = Math.floor(v / 65536)
          t11 = v - c * 65536
          v = t12 + c + 65535
          c = Math.floor(v / 65536)
          t12 = v - c * 65536
          v = t13 + c + 65535
          c = Math.floor(v / 65536)
          t13 = v - c * 65536
          v = t14 + c + 65535
          c = Math.floor(v / 65536)
          t14 = v - c * 65536
          v = t15 + c + 65535
          c = Math.floor(v / 65536)
          t15 = v - c * 65536
          t0 += c - 1 + 37 * (c - 1)

          // second car
          c = 1
          v = t0 + c + 65535
          c = Math.floor(v / 65536)
          t0 = v - c * 65536
          v = t1 + c + 65535
          c = Math.floor(v / 65536)
          t1 = v - c * 65536
          v = t2 + c + 65535
          c = Math.floor(v / 65536)
          t2 = v - c * 65536
          v = t3 + c + 65535
          c = Math.floor(v / 65536)
          t3 = v - c * 65536
          v = t4 + c + 65535
          c = Math.floor(v / 65536)
          t4 = v - c * 65536
          v = t5 + c + 65535
          c = Math.floor(v / 65536)
          t5 = v - c * 65536
          v = t6 + c + 65535
          c = Math.floor(v / 65536)
          t6 = v - c * 65536
          v = t7 + c + 65535
          c = Math.floor(v / 65536)
          t7 = v - c * 65536
          v = t8 + c + 65535
          c = Math.floor(v / 65536)
          t8 = v - c * 65536
          v = t9 + c + 65535
          c = Math.floor(v / 65536)
          t9 = v - c * 65536
          v = t10 + c + 65535
          c = Math.floor(v / 65536)
          t10 = v - c * 65536
          v = t11 + c + 65535
          c = Math.floor(v / 65536)
          t11 = v - c * 65536
          v = t12 + c + 65535
          c = Math.floor(v / 65536)
          t12 = v - c * 65536
          v = t13 + c + 65535
          c = Math.floor(v / 65536)
          t13 = v - c * 65536
          v = t14 + c + 65535
          c = Math.floor(v / 65536)
          t14 = v - c * 65536
          v = t15 + c + 65535
          c = Math.floor(v / 65536)
          t15 = v - c * 65536
          t0 += c - 1 + 37 * (c - 1)

          o[0] = t0
          o[1] = t1
          o[2] = t2
          o[3] = t3
          o[4] = t4
          o[5] = t5
          o[6] = t6
          o[7] = t7
          o[8] = t8
          o[9] = t9
          o[10] = t10
          o[11] = t11
          o[12] = t12
          o[13] = t13
          o[14] = t14
          o[15] = t15
        }

        function S(o, a) {
          M(o, a, a)
        }

        function inv25519(o, i) {
          var c = gf()
          var a
          for (a = 0; a < 16; a++) c[a] = i[a]
          for (a = 253; a >= 0; a--) {
            S(c, c)
            if (a !== 2 && a !== 4) M(c, c, i)
          }
          for (a = 0; a < 16; a++) o[a] = c[a]
        }

        function pow2523(o, i) {
          var c = gf()
          var a
          for (a = 0; a < 16; a++) c[a] = i[a]
          for (a = 250; a >= 0; a--) {
            S(c, c)
            if (a !== 1) M(c, c, i)
          }
          for (a = 0; a < 16; a++) o[a] = c[a]
        }

        function crypto_scalarmult(q, n, p) {
          check(q, crypto_scalarmult_BYTES)
          check(n, crypto_scalarmult_SCALARBYTES)
          check(p, crypto_scalarmult_BYTES)
          var z = new Uint8Array(32)
          var x = new Float64Array(80),
            r,
            i
          var a = gf(),
            b = gf(),
            c = gf(),
            d = gf(),
            e = gf(),
            f = gf()
          for (i = 0; i < 31; i++) z[i] = n[i]
          z[31] = (n[31] & 127) | 64
          z[0] &= 248
          unpack25519(x, p)
          for (i = 0; i < 16; i++) {
            b[i] = x[i]
            d[i] = a[i] = c[i] = 0
          }
          a[0] = d[0] = 1
          for (i = 254; i >= 0; --i) {
            r = (z[i >>> 3] >>> (i & 7)) & 1
            sel25519(a, b, r)
            sel25519(c, d, r)
            A(e, a, c)
            Z(a, a, c)
            A(c, b, d)
            Z(b, b, d)
            S(d, e)
            S(f, a)
            M(a, c, a)
            M(c, b, e)
            A(e, a, c)
            Z(a, a, c)
            S(b, a)
            Z(c, d, f)
            M(a, c, _121665)
            A(a, a, d)
            M(c, c, a)
            M(a, d, f)
            M(d, b, x)
            S(b, e)
            sel25519(a, b, r)
            sel25519(c, d, r)
          }
          for (i = 0; i < 16; i++) {
            x[i + 16] = a[i]
            x[i + 32] = c[i]
            x[i + 48] = b[i]
            x[i + 64] = d[i]
          }
          var x32 = x.subarray(32)
          var x16 = x.subarray(16)
          inv25519(x32, x32)
          M(x16, x16, x32)
          pack25519(q, x16)
          return 0
        }

        function crypto_scalarmult_base(q, n) {
          return crypto_scalarmult(q, n, _9)
        }

        var K = [
          0x428a2f98,
          0xd728ae22,
          0x71374491,
          0x23ef65cd,
          0xb5c0fbcf,
          0xec4d3b2f,
          0xe9b5dba5,
          0x8189dbbc,
          0x3956c25b,
          0xf348b538,
          0x59f111f1,
          0xb605d019,
          0x923f82a4,
          0xaf194f9b,
          0xab1c5ed5,
          0xda6d8118,
          0xd807aa98,
          0xa3030242,
          0x12835b01,
          0x45706fbe,
          0x243185be,
          0x4ee4b28c,
          0x550c7dc3,
          0xd5ffb4e2,
          0x72be5d74,
          0xf27b896f,
          0x80deb1fe,
          0x3b1696b1,
          0x9bdc06a7,
          0x25c71235,
          0xc19bf174,
          0xcf692694,
          0xe49b69c1,
          0x9ef14ad2,
          0xefbe4786,
          0x384f25e3,
          0x0fc19dc6,
          0x8b8cd5b5,
          0x240ca1cc,
          0x77ac9c65,
          0x2de92c6f,
          0x592b0275,
          0x4a7484aa,
          0x6ea6e483,
          0x5cb0a9dc,
          0xbd41fbd4,
          0x76f988da,
          0x831153b5,
          0x983e5152,
          0xee66dfab,
          0xa831c66d,
          0x2db43210,
          0xb00327c8,
          0x98fb213f,
          0xbf597fc7,
          0xbeef0ee4,
          0xc6e00bf3,
          0x3da88fc2,
          0xd5a79147,
          0x930aa725,
          0x06ca6351,
          0xe003826f,
          0x14292967,
          0x0a0e6e70,
          0x27b70a85,
          0x46d22ffc,
          0x2e1b2138,
          0x5c26c926,
          0x4d2c6dfc,
          0x5ac42aed,
          0x53380d13,
          0x9d95b3df,
          0x650a7354,
          0x8baf63de,
          0x766a0abb,
          0x3c77b2a8,
          0x81c2c92e,
          0x47edaee6,
          0x92722c85,
          0x1482353b,
          0xa2bfe8a1,
          0x4cf10364,
          0xa81a664b,
          0xbc423001,
          0xc24b8b70,
          0xd0f89791,
          0xc76c51a3,
          0x0654be30,
          0xd192e819,
          0xd6ef5218,
          0xd6990624,
          0x5565a910,
          0xf40e3585,
          0x5771202a,
          0x106aa070,
          0x32bbd1b8,
          0x19a4c116,
          0xb8d2d0c8,
          0x1e376c08,
          0x5141ab53,
          0x2748774c,
          0xdf8eeb99,
          0x34b0bcb5,
          0xe19b48a8,
          0x391c0cb3,
          0xc5c95a63,
          0x4ed8aa4a,
          0xe3418acb,
          0x5b9cca4f,
          0x7763e373,
          0x682e6ff3,
          0xd6b2b8a3,
          0x748f82ee,
          0x5defb2fc,
          0x78a5636f,
          0x43172f60,
          0x84c87814,
          0xa1f0ab72,
          0x8cc70208,
          0x1a6439ec,
          0x90befffa,
          0x23631e28,
          0xa4506ceb,
          0xde82bde9,
          0xbef9a3f7,
          0xb2c67915,
          0xc67178f2,
          0xe372532b,
          0xca273ece,
          0xea26619c,
          0xd186b8c7,
          0x21c0c207,
          0xeada7dd6,
          0xcde0eb1e,
          0xf57d4f7f,
          0xee6ed178,
          0x06f067aa,
          0x72176fba,
          0x0a637dc5,
          0xa2c898a6,
          0x113f9804,
          0xbef90dae,
          0x1b710b35,
          0x131c471b,
          0x28db77f5,
          0x23047d84,
          0x32caab7b,
          0x40c72493,
          0x3c9ebe0a,
          0x15c9bebc,
          0x431d67c4,
          0x9c100d4c,
          0x4cc5d4be,
          0xcb3e42b6,
          0x597f299c,
          0xfc657e2a,
          0x5fcb6fab,
          0x3ad6faec,
          0x6c44198c,
          0x4a475817
        ]

        function crypto_hashblocks_hl(hh, hl, m, n) {
          var wh = new Int32Array(16),
            wl = new Int32Array(16),
            bh0,
            bh1,
            bh2,
            bh3,
            bh4,
            bh5,
            bh6,
            bh7,
            bl0,
            bl1,
            bl2,
            bl3,
            bl4,
            bl5,
            bl6,
            bl7,
            th,
            tl,
            i,
            j,
            h,
            l,
            a,
            b,
            c,
            d

          var ah0 = hh[0],
            ah1 = hh[1],
            ah2 = hh[2],
            ah3 = hh[3],
            ah4 = hh[4],
            ah5 = hh[5],
            ah6 = hh[6],
            ah7 = hh[7],
            al0 = hl[0],
            al1 = hl[1],
            al2 = hl[2],
            al3 = hl[3],
            al4 = hl[4],
            al5 = hl[5],
            al6 = hl[6],
            al7 = hl[7]

          var pos = 0
          while (n >= 128) {
            for (i = 0; i < 16; i++) {
              j = 8 * i + pos
              wh[i] =
                (m[j + 0] << 24) | (m[j + 1] << 16) | (m[j + 2] << 8) | m[j + 3]
              wl[i] =
                (m[j + 4] << 24) | (m[j + 5] << 16) | (m[j + 6] << 8) | m[j + 7]
            }
            for (i = 0; i < 80; i++) {
              bh0 = ah0
              bh1 = ah1
              bh2 = ah2
              bh3 = ah3
              bh4 = ah4
              bh5 = ah5
              bh6 = ah6
              bh7 = ah7

              bl0 = al0
              bl1 = al1
              bl2 = al2
              bl3 = al3
              bl4 = al4
              bl5 = al5
              bl6 = al6
              bl7 = al7

              // add
              h = ah7
              l = al7

              a = l & 0xffff
              b = l >>> 16
              c = h & 0xffff
              d = h >>> 16

              // Sigma1
              h =
                ((ah4 >>> 14) | (al4 << (32 - 14))) ^
                ((ah4 >>> 18) | (al4 << (32 - 18))) ^
                ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))))
              l =
                ((al4 >>> 14) | (ah4 << (32 - 14))) ^
                ((al4 >>> 18) | (ah4 << (32 - 18))) ^
                ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))))

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // Ch
              h = (ah4 & ah5) ^ (~ah4 & ah6)
              l = (al4 & al5) ^ (~al4 & al6)

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // K
              h = K[i * 2]
              l = K[i * 2 + 1]

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // w
              h = wh[i % 16]
              l = wl[i % 16]

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              b += a >>> 16
              c += b >>> 16
              d += c >>> 16

              th = (c & 0xffff) | (d << 16)
              tl = (a & 0xffff) | (b << 16)

              // add
              h = th
              l = tl

              a = l & 0xffff
              b = l >>> 16
              c = h & 0xffff
              d = h >>> 16

              // Sigma0
              h =
                ((ah0 >>> 28) | (al0 << (32 - 28))) ^
                ((al0 >>> (34 - 32)) | (ah0 << (32 - (34 - 32)))) ^
                ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))))
              l =
                ((al0 >>> 28) | (ah0 << (32 - 28))) ^
                ((ah0 >>> (34 - 32)) | (al0 << (32 - (34 - 32)))) ^
                ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))))

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // Maj
              h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2)
              l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2)

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              b += a >>> 16
              c += b >>> 16
              d += c >>> 16

              bh7 = (c & 0xffff) | (d << 16)
              bl7 = (a & 0xffff) | (b << 16)

              // add
              h = bh3
              l = bl3

              a = l & 0xffff
              b = l >>> 16
              c = h & 0xffff
              d = h >>> 16

              h = th
              l = tl

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              b += a >>> 16
              c += b >>> 16
              d += c >>> 16

              bh3 = (c & 0xffff) | (d << 16)
              bl3 = (a & 0xffff) | (b << 16)

              ah1 = bh0
              ah2 = bh1
              ah3 = bh2
              ah4 = bh3
              ah5 = bh4
              ah6 = bh5
              ah7 = bh6
              ah0 = bh7

              al1 = bl0
              al2 = bl1
              al3 = bl2
              al4 = bl3
              al5 = bl4
              al6 = bl5
              al7 = bl6
              al0 = bl7

              if (i % 16 === 15) {
                for (j = 0; j < 16; j++) {
                  // add
                  h = wh[j]
                  l = wl[j]

                  a = l & 0xffff
                  b = l >>> 16
                  c = h & 0xffff
                  d = h >>> 16

                  h = wh[(j + 9) % 16]
                  l = wl[(j + 9) % 16]

                  a += l & 0xffff
                  b += l >>> 16
                  c += h & 0xffff
                  d += h >>> 16

                  // sigma0
                  th = wh[(j + 1) % 16]
                  tl = wl[(j + 1) % 16]
                  h =
                    ((th >>> 1) | (tl << (32 - 1))) ^
                    ((th >>> 8) | (tl << (32 - 8))) ^
                    (th >>> 7)
                  l =
                    ((tl >>> 1) | (th << (32 - 1))) ^
                    ((tl >>> 8) | (th << (32 - 8))) ^
                    ((tl >>> 7) | (th << (32 - 7)))

                  a += l & 0xffff
                  b += l >>> 16
                  c += h & 0xffff
                  d += h >>> 16

                  // sigma1
                  th = wh[(j + 14) % 16]
                  tl = wl[(j + 14) % 16]
                  h =
                    ((th >>> 19) | (tl << (32 - 19))) ^
                    ((tl >>> (61 - 32)) | (th << (32 - (61 - 32)))) ^
                    (th >>> 6)
                  l =
                    ((tl >>> 19) | (th << (32 - 19))) ^
                    ((th >>> (61 - 32)) | (tl << (32 - (61 - 32)))) ^
                    ((tl >>> 6) | (th << (32 - 6)))

                  a += l & 0xffff
                  b += l >>> 16
                  c += h & 0xffff
                  d += h >>> 16

                  b += a >>> 16
                  c += b >>> 16
                  d += c >>> 16

                  wh[j] = (c & 0xffff) | (d << 16)
                  wl[j] = (a & 0xffff) | (b << 16)
                }
              }
            }

            // add
            h = ah0
            l = al0

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[0]
            l = hl[0]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[0] = ah0 = (c & 0xffff) | (d << 16)
            hl[0] = al0 = (a & 0xffff) | (b << 16)

            h = ah1
            l = al1

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[1]
            l = hl[1]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[1] = ah1 = (c & 0xffff) | (d << 16)
            hl[1] = al1 = (a & 0xffff) | (b << 16)

            h = ah2
            l = al2

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[2]
            l = hl[2]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[2] = ah2 = (c & 0xffff) | (d << 16)
            hl[2] = al2 = (a & 0xffff) | (b << 16)

            h = ah3
            l = al3

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[3]
            l = hl[3]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[3] = ah3 = (c & 0xffff) | (d << 16)
            hl[3] = al3 = (a & 0xffff) | (b << 16)

            h = ah4
            l = al4

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[4]
            l = hl[4]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[4] = ah4 = (c & 0xffff) | (d << 16)
            hl[4] = al4 = (a & 0xffff) | (b << 16)

            h = ah5
            l = al5

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[5]
            l = hl[5]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[5] = ah5 = (c & 0xffff) | (d << 16)
            hl[5] = al5 = (a & 0xffff) | (b << 16)

            h = ah6
            l = al6

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[6]
            l = hl[6]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[6] = ah6 = (c & 0xffff) | (d << 16)
            hl[6] = al6 = (a & 0xffff) | (b << 16)

            h = ah7
            l = al7

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[7]
            l = hl[7]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[7] = ah7 = (c & 0xffff) | (d << 16)
            hl[7] = al7 = (a & 0xffff) | (b << 16)

            pos += 128
            n -= 128
          }

          return n
        }

        function crypto_hash(out, m, n) {
          var hh = new Int32Array(8),
            hl = new Int32Array(8),
            x = new Uint8Array(256),
            i,
            b = n

          hh[0] = 0x6a09e667
          hh[1] = 0xbb67ae85
          hh[2] = 0x3c6ef372
          hh[3] = 0xa54ff53a
          hh[4] = 0x510e527f
          hh[5] = 0x9b05688c
          hh[6] = 0x1f83d9ab
          hh[7] = 0x5be0cd19

          hl[0] = 0xf3bcc908
          hl[1] = 0x84caa73b
          hl[2] = 0xfe94f82b
          hl[3] = 0x5f1d36f1
          hl[4] = 0xade682d1
          hl[5] = 0x2b3e6c1f
          hl[6] = 0xfb41bd6b
          hl[7] = 0x137e2179

          crypto_hashblocks_hl(hh, hl, m, n)
          n %= 128

          for (i = 0; i < n; i++) x[i] = m[b - n + i]
          x[n] = 128

          n = 256 - 128 * (n < 112 ? 1 : 0)
          x[n - 9] = 0
          ts64(x, n - 8, (b / 0x20000000) | 0, b << 3)
          crypto_hashblocks_hl(hh, hl, x, n)

          for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i])

          return 0
        }

        function add(p, q) {
          var a = gf(),
            b = gf(),
            c = gf(),
            d = gf(),
            e = gf(),
            f = gf(),
            g = gf(),
            h = gf(),
            t = gf()

          Z(a, p[1], p[0])
          Z(t, q[1], q[0])
          M(a, a, t)
          A(b, p[0], p[1])
          A(t, q[0], q[1])
          M(b, b, t)
          M(c, p[3], q[3])
          M(c, c, D2)
          M(d, p[2], q[2])
          A(d, d, d)
          Z(e, b, a)
          Z(f, d, c)
          A(g, d, c)
          A(h, b, a)

          M(p[0], e, f)
          M(p[1], h, g)
          M(p[2], g, f)
          M(p[3], e, h)
        }

        function cswap(p, q, b) {
          var i
          for (i = 0; i < 4; i++) {
            sel25519(p[i], q[i], b)
          }
        }

        function pack(r, p) {
          var tx = gf(),
            ty = gf(),
            zi = gf()
          inv25519(zi, p[2])
          M(tx, p[0], zi)
          M(ty, p[1], zi)
          pack25519(r, ty)
          r[31] ^= par25519(tx) << 7
        }

        function scalarmult(p, q, s) {
          var b, i
          set25519(p[0], gf0)
          set25519(p[1], gf1)
          set25519(p[2], gf1)
          set25519(p[3], gf0)
          for (i = 255; i >= 0; --i) {
            b = (s[(i / 8) | 0] >> (i & 7)) & 1
            cswap(p, q, b)
            add(q, p)
            add(p, p)
            cswap(p, q, b)
          }
        }

        function scalarbase(p, s) {
          var q = [gf(), gf(), gf(), gf()]
          set25519(q[0], X)
          set25519(q[1], Y)
          set25519(q[2], gf1)
          M(q[3], X, Y)
          scalarmult(p, q, s)
        }

        function crypto_sign_keypair(pk, sk, seeded) {
          check(pk, sodium.crypto_sign_PUBLICKEYBYTES)
          check(sk, sodium.crypto_sign_SECRETKEYBYTES)

          var d = new Uint8Array(64)
          var p = [gf(), gf(), gf(), gf()]
          var i

          if (!seeded) randombytes(sk, 32)
          crypto_hash(d, sk, 32)
          d[0] &= 248
          d[31] &= 127
          d[31] |= 64

          scalarbase(p, d)
          pack(pk, p)

          for (i = 0; i < 32; i++) sk[i + 32] = pk[i]
          return 0
        }

        function crypto_sign_seed_keypair(pk, sk, seed) {
          check(seed, sodium.crypto_sign_SEEDBYTES)
          seed.copy(sk)
          crypto_sign_keypair(pk, sk, true)
        }

        var L = new Float64Array([
          0xed,
          0xd3,
          0xf5,
          0x5c,
          0x1a,
          0x63,
          0x12,
          0x58,
          0xd6,
          0x9c,
          0xf7,
          0xa2,
          0xde,
          0xf9,
          0xde,
          0x14,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0x10
        ])

        function modL(r, x) {
          var carry, i, j, k
          for (i = 63; i >= 32; --i) {
            carry = 0
            for (j = i - 32, k = i - 12; j < k; ++j) {
              x[j] += carry - 16 * x[i] * L[j - (i - 32)]
              carry = (x[j] + 128) >> 8
              x[j] -= carry * 256
            }
            x[j] += carry
            x[i] = 0
          }
          carry = 0
          for (j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j]
            carry = x[j] >> 8
            x[j] &= 255
          }
          for (j = 0; j < 32; j++) x[j] -= carry * L[j]
          for (i = 0; i < 32; i++) {
            x[i + 1] += x[i] >> 8
            r[i] = x[i] & 255
          }
        }

        function reduce(r) {
          var x = new Float64Array(64),
            i
          for (i = 0; i < 64; i++) x[i] = r[i]
          for (i = 0; i < 64; i++) r[i] = 0
          modL(r, x)
        }

        // Note: difference from C - smlen returned, not passed as argument.
        function crypto_sign(sm, m, sk) {
          check(sm, crypto_sign_BYTES + m.length)
          check(m, 0)
          check(sk, crypto_sign_SECRETKEYBYTES)
          var n = m.length

          var d = new Uint8Array(64),
            h = new Uint8Array(64),
            r = new Uint8Array(64)
          var i,
            j,
            x = new Float64Array(64)
          var p = [gf(), gf(), gf(), gf()]

          crypto_hash(d, sk, 32)
          d[0] &= 248
          d[31] &= 127
          d[31] |= 64

          var smlen = n + 64
          for (i = 0; i < n; i++) sm[64 + i] = m[i]
          for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i]

          crypto_hash(r, sm.subarray(32), n + 32)
          reduce(r)
          scalarbase(p, r)
          pack(sm, p)

          for (i = 32; i < 64; i++) sm[i] = sk[i]
          crypto_hash(h, sm, n + 64)
          reduce(h)

          for (i = 0; i < 64; i++) x[i] = 0
          for (i = 0; i < 32; i++) x[i] = r[i]
          for (i = 0; i < 32; i++) {
            for (j = 0; j < 32; j++) {
              x[i + j] += h[i] * d[j]
            }
          }

          modL(sm.subarray(32), x)
        }

        function crypto_sign_detached(sig, m, sk) {
          var sm = new Uint8Array(m.length + crypto_sign_BYTES)
          crypto_sign(sm, m, sk)
          for (var i = 0; i < crypto_sign_BYTES; i++) sig[i] = sm[i]
        }

        function unpackneg(r, p) {
          var t = gf(),
            chk = gf(),
            num = gf(),
            den = gf(),
            den2 = gf(),
            den4 = gf(),
            den6 = gf()

          set25519(r[2], gf1)
          unpack25519(r[1], p)
          S(num, r[1])
          M(den, num, D)
          Z(num, num, r[2])
          A(den, r[2], den)

          S(den2, den)
          S(den4, den2)
          M(den6, den4, den2)
          M(t, den6, num)
          M(t, t, den)

          pow2523(t, t)
          M(t, t, num)
          M(t, t, den)
          M(t, t, den)
          M(r[0], t, den)

          S(chk, r[0])
          M(chk, chk, den)
          if (neq25519(chk, num)) M(r[0], r[0], I)

          S(chk, r[0])
          M(chk, chk, den)
          if (neq25519(chk, num)) return -1

          if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0])

          M(r[3], r[0], r[1])
          return 0
        }

        function crypto_sign_open(msg, sm, pk) {
          check(msg, sm.length - crypto_sign_BYTES)
          check(sm, crypto_sign_BYTES)
          check(pk, crypto_sign_PUBLICKEYBYTES)
          var n = sm.length
          var m = new Uint8Array(sm.length)

          var i, mlen
          var t = new Uint8Array(32),
            h = new Uint8Array(64)
          var p = [gf(), gf(), gf(), gf()],
            q = [gf(), gf(), gf(), gf()]

          mlen = -1
          if (n < 64) return false

          if (unpackneg(q, pk)) return false

          for (i = 0; i < n; i++) m[i] = sm[i]
          for (i = 0; i < 32; i++) m[i + 32] = pk[i]
          crypto_hash(h, m, n)
          reduce(h)
          scalarmult(p, q, h)

          scalarbase(q, sm.subarray(32))
          add(p, q)
          pack(t, p)

          n -= 64
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i = 0; i < n; i++) m[i] = 0
            return false
          }

          for (i = 0; i < n; i++) msg[i] = sm[i + 64]
          mlen = n
          return true
        }

        function crypto_sign_verify_detached(sig, m, pk) {
          check(sig, crypto_sign_BYTES)
          var sm = new Uint8Array(m.length + crypto_sign_BYTES)
          var i = 0
          for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i]
          for (i = 0; i < m.length; i++) sm[i + crypto_sign_BYTES] = m[i]
          return crypto_sign_open(m, sm, pk)
        }

        function crypto_secretbox_detached(o, mac, msg, n, k) {
          check(mac, sodium.crypto_secretbox_MACBYTES)
          var tmp = new Uint8Array(msg.length + mac.length)
          crypto_secretbox_easy(tmp, msg, n, k)
          o.set(tmp.subarray(0, msg.length))
          mac.set(tmp.subarray(msg.length))
        }

        function crypto_secretbox_open_detached(msg, o, mac, n, k) {
          check(mac, sodium.crypto_secretbox_MACBYTES)
          var tmp = new Uint8Array(o.length + mac.length)
          tmp.set(o)
          tmp.set(mac, msg.length)
          return crypto_secretbox_open_easy(msg, tmp, n, k)
        }

        function crypto_secretbox_easy(o, msg, n, k) {
          check(msg, 0)
          check(o, msg.length + sodium.crypto_secretbox_MACBYTES)
          check(n, crypto_secretbox_NONCEBYTES)
          check(k, crypto_secretbox_KEYBYTES)

          var i
          var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length)
          var c = new Uint8Array(m.length)
          for (i = 0; i < msg.length; i++)
            m[i + crypto_secretbox_ZEROBYTES] = msg[i]
          crypto_secretbox(c, m, m.length, n, k)
          for (i = crypto_secretbox_BOXZEROBYTES; i < c.length; i++)
            o[i - crypto_secretbox_BOXZEROBYTES] = c[i]
        }

        function crypto_secretbox_open_easy(msg, box, n, k) {
          check(box, sodium.crypto_secretbox_MACBYTES)
          check(msg, box.length - sodium.crypto_secretbox_MACBYTES)
          check(n, crypto_secretbox_NONCEBYTES)
          check(k, crypto_secretbox_KEYBYTES)

          var i
          var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length)
          var m = new Uint8Array(c.length)
          for (i = 0; i < box.length; i++)
            c[i + crypto_secretbox_BOXZEROBYTES] = box[i]
          if (c.length < 32) return false
          if (crypto_secretbox_open(m, c, c.length, n, k) !== 0) return false

          for (i = crypto_secretbox_ZEROBYTES; i < m.length; i++)
            msg[i - crypto_secretbox_ZEROBYTES] = m[i]
          return true
        }

        var crypto_secretbox_KEYBYTES = 32,
          crypto_secretbox_NONCEBYTES = 24,
          crypto_secretbox_ZEROBYTES = 32,
          crypto_secretbox_BOXZEROBYTES = 16,
          crypto_scalarmult_BYTES = 32,
          crypto_scalarmult_SCALARBYTES = 32,
          crypto_box_PUBLICKEYBYTES = 32,
          crypto_box_SECRETKEYBYTES = 32,
          crypto_box_BEFORENMBYTES = 32,
          crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
          crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
          crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
          crypto_sign_BYTES = 64,
          crypto_sign_PUBLICKEYBYTES = 32,
          crypto_sign_SECRETKEYBYTES = 64,
          crypto_sign_SEEDBYTES = 32,
          crypto_hash_BYTES = 64

        sodium.memzero = function(len, offset) {
          for (var i = offset; i < len; i++) arr[i] = 0
        }

        sodium.crypto_sign_BYTES = crypto_sign_BYTES
        sodium.crypto_sign_PUBLICKEYBYTES = crypto_sign_PUBLICKEYBYTES
        sodium.crypto_sign_SECRETKEYBYTES = crypto_sign_SECRETKEYBYTES
        sodium.crypto_sign_SEEDBYTES = crypto_sign_SEEDBYTES
        sodium.crypto_sign_keypair = crypto_sign_keypair
        sodium.crypto_sign_seed_keypair = crypto_sign_seed_keypair
        sodium.crypto_sign = crypto_sign
        sodium.crypto_sign_open = crypto_sign_open
        sodium.crypto_sign_detached = crypto_sign_detached
        sodium.crypto_sign_verify_detached = crypto_sign_verify_detached

        forward(require("./crypto_generichash"))
        forward(require("./crypto_kdf"))
        forward(require("./crypto_shorthash"))
        forward(require("./randombytes"))
        forward(require("./crypto_stream"))

        sodium.crypto_scalarmult_BYTES = crypto_scalarmult_BYTES
        sodium.crypto_scalarmult_SCALARBYTES = crypto_scalarmult_SCALARBYTES
        sodium.crypto_scalarmult_base = crypto_scalarmult_base
        sodium.crypto_scalarmult = crypto_scalarmult

        ;(sodium.crypto_secretbox_KEYBYTES = crypto_secretbox_KEYBYTES),
          (sodium.crypto_secretbox_NONCEBYTES = crypto_secretbox_NONCEBYTES),
          (sodium.crypto_secretbox_MACBYTES = 16)
        sodium.crypto_secretbox_easy = crypto_secretbox_easy
        sodium.crypto_secretbox_open_easy = crypto_secretbox_open_easy
        sodium.crypto_secretbox_detached = crypto_secretbox_detached
        sodium.crypto_secretbox_open_detached = crypto_secretbox_open_detached

        function cleanup(arr) {
          for (var i = 0; i < arr.length; i++) arr[i] = 0
        }

        function check(buf, len) {
          if (!buf || (len && buf.length < len))
            throw new Error(
              "Argument must be a buffer" + (len ? " of length " + len : "")
            )
        }

        function forward(submodule) {
          Object.keys(submodule).forEach(function(prop) {
            module.exports[prop] = submodule[prop]
          })
        }
      },
      {
        "./crypto_generichash": 64,
        "./crypto_kdf": 65,
        "./crypto_shorthash": 66,
        "./crypto_stream": 67,
        "./randombytes": 69
      }
    ],
    69: [
      function(require, module, exports) {
        ;(function(global) {
          var assert = require("nanoassert")
          var randombytes = (function() {
            var QUOTA = 65536 // limit for QuotaExceededException
            var crypto =
              typeof global !== "undefined"
                ? (crypto = global.crypto || global.msCrypto)
                : null

            function browserBytes(out, n) {
              for (var i = 0; i < n; i += QUOTA) {
                crypto.getRandomValues(
                  out.subarray(i, i + Math.min(n - i, QUOTA))
                )
              }
            }

            function nodeBytes(out, n) {
              out.set(crypto.randomBytes(n))
            }

            function noImpl() {
              throw new Error("No secure random number generator available")
            }

            if (crypto && crypto.getRandomValues) {
              return browserBytes
            } else if (typeof require !== "undefined") {
              // Node.js.
              crypto = require("crypto")
              if (crypto && crypto.randomBytes) {
                return nodeBytes
              }
            }

            return noImpl
          })()

          Object.defineProperty(module.exports, "randombytes", {
            value: randombytes
          })

          module.exports.randombytes_buf = function(out) {
            assert(out, "out must be given")
            randombytes(out, out.length)
          }
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {}
        ))
      },
      { crypto: 14, nanoassert: 42 }
    ],
    70: [
      function(require, module, exports) {
        module.exports = require("sodium-javascript")
      },
      { "sodium-javascript": 68 }
    ],
    71: [
      function(require, module, exports) {
        module.exports = indexOf

        function indexOf(left, right) {
          var result = new Array(right.length)
          var i = 0
          var j = 0

          while (i < left.length && j < right.length) {
            var a = left[i]
            var b = right[j]

            if (a === b) {
              result[j++] = i
              continue
            }

            if (a < b) {
              i++
              continue
            }

            result[j++] = -1
            continue
          }

          for (; j < right.length; j++) result[j] = -1

          return result
        }
      },
      {}
    ],
    72: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var pager = require("memory-pager")

          module.exports = Bitfield

          function Bitfield(opts) {
            if (!(this instanceof Bitfield)) return new Bitfield(opts)
            if (!opts) opts = {}
            if (Buffer.isBuffer(opts)) opts = { buffer: opts }

            this.pageOffset = opts.pageOffset || 0
            this.pageSize = opts.pageSize || 1024
            this.pages = opts.pages || pager(this.pageSize)

            this.byteLength = this.pages.length * this.pageSize
            this.length = 8 * this.byteLength

            if (!powerOfTwo(this.pageSize))
              throw new Error("The page size should be a power of two")

            this._trackUpdates = !!opts.trackUpdates
            this._pageMask = this.pageSize - 1

            if (opts.buffer) {
              for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
                this.pages.set(
                  i / this.pageSize,
                  opts.buffer.slice(i, i + this.pageSize)
                )
              }
              this.byteLength = opts.buffer.length
              this.length = 8 * this.byteLength
            }
          }

          Bitfield.prototype.get = function(i) {
            var o = i & 7
            var j = (i - o) / 8

            return !!(this.getByte(j) & (128 >> o))
          }

          Bitfield.prototype.getByte = function(i) {
            var o = i & this._pageMask
            var j = (i - o) / this.pageSize
            var page = this.pages.get(j, true)

            return page ? page.buffer[o + this.pageOffset] : 0
          }

          Bitfield.prototype.set = function(i, v) {
            var o = i & 7
            var j = (i - o) / 8
            var b = this.getByte(j)

            return this.setByte(j, v ? b | (128 >> o) : b & (255 ^ (128 >> o)))
          }

          Bitfield.prototype.toBuffer = function() {
            var all = alloc(this.pages.length * this.pageSize)

            for (var i = 0; i < this.pages.length; i++) {
              var next = this.pages.get(i, true)
              var allOffset = i * this.pageSize
              if (next)
                next.buffer.copy(
                  all,
                  allOffset,
                  this.pageOffset,
                  this.pageOffset + this.pageSize
                )
            }

            return all
          }

          Bitfield.prototype.setByte = function(i, b) {
            var o = i & this._pageMask
            var j = (i - o) / this.pageSize
            var page = this.pages.get(j, false)

            o += this.pageOffset

            if (page.buffer[o] === b) return false
            page.buffer[o] = b

            if (i >= this.byteLength) {
              this.byteLength = i + 1
              this.length = this.byteLength * 8
            }

            if (this._trackUpdates) this.pages.updated(page)

            return true
          }

          function alloc(n) {
            if (Buffer.alloc) return Buffer.alloc(n)
            var b = new Buffer(n)
            b.fill(0)
            return b
          }

          function powerOfTwo(x) {
            return !(x & (x - 1))
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "memory-pager": 40 }
    ],
    73: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict"

        /*<replacement>*/

        var Buffer = require("safe-buffer").Buffer
        /*</replacement>*/

        var isEncoding =
          Buffer.isEncoding ||
          function(encoding) {
            encoding = "" + encoding
            switch (encoding && encoding.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return true
              default:
                return false
            }
          }

        function _normalizeEncoding(enc) {
          if (!enc) return "utf8"
          var retried
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8"
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le"
              case "latin1":
              case "binary":
                return "latin1"
              case "base64":
              case "ascii":
              case "hex":
                return enc
              default:
                if (retried) return // undefined
                enc = ("" + enc).toLowerCase()
                retried = true
            }
          }
        }

        // Do not cache `Buffer.isEncoding` when checking encoding names as some
        // modules monkey-patch it to support additional encodings
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc)
          if (
            typeof nenc !== "string" &&
            (Buffer.isEncoding === isEncoding || !isEncoding(enc))
          )
            throw new Error("Unknown encoding: " + enc)
          return nenc || enc
        }

        // StringDecoder provides an interface for efficiently splitting a series of
        // buffers into a series of JS strings without breaking apart multi-byte
        // characters.
        exports.StringDecoder = StringDecoder
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding)
          var nb
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text
              this.end = utf16End
              nb = 4
              break
            case "utf8":
              this.fillLast = utf8FillLast
              nb = 4
              break
            case "base64":
              this.text = base64Text
              this.end = base64End
              nb = 3
              break
            default:
              this.write = simpleWrite
              this.end = simpleEnd
              return
          }
          this.lastNeed = 0
          this.lastTotal = 0
          this.lastChar = Buffer.allocUnsafe(nb)
        }

        StringDecoder.prototype.write = function(buf) {
          if (buf.length === 0) return ""
          var r
          var i
          if (this.lastNeed) {
            r = this.fillLast(buf)
            if (r === undefined) return ""
            i = this.lastNeed
            this.lastNeed = 0
          } else {
            i = 0
          }
          if (i < buf.length)
            return r ? r + this.text(buf, i) : this.text(buf, i)
          return r || ""
        }

        StringDecoder.prototype.end = utf8End

        // Returns only complete characters in a Buffer
        StringDecoder.prototype.text = utf8Text

        // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
        StringDecoder.prototype.fillLast = function(buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(
              this.lastChar,
              this.lastTotal - this.lastNeed,
              0,
              this.lastNeed
            )
            return this.lastChar.toString(this.encoding, 0, this.lastTotal)
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length)
          this.lastNeed -= buf.length
        }

        // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
        // continuation byte. If an invalid byte is detected, -2 is returned.
        function utf8CheckByte(byte) {
          if (byte <= 0x7f) return 0
          else if (byte >> 5 === 0x06) return 2
          else if (byte >> 4 === 0x0e) return 3
          else if (byte >> 3 === 0x1e) return 4
          return byte >> 6 === 0x02 ? -1 : -2
        }

        // Checks at most 3 bytes at the end of a Buffer in order to detect an
        // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
        // needed to complete the UTF-8 character (if applicable) are returned.
        function utf8CheckIncomplete(self, buf, i) {
          var j = buf.length - 1
          if (j < i) return 0
          var nb = utf8CheckByte(buf[j])
          if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 1
            return nb
          }
          if (--j < i || nb === -2) return 0
          nb = utf8CheckByte(buf[j])
          if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 2
            return nb
          }
          if (--j < i || nb === -2) return 0
          nb = utf8CheckByte(buf[j])
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2) nb = 0
              else self.lastNeed = nb - 3
            }
            return nb
          }
          return 0
        }

        // Validates as many continuation bytes for a multi-byte UTF-8 character as
        // needed or are available. If we see a non-continuation byte where we expect
        // one, we "replace" the validated continuation bytes we've seen so far with
        // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
        // behavior. The continuation byte check is included three times in the case
        // where all of the continuation bytes for a character exist in the same buffer.
        // It is also done this way as a slight performance increase instead of using a
        // loop.
        function utf8CheckExtraBytes(self, buf, p) {
          if ((buf[0] & 0xc0) !== 0x80) {
            self.lastNeed = 0
            return "\ufffd"
          }
          if (self.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 0xc0) !== 0x80) {
              self.lastNeed = 1
              return "\ufffd"
            }
            if (self.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 0xc0) !== 0x80) {
                self.lastNeed = 2
                return "\ufffd"
              }
            }
          }
        }

        // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed
          var r = utf8CheckExtraBytes(this, buf, p)
          if (r !== undefined) return r
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed)
            return this.lastChar.toString(this.encoding, 0, this.lastTotal)
          }
          buf.copy(this.lastChar, p, 0, buf.length)
          this.lastNeed -= buf.length
        }

        // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
        // partial character, the character's bytes are buffered until the required
        // number of bytes are available.
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i)
          if (!this.lastNeed) return buf.toString("utf8", i)
          this.lastTotal = total
          var end = buf.length - (total - this.lastNeed)
          buf.copy(this.lastChar, 0, end)
          return buf.toString("utf8", i, end)
        }

        // For UTF-8, a replacement character is added when ending on a partial
        // character.
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : ""
          if (this.lastNeed) return r + "\ufffd"
          return r
        }

        // UTF-16LE typically needs two bytes per character, but even if we have an even
        // number of bytes available, we need to check if we end on a leading/high
        // surrogate. In that case, we need to wait for the next two bytes in order to
        // decode the last character properly.
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i)
            if (r) {
              var c = r.charCodeAt(r.length - 1)
              if (c >= 0xd800 && c <= 0xdbff) {
                this.lastNeed = 2
                this.lastTotal = 4
                this.lastChar[0] = buf[buf.length - 2]
                this.lastChar[1] = buf[buf.length - 1]
                return r.slice(0, -1)
              }
            }
            return r
          }
          this.lastNeed = 1
          this.lastTotal = 2
          this.lastChar[0] = buf[buf.length - 1]
          return buf.toString("utf16le", i, buf.length - 1)
        }

        // For UTF-16LE we do not explicitly append special replacement characters if we
        // end on a partial character, we simply let v8 handle that.
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : ""
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed
            return r + this.lastChar.toString("utf16le", 0, end)
          }
          return r
        }

        function base64Text(buf, i) {
          var n = (buf.length - i) % 3
          if (n === 0) return buf.toString("base64", i)
          this.lastNeed = 3 - n
          this.lastTotal = 3
          if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1]
          } else {
            this.lastChar[0] = buf[buf.length - 2]
            this.lastChar[1] = buf[buf.length - 1]
          }
          return buf.toString("base64", i, buf.length - n)
        }

        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : ""
          if (this.lastNeed)
            return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed)
          return r
        }

        // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
        function simpleWrite(buf) {
          return buf.toString(this.encoding)
        }

        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : ""
        }
      },
      { "safe-buffer": 59 }
    ],
    74: [
      function(require, module, exports) {
        ;(function(process) {
          "use strict"

          var nextTick = nextTickArgs
          process.nextTick(upgrade, 42) // pass 42 and see if upgrade is called with it

          module.exports = thunky

          function thunky(fn) {
            var state = run
            return thunk

            function thunk(callback) {
              state(callback || noop)
            }

            function run(callback) {
              var stack = [callback]
              state = wait
              fn(done)

              function wait(callback) {
                stack.push(callback)
              }

              function done(err) {
                var args = arguments
                state = isError(err) ? run : finished
                while (stack.length) finished(stack.shift())

                function finished(callback) {
                  nextTick(apply, callback, args)
                }
              }
            }
          }

          function isError(err) {
            // inlined from util so this works in the browser
            return Object.prototype.toString.call(err) === "[object Error]"
          }

          function noop() {}

          function apply(callback, args) {
            callback.apply(null, args)
          }

          function upgrade(val) {
            if (val === 42) nextTick = process.nextTick
          }

          function nextTickArgs(fn, a, b) {
            process.nextTick(function() {
              fn(a, b)
            })
          }
        }.call(this, require("_process")))
      },
      { _process: 44 }
    ],
    75: [
      function(require, module, exports) {
        ;(function(setImmediate, clearImmediate) {
          var nextTick = require("process/browser.js").nextTick
          var apply = Function.prototype.apply
          var slice = Array.prototype.slice
          var immediateIds = {}
          var nextImmediateId = 0

          // DOM APIs, for completeness

          exports.setTimeout = function() {
            return new Timeout(
              apply.call(setTimeout, window, arguments),
              clearTimeout
            )
          }
          exports.setInterval = function() {
            return new Timeout(
              apply.call(setInterval, window, arguments),
              clearInterval
            )
          }
          exports.clearTimeout = exports.clearInterval = function(timeout) {
            timeout.close()
          }

          function Timeout(id, clearFn) {
            this._id = id
            this._clearFn = clearFn
          }
          Timeout.prototype.unref = Timeout.prototype.ref = function() {}
          Timeout.prototype.close = function() {
            this._clearFn.call(window, this._id)
          }

          // Does not start the time, just sets up the members needed.
          exports.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId)
            item._idleTimeout = msecs
          }

          exports.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId)
            item._idleTimeout = -1
          }

          exports._unrefActive = exports.active = function(item) {
            clearTimeout(item._idleTimeoutId)

            var msecs = item._idleTimeout
            if (msecs >= 0) {
              item._idleTimeoutId = setTimeout(function onTimeout() {
                if (item._onTimeout) item._onTimeout()
              }, msecs)
            }
          }

          // That's not how node.js implements it but the exposed api is the same.
          exports.setImmediate =
            typeof setImmediate === "function"
              ? setImmediate
              : function(fn) {
                  var id = nextImmediateId++
                  var args =
                    arguments.length < 2 ? false : slice.call(arguments, 1)

                  immediateIds[id] = true

                  nextTick(function onNextTick() {
                    if (immediateIds[id]) {
                      // fn.call() is faster so we optimize for the common use-case
                      // @see http://jsperf.com/call-apply-segu
                      if (args) {
                        fn.apply(null, args)
                      } else {
                        fn.call(null)
                      }
                      // Prevent ids from leaking
                      exports.clearImmediate(id)
                    }
                  })

                  return id
                }

          exports.clearImmediate =
            typeof clearImmediate === "function"
              ? clearImmediate
              : function(id) {
                  delete immediateIds[id]
                }
        }.call(
          this,
          require("timers").setImmediate,
          require("timers").clearImmediate
        ))
      },
      { "process/browser.js": 44, timers: 75 }
    ],
    76: [
      function(require, module, exports) {
        var bufferAlloc = require("buffer-alloc")

        var UINT_32_MAX = Math.pow(2, 32)

        exports.encodingLength = function() {
          return 8
        }

        exports.encode = function(num, buf, offset) {
          if (!buf) buf = bufferAlloc(8)
          if (!offset) offset = 0

          var top = Math.floor(num / UINT_32_MAX)
          var rem = num - top * UINT_32_MAX

          buf.writeUInt32BE(top, offset)
          buf.writeUInt32BE(rem, offset + 4)
          return buf
        }

        exports.decode = function(buf, offset) {
          if (!offset) offset = 0

          var top = buf.readUInt32BE(offset)
          var rem = buf.readUInt32BE(offset + 4)

          return top * UINT_32_MAX + rem
        }

        exports.encode.bytes = 8
        exports.decode.bytes = 8
      },
      { "buffer-alloc": 16 }
    ],
    77: [
      function(require, module, exports) {
        module.exports = remove

        function remove(arr, i) {
          if (i >= arr.length || i < 0) return
          var last = arr.pop()
          if (i < arr.length) {
            var tmp = arr[i]
            arr[i] = last
            return tmp
          }
          return last
        }
      },
      {}
    ],
    78: [
      function(require, module, exports) {
        exports.add = add
        exports.has = has
        exports.remove = remove
        exports.swap = swap

        function add(list, item) {
          if (has(list, item)) return item
          item._index = list.length
          list.push(item)
          return item
        }

        function has(list, item) {
          return item._index < list.length && list[item._index] === item
        }

        function remove(list, item) {
          if (!has(list, item)) return null

          var last = list.pop()
          if (last !== item) {
            list[item._index] = last
            last._index = item._index
          }

          return item
        }

        function swap(list, a, b) {
          if (!has(list, a) || !has(list, b)) return
          var tmp = a._index
          a._index = b._index
          list[a._index] = a
          b._index = tmp
          list[b._index] = b
        }
      },
      {}
    ],
    79: [
      function(require, module, exports) {
        ;(function(global) {
          /**
           * Module exports.
           */

          module.exports = deprecate

          /**
           * Mark that a method should not be used.
           * Returns a modified function which warns once by default.
           *
           * If `localStorage.noDeprecation = true` is set, then it is a no-op.
           *
           * If `localStorage.throwDeprecation = true` is set, then deprecated functions
           * will throw an Error when invoked.
           *
           * If `localStorage.traceDeprecation = true` is set, then deprecated functions
           * will invoke `console.trace()` instead of `console.error()`.
           *
           * @param {Function} fn - the function to deprecate
           * @param {String} msg - the string to print to the console when `fn` is invoked
           * @returns {Function} a new "deprecated" version of `fn`
           * @api public
           */

          function deprecate(fn, msg) {
            if (config("noDeprecation")) {
              return fn
            }

            var warned = false
            function deprecated() {
              if (!warned) {
                if (config("throwDeprecation")) {
                  throw new Error(msg)
                } else if (config("traceDeprecation")) {
                  console.trace(msg)
                } else {
                  console.warn(msg)
                }
                warned = true
              }
              return fn.apply(this, arguments)
            }

            return deprecated
          }

          /**
           * Checks `localStorage` for boolean values for the given `name`.
           *
           * @param {String} name
           * @returns {Boolean}
           * @api private
           */

          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage) return false
            } catch (_) {
              return false
            }
            var val = global.localStorage[name]
            if (null == val) return false
            return String(val).toLowerCase() === "true"
          }
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {}
        ))
      },
      {}
    ],
    80: [
      function(require, module, exports) {
        module.exports = read

        var MSB = 0x80,
          REST = 0x7f

        function read(buf, offset) {
          var res = 0,
            offset = offset || 0,
            shift = 0,
            counter = offset,
            b,
            l = buf.length

          do {
            if (counter >= l) {
              read.bytes = 0
              throw new RangeError("Could not decode varint")
            }
            b = buf[counter++]
            res +=
              shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift)
            shift += 7
          } while (b >= MSB)

          read.bytes = counter - offset

          return res
        }
      },
      {}
    ],
    81: [
      function(require, module, exports) {
        arguments[4][8][0].apply(exports, arguments)
      },
      { dup: 8 }
    ],
    82: [
      function(require, module, exports) {
        arguments[4][9][0].apply(exports, arguments)
      },
      { "./decode.js": 80, "./encode.js": 81, "./length.js": 83, dup: 9 }
    ],
    83: [
      function(require, module, exports) {
        arguments[4][10][0].apply(exports, arguments)
      },
      { dup: 10 }
    ],
    84: [
      function(require, module, exports) {
        var xsalsa20 = require("./xsalsa20")()

        var SIGMA = new Uint8Array([
          101,
          120,
          112,
          97,
          110,
          100,
          32,
          51,
          50,
          45,
          98,
          121,
          116,
          101,
          32,
          107
        ])
        var head = 144
        var top = head
        var free = []

        module.exports = XSalsa20

        XSalsa20.NONCEBYTES = 24
        XSalsa20.KEYBYTES = 32

        function XSalsa20(nonce, key) {
          if (!(this instanceof XSalsa20)) return new XSalsa20(nonce, key)
          if (!nonce || nonce.length < 24)
            throw new Error("nonce must be at least 24 bytes")
          if (!key || key.length < 32)
            throw new Error("key must be at least 32 bytes")
          this._xor =
            xsalsa20 && xsalsa20.exports
              ? new WASM(nonce, key)
              : new Fallback(nonce, key)
        }

        XSalsa20.prototype.update = function(input, output) {
          if (!input) throw new Error("input must be Uint8Array or Buffer")
          if (!output) output = new Uint8Array(input.length)
          if (input.length) this._xor.update(input, output)
          return output
        }

        XSalsa20.prototype.final = XSalsa20.prototype.finalize = function() {
          this._xor.finalize()
          this._xor = null
        }

        function WASM(nonce, key) {
          if (!free.length) {
            free.push(head)
            head += 64
          }

          this._pointer = free.pop()
          this._nonce = this._pointer + 8
          this._key = this._nonce + 24
          this._overflow = 0

          xsalsa20.memory.fill(0, this._pointer, this._pointer + 8)
          xsalsa20.memory.set(nonce, this._nonce)
          xsalsa20.memory.set(key, this._key)
        }

        WASM.prototype.update = function(input, output) {
          var len = this._overflow + input.length
          var start = head + this._overflow

          top = head + len
          if (top >= xsalsa20.memory.length) xsalsa20.realloc(top)

          xsalsa20.memory.set(input, start)
          xsalsa20.exports.xsalsa20_xor(
            this._pointer,
            head,
            head,
            len,
            this._nonce,
            this._key
          )
          output.set(xsalsa20.memory.subarray(start, head + len))

          this._overflow = len & 63
        }

        WASM.prototype.finalize = function() {
          xsalsa20.memory.fill(0, this._pointer, this._key + 32)
          if (top > head) {
            xsalsa20.memory.fill(0, head, top)
            top = 0
          }
          free.push(this._pointer)
        }

        function Fallback(nonce, key) {
          this._s = new Uint8Array(32)
          this._z = new Uint8Array(16)
          this._overflow = 0
          core_hsalsa20(this._s, nonce, key, SIGMA)
          for (var i = 0; i < 8; i++) this._z[i] = nonce[i + 16]
        }

        Fallback.prototype.update = function(input, output) {
          var x = new Uint8Array(64)
          var u = 0
          var i = this._overflow
          var b = input.length + this._overflow
          var z = this._z
          var mpos = -this._overflow
          var cpos = -this._overflow

          while (b >= 64) {
            core_salsa20(x, z, this._s, SIGMA)
            for (; i < 64; i++) output[cpos + i] = input[mpos + i] ^ x[i]
            u = 1
            for (i = 8; i < 16; i++) {
              u += (z[i] & 0xff) | 0
              z[i] = u & 0xff
              u >>>= 8
            }
            b -= 64
            cpos += 64
            mpos += 64
            i = 0
          }
          if (b > 0) {
            core_salsa20(x, z, this._s, SIGMA)
            for (; i < b; i++) output[cpos + i] = input[mpos + i] ^ x[i]
          }

          this._overflow = b & 63
        }

        Fallback.prototype.finalize = function() {
          this._s.fill(0)
          this._z.fill(0)
        }

        // below methods are ported from tweet nacl

        function core_salsa20(o, p, k, c) {
          var j0 =
              (c[0] & 0xff) |
              ((c[1] & 0xff) << 8) |
              ((c[2] & 0xff) << 16) |
              ((c[3] & 0xff) << 24),
            j1 =
              (k[0] & 0xff) |
              ((k[1] & 0xff) << 8) |
              ((k[2] & 0xff) << 16) |
              ((k[3] & 0xff) << 24),
            j2 =
              (k[4] & 0xff) |
              ((k[5] & 0xff) << 8) |
              ((k[6] & 0xff) << 16) |
              ((k[7] & 0xff) << 24),
            j3 =
              (k[8] & 0xff) |
              ((k[9] & 0xff) << 8) |
              ((k[10] & 0xff) << 16) |
              ((k[11] & 0xff) << 24),
            j4 =
              (k[12] & 0xff) |
              ((k[13] & 0xff) << 8) |
              ((k[14] & 0xff) << 16) |
              ((k[15] & 0xff) << 24),
            j5 =
              (c[4] & 0xff) |
              ((c[5] & 0xff) << 8) |
              ((c[6] & 0xff) << 16) |
              ((c[7] & 0xff) << 24),
            j6 =
              (p[0] & 0xff) |
              ((p[1] & 0xff) << 8) |
              ((p[2] & 0xff) << 16) |
              ((p[3] & 0xff) << 24),
            j7 =
              (p[4] & 0xff) |
              ((p[5] & 0xff) << 8) |
              ((p[6] & 0xff) << 16) |
              ((p[7] & 0xff) << 24),
            j8 =
              (p[8] & 0xff) |
              ((p[9] & 0xff) << 8) |
              ((p[10] & 0xff) << 16) |
              ((p[11] & 0xff) << 24),
            j9 =
              (p[12] & 0xff) |
              ((p[13] & 0xff) << 8) |
              ((p[14] & 0xff) << 16) |
              ((p[15] & 0xff) << 24),
            j10 =
              (c[8] & 0xff) |
              ((c[9] & 0xff) << 8) |
              ((c[10] & 0xff) << 16) |
              ((c[11] & 0xff) << 24),
            j11 =
              (k[16] & 0xff) |
              ((k[17] & 0xff) << 8) |
              ((k[18] & 0xff) << 16) |
              ((k[19] & 0xff) << 24),
            j12 =
              (k[20] & 0xff) |
              ((k[21] & 0xff) << 8) |
              ((k[22] & 0xff) << 16) |
              ((k[23] & 0xff) << 24),
            j13 =
              (k[24] & 0xff) |
              ((k[25] & 0xff) << 8) |
              ((k[26] & 0xff) << 16) |
              ((k[27] & 0xff) << 24),
            j14 =
              (k[28] & 0xff) |
              ((k[29] & 0xff) << 8) |
              ((k[30] & 0xff) << 16) |
              ((k[31] & 0xff) << 24),
            j15 =
              (c[12] & 0xff) |
              ((c[13] & 0xff) << 8) |
              ((c[14] & 0xff) << 16) |
              ((c[15] & 0xff) << 24)

          var x0 = j0,
            x1 = j1,
            x2 = j2,
            x3 = j3,
            x4 = j4,
            x5 = j5,
            x6 = j6,
            x7 = j7,
            x8 = j8,
            x9 = j9,
            x10 = j10,
            x11 = j11,
            x12 = j12,
            x13 = j13,
            x14 = j14,
            x15 = j15,
            u

          for (var i = 0; i < 20; i += 2) {
            u = (x0 + x12) | 0
            x4 ^= (u << 7) | (u >>> 25)
            u = (x4 + x0) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x4) | 0
            x12 ^= (u << 13) | (u >>> 19)
            u = (x12 + x8) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x1) | 0
            x9 ^= (u << 7) | (u >>> 25)
            u = (x9 + x5) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x9) | 0
            x1 ^= (u << 13) | (u >>> 19)
            u = (x1 + x13) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x6) | 0
            x14 ^= (u << 7) | (u >>> 25)
            u = (x14 + x10) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x14) | 0
            x6 ^= (u << 13) | (u >>> 19)
            u = (x6 + x2) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x11) | 0
            x3 ^= (u << 7) | (u >>> 25)
            u = (x3 + x15) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x3) | 0
            x11 ^= (u << 13) | (u >>> 19)
            u = (x11 + x7) | 0
            x15 ^= (u << 18) | (u >>> 14)

            u = (x0 + x3) | 0
            x1 ^= (u << 7) | (u >>> 25)
            u = (x1 + x0) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x1) | 0
            x3 ^= (u << 13) | (u >>> 19)
            u = (x3 + x2) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x4) | 0
            x6 ^= (u << 7) | (u >>> 25)
            u = (x6 + x5) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x6) | 0
            x4 ^= (u << 13) | (u >>> 19)
            u = (x4 + x7) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x9) | 0
            x11 ^= (u << 7) | (u >>> 25)
            u = (x11 + x10) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x11) | 0
            x9 ^= (u << 13) | (u >>> 19)
            u = (x9 + x8) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x14) | 0
            x12 ^= (u << 7) | (u >>> 25)
            u = (x12 + x15) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x12) | 0
            x14 ^= (u << 13) | (u >>> 19)
            u = (x14 + x13) | 0
            x15 ^= (u << 18) | (u >>> 14)
          }
          x0 = (x0 + j0) | 0
          x1 = (x1 + j1) | 0
          x2 = (x2 + j2) | 0
          x3 = (x3 + j3) | 0
          x4 = (x4 + j4) | 0
          x5 = (x5 + j5) | 0
          x6 = (x6 + j6) | 0
          x7 = (x7 + j7) | 0
          x8 = (x8 + j8) | 0
          x9 = (x9 + j9) | 0
          x10 = (x10 + j10) | 0
          x11 = (x11 + j11) | 0
          x12 = (x12 + j12) | 0
          x13 = (x13 + j13) | 0
          x14 = (x14 + j14) | 0
          x15 = (x15 + j15) | 0

          o[0] = (x0 >>> 0) & 0xff
          o[1] = (x0 >>> 8) & 0xff
          o[2] = (x0 >>> 16) & 0xff
          o[3] = (x0 >>> 24) & 0xff

          o[4] = (x1 >>> 0) & 0xff
          o[5] = (x1 >>> 8) & 0xff
          o[6] = (x1 >>> 16) & 0xff
          o[7] = (x1 >>> 24) & 0xff

          o[8] = (x2 >>> 0) & 0xff
          o[9] = (x2 >>> 8) & 0xff
          o[10] = (x2 >>> 16) & 0xff
          o[11] = (x2 >>> 24) & 0xff

          o[12] = (x3 >>> 0) & 0xff
          o[13] = (x3 >>> 8) & 0xff
          o[14] = (x3 >>> 16) & 0xff
          o[15] = (x3 >>> 24) & 0xff

          o[16] = (x4 >>> 0) & 0xff
          o[17] = (x4 >>> 8) & 0xff
          o[18] = (x4 >>> 16) & 0xff
          o[19] = (x4 >>> 24) & 0xff

          o[20] = (x5 >>> 0) & 0xff
          o[21] = (x5 >>> 8) & 0xff
          o[22] = (x5 >>> 16) & 0xff
          o[23] = (x5 >>> 24) & 0xff

          o[24] = (x6 >>> 0) & 0xff
          o[25] = (x6 >>> 8) & 0xff
          o[26] = (x6 >>> 16) & 0xff
          o[27] = (x6 >>> 24) & 0xff

          o[28] = (x7 >>> 0) & 0xff
          o[29] = (x7 >>> 8) & 0xff
          o[30] = (x7 >>> 16) & 0xff
          o[31] = (x7 >>> 24) & 0xff

          o[32] = (x8 >>> 0) & 0xff
          o[33] = (x8 >>> 8) & 0xff
          o[34] = (x8 >>> 16) & 0xff
          o[35] = (x8 >>> 24) & 0xff

          o[36] = (x9 >>> 0) & 0xff
          o[37] = (x9 >>> 8) & 0xff
          o[38] = (x9 >>> 16) & 0xff
          o[39] = (x9 >>> 24) & 0xff

          o[40] = (x10 >>> 0) & 0xff
          o[41] = (x10 >>> 8) & 0xff
          o[42] = (x10 >>> 16) & 0xff
          o[43] = (x10 >>> 24) & 0xff

          o[44] = (x11 >>> 0) & 0xff
          o[45] = (x11 >>> 8) & 0xff
          o[46] = (x11 >>> 16) & 0xff
          o[47] = (x11 >>> 24) & 0xff

          o[48] = (x12 >>> 0) & 0xff
          o[49] = (x12 >>> 8) & 0xff
          o[50] = (x12 >>> 16) & 0xff
          o[51] = (x12 >>> 24) & 0xff

          o[52] = (x13 >>> 0) & 0xff
          o[53] = (x13 >>> 8) & 0xff
          o[54] = (x13 >>> 16) & 0xff
          o[55] = (x13 >>> 24) & 0xff

          o[56] = (x14 >>> 0) & 0xff
          o[57] = (x14 >>> 8) & 0xff
          o[58] = (x14 >>> 16) & 0xff
          o[59] = (x14 >>> 24) & 0xff

          o[60] = (x15 >>> 0) & 0xff
          o[61] = (x15 >>> 8) & 0xff
          o[62] = (x15 >>> 16) & 0xff
          o[63] = (x15 >>> 24) & 0xff
        }

        function core_hsalsa20(o, p, k, c) {
          var j0 =
              (c[0] & 0xff) |
              ((c[1] & 0xff) << 8) |
              ((c[2] & 0xff) << 16) |
              ((c[3] & 0xff) << 24),
            j1 =
              (k[0] & 0xff) |
              ((k[1] & 0xff) << 8) |
              ((k[2] & 0xff) << 16) |
              ((k[3] & 0xff) << 24),
            j2 =
              (k[4] & 0xff) |
              ((k[5] & 0xff) << 8) |
              ((k[6] & 0xff) << 16) |
              ((k[7] & 0xff) << 24),
            j3 =
              (k[8] & 0xff) |
              ((k[9] & 0xff) << 8) |
              ((k[10] & 0xff) << 16) |
              ((k[11] & 0xff) << 24),
            j4 =
              (k[12] & 0xff) |
              ((k[13] & 0xff) << 8) |
              ((k[14] & 0xff) << 16) |
              ((k[15] & 0xff) << 24),
            j5 =
              (c[4] & 0xff) |
              ((c[5] & 0xff) << 8) |
              ((c[6] & 0xff) << 16) |
              ((c[7] & 0xff) << 24),
            j6 =
              (p[0] & 0xff) |
              ((p[1] & 0xff) << 8) |
              ((p[2] & 0xff) << 16) |
              ((p[3] & 0xff) << 24),
            j7 =
              (p[4] & 0xff) |
              ((p[5] & 0xff) << 8) |
              ((p[6] & 0xff) << 16) |
              ((p[7] & 0xff) << 24),
            j8 =
              (p[8] & 0xff) |
              ((p[9] & 0xff) << 8) |
              ((p[10] & 0xff) << 16) |
              ((p[11] & 0xff) << 24),
            j9 =
              (p[12] & 0xff) |
              ((p[13] & 0xff) << 8) |
              ((p[14] & 0xff) << 16) |
              ((p[15] & 0xff) << 24),
            j10 =
              (c[8] & 0xff) |
              ((c[9] & 0xff) << 8) |
              ((c[10] & 0xff) << 16) |
              ((c[11] & 0xff) << 24),
            j11 =
              (k[16] & 0xff) |
              ((k[17] & 0xff) << 8) |
              ((k[18] & 0xff) << 16) |
              ((k[19] & 0xff) << 24),
            j12 =
              (k[20] & 0xff) |
              ((k[21] & 0xff) << 8) |
              ((k[22] & 0xff) << 16) |
              ((k[23] & 0xff) << 24),
            j13 =
              (k[24] & 0xff) |
              ((k[25] & 0xff) << 8) |
              ((k[26] & 0xff) << 16) |
              ((k[27] & 0xff) << 24),
            j14 =
              (k[28] & 0xff) |
              ((k[29] & 0xff) << 8) |
              ((k[30] & 0xff) << 16) |
              ((k[31] & 0xff) << 24),
            j15 =
              (c[12] & 0xff) |
              ((c[13] & 0xff) << 8) |
              ((c[14] & 0xff) << 16) |
              ((c[15] & 0xff) << 24)

          var x0 = j0,
            x1 = j1,
            x2 = j2,
            x3 = j3,
            x4 = j4,
            x5 = j5,
            x6 = j6,
            x7 = j7,
            x8 = j8,
            x9 = j9,
            x10 = j10,
            x11 = j11,
            x12 = j12,
            x13 = j13,
            x14 = j14,
            x15 = j15,
            u

          for (var i = 0; i < 20; i += 2) {
            u = (x0 + x12) | 0
            x4 ^= (u << 7) | (u >>> 25)
            u = (x4 + x0) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x4) | 0
            x12 ^= (u << 13) | (u >>> 19)
            u = (x12 + x8) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x1) | 0
            x9 ^= (u << 7) | (u >>> 25)
            u = (x9 + x5) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x9) | 0
            x1 ^= (u << 13) | (u >>> 19)
            u = (x1 + x13) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x6) | 0
            x14 ^= (u << 7) | (u >>> 25)
            u = (x14 + x10) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x14) | 0
            x6 ^= (u << 13) | (u >>> 19)
            u = (x6 + x2) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x11) | 0
            x3 ^= (u << 7) | (u >>> 25)
            u = (x3 + x15) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x3) | 0
            x11 ^= (u << 13) | (u >>> 19)
            u = (x11 + x7) | 0
            x15 ^= (u << 18) | (u >>> 14)

            u = (x0 + x3) | 0
            x1 ^= (u << 7) | (u >>> 25)
            u = (x1 + x0) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x1) | 0
            x3 ^= (u << 13) | (u >>> 19)
            u = (x3 + x2) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x4) | 0
            x6 ^= (u << 7) | (u >>> 25)
            u = (x6 + x5) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x6) | 0
            x4 ^= (u << 13) | (u >>> 19)
            u = (x4 + x7) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x9) | 0
            x11 ^= (u << 7) | (u >>> 25)
            u = (x11 + x10) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x11) | 0
            x9 ^= (u << 13) | (u >>> 19)
            u = (x9 + x8) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x14) | 0
            x12 ^= (u << 7) | (u >>> 25)
            u = (x12 + x15) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x12) | 0
            x14 ^= (u << 13) | (u >>> 19)
            u = (x14 + x13) | 0
            x15 ^= (u << 18) | (u >>> 14)
          }

          o[0] = (x0 >>> 0) & 0xff
          o[1] = (x0 >>> 8) & 0xff
          o[2] = (x0 >>> 16) & 0xff
          o[3] = (x0 >>> 24) & 0xff

          o[4] = (x5 >>> 0) & 0xff
          o[5] = (x5 >>> 8) & 0xff
          o[6] = (x5 >>> 16) & 0xff
          o[7] = (x5 >>> 24) & 0xff

          o[8] = (x10 >>> 0) & 0xff
          o[9] = (x10 >>> 8) & 0xff
          o[10] = (x10 >>> 16) & 0xff
          o[11] = (x10 >>> 24) & 0xff

          o[12] = (x15 >>> 0) & 0xff
          o[13] = (x15 >>> 8) & 0xff
          o[14] = (x15 >>> 16) & 0xff
          o[15] = (x15 >>> 24) & 0xff

          o[16] = (x6 >>> 0) & 0xff
          o[17] = (x6 >>> 8) & 0xff
          o[18] = (x6 >>> 16) & 0xff
          o[19] = (x6 >>> 24) & 0xff

          o[20] = (x7 >>> 0) & 0xff
          o[21] = (x7 >>> 8) & 0xff
          o[22] = (x7 >>> 16) & 0xff
          o[23] = (x7 >>> 24) & 0xff

          o[24] = (x8 >>> 0) & 0xff
          o[25] = (x8 >>> 8) & 0xff
          o[26] = (x8 >>> 16) & 0xff
          o[27] = (x8 >>> 24) & 0xff

          o[28] = (x9 >>> 0) & 0xff
          o[29] = (x9 >>> 8) & 0xff
          o[30] = (x9 >>> 16) & 0xff
          o[31] = (x9 >>> 24) & 0xff
        }
      },
      { "./xsalsa20": 85 }
    ],
    85: [
      function(require, module, exports) {
        module.exports = loadWebAssembly

        loadWebAssembly.supported = typeof WebAssembly !== "undefined"

        function loadWebAssembly(opts) {
          if (!loadWebAssembly.supported) return null

          var imp = opts && opts.imports
          var wasm = toUint8Array(
            "AGFzbQEAAAABGgNgBn9/f39/fwBgBn9/f39+fwF+YAN/f38AAwcGAAEBAgICBQUBAQroBwcoAwZtZW1vcnkCAAx4c2Fsc2EyMF94b3IAAAxjb3JlX3NhbHNhMjAABArqEQYYACAAIAEgAiADIAQgACkDACAFEAE3AwALPQBB8AAgAyAFEAMgACABIAIgA0EQaiAEQfAAEAJB8ABCADcDAEH4AEIANwMAQYABQgA3AwBBiAFCADcDAAuHBQEBfyACQQBGBEBCAA8LQdAAIAUpAwA3AwBB2AAgBUEIaikDADcDAEHgACAFQRBqKQMANwMAQegAIAVBGGopAwA3AwBBACADKQMANwMAQQggBDcDAAJAA0AgAkHAAEkNAUEQQQBB0AAQBSAAIAEpAwBBECkDAIU3AwAgAEEIaiABQQhqKQMAQRgpAwCFNwMAIABBEGogAUEQaikDAEEgKQMAhTcDACAAQRhqIAFBGGopAwBBKCkDAIU3AwAgAEEgaiABQSBqKQMAQTApAwCFNwMAIABBKGogAUEoaikDAEE4KQMAhTcDACAAQTBqIAFBMGopAwBBwAApAwCFNwMAIABBOGogAUE4aikDAEHIACkDAIU3AwBBCEEIKQMAQgF8NwMAIABBwABqIQAgAUHAAGohASACQcAAayECDAALC0EIKQMAIQQgAkEASwRAQRBBAEHQABAFAkACQAJAAkACQAJAAkACQCACQQhuDgcHBgUEAwIBAAsgAEE4aiABQThqKQMAQcgAKQMAhTcDAAsgAEEwaiABQTBqKQMAQcAAKQMAhTcDAAsgAEEoaiABQShqKQMAQTgpAwCFNwMACyAAQSBqIAFBIGopAwBBMCkDAIU3AwALIABBGGogAUEYaikDAEEoKQMAhTcDAAsgAEEQaiABQRBqKQMAQSApAwCFNwMACyAAQQhqIAFBCGopAwBBGCkDAIU3AwALIAAgASkDAEEQKQMAhTcDAAtBEEIANwMAQRhCADcDAEEgQgA3AwBBKEIANwMAQTBCADcDAEE4QgA3AwBBwABCADcDAEHIAEIANwMAQdAAQgA3AwBB2ABCADcDAEHgAEIANwMAQegAQgA3AwAgBA8LnQUBEX9B5fDBiwYhA0HuyIGZAyEIQbLaiMsHIQ1B9MqB2QYhEiACKAIAIQQgAkEEaigCACEFIAJBCGooAgAhBiACQQxqKAIAIQcgAkEQaigCACEOIAJBFGooAgAhDyACQRhqKAIAIRAgAkEcaigCACERIAEoAgAhCSABQQRqKAIAIQogAUEIaigCACELIAFBDGooAgAhDEEUIRMCQANAIBNBAEYNASAHIAMgD2pBB3dzIQcgCyAHIANqQQl3cyELIA8gCyAHakENd3MhDyADIA8gC2pBEndzIQMgDCAIIARqQQd3cyEMIBAgDCAIakEJd3MhECAEIBAgDGpBDXdzIQQgCCAEIBBqQRJ3cyEIIBEgDSAJakEHd3MhESAFIBEgDWpBCXdzIQUgCSAFIBFqQQ13cyEJIA0gCSAFakESd3MhDSAGIBIgDmpBB3dzIQYgCiAGIBJqQQl3cyEKIA4gCiAGakENd3MhDiASIA4gCmpBEndzIRIgBCADIAZqQQd3cyEEIAUgBCADakEJd3MhBSAGIAUgBGpBDXdzIQYgAyAGIAVqQRJ3cyEDIAkgCCAHakEHd3MhCSAKIAkgCGpBCXdzIQogByAKIAlqQQ13cyEHIAggByAKakESd3MhCCAOIA0gDGpBB3dzIQ4gCyAOIA1qQQl3cyELIAwgCyAOakENd3MhDCANIAwgC2pBEndzIQ0gDyASIBFqQQd3cyEPIBAgDyASakEJd3MhECARIBAgD2pBDXdzIREgEiARIBBqQRJ3cyESIBNBAmshEwwACwsgACADNgIAIABBBGogCDYCACAAQQhqIA02AgAgAEEMaiASNgIAIABBEGogCTYCACAAQRRqIAo2AgAgAEEYaiALNgIAIABBHGogDDYCAAsKACAAIAEgAhAFC90GASF/QeXwwYsGIQNB7siBmQMhCEGy2ojLByENQfTKgdkGIRIgAigCACEEIAJBBGooAgAhBSACQQhqKAIAIQYgAkEMaigCACEHIAJBEGooAgAhDiACQRRqKAIAIQ8gAkEYaigCACEQIAJBHGooAgAhESABKAIAIQkgAUEEaigCACEKIAFBCGooAgAhCyABQQxqKAIAIQwgAyETIAQhFCAFIRUgBiEWIAchFyAIIRggCSEZIAohGiALIRsgDCEcIA0hHSAOIR4gDyEfIBAhICARISEgEiEiQRQhIwJAA0AgI0EARg0BIAcgAyAPakEHd3MhByALIAcgA2pBCXdzIQsgDyALIAdqQQ13cyEPIAMgDyALakESd3MhAyAMIAggBGpBB3dzIQwgECAMIAhqQQl3cyEQIAQgECAMakENd3MhBCAIIAQgEGpBEndzIQggESANIAlqQQd3cyERIAUgESANakEJd3MhBSAJIAUgEWpBDXdzIQkgDSAJIAVqQRJ3cyENIAYgEiAOakEHd3MhBiAKIAYgEmpBCXdzIQogDiAKIAZqQQ13cyEOIBIgDiAKakESd3MhEiAEIAMgBmpBB3dzIQQgBSAEIANqQQl3cyEFIAYgBSAEakENd3MhBiADIAYgBWpBEndzIQMgCSAIIAdqQQd3cyEJIAogCSAIakEJd3MhCiAHIAogCWpBDXdzIQcgCCAHIApqQRJ3cyEIIA4gDSAMakEHd3MhDiALIA4gDWpBCXdzIQsgDCALIA5qQQ13cyEMIA0gDCALakESd3MhDSAPIBIgEWpBB3dzIQ8gECAPIBJqQQl3cyEQIBEgECAPakENd3MhESASIBEgEGpBEndzIRIgI0ECayEjDAALCyAAIAMgE2o2AgAgAEEEaiAEIBRqNgIAIABBCGogBSAVajYCACAAQQxqIAYgFmo2AgAgAEEQaiAHIBdqNgIAIABBFGogCCAYajYCACAAQRhqIAkgGWo2AgAgAEEcaiAKIBpqNgIAIABBIGogCyAbajYCACAAQSRqIAwgHGo2AgAgAEEoaiANIB1qNgIAIABBLGogDiAeajYCACAAQTBqIA8gH2o2AgAgAEE0aiAQICBqNgIAIABBOGogESAhajYCACAAQTxqIBIgImo2AgAL"
          )
          var ready = null

          var mod = {
            buffer: wasm,
            memory: null,
            exports: null,
            realloc: realloc,
            onload: onload
          }

          onload(function() {})

          return mod

          function realloc(size) {
            mod.exports.memory.grow(
              Math.ceil(Math.abs(size - mod.memory.length) / 65536)
            )
            mod.memory = new Uint8Array(mod.exports.memory.buffer)
          }

          function onload(cb) {
            if (mod.exports) return cb()

            if (ready) {
              ready.then(cb.bind(null, null)).catch(cb)
              return
            }

            try {
              if (opts && opts.async) throw new Error("async")
              setup({
                instance: new WebAssembly.Instance(
                  new WebAssembly.Module(wasm),
                  imp
                )
              })
            } catch (err) {
              ready = WebAssembly.instantiate(wasm, imp).then(setup)
            }

            onload(cb)
          }

          function setup(w) {
            mod.exports = w.instance.exports
            mod.memory =
              mod.exports.memory &&
              mod.exports.memory.buffer &&
              new Uint8Array(mod.exports.memory.buffer)
          }
        }

        function toUint8Array(s) {
          if (typeof atob === "function")
            return new Uint8Array(
              atob(s)
                .split("")
                .map(charCodeAt)
            )
          return new (require("buf" + "fer")).Buffer(s, "base64")
        }

        function charCodeAt(c) {
          return c.charCodeAt(0)
        }
      },
      {}
    ],
    86: [
      function(require, module, exports) {
        "use strict"

        var hypercore = require("hypercore")
        var RandomAccessIDBFile = require("./random-access-idb-file")

        const main = async options => {
          const volume = await RandomAccessIDBFile.mount(options)
          var feed = hypercore(volume, { valueEncoding: "json" })

          feed.append({
            hello: "world"
          })

          feed.append({
            hej: "verden"
          })

          feed.append({
            hola: "mundo"
          })

          feed.flush(function() {
            console.log(
              "Appended 3 more blocks, %d in total (%d bytes)\n",
              feed.length,
              feed.byteLength
            )

            feed
              .createReadStream()
              .on("data", console.log.bind(console))
              .on("end", console.log.bind(console, "\n(end)"))
          })
        }

        main({ debug: false })
      },
      { "./random-access-idb-file": 87, hypercore: 30 }
    ],
    87: [
      function(require, module, exports) {
        // @flow

        const RandomAccess = require("random-access-storage")
        const { Buffer } = require("Buffer")

        const promise = request =>
          new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result)
            request.onerror = () => reject(request.error)
          })

        class RandomAccessIDBFileVolume {
          constructor(db, name, version, storeName, options) {
            this.db = db
            this.name = name
            this.version = version
            this.storeName = storeName
            this.options = options
          }
          store() {
            const { db, storeName } = this
            const transaction = db.transaction([storeName], "readwrite")
            return transaction.objectStore(storeName)
          }
          async delete(url) {
            return await promise(this.store().delete(url))
          }
          async save(url, file) {
            return await promise(this.store().put(file, url))
          }
          async open(url, mode) {
            const file = await promise(this.store().get(url))
            if (file) {
              return file
            } else if (mode === "readwrite") {
              return await promise(
                this.db.createMutableFile(url, "binary/random")
              )
            } else {
              throw new RangeError(`File ${url} does not exist`)
            }
          }

          mount(file, options) {
            return new RandomAccessIDBFile(this, `/${file}`, options)
          }
        }

        class RandomAccessIDBFile extends RandomAccess {
          static async mount(options = {}) {
            if (!self.IDBMutableFile) {
              throw Error(
                `Implementation depends on IDBMutableFile https://developer.mozilla.org/en-US/docs/Web/API/IDBMutableFile`
              )
            } else {
              const name = options.name || `RandomAccess`
              const version = options.version || 1.0
              const storeName = options.storeName || `IDBMutableFile`

              const request = indexedDB.open(name, version)
              request.onupgradeneeded = () => {
                const db = request.result
                if (!db.objectStoreNames.contains(storeName)) {
                  db.createObjectStore(storeName)
                }
              }
              const db = await promise(request)
              const volume = new RandomAccessIDBFileVolume(
                db,
                name,
                version,
                storeName,
                options
              )
              return (path, options) => volume.mount(path, options)
            }
          }
          static async open(self, { mode }) {
            self.debug && console.log(`>> open ${self.url} ${mode}`)

            if (!self.file || (self.mode !== mode && mode === "readwrite")) {
              self.mode = mode
              self.file = await self.volume.open(self.url, mode)
            }

            self.debug && console.log(`<< open ${self.url} ${mode}`)
            return self
          }
          static async read(self, { data, offset, size }) {
            self.debug &&
              console.log(`>> read ${self.url} <${offset}, ${size}>`)
            const buffer = data || Buffer.allocUnsafe(size)
            if (size === 0) {
              return buffer
            }

            const file = self.activate()
            file.location = offset
            const chunk = await promise(file.readAsArrayBuffer(size))

            Buffer.from(chunk).copy(buffer)
            self.debug &&
              console.log(`<< read ${self.url} <${offset}, ${size}>`, buffer)
            return buffer
          }
          static async write(self, { data, offset, size }) {
            self.debug &&
              console.log(`>> write ${self.url} <${offset}, ${size}>`, data)
            const { byteLength, byteOffset } = data
            const chunk =
              byteLength === size
                ? byteOffset > 0
                  ? data.buffer.slice(byteOffset)
                  : data.buffer
                : byteLength > size
                  ? data.buffer.slice(byteOffset, byteOffset + size)
                  : byteOffset > 0
                    ? data.buffer.slice(byteOffset)
                    : data.buffer

            const file = self.activate()
            file.location = offset
            const wrote = await file.write(chunk)

            self.debug &&
              console.log(`<< write ${wrote} ${self.url} <${offset}, ${size}>`)

            return wrote
          }
          static async delete(self, { offset, size }) {
            this.debug &&
              console.log(`>> delete ${self.url} <${offset}, ${size}>`)
            const file = self.activate()
            await promise(file.truncate(offset))

            this.debug &&
              console.log(`<< delete ${self.url} <${offset}, ${size}>`)
          }
          static async stat(self) {
            self.debug && console.log(`>> stat ${self.url}`)
            const file = self.activate()
            const stat = await promise(file.getMetadata())
            self.debug &&
              console.log(`<< stat {size:${stat.size}} ${self.url} `)

            return stat
          }
          static async close(self) {
            self.debug && console.log(`>> close ${self.url}`)
            const { lockedFile } = this
            if (lockedFile.active) {
              await promise(lockedFile.flush())
            }
            await self.volume.save(self.url, self.file)
            this.lockedFile = null
            this.file = null
            self.debug && console.log(`<< close ${self.url}`)
          }
          static async destroy(self) {
            self.debug && console.log(`>> destroy ${self.url}`)
            await self.volume.delete(self.url)
            self.debug && console.log(`<< destroy ${self.url}`)
          }

          static async awake(self) {
            const { workQueue } = self
            self.isIdle = false
            let index = 0
            while (index < workQueue.length) {
              const request = workQueue[index++]
              await this.wait(self, request)
            }
            workQueue.length = 0
            self.isIdle = true
            if (self.file) {
              await self.volume.save(self.url, self.file)
            }
          }
          static schedule(self, request) {
            self.workQueue.push(request)
            if (self.isIdle) {
              this.awake(self)
            }
          }
          static perform(self, request) {
            switch (request.type) {
              case RequestType.open: {
                return this.open(self, request)
              }
              case RequestType.read: {
                return this.read(self, request)
              }
              case RequestType.write: {
                return this.write(self, request)
              }
              case RequestType.delete: {
                return this.delete(self, request)
              }
              case RequestType.stat: {
                return this.stat(self, request)
              }
              case RequestType.close: {
                return this.close(self, request)
              }
              case RequestType.destroy: {
                return this.destory(self, request)
              }
            }
          }
          static async wait(self, request) {
            try {
              const result = await this.perform(self, request)
              request.callback(null, result)
            } catch (error) {
              request.callback(error)
            }
          }
          _open(request) {
            request.mode = "readwrite"
            RandomAccessIDBFile.schedule(this, request)
          }
          _openReadonly(request) {
            request.mode = "readonly"
            RandomAccessIDBFile.schedule(this, request)
          }
          _write(request) {
            RandomAccessIDBFile.schedule(this, request)
          }
          _read(request) {
            RandomAccessIDBFile.schedule(this, request)
          }
          _del(request) {
            RandomAccessIDBFile.schedule(this, request)
          }
          _stat(request) {
            RandomAccessIDBFile.wait(this, request)
          }
          _close(request) {
            RandomAccessIDBFile.schedule(this, request)
          }
          _destroy(request) {
            RandomAccessIDBFile.schedule(this, request)
          }
          constructor(volume, url, options) {
            super()
            this.volume = volume
            this.url = url
            this.options = options
            this.file = null
            this.mode = null
            this.lockedFile = null

            this.workQueue = []
            this.isIdle = true
            this.debug = !!volume.options.debug
          }
          activate() {
            const { lockedFile, file, mode } = this
            if (lockedFile && lockedFile.active) {
              return lockedFile
            } else {
              const lockedFile = file.open(mode)
              this.lockedFile = lockedFile
              return lockedFile
            }
          }
        }

        const RequestType = {
          open: 0,
          read: 1,
          write: 2,
          delete: 3,
          stat: 4,
          close: 5,
          destroy: 6
        }

        module.exports = RandomAccessIDBFile
      },
      { Buffer: 1, "random-access-storage": 47 }
    ]
  },
  {},
  [86]
)
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LWxydS9jcmMxNi5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1scnUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXRvbWljLWJhdGNoZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkLXJsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRmaWVsZC1ybGUvbm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvYml0ZmllbGQtcmxlL25vZGVfbW9kdWxlcy92YXJpbnQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkLXJsZS9ub2RlX21vZHVsZXMvdmFyaW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkLXJsZS9ub2RlX21vZHVsZXMvdmFyaW50L2xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9ibGFrZTJiLXdhc20vYmxha2UyYi5qcyIsIm5vZGVfbW9kdWxlcy9ibGFrZTJiLXdhc20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmxha2UyYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLWFsbG9jLXVuc2FmZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItYWxsb2MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLWVxdWFscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItZmlsbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItZnJvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWxrLXdyaXRlLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2RlY3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmxhdC10cmVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zyb20yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS1wcm90b2NvbC9mZWVkLmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS1wcm90b2NvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcmNvcmUtcHJvdG9jb2wvbWVzc2FnZXMuanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS9saWIvYml0ZmllbGQuanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2xpYi9jcnlwdG8uanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2xpYi9yZXBsaWNhdGUuanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2xpYi9zdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS9saWIvdHJlZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xhc3Qtb25lLXdpbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVtb3J5LXBhZ2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lcmtsZS10cmVlLXN0cmVhbS9nZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvbmFub2Fzc2VydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9jb2wtYnVmZmVycy1lbmNvZGluZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZG9tLWFjY2Vzcy1maWxlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFuZG9tLWFjY2Vzcy1zdG9yYWdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmVkLXZhcmludC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaXBoYXNoMjQvZmFsbGJhY2suanMiLCJub2RlX21vZHVsZXMvc2lwaGFzaDI0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpcGhhc2gyNC9zaXBoYXNoMjQuanMiLCJub2RlX21vZHVsZXMvc29kaXVtLWphdmFzY3JpcHQvY3J5cHRvX2dlbmVyaWNoYXNoLmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS1qYXZhc2NyaXB0L2NyeXB0b19rZGYuanMiLCJub2RlX21vZHVsZXMvc29kaXVtLWphdmFzY3JpcHQvY3J5cHRvX3Nob3J0aGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9zb2RpdW0tamF2YXNjcmlwdC9jcnlwdG9fc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS1qYXZhc2NyaXB0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS1qYXZhc2NyaXB0L3JhbmRvbWJ5dGVzLmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS11bml2ZXJzYWwvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3J0ZWQtaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zcGFyc2UtYml0ZmllbGQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3RodW5reS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3VpbnQ2NGJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Vub3JkZXJlZC1hcnJheS1yZW1vdmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdW5vcmRlcmVkLXNldC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMveHNhbHNhMjAvaW5kZXguanMiLCJub2RlX21vZHVsZXMveHNhbHNhMjAveHNhbHNhMjAuanMiLCJzcmMvaWRiLWh5cGVybG9nLmpzIiwic3JjL3JhbmRvbS1hY2Nlc3MtaWRiLWZpbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6VEE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6akNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlSQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzN3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hDQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzliQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSB8fCAodmFsdWUgJiYgaXNBcnJheUJ1ZmZlcih2YWx1ZS5idWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvYmopIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZikpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNBcnJheUJ1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVycyBmcm9tIGFub3RoZXIgY29udGV4dCAoaS5lLiBhbiBpZnJhbWUpIGRvIG5vdCBwYXNzIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2tcbi8vIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIHZhbGlkLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIgKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicgJiZcbiAgICAgIHR5cGVvZiBvYmouYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpXG59XG5cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvLyBjcmMxNiBpbXBsLCBvcHRpbWl6ZWQgZm9yIG51bWVyaWMgaW5wdXRzXG5cbnZhciBUQUJMRSA9IFtcbiAgMHgwMDAwLCAweDEwMjEsIDB4MjA0MiwgMHgzMDYzLCAweDQwODQsIDB4NTBhNSwgMHg2MGM2LCAweDcwZTcsXG4gIDB4ODEwOCwgMHg5MTI5LCAweGExNGEsIDB4YjE2YiwgMHhjMThjLCAweGQxYWQsIDB4ZTFjZSwgMHhmMWVmLFxuICAweDEyMzEsIDB4MDIxMCwgMHgzMjczLCAweDIyNTIsIDB4NTJiNSwgMHg0Mjk0LCAweDcyZjcsIDB4NjJkNixcbiAgMHg5MzM5LCAweDgzMTgsIDB4YjM3YiwgMHhhMzVhLCAweGQzYmQsIDB4YzM5YywgMHhmM2ZmLCAweGUzZGUsXG4gIDB4MjQ2MiwgMHgzNDQzLCAweDA0MjAsIDB4MTQwMSwgMHg2NGU2LCAweDc0YzcsIDB4NDRhNCwgMHg1NDg1LFxuICAweGE1NmEsIDB4YjU0YiwgMHg4NTI4LCAweDk1MDksIDB4ZTVlZSwgMHhmNWNmLCAweGM1YWMsIDB4ZDU4ZCxcbiAgMHgzNjUzLCAweDI2NzIsIDB4MTYxMSwgMHgwNjMwLCAweDc2ZDcsIDB4NjZmNiwgMHg1Njk1LCAweDQ2YjQsXG4gIDB4Yjc1YiwgMHhhNzdhLCAweDk3MTksIDB4ODczOCwgMHhmN2RmLCAweGU3ZmUsIDB4ZDc5ZCwgMHhjN2JjLFxuICAweDQ4YzQsIDB4NThlNSwgMHg2ODg2LCAweDc4YTcsIDB4MDg0MCwgMHgxODYxLCAweDI4MDIsIDB4MzgyMyxcbiAgMHhjOWNjLCAweGQ5ZWQsIDB4ZTk4ZSwgMHhmOWFmLCAweDg5NDgsIDB4OTk2OSwgMHhhOTBhLCAweGI5MmIsXG4gIDB4NWFmNSwgMHg0YWQ0LCAweDdhYjcsIDB4NmE5NiwgMHgxYTcxLCAweDBhNTAsIDB4M2EzMywgMHgyYTEyLFxuICAweGRiZmQsIDB4Y2JkYywgMHhmYmJmLCAweGViOWUsIDB4OWI3OSwgMHg4YjU4LCAweGJiM2IsIDB4YWIxYSxcbiAgMHg2Y2E2LCAweDdjODcsIDB4NGNlNCwgMHg1Y2M1LCAweDJjMjIsIDB4M2MwMywgMHgwYzYwLCAweDFjNDEsXG4gIDB4ZWRhZSwgMHhmZDhmLCAweGNkZWMsIDB4ZGRjZCwgMHhhZDJhLCAweGJkMGIsIDB4OGQ2OCwgMHg5ZDQ5LFxuICAweDdlOTcsIDB4NmViNiwgMHg1ZWQ1LCAweDRlZjQsIDB4M2UxMywgMHgyZTMyLCAweDFlNTEsIDB4MGU3MCxcbiAgMHhmZjlmLCAweGVmYmUsIDB4ZGZkZCwgMHhjZmZjLCAweGJmMWIsIDB4YWYzYSwgMHg5ZjU5LCAweDhmNzgsXG4gIDB4OTE4OCwgMHg4MWE5LCAweGIxY2EsIDB4YTFlYiwgMHhkMTBjLCAweGMxMmQsIDB4ZjE0ZSwgMHhlMTZmLFxuICAweDEwODAsIDB4MDBhMSwgMHgzMGMyLCAweDIwZTMsIDB4NTAwNCwgMHg0MDI1LCAweDcwNDYsIDB4NjA2NyxcbiAgMHg4M2I5LCAweDkzOTgsIDB4YTNmYiwgMHhiM2RhLCAweGMzM2QsIDB4ZDMxYywgMHhlMzdmLCAweGYzNWUsXG4gIDB4MDJiMSwgMHgxMjkwLCAweDIyZjMsIDB4MzJkMiwgMHg0MjM1LCAweDUyMTQsIDB4NjI3NywgMHg3MjU2LFxuICAweGI1ZWEsIDB4YTVjYiwgMHg5NWE4LCAweDg1ODksIDB4ZjU2ZSwgMHhlNTRmLCAweGQ1MmMsIDB4YzUwZCxcbiAgMHgzNGUyLCAweDI0YzMsIDB4MTRhMCwgMHgwNDgxLCAweDc0NjYsIDB4NjQ0NywgMHg1NDI0LCAweDQ0MDUsXG4gIDB4YTdkYiwgMHhiN2ZhLCAweDg3OTksIDB4OTdiOCwgMHhlNzVmLCAweGY3N2UsIDB4YzcxZCwgMHhkNzNjLFxuICAweDI2ZDMsIDB4MzZmMiwgMHgwNjkxLCAweDE2YjAsIDB4NjY1NywgMHg3Njc2LCAweDQ2MTUsIDB4NTYzNCxcbiAgMHhkOTRjLCAweGM5NmQsIDB4ZjkwZSwgMHhlOTJmLCAweDk5YzgsIDB4ODllOSwgMHhiOThhLCAweGE5YWIsXG4gIDB4NTg0NCwgMHg0ODY1LCAweDc4MDYsIDB4NjgyNywgMHgxOGMwLCAweDA4ZTEsIDB4Mzg4MiwgMHgyOGEzLFxuICAweGNiN2QsIDB4ZGI1YywgMHhlYjNmLCAweGZiMWUsIDB4OGJmOSwgMHg5YmQ4LCAweGFiYmIsIDB4YmI5YSxcbiAgMHg0YTc1LCAweDVhNTQsIDB4NmEzNywgMHg3YTE2LCAweDBhZjEsIDB4MWFkMCwgMHgyYWIzLCAweDNhOTIsXG4gIDB4ZmQyZSwgMHhlZDBmLCAweGRkNmMsIDB4Y2Q0ZCwgMHhiZGFhLCAweGFkOGIsIDB4OWRlOCwgMHg4ZGM5LFxuICAweDdjMjYsIDB4NmMwNywgMHg1YzY0LCAweDRjNDUsIDB4M2NhMiwgMHgyYzgzLCAweDFjZTAsIDB4MGNjMSxcbiAgMHhlZjFmLCAweGZmM2UsIDB4Y2Y1ZCwgMHhkZjdjLCAweGFmOWIsIDB4YmZiYSwgMHg4ZmQ5LCAweDlmZjgsXG4gIDB4NmUxNywgMHg3ZTM2LCAweDRlNTUsIDB4NWU3NCwgMHgyZTkzLCAweDNlYjIsIDB4MGVkMSwgMHgxZWYwXG5dXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMTZcblxuZnVuY3Rpb24gY3JjMTYgKG4pIHtcbiAgdmFyIGNyYyA9IDBcbiAgdmFyIHIgPSAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICByID0gbiAmIDB4ZmZcbiAgICBuID0gKG4gLSByKSAvIDI1NlxuICAgIGNyYyA9ICgoY3JjIDw8IDgpIF4gVEFCTEVbKChjcmMgPj4gOCkgXiByKSAmIDB4ZmZdKSAmIDB4ZmZmZlxuICB9XG5cbiAgcmV0dXJuIGNyY1xufVxuIiwidmFyIGhhc2ggPSByZXF1aXJlKCcuL2NyYzE2JylcblxubW9kdWxlLmV4cG9ydHMgPSBMUlVcblxuZnVuY3Rpb24gTFJVIChtYXgsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExSVSkpIHJldHVybiBuZXcgTFJVKG1heCwgb3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICAvLyBob3cgbWFueSBjb2xsaXNpb25zIGJlZm9yZSBldmljdGluZyAoZmFjdG9yIG9mIHR3byBmb3IgZmFzdCBtb2R1bG8pXG4gIHRoaXMuY29sbGlzaW9ucyA9IGZhY3Rvck9mVHdvKG9wdHMuY29sbGlzaW9ucyB8fCBvcHRzLmJ1Y2tldFNpemUgfHwgNClcbiAgLy8gYnVja2V0cyBzaG91bGQgYmUgYSBmYWN0b3Igb2YgdHdvIGZvciBmYXN0IG1vZHVsbyBhcyB3ZWxsXG4gIHRoaXMuYnVja2V0cyA9IGZhY3Rvck9mKG1heCwgdGhpcy5jb2xsaXNpb25zKSAvIHRoaXMuY29sbGlzaW9uc1xuXG4gIC8vIHdlIHVzZSAxNmJpdCBoYXNoaW5nIHRvIGJ1Y2tldCBpbmRleCBtdXN0IGJlIDwweGZmZmZcbiAgd2hpbGUgKHRoaXMuYnVja2V0cyA+IDY1NTM2KSB7XG4gICAgdGhpcy5idWNrZXRzID4+PSAxXG4gICAgdGhpcy5jb2xsaXNpb25zIDw8PSAxXG4gIH1cblxuICB0aGlzLnNpemUgPSB0aGlzLmJ1Y2tldHMgKiB0aGlzLmNvbGxpc2lvbnNcbiAgdGhpcy53cmFwID0gIW9wdHMuaW5kZXhlZFZhbHVlc1xuICB0aGlzLmNhY2hlID0gbmV3IEFycmF5KHRoaXMuc2l6ZSlcbiAgdGhpcy5oYXNoID0gdGhpcy5idWNrZXRzID09PSA2NTUzNiA/IGhhc2ggOiBtYXNrZWRIYXNoKHRoaXMuYnVja2V0cyAtIDEpXG4gIHRoaXMuZXZpY3QgPSBvcHRzLmV2aWN0IHx8IG51bGxcbn1cblxuTFJVLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbCkge1xuICB2YXIgcGFnZVN0YXJ0ID0gdGhpcy5jb2xsaXNpb25zICogdGhpcy5oYXNoKGluZGV4KVxuICB2YXIgcGFnZUVuZCA9IHBhZ2VTdGFydCArIHRoaXMuY29sbGlzaW9uc1xuICB2YXIgcHRyID0gcGFnZVN0YXJ0XG4gIHZhciBwYWdlID0gbnVsbFxuXG4gIHdoaWxlIChwdHIgPCBwYWdlRW5kKSB7XG4gICAgcGFnZSA9IHRoaXMuY2FjaGVbcHRyXVxuXG4gICAgaWYgKCFwYWdlKSB7XG4gICAgICAvLyBubyBleGl0aW5nIHZlcnNpb24sIGJ1dCB3ZSBoYXZlIHNwYWNlIHRvIHN0b3JlIGl0XG4gICAgICBwYWdlID0gdGhpcy5jYWNoZVtwdHJdID0gdGhpcy53cmFwID8gbmV3IE5vZGUoaW5kZXgsIHZhbCkgOiB2YWxcbiAgICAgIG1vdmUodGhpcy5jYWNoZSwgcGFnZVN0YXJ0LCBwdHIsIHBhZ2UpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocGFnZS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyB2ZXJzaW9uIGFuZCBtb3ZlIHRvIGhlYWQgb2YgYnVja2V0XG4gICAgICBpZiAodGhpcy53cmFwKSBwYWdlLnZhbHVlID0gdmFsXG4gICAgICBlbHNlIHRoaXMuY2FjaGVbcHRyXSA9IHZhbFxuICAgICAgbW92ZSh0aGlzLmNhY2hlLCBwYWdlU3RhcnQsIHB0ciwgcGFnZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHB0cisrXG4gIH1cblxuICAvLyBidWNrZXQgaXMgZnVsbCwgdXBkYXRlIG9sZGVzdCAobGFzdCBlbGVtZW50IGluIGJ1Y2tldClcbiAgaWYgKHRoaXMud3JhcCkge1xuICAgIGlmICh0aGlzLmV2aWN0KSB0aGlzLmV2aWN0KHBhZ2UuaW5kZXgsIHBhZ2UudmFsdWUpXG4gICAgcGFnZS5pbmRleCA9IGluZGV4XG4gICAgcGFnZS52YWx1ZSA9IHZhbFxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmV2aWN0KSB0aGlzLmV2aWN0KHBhZ2UuaW5kZXgsIHBhZ2UpXG4gICAgdGhpcy5jYWNoZVtwdHIgLSAxXSA9IHZhbFxuICB9XG4gIG1vdmUodGhpcy5jYWNoZSwgcGFnZVN0YXJ0LCBwdHIgLSAxLCBwYWdlKVxufVxuXG5MUlUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB2YXIgcGFnZVN0YXJ0ID0gdGhpcy5jb2xsaXNpb25zICogdGhpcy5oYXNoKGluZGV4KVxuICB2YXIgcGFnZUVuZCA9IHBhZ2VTdGFydCArIHRoaXMuY29sbGlzaW9uc1xuICB2YXIgcHRyID0gcGFnZVN0YXJ0XG5cbiAgd2hpbGUgKHB0ciA8IHBhZ2VFbmQpIHtcbiAgICB2YXIgcGFnZSA9IHRoaXMuY2FjaGVbcHRyKytdXG5cbiAgICBpZiAoIXBhZ2UpIHJldHVybiBudWxsXG4gICAgaWYgKHBhZ2UuaW5kZXggIT09IGluZGV4KSBjb250aW51ZVxuXG4gICAgLy8gd2UgZm91bmQgaXQhIG1vdmUgdG8gaGVhZCBvZiBidWNrZXQgYW5kIHJldHVybiB2YWx1ZVxuICAgIG1vdmUodGhpcy5jYWNoZSwgcGFnZVN0YXJ0LCBwdHIgLSAxLCBwYWdlKVxuXG4gICAgcmV0dXJuIHRoaXMud3JhcCA/IHBhZ2UudmFsdWUgOiBwYWdlXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBtb3ZlIChsaXN0LCBpbmRleCwgaXRlbUluZGV4LCBpdGVtKSB7XG4gIHdoaWxlIChpdGVtSW5kZXggPiBpbmRleCkgbGlzdFtpdGVtSW5kZXhdID0gbGlzdFstLWl0ZW1JbmRleF1cbiAgbGlzdFtpbmRleF0gPSBpdGVtXG59XG5cbmZ1bmN0aW9uIE5vZGUgKGluZGV4LCB2YWx1ZSkge1xuICB0aGlzLmluZGV4ID0gaW5kZXhcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGZhY3Rvck9mIChuLCBmYWN0b3IpIHtcbiAgbiA9IGZhY3Rvck9mVHdvKG4pXG4gIHdoaWxlIChuICYgKGZhY3RvciAtIDEpKSBuIDw8PSAxXG4gIHJldHVybiBuXG59XG5cbmZ1bmN0aW9uIGZhY3Rvck9mVHdvIChuKSB7XG4gIGlmIChuICYmICEobiAmIChuIC0gMSkpKSByZXR1cm4gblxuICB2YXIgcCA9IDFcbiAgd2hpbGUgKHAgPCBuKSBwIDw8PSAxXG4gIHJldHVybiBwXG59XG5cbmZ1bmN0aW9uIG1hc2tlZEhhc2ggKG1hc2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGhhc2gobikgJiBtYXNrXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYmF0Y2hlclxuXG5mdW5jdGlvbiBiYXRjaGVyIChydW4pIHtcbiAgdmFyIHJ1bm5pbmcgPSBmYWxzZVxuICB2YXIgcGVuZGluZ0JhdGNoID0gbnVsbFxuICB2YXIgcGVuZGluZ0NhbGxiYWNrcyA9IG51bGxcbiAgdmFyIGNhbGxiYWNrcyA9IG51bGxcblxuICByZXR1cm4gYXBwZW5kXG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgaWYgKGNhbGxiYWNrcykgY2FsbEFsbChjYWxsYmFja3MsIGVycilcblxuICAgIHJ1bm5pbmcgPSBmYWxzZVxuICAgIGNhbGxiYWNrcyA9IHBlbmRpbmdDYWxsYmFja3NcbiAgICB2YXIgbmV4dEJhdGNoID0gcGVuZGluZ0JhdGNoXG5cbiAgICBwZW5kaW5nQmF0Y2ggPSBudWxsXG4gICAgcGVuZGluZ0NhbGxiYWNrcyA9IG51bGxcblxuICAgIGlmICghbmV4dEJhdGNoIHx8ICFuZXh0QmF0Y2gubGVuZ3RoKSB7XG4gICAgICBpZiAoIWNhbGxiYWNrcyB8fCAhY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFja3MgPSBudWxsXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKCFuZXh0QmF0Y2gpIG5leHRCYXRjaCA9IFtdXG4gICAgfVxuXG4gICAgcnVubmluZyA9IHRydWVcbiAgICBydW4obmV4dEJhdGNoLCBkb25lKVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kICh2YWwsIGNiKSB7XG4gICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgIGlmICghcGVuZGluZ0JhdGNoKSB7XG4gICAgICAgIHBlbmRpbmdCYXRjaCA9IFtdXG4gICAgICAgIHBlbmRpbmdDYWxsYmFja3MgPSBbXVxuICAgICAgfVxuICAgICAgcHVzaEFsbChwZW5kaW5nQmF0Y2gsIHZhbClcbiAgICAgIGlmIChjYikgcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2IpIGNhbGxiYWNrcyA9IFtjYl1cbiAgICAgIHJ1bm5pbmcgPSB0cnVlXG4gICAgICBydW4oQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0sIGRvbmUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hBbGwgKGxpc3QsIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSBwdXNoQXJyYXkobGlzdCwgdmFsKVxuICBlbHNlIGxpc3QucHVzaCh2YWwpXG59XG5cbmZ1bmN0aW9uIHB1c2hBcnJheSAobGlzdCwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSBsaXN0LnB1c2godmFsW2ldKVxufVxuXG5mdW5jdGlvbiBjYWxsQWxsIChsaXN0LCBlcnIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSBsaXN0W2ldKGVycilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwidmFyIHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlXG5leHBvcnRzLmVuY29kZS5ieXRlcyA9IDBcbmV4cG9ydHMuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuXG5leHBvcnRzLmRlY29kZSA9IGRlY29kZVxuZXhwb3J0cy5kZWNvZGUuYnl0ZXMgPSAwXG5leHBvcnRzLmRlY29kaW5nTGVuZ3RoID0gZGVjb2RpbmdMZW5ndGhcblxuZnVuY3Rpb24gU3RhdGUgKGlucHV0LCBvdXRwdXQsIG9mZnNldCkge1xuICB0aGlzLmlucHV0T2Zmc2V0ID0gMFxuICB0aGlzLmlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoXG4gIHRoaXMuaW5wdXQgPSBpbnB1dFxuICB0aGlzLm91dHB1dE9mZnNldCA9IG9mZnNldFxuICB0aGlzLm91dHB1dCA9IG91dHB1dFxufVxuXG5mdW5jdGlvbiBlbmNvZGUgKGJpdGZpZWxkLCBidWZmZXIsIG9mZnNldCkge1xuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICBpZiAoIWJ1ZmZlcikgYnVmZmVyID0gbmV3IEJ1ZmZlcihlbmNvZGluZ0xlbmd0aChiaXRmaWVsZCkpXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShiaXRmaWVsZCwgYnVmZmVyLCBvZmZzZXQpXG4gIHJsZShzdGF0ZSlcbiAgZW5jb2RlLmJ5dGVzID0gc3RhdGUub3V0cHV0T2Zmc2V0IC0gb2Zmc2V0XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKGJpdGZpZWxkKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShiaXRmaWVsZCwgbnVsbCwgMClcbiAgcmxlKHN0YXRlKVxuICByZXR1cm4gc3RhdGUub3V0cHV0T2Zmc2V0XG59XG5cbmZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICB2YXIgYml0ZmllbGQgPSBuZXcgQnVmZmVyKGRlY29kaW5nTGVuZ3RoKGJ1ZmZlciwgb2Zmc2V0KSlcbiAgdmFyIHB0ciA9IDBcblxuICB3aGlsZSAob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCkge1xuICAgIHZhciBuZXh0ID0gdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICB2YXIgcmVwZWF0ID0gbmV4dCAmIDFcbiAgICB2YXIgbGVuID0gcmVwZWF0ID8gKG5leHQgLSAobmV4dCAmIDMpKSAvIDQgOiBuZXh0IC8gMlxuXG4gICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcblxuICAgIGlmIChyZXBlYXQpIHtcbiAgICAgIGJpdGZpZWxkLmZpbGwobmV4dCAmIDIgPyAyNTUgOiAwLCBwdHIsIHB0ciArIGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyLmNvcHkoYml0ZmllbGQsIHB0ciwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pXG4gICAgICBvZmZzZXQgKz0gbGVuXG4gICAgfVxuXG4gICAgcHRyICs9IGxlblxuICB9XG5cbiAgZGVjb2RlLmJ5dGVzID0gYnVmZmVyLmxlbmd0aCAtIG9mZnNldFxuXG4gIHJldHVybiBiaXRmaWVsZFxufVxuXG5mdW5jdGlvbiBkZWNvZGluZ0xlbmd0aCAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICB2YXIgbGVuID0gMFxuXG4gIHdoaWxlIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgdmFyIG5leHQgPSB2YXJpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG5cbiAgICB2YXIgcmVwZWF0ID0gbmV4dCAmIDFcbiAgICB2YXIgc2xpY2UgPSByZXBlYXQgPyAobmV4dCAtIChuZXh0ICYgMykpIC8gNCA6IG5leHQgLyAyXG5cbiAgICBsZW4gKz0gc2xpY2VcbiAgICBpZiAoIXJlcGVhdCkgb2Zmc2V0ICs9IHNsaWNlXG4gIH1cblxuICBpZiAob2Zmc2V0ID4gYnVmZmVyLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJMRSBiaXRmaWVsZCcpXG5cbiAgcmV0dXJuIGxlblxufVxuXG5mdW5jdGlvbiBybGUgKHN0YXRlKSB7XG4gIHZhciBsZW4gPSAwXG4gIHZhciBiaXRzID0gMFxuICB2YXIgaW5wdXQgPSBzdGF0ZS5pbnB1dFxuXG4gIHdoaWxlIChzdGF0ZS5pbnB1dExlbmd0aCA+IDAgJiYgIWlucHV0W3N0YXRlLmlucHV0TGVuZ3RoIC0gMV0pIHN0YXRlLmlucHV0TGVuZ3RoLS1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmlucHV0TGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaW5wdXRbaV0gPT09IGJpdHMpIHtcbiAgICAgIGxlbisrXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChsZW4pIGVuY29kZVVwZGF0ZShzdGF0ZSwgaSwgbGVuLCBiaXRzKVxuXG4gICAgaWYgKGlucHV0W2ldID09PSAwIHx8IGlucHV0W2ldID09PSAyNTUpIHtcbiAgICAgIGJpdHMgPSBpbnB1dFtpXVxuICAgICAgbGVuID0gMVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW4gPSAwXG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbikgZW5jb2RlVXBkYXRlKHN0YXRlLCBzdGF0ZS5pbnB1dExlbmd0aCwgbGVuLCBiaXRzKVxuICBlbmNvZGVGaW5hbChzdGF0ZSlcbn1cblxuZnVuY3Rpb24gZW5jb2RlSGVhZCAoc3RhdGUsIGVuZCkge1xuICB2YXIgaGVhZExlbmd0aCA9IGVuZCAtIHN0YXRlLmlucHV0T2Zmc2V0XG4gIHZhcmludC5lbmNvZGUoMiAqIGhlYWRMZW5ndGgsIHN0YXRlLm91dHB1dCwgc3RhdGUub3V0cHV0T2Zmc2V0KVxuICBzdGF0ZS5vdXRwdXRPZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuICBzdGF0ZS5pbnB1dC5jb3B5KHN0YXRlLm91dHB1dCwgc3RhdGUub3V0cHV0T2Zmc2V0LCBzdGF0ZS5pbnB1dE9mZnNldCwgZW5kKVxuICBzdGF0ZS5vdXRwdXRPZmZzZXQgKz0gaGVhZExlbmd0aFxufVxuXG5mdW5jdGlvbiBlbmNvZGVGaW5hbCAoc3RhdGUpIHtcbiAgdmFyIGhlYWRMZW5ndGggPSBzdGF0ZS5pbnB1dExlbmd0aCAtIHN0YXRlLmlucHV0T2Zmc2V0XG4gIGlmICghaGVhZExlbmd0aCkgcmV0dXJuXG5cbiAgaWYgKCFzdGF0ZS5vdXRwdXQpIHtcbiAgICBzdGF0ZS5vdXRwdXRPZmZzZXQgKz0gKGhlYWRMZW5ndGggKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoMiAqIGhlYWRMZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIGVuY29kZUhlYWQoc3RhdGUsIHN0YXRlLmlucHV0TGVuZ3RoKVxuICB9XG5cbiAgc3RhdGUuaW5wdXRPZmZzZXQgPSBzdGF0ZS5pbnB1dExlbmd0aFxufVxuXG5mdW5jdGlvbiBlbmNvZGVVcGRhdGUgKHN0YXRlLCBpLCBsZW4sIGJpdCkge1xuICB2YXIgaGVhZExlbmd0aCA9IGkgLSBsZW4gLSBzdGF0ZS5pbnB1dE9mZnNldFxuICB2YXIgaGVhZENvc3QgPSAoaGVhZExlbmd0aCA/IHZhcmludC5lbmNvZGluZ0xlbmd0aCgyICogaGVhZExlbmd0aCkgKyBoZWFkTGVuZ3RoIDogMClcbiAgdmFyIGVuYyA9IDQgKiBsZW4gKyAoYml0ID8gMiA6IDApICsgMSAvLyBsZW4gPDwgMiB8IGJpdCA8PCAxIHwgMVxuICB2YXIgZW5jQ29zdCA9IGhlYWRDb3N0ICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKGVuYylcbiAgdmFyIGJhc2VDb3N0ID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKDIgKiAoaSAtIHN0YXRlLmlucHV0T2Zmc2V0KSkgKyBpIC0gc3RhdGUuaW5wdXRPZmZzZXRcblxuICBpZiAoZW5jQ29zdCA+PSBiYXNlQ29zdCkgcmV0dXJuXG5cbiAgaWYgKCFzdGF0ZS5vdXRwdXQpIHtcbiAgICBzdGF0ZS5vdXRwdXRPZmZzZXQgKz0gZW5jQ29zdFxuICAgIHN0YXRlLmlucHV0T2Zmc2V0ID0gaVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGhlYWRMZW5ndGgpIGVuY29kZUhlYWQoc3RhdGUsIGkgLSBsZW4pXG5cbiAgdmFyaW50LmVuY29kZShlbmMsIHN0YXRlLm91dHB1dCwgc3RhdGUub3V0cHV0T2Zmc2V0KVxuICBzdGF0ZS5vdXRwdXRPZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuICBzdGF0ZS5pbnB1dE9mZnNldCA9IGlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVhZFxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyAgICA9IDBcbiAgICAsIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gICAgLCBzaGlmdCAgPSAwXG4gICAgLCBjb3VudGVyID0gb2Zmc2V0XG4gICAgLCBiXG4gICAgLCBsID0gYnVmLmxlbmd0aFxuXG4gIGRvIHtcbiAgICBpZihjb3VudGVyID49IGwpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwXG4gICAgICByZWFkLmJ5dGVzUmVhZCA9IDAgLy8gREVQUkVDQVRFRFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICBiID0gYnVmW2NvdW50ZXIrK11cbiAgICByZXMgKz0gc2hpZnQgPCAyOFxuICAgICAgPyAoYiAmIFJFU1QpIDw8IHNoaWZ0XG4gICAgICA6IChiICYgUkVTVCkgKiBNYXRoLnBvdygyLCBzaGlmdClcbiAgICBzaGlmdCArPSA3XG4gIH0gd2hpbGUgKGIgPj0gTVNCKVxuXG4gIHJlYWQuYnl0ZXMgPSBjb3VudGVyIC0gb2Zmc2V0XG5cbiAgcmV0dXJuIHJlc1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuICAsIE1TQkFMTCA9IH5SRVNUXG4gICwgSU5UID0gTWF0aC5wb3coMiwgMzEpXG5cbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIG91dCA9IG91dCB8fCBbXVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgd2hpbGUobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gLz0gMTI4XG4gIH1cbiAgd2hpbGUobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSA+Pj49IDdcbiAgfVxuICBvdXRbb2Zmc2V0XSA9IG51bSB8IDBcbiAgXG4gIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldCArIDFcbiAgXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZTogcmVxdWlyZSgnLi9lbmNvZGUuanMnKVxuICAsIGRlY29kZTogcmVxdWlyZSgnLi9kZWNvZGUuanMnKVxuICAsIGVuY29kaW5nTGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aC5qcycpXG59XG4iLCJcbnZhciBOMSA9IE1hdGgucG93KDIsICA3KVxudmFyIE4yID0gTWF0aC5wb3coMiwgMTQpXG52YXIgTjMgPSBNYXRoLnBvdygyLCAyMSlcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KVxudmFyIE41ID0gTWF0aC5wb3coMiwgMzUpXG52YXIgTjYgPSBNYXRoLnBvdygyLCA0MilcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KVxudmFyIE44ID0gTWF0aC5wb3coMiwgNTYpXG52YXIgTjkgPSBNYXRoLnBvdygyLCA2MylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA8IE4xID8gMVxuICA6IHZhbHVlIDwgTjIgPyAyXG4gIDogdmFsdWUgPCBOMyA/IDNcbiAgOiB2YWx1ZSA8IE40ID8gNFxuICA6IHZhbHVlIDwgTjUgPyA1XG4gIDogdmFsdWUgPCBONiA/IDZcbiAgOiB2YWx1ZSA8IE43ID8gN1xuICA6IHZhbHVlIDwgTjggPyA4XG4gIDogdmFsdWUgPCBOOSA/IDlcbiAgOiAgICAgICAgICAgICAgMTBcbiAgKVxufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRXZWJBc3NlbWJseVxuXG5sb2FkV2ViQXNzZW1ibHkuc3VwcG9ydGVkID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSAndW5kZWZpbmVkJ1xuXG5mdW5jdGlvbiBsb2FkV2ViQXNzZW1ibHkgKG9wdHMpIHtcbiAgaWYgKCFsb2FkV2ViQXNzZW1ibHkuc3VwcG9ydGVkKSByZXR1cm4gbnVsbFxuXG4gIHZhciBpbXAgPSBvcHRzICYmIG9wdHMuaW1wb3J0c1xuICB2YXIgd2FzbSA9IHRvVWludDhBcnJheSgnQUdGemJRRUFBQUFCRUFOZ0FuOS9BR0FEZjM5L0FHQUJmd0FEQlFRQUFRSUNCUVVCQVFyb0J3ZE5CUVp0WlcxdmNua0NBQXhpYkdGclpUSmlYMmx1YVhRQUFBNWliR0ZyWlRKaVgzVndaR0YwWlFBQkRXSnNZV3RsTW1KZlptbHVZV3dBQWhCaWJHRnJaVEppWDJOdmJYQnlaWE56QUFNSzAwQUVsZ01BSUFCQ0FEY0RBQ0FBUVFocVFnQTNBd0FnQUVFUWFrSUFOd01BSUFCQkdHcENBRGNEQUNBQVFTQnFRZ0EzQXdBZ0FFRW9ha0lBTndNQUlBQkJNR3BDQURjREFDQUFRVGhxUWdBM0F3QWdBRUhBQUdwQ0FEY0RBQ0FBUWNnQWFrSUFOd01BSUFCQjBBQnFRZ0EzQXdBZ0FFSFlBR3BDQURjREFDQUFRZUFBYWtJQU53TUFJQUJCNkFCcVFnQTNBd0FnQUVId0FHcENBRGNEQUNBQVFmZ0Fha0lBTndNQUlBQkJnQUZxUW9pUzg1My96UG1FNmdCQkFDa0RBSVUzQXdBZ0FFR0lBV3BDdTg2cXB0alE2N083ZjBFSUtRTUFoVGNEQUNBQVFaQUJha0tyOE5QMHIrNjh0enhCRUNrREFJVTNBd0FnQUVHWUFXcEM4ZTMwK0tXbi9hZWxmMEVZS1FNQWhUY0RBQ0FBUWFBQmFrTFJoWnJ2K3MrVWg5RUFRU0FwQXdDRk53TUFJQUJCcUFGcVFwL1krZG5Da2RxQ20zOUJLQ2tEQUlVM0F3QWdBRUd3QVdwQzYvcUcycisxOXNFZlFUQXBBd0NGTndNQUlBQkJ1QUZxUXZuQytKdVJvN1B3MndCQk9Da0RBSVUzQXdBZ0FFSEFBV3BDQURjREFDQUFRY2dCYWtJQU53TUFJQUJCMEFGcVFnQTNBd0FMYlFFRGZ5QUFRY0FCYWlFRElBQkJ5QUZxSVFRZ0JDa0RBS2NoQlFKQUEwQWdBU0FDUmcwQklBVkJnQUZHQkVBZ0F5QURLUU1BSUFXdGZEY0RBRUVBSVFVZ0FCQURDeUFBSUFWcUlBRXRBQUE2QUFBZ0JVRUJhaUVGSUFGQkFXb2hBUXdBQ3dzZ0JDQUZyVGNEQUF0a0FRTi9JQUJCd0FGcUlRRWdBRUhJQVdvaEFpQUJJQUVwQXdBZ0Fpa0RBSHczQXdBZ0FFSFFBV3BDZnpjREFDQUNLUU1BcHlFREFrQURRQ0FEUVlBQlJnMEJJQUFnQTJwQkFEb0FBQ0FEUVFGcUlRTU1BQXNMSUFJZ0E2MDNBd0FnQUJBREMrVTdBaUIrQ1g4Z0FFR0FBV29oSVNBQVFZZ0JhaUVpSUFCQmtBRnFJU01nQUVHWUFXb2hKQ0FBUWFBQmFpRWxJQUJCcUFGcUlTWWdBRUd3QVdvaEp5QUFRYmdCYWlFb0lDRXBBd0FoQVNBaUtRTUFJUUlnSXlrREFDRURJQ1FwQXdBaEJDQWxLUU1BSVFVZ0ppa0RBQ0VHSUNjcEF3QWhCeUFvS1FNQUlRaENpSkx6bmYvTStZVHFBQ0VKUXJ2T3FxYlkwT3V6dTM4aENrS3I4TlAwcis2OHR6d2hDMEx4N2ZUNHBhZjlwNlYvSVF4QzBZV2E3L3JQbElmUkFDRU5RcC9ZK2RuQ2tkcUNtMzhoRGtMcitvYmF2N1gyd1I4aEQwTDV3dmlia2FPejhOc0FJUkFnQUNrREFDRVJJQUJCQ0dvcEF3QWhFaUFBUVJCcUtRTUFJUk1nQUVFWWFpa0RBQ0VVSUFCQklHb3BBd0FoRlNBQVFTaHFLUU1BSVJZZ0FFRXdhaWtEQUNFWElBQkJPR29wQXdBaEdDQUFRY0FBYWlrREFDRVpJQUJCeUFCcUtRTUFJUm9nQUVIUUFHb3BBd0FoR3lBQVFkZ0FhaWtEQUNFY0lBQkI0QUJxS1FNQUlSMGdBRUhvQUdvcEF3QWhIaUFBUWZBQWFpa0RBQ0VmSUFCQitBQnFLUU1BSVNBZ0RTQUFRY0FCYWlrREFJVWhEU0FQSUFCQjBBRnFLUU1BaFNFUElBRWdCU0FSZkh3aEFTQU5JQUdGUWlDS0lRMGdDU0FOZkNFSklBVWdDWVZDR0lvaEJTQUJJQVVnRW54OElRRWdEU0FCaFVJUWlpRU5JQWtnRFh3aENTQUZJQW1GUWorS0lRVWdBaUFHSUJOOGZDRUNJQTRnQW9WQ0lJb2hEaUFLSUE1OElRb2dCaUFLaFVJWWlpRUdJQUlnQmlBVWZId2hBaUFPSUFLRlFoQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ1A0b2hCaUFESUFjZ0ZYeDhJUU1nRHlBRGhVSWdpaUVQSUFzZ0Qzd2hDeUFISUF1RlFoaUtJUWNnQXlBSElCWjhmQ0VESUE4Z0E0VkNFSW9oRHlBTElBOThJUXNnQnlBTGhVSS9paUVISUFRZ0NDQVhmSHdoQkNBUUlBU0ZRaUNLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNHSW9oQ0NBRUlBZ2dHSHg4SVFRZ0VDQUVoVUlRaWlFUUlBd2dFSHdoRENBSUlBeUZRaitLSVFnZ0FTQUdJQmw4ZkNFQklCQWdBWVZDSUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUlZaWlFR0lBRWdCaUFhZkh3aEFTQVFJQUdGUWhDS0lSQWdDeUFRZkNFTElBWWdDNFZDUDRvaEJpQUNJQWNnRzN4OElRSWdEU0FDaFVJZ2lpRU5JQXdnRFh3aERDQUhJQXlGUWhpS0lRY2dBaUFISUJ4OGZDRUNJQTBnQW9WQ0VJb2hEU0FNSUExOElRd2dCeUFNaFVJL2lpRUhJQU1nQ0NBZGZId2hBeUFPSUFPRlFpQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ0dJb2hDQ0FESUFnZ0hueDhJUU1nRGlBRGhVSVFpaUVPSUFrZ0Rud2hDU0FJSUFtRlFqK0tJUWdnQkNBRklCOThmQ0VFSUE4Z0JJVkNJSW9oRHlBS0lBOThJUW9nQlNBS2hVSVlpaUVGSUFRZ0JTQWdmSHdoQkNBUElBU0ZRaENLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNQNG9oQlNBQklBVWdIM3g4SVFFZ0RTQUJoVUlnaWlFTklBa2dEWHdoQ1NBRklBbUZRaGlLSVFVZ0FTQUZJQnQ4ZkNFQklBMGdBWVZDRUlvaERTQUpJQTE4SVFrZ0JTQUpoVUkvaWlFRklBSWdCaUFWZkh3aEFpQU9JQUtGUWlDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDR0lvaEJpQUNJQVlnR1h4OElRSWdEaUFDaFVJUWlpRU9JQW9nRG53aENpQUdJQXFGUWorS0lRWWdBeUFISUJwOGZDRURJQThnQTRWQ0lJb2hEeUFMSUE5OElRc2dCeUFMaFVJWWlpRUhJQU1nQnlBZ2ZId2hBeUFQSUFPRlFoQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ1A0b2hCeUFFSUFnZ0hueDhJUVFnRUNBRWhVSWdpaUVRSUF3Z0VId2hEQ0FJSUF5RlFoaUtJUWdnQkNBSUlCZDhmQ0VFSUJBZ0JJVkNFSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSS9paUVJSUFFZ0JpQVNmSHdoQVNBUUlBR0ZRaUNLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNHSW9oQmlBQklBWWdIWHg4SVFFZ0VDQUJoVUlRaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaitLSVFZZ0FpQUhJQkY4ZkNFQ0lBMGdBb1ZDSUlvaERTQU1JQTE4SVF3Z0J5QU1oVUlZaWlFSElBSWdCeUFUZkh3aEFpQU5JQUtGUWhDS0lRMGdEQ0FOZkNFTUlBY2dESVZDUDRvaEJ5QURJQWdnSEh4OElRTWdEaUFEaFVJZ2lpRU9JQWtnRG53aENTQUlJQW1GUWhpS0lRZ2dBeUFJSUJoOGZDRURJQTRnQTRWQ0VJb2hEaUFKSUE1OElRa2dDQ0FKaFVJL2lpRUlJQVFnQlNBV2ZId2hCQ0FQSUFTRlFpQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ0dJb2hCU0FFSUFVZ0ZIeDhJUVFnRHlBRWhVSVFpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFqK0tJUVVnQVNBRklCeDhmQ0VCSUEwZ0FZVkNJSW9oRFNBSklBMThJUWtnQlNBSmhVSVlpaUVGSUFFZ0JTQVpmSHdoQVNBTklBR0ZRaENLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNQNG9oQlNBQ0lBWWdIWHg4SVFJZ0RpQUNoVUlnaWlFT0lBb2dEbndoQ2lBR0lBcUZRaGlLSVFZZ0FpQUdJQkY4ZkNFQ0lBNGdBb1ZDRUlvaERpQUtJQTU4SVFvZ0JpQUtoVUkvaWlFR0lBTWdCeUFXZkh3aEF5QVBJQU9GUWlDS0lROGdDeUFQZkNFTElBY2dDNFZDR0lvaEJ5QURJQWNnRTN4OElRTWdEeUFEaFVJUWlpRVBJQXNnRDN3aEN5QUhJQXVGUWorS0lRY2dCQ0FJSUNCOGZDRUVJQkFnQklWQ0lJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJWWlpRUlJQVFnQ0NBZWZId2hCQ0FRSUFTRlFoQ0tJUkFnRENBUWZDRU1JQWdnRElWQ1A0b2hDQ0FCSUFZZ0czeDhJUUVnRUNBQmhVSWdpaUVRSUFzZ0VId2hDeUFHSUF1RlFoaUtJUVlnQVNBR0lCOThmQ0VCSUJBZ0FZVkNFSW9oRUNBTElCQjhJUXNnQmlBTGhVSS9paUVHSUFJZ0J5QVVmSHdoQWlBTklBS0ZRaUNLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNHSW9oQnlBQ0lBY2dGM3g4SVFJZ0RTQUNoVUlRaWlFTklBd2dEWHdoRENBSElBeUZRaitLSVFjZ0F5QUlJQmg4ZkNFRElBNGdBNFZDSUlvaERpQUpJQTU4SVFrZ0NDQUpoVUlZaWlFSUlBTWdDQ0FTZkh3aEF5QU9JQU9GUWhDS0lRNGdDU0FPZkNFSklBZ2dDWVZDUDRvaENDQUVJQVVnR254OElRUWdEeUFFaFVJZ2lpRVBJQW9nRDN3aENpQUZJQXFGUWhpS0lRVWdCQ0FGSUJWOGZDRUVJQThnQklWQ0VJb2hEeUFLSUE5OElRb2dCU0FLaFVJL2lpRUZJQUVnQlNBWWZId2hBU0FOSUFHRlFpQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ0dJb2hCU0FCSUFVZ0dueDhJUUVnRFNBQmhVSVFpaUVOSUFrZ0RYd2hDU0FGSUFtRlFqK0tJUVVnQWlBR0lCUjhmQ0VDSUE0Z0FvVkNJSW9oRGlBS0lBNThJUW9nQmlBS2hVSVlpaUVHSUFJZ0JpQVNmSHdoQWlBT0lBS0ZRaENLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNQNG9oQmlBRElBY2dIbng4SVFNZ0R5QURoVUlnaWlFUElBc2dEM3doQ3lBSElBdUZRaGlLSVFjZ0F5QUhJQjE4ZkNFRElBOGdBNFZDRUlvaER5QUxJQTk4SVFzZ0J5QUxoVUkvaWlFSElBUWdDQ0FjZkh3aEJDQVFJQVNGUWlDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDR0lvaENDQUVJQWdnSDN4OElRUWdFQ0FFaFVJUWlpRVFJQXdnRUh3aERDQUlJQXlGUWorS0lRZ2dBU0FHSUJOOGZDRUJJQkFnQVlWQ0lJb2hFQ0FMSUJCOElRc2dCaUFMaFVJWWlpRUdJQUVnQmlBWGZId2hBU0FRSUFHRlFoQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ1A0b2hCaUFDSUFjZ0ZueDhJUUlnRFNBQ2hVSWdpaUVOSUF3Z0RYd2hEQ0FISUF5RlFoaUtJUWNnQWlBSElCdDhmQ0VDSUEwZ0FvVkNFSW9oRFNBTUlBMThJUXdnQnlBTWhVSS9paUVISUFNZ0NDQVZmSHdoQXlBT0lBT0ZRaUNLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNHSW9oQ0NBRElBZ2dFWHg4SVFNZ0RpQURoVUlRaWlFT0lBa2dEbndoQ1NBSUlBbUZRaitLSVFnZ0JDQUZJQ0I4ZkNFRUlBOGdCSVZDSUlvaER5QUtJQTk4SVFvZ0JTQUtoVUlZaWlFRklBUWdCU0FaZkh3aEJDQVBJQVNGUWhDS0lROGdDaUFQZkNFS0lBVWdDb1ZDUDRvaEJTQUJJQVVnR254OElRRWdEU0FCaFVJZ2lpRU5JQWtnRFh3aENTQUZJQW1GUWhpS0lRVWdBU0FGSUJGOGZDRUJJQTBnQVlWQ0VJb2hEU0FKSUExOElRa2dCU0FKaFVJL2lpRUZJQUlnQmlBV2ZId2hBaUFPSUFLRlFpQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ0dJb2hCaUFDSUFZZ0dIeDhJUUlnRGlBQ2hVSVFpaUVPSUFvZ0Rud2hDaUFHSUFxRlFqK0tJUVlnQXlBSElCTjhmQ0VESUE4Z0E0VkNJSW9oRHlBTElBOThJUXNnQnlBTGhVSVlpaUVISUFNZ0J5QVZmSHdoQXlBUElBT0ZRaENLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNQNG9oQnlBRUlBZ2dHM3g4SVFRZ0VDQUVoVUlnaWlFUUlBd2dFSHdoRENBSUlBeUZRaGlLSVFnZ0JDQUlJQ0I4ZkNFRUlCQWdCSVZDRUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUkvaWlFSUlBRWdCaUFmZkh3aEFTQVFJQUdGUWlDS0lSQWdDeUFRZkNFTElBWWdDNFZDR0lvaEJpQUJJQVlnRW54OElRRWdFQ0FCaFVJUWlpRVFJQXNnRUh3aEN5QUdJQXVGUWorS0lRWWdBaUFISUJ4OGZDRUNJQTBnQW9WQ0lJb2hEU0FNSUExOElRd2dCeUFNaFVJWWlpRUhJQUlnQnlBZGZId2hBaUFOSUFLRlFoQ0tJUTBnRENBTmZDRU1JQWNnRElWQ1A0b2hCeUFESUFnZ0YzeDhJUU1nRGlBRGhVSWdpaUVPSUFrZ0Rud2hDU0FJSUFtRlFoaUtJUWdnQXlBSUlCbDhmQ0VESUE0Z0E0VkNFSW9oRGlBSklBNThJUWtnQ0NBSmhVSS9paUVJSUFRZ0JTQVVmSHdoQkNBUElBU0ZRaUNLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNHSW9oQlNBRUlBVWdIbng4SVFRZ0R5QUVoVUlRaWlFUElBb2dEM3doQ2lBRklBcUZRaitLSVFVZ0FTQUZJQk44ZkNFQklBMGdBWVZDSUlvaERTQUpJQTE4SVFrZ0JTQUpoVUlZaWlFRklBRWdCU0FkZkh3aEFTQU5JQUdGUWhDS0lRMGdDU0FOZkNFSklBVWdDWVZDUDRvaEJTQUNJQVlnRjN4OElRSWdEaUFDaFVJZ2lpRU9JQW9nRG53aENpQUdJQXFGUWhpS0lRWWdBaUFHSUJ0OGZDRUNJQTRnQW9WQ0VJb2hEaUFLSUE1OElRb2dCaUFLaFVJL2lpRUdJQU1nQnlBUmZId2hBeUFQSUFPRlFpQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ0dJb2hCeUFESUFjZ0hIeDhJUU1nRHlBRGhVSVFpaUVQSUFzZ0Qzd2hDeUFISUF1RlFqK0tJUWNnQkNBSUlCbDhmQ0VFSUJBZ0JJVkNJSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSVlpaUVJSUFRZ0NDQVVmSHdoQkNBUUlBU0ZRaENLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNQNG9oQ0NBQklBWWdGWHg4SVFFZ0VDQUJoVUlnaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaGlLSVFZZ0FTQUdJQjU4ZkNFQklCQWdBWVZDRUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUkvaWlFR0lBSWdCeUFZZkh3aEFpQU5JQUtGUWlDS0lRMGdEQ0FOZkNFTUlBY2dESVZDR0lvaEJ5QUNJQWNnRm54OElRSWdEU0FDaFVJUWlpRU5JQXdnRFh3aERDQUhJQXlGUWorS0lRY2dBeUFJSUNCOGZDRURJQTRnQTRWQ0lJb2hEaUFKSUE1OElRa2dDQ0FKaFVJWWlpRUlJQU1nQ0NBZmZId2hBeUFPSUFPRlFoQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ1A0b2hDQ0FFSUFVZ0VueDhJUVFnRHlBRWhVSWdpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFoaUtJUVVnQkNBRklCcDhmQ0VFSUE4Z0JJVkNFSW9oRHlBS0lBOThJUW9nQlNBS2hVSS9paUVGSUFFZ0JTQWRmSHdoQVNBTklBR0ZRaUNLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNHSW9oQlNBQklBVWdGbng4SVFFZ0RTQUJoVUlRaWlFTklBa2dEWHdoQ1NBRklBbUZRaitLSVFVZ0FpQUdJQko4ZkNFQ0lBNGdBb1ZDSUlvaERpQUtJQTU4SVFvZ0JpQUtoVUlZaWlFR0lBSWdCaUFnZkh3aEFpQU9JQUtGUWhDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDUDRvaEJpQURJQWNnSDN4OElRTWdEeUFEaFVJZ2lpRVBJQXNnRDN3aEN5QUhJQXVGUWhpS0lRY2dBeUFISUI1OGZDRURJQThnQTRWQ0VJb2hEeUFMSUE5OElRc2dCeUFMaFVJL2lpRUhJQVFnQ0NBVmZId2hCQ0FRSUFTRlFpQ0tJUkFnRENBUWZDRU1JQWdnRElWQ0dJb2hDQ0FFSUFnZ0czeDhJUVFnRUNBRWhVSVFpaUVRSUF3Z0VId2hEQ0FJSUF5RlFqK0tJUWdnQVNBR0lCRjhmQ0VCSUJBZ0FZVkNJSW9oRUNBTElCQjhJUXNnQmlBTGhVSVlpaUVHSUFFZ0JpQVlmSHdoQVNBUUlBR0ZRaENLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNQNG9oQmlBQ0lBY2dGM3g4SVFJZ0RTQUNoVUlnaWlFTklBd2dEWHdoRENBSElBeUZRaGlLSVFjZ0FpQUhJQlI4ZkNFQ0lBMGdBb1ZDRUlvaERTQU1JQTE4SVF3Z0J5QU1oVUkvaWlFSElBTWdDQ0FhZkh3aEF5QU9JQU9GUWlDS0lRNGdDU0FPZkNFSklBZ2dDWVZDR0lvaENDQURJQWdnRTN4OElRTWdEaUFEaFVJUWlpRU9JQWtnRG53aENTQUlJQW1GUWorS0lRZ2dCQ0FGSUJsOGZDRUVJQThnQklWQ0lJb2hEeUFLSUE5OElRb2dCU0FLaFVJWWlpRUZJQVFnQlNBY2ZId2hCQ0FQSUFTRlFoQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ1A0b2hCU0FCSUFVZ0hueDhJUUVnRFNBQmhVSWdpaUVOSUFrZ0RYd2hDU0FGSUFtRlFoaUtJUVVnQVNBRklCeDhmQ0VCSUEwZ0FZVkNFSW9oRFNBSklBMThJUWtnQlNBSmhVSS9paUVGSUFJZ0JpQVlmSHdoQWlBT0lBS0ZRaUNLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNHSW9oQmlBQ0lBWWdIM3g4SVFJZ0RpQUNoVUlRaWlFT0lBb2dEbndoQ2lBR0lBcUZRaitLSVFZZ0F5QUhJQjE4ZkNFRElBOGdBNFZDSUlvaER5QUxJQTk4SVFzZ0J5QUxoVUlZaWlFSElBTWdCeUFTZkh3aEF5QVBJQU9GUWhDS0lROGdDeUFQZkNFTElBY2dDNFZDUDRvaEJ5QUVJQWdnRkh4OElRUWdFQ0FFaFVJZ2lpRVFJQXdnRUh3aERDQUlJQXlGUWhpS0lRZ2dCQ0FJSUJwOGZDRUVJQkFnQklWQ0VJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJL2lpRUlJQUVnQmlBV2ZId2hBU0FRSUFHRlFpQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ0dJb2hCaUFCSUFZZ0VYeDhJUUVnRUNBQmhVSVFpaUVRSUFzZ0VId2hDeUFHSUF1RlFqK0tJUVlnQWlBSElDQjhmQ0VDSUEwZ0FvVkNJSW9oRFNBTUlBMThJUXdnQnlBTWhVSVlpaUVISUFJZ0J5QVZmSHdoQWlBTklBS0ZRaENLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNQNG9oQnlBRElBZ2dHWHg4SVFNZ0RpQURoVUlnaWlFT0lBa2dEbndoQ1NBSUlBbUZRaGlLSVFnZ0F5QUlJQmQ4ZkNFRElBNGdBNFZDRUlvaERpQUpJQTU4SVFrZ0NDQUpoVUkvaWlFSUlBUWdCU0FUZkh3aEJDQVBJQVNGUWlDS0lROGdDaUFQZkNFS0lBVWdDb1ZDR0lvaEJTQUVJQVVnRzN4OElRUWdEeUFFaFVJUWlpRVBJQW9nRDN3aENpQUZJQXFGUWorS0lRVWdBU0FGSUJkOGZDRUJJQTBnQVlWQ0lJb2hEU0FKSUExOElRa2dCU0FKaFVJWWlpRUZJQUVnQlNBZ2ZId2hBU0FOSUFHRlFoQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ1A0b2hCU0FDSUFZZ0gzeDhJUUlnRGlBQ2hVSWdpaUVPSUFvZ0Rud2hDaUFHSUFxRlFoaUtJUVlnQWlBR0lCcDhmQ0VDSUE0Z0FvVkNFSW9oRGlBS0lBNThJUW9nQmlBS2hVSS9paUVHSUFNZ0J5QWNmSHdoQXlBUElBT0ZRaUNLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNHSW9oQnlBRElBY2dGSHg4SVFNZ0R5QURoVUlRaWlFUElBc2dEM3doQ3lBSElBdUZRaitLSVFjZ0JDQUlJQkY4ZkNFRUlCQWdCSVZDSUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUlZaWlFSUlBUWdDQ0FaZkh3aEJDQVFJQVNGUWhDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDUDRvaENDQUJJQVlnSFh4OElRRWdFQ0FCaFVJZ2lpRVFJQXNnRUh3aEN5QUdJQXVGUWhpS0lRWWdBU0FHSUJOOGZDRUJJQkFnQVlWQ0VJb2hFQ0FMSUJCOElRc2dCaUFMaFVJL2lpRUdJQUlnQnlBZWZId2hBaUFOSUFLRlFpQ0tJUTBnRENBTmZDRU1JQWNnRElWQ0dJb2hCeUFDSUFjZ0dIeDhJUUlnRFNBQ2hVSVFpaUVOSUF3Z0RYd2hEQ0FISUF5RlFqK0tJUWNnQXlBSUlCSjhmQ0VESUE0Z0E0VkNJSW9oRGlBSklBNThJUWtnQ0NBSmhVSVlpaUVJSUFNZ0NDQVZmSHdoQXlBT0lBT0ZRaENLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNQNG9oQ0NBRUlBVWdHM3g4SVFRZ0R5QUVoVUlnaWlFUElBb2dEM3doQ2lBRklBcUZRaGlLSVFVZ0JDQUZJQlo4ZkNFRUlBOGdCSVZDRUlvaER5QUtJQTk4SVFvZ0JTQUtoVUkvaWlFRklBRWdCU0FiZkh3aEFTQU5JQUdGUWlDS0lRMGdDU0FOZkNFSklBVWdDWVZDR0lvaEJTQUJJQVVnRTN4OElRRWdEU0FCaFVJUWlpRU5JQWtnRFh3aENTQUZJQW1GUWorS0lRVWdBaUFHSUJsOGZDRUNJQTRnQW9WQ0lJb2hEaUFLSUE1OElRb2dCaUFLaFVJWWlpRUdJQUlnQmlBVmZId2hBaUFPSUFLRlFoQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ1A0b2hCaUFESUFjZ0dIeDhJUU1nRHlBRGhVSWdpaUVQSUFzZ0Qzd2hDeUFISUF1RlFoaUtJUWNnQXlBSElCZDhmQ0VESUE4Z0E0VkNFSW9oRHlBTElBOThJUXNnQnlBTGhVSS9paUVISUFRZ0NDQVNmSHdoQkNBUUlBU0ZRaUNLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNHSW9oQ0NBRUlBZ2dGbng4SVFRZ0VDQUVoVUlRaWlFUUlBd2dFSHdoRENBSUlBeUZRaitLSVFnZ0FTQUdJQ0I4ZkNFQklCQWdBWVZDSUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUlZaWlFR0lBRWdCaUFjZkh3aEFTQVFJQUdGUWhDS0lSQWdDeUFRZkNFTElBWWdDNFZDUDRvaEJpQUNJQWNnR254OElRSWdEU0FDaFVJZ2lpRU5JQXdnRFh3aERDQUhJQXlGUWhpS0lRY2dBaUFISUI5OGZDRUNJQTBnQW9WQ0VJb2hEU0FNSUExOElRd2dCeUFNaFVJL2lpRUhJQU1nQ0NBVWZId2hBeUFPSUFPRlFpQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ0dJb2hDQ0FESUFnZ0hYeDhJUU1nRGlBRGhVSVFpaUVPSUFrZ0Rud2hDU0FJSUFtRlFqK0tJUWdnQkNBRklCNThmQ0VFSUE4Z0JJVkNJSW9oRHlBS0lBOThJUW9nQlNBS2hVSVlpaUVGSUFRZ0JTQVJmSHdoQkNBUElBU0ZRaENLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNQNG9oQlNBQklBVWdFWHg4SVFFZ0RTQUJoVUlnaWlFTklBa2dEWHdoQ1NBRklBbUZRaGlLSVFVZ0FTQUZJQko4ZkNFQklBMGdBWVZDRUlvaERTQUpJQTE4SVFrZ0JTQUpoVUkvaWlFRklBSWdCaUFUZkh3aEFpQU9JQUtGUWlDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDR0lvaEJpQUNJQVlnRkh4OElRSWdEaUFDaFVJUWlpRU9JQW9nRG53aENpQUdJQXFGUWorS0lRWWdBeUFISUJWOGZDRURJQThnQTRWQ0lJb2hEeUFMSUE5OElRc2dCeUFMaFVJWWlpRUhJQU1nQnlBV2ZId2hBeUFQSUFPRlFoQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ1A0b2hCeUFFSUFnZ0YzeDhJUVFnRUNBRWhVSWdpaUVRSUF3Z0VId2hEQ0FJSUF5RlFoaUtJUWdnQkNBSUlCaDhmQ0VFSUJBZ0JJVkNFSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSS9paUVJSUFFZ0JpQVpmSHdoQVNBUUlBR0ZRaUNLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNHSW9oQmlBQklBWWdHbng4SVFFZ0VDQUJoVUlRaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaitLSVFZZ0FpQUhJQnQ4ZkNFQ0lBMGdBb1ZDSUlvaERTQU1JQTE4SVF3Z0J5QU1oVUlZaWlFSElBSWdCeUFjZkh3aEFpQU5JQUtGUWhDS0lRMGdEQ0FOZkNFTUlBY2dESVZDUDRvaEJ5QURJQWdnSFh4OElRTWdEaUFEaFVJZ2lpRU9JQWtnRG53aENTQUlJQW1GUWhpS0lRZ2dBeUFJSUI1OGZDRURJQTRnQTRWQ0VJb2hEaUFKSUE1OElRa2dDQ0FKaFVJL2lpRUlJQVFnQlNBZmZId2hCQ0FQSUFTRlFpQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ0dJb2hCU0FFSUFVZ0lIeDhJUVFnRHlBRWhVSVFpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFqK0tJUVVnQVNBRklCOThmQ0VCSUEwZ0FZVkNJSW9oRFNBSklBMThJUWtnQlNBSmhVSVlpaUVGSUFFZ0JTQWJmSHdoQVNBTklBR0ZRaENLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNQNG9oQlNBQ0lBWWdGWHg4SVFJZ0RpQUNoVUlnaWlFT0lBb2dEbndoQ2lBR0lBcUZRaGlLSVFZZ0FpQUdJQmw4ZkNFQ0lBNGdBb1ZDRUlvaERpQUtJQTU4SVFvZ0JpQUtoVUkvaWlFR0lBTWdCeUFhZkh3aEF5QVBJQU9GUWlDS0lROGdDeUFQZkNFTElBY2dDNFZDR0lvaEJ5QURJQWNnSUh4OElRTWdEeUFEaFVJUWlpRVBJQXNnRDN3aEN5QUhJQXVGUWorS0lRY2dCQ0FJSUI1OGZDRUVJQkFnQklWQ0lJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJWWlpRUlJQVFnQ0NBWGZId2hCQ0FRSUFTRlFoQ0tJUkFnRENBUWZDRU1JQWdnRElWQ1A0b2hDQ0FCSUFZZ0VueDhJUUVnRUNBQmhVSWdpaUVRSUFzZ0VId2hDeUFHSUF1RlFoaUtJUVlnQVNBR0lCMThmQ0VCSUJBZ0FZVkNFSW9oRUNBTElCQjhJUXNnQmlBTGhVSS9paUVHSUFJZ0J5QVJmSHdoQWlBTklBS0ZRaUNLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNHSW9oQnlBQ0lBY2dFM3g4SVFJZ0RTQUNoVUlRaWlFTklBd2dEWHdoRENBSElBeUZRaitLSVFjZ0F5QUlJQng4ZkNFRElBNGdBNFZDSUlvaERpQUpJQTU4SVFrZ0NDQUpoVUlZaWlFSUlBTWdDQ0FZZkh3aEF5QU9JQU9GUWhDS0lRNGdDU0FPZkNFSklBZ2dDWVZDUDRvaENDQUVJQVVnRm54OElRUWdEeUFFaFVJZ2lpRVBJQW9nRDN3aENpQUZJQXFGUWhpS0lRVWdCQ0FGSUJSOGZDRUVJQThnQklWQ0VJb2hEeUFLSUE5OElRb2dCU0FLaFVJL2lpRUZJQ0VnSVNrREFDQUJJQW1GaFRjREFDQWlJQ0lwQXdBZ0FpQUtoWVUzQXdBZ0l5QWpLUU1BSUFNZ0M0V0ZOd01BSUNRZ0pDa0RBQ0FFSUF5RmhUY0RBQ0FsSUNVcEF3QWdCU0FOaFlVM0F3QWdKaUFtS1FNQUlBWWdEb1dGTndNQUlDY2dKeWtEQUNBSElBK0ZoVGNEQUNBb0lDZ3BBd0FnQ0NBUWhZVTNBd0FMJylcbiAgdmFyIHJlYWR5ID0gbnVsbFxuXG4gIHZhciBtb2QgPSB7XG4gICAgYnVmZmVyOiB3YXNtLFxuICAgIG1lbW9yeTogbnVsbCxcbiAgICBleHBvcnRzOiBudWxsLFxuICAgIHJlYWxsb2M6IHJlYWxsb2MsXG4gICAgb25sb2FkOiBvbmxvYWRcbiAgfVxuXG4gIG9ubG9hZChmdW5jdGlvbiAoKSB7fSlcblxuICByZXR1cm4gbW9kXG5cbiAgZnVuY3Rpb24gcmVhbGxvYyAoc2l6ZSkge1xuICAgIG1vZC5leHBvcnRzLm1lbW9yeS5ncm93KE1hdGguY2VpbChNYXRoLmFicyhzaXplIC0gbW9kLm1lbW9yeS5sZW5ndGgpIC8gNjU1MzYpKVxuICAgIG1vZC5tZW1vcnkgPSBuZXcgVWludDhBcnJheShtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25sb2FkIChjYikge1xuICAgIGlmIChtb2QuZXhwb3J0cykgcmV0dXJuIGNiKClcblxuICAgIGlmIChyZWFkeSkge1xuICAgICAgcmVhZHkudGhlbihjYi5iaW5kKG51bGwsIG51bGwpKS5jYXRjaChjYilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLmFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jJylcbiAgICAgIHNldHVwKHtpbnN0YW5jZTogbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUod2FzbSksIGltcCl9KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVhZHkgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3YXNtLCBpbXApLnRoZW4oc2V0dXApXG4gICAgfVxuXG4gICAgb25sb2FkKGNiKVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXAgKHcpIHtcbiAgICBtb2QuZXhwb3J0cyA9IHcuaW5zdGFuY2UuZXhwb3J0c1xuICAgIG1vZC5tZW1vcnkgPSBtb2QuZXhwb3J0cy5tZW1vcnkgJiYgbW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlciAmJiBuZXcgVWludDhBcnJheShtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvVWludDhBcnJheSAocykge1xuICBpZiAodHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicpIHJldHVybiBuZXcgVWludDhBcnJheShhdG9iKHMpLnNwbGl0KCcnKS5tYXAoY2hhckNvZGVBdCkpXG4gIHJldHVybiBuZXcgKHJlcXVpcmUoJ2J1ZicgKyAnZmVyJykuQnVmZmVyKShzLCAnYmFzZTY0Jylcbn1cblxuZnVuY3Rpb24gY2hhckNvZGVBdCAoYykge1xuICByZXR1cm4gYy5jaGFyQ29kZUF0KDApXG59XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbmFub2Fzc2VydCcpXG52YXIgd2FzbSA9IHJlcXVpcmUoJy4vYmxha2UyYicpKClcblxudmFyIGhlYWQgPSA2NFxudmFyIGZyZWVMaXN0ID0gW11cblxubW9kdWxlLmV4cG9ydHMgPSBCbGFrZTJiXG52YXIgQllURVNfTUlOID0gbW9kdWxlLmV4cG9ydHMuQllURVNfTUlOID0gMTZcbnZhciBCWVRFU19NQVggPSBtb2R1bGUuZXhwb3J0cy5CWVRFU19NQVggPSA2NFxudmFyIEJZVEVTID0gbW9kdWxlLmV4cG9ydHMuQllURVMgPSAzMlxudmFyIEtFWUJZVEVTX01JTiA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTX01JTiA9IDE2XG52YXIgS0VZQllURVNfTUFYID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVNfTUFYID0gNjRcbnZhciBLRVlCWVRFUyA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTID0gMzJcbnZhciBTQUxUQllURVMgPSBtb2R1bGUuZXhwb3J0cy5TQUxUQllURVMgPSAxNlxudmFyIFBFUlNPTkFMQllURVMgPSBtb2R1bGUuZXhwb3J0cy5QRVJTT05BTEJZVEVTID0gMTZcblxuZnVuY3Rpb24gQmxha2UyYiAoZGlnZXN0TGVuZ3RoLCBrZXksIHNhbHQsIHBlcnNvbmFsLCBub0Fzc2VydCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmxha2UyYikpIHJldHVybiBuZXcgQmxha2UyYihkaWdlc3RMZW5ndGgsIGtleSwgc2FsdCwgcGVyc29uYWwsIG5vQXNzZXJ0KVxuICBpZiAoISh3YXNtICYmIHdhc20uZXhwb3J0cykpIHRocm93IG5ldyBFcnJvcignV0FTTSBub3QgbG9hZGVkLiBXYWl0IGZvciBCbGFrZTJiLnJlYWR5KGNiKScpXG4gIGlmICghZGlnZXN0TGVuZ3RoKSBkaWdlc3RMZW5ndGggPSAzMlxuXG4gIGlmIChub0Fzc2VydCAhPT0gdHJ1ZSkge1xuICAgIGFzc2VydChkaWdlc3RMZW5ndGggPj0gQllURVNfTUlOLCAnZGlnZXN0TGVuZ3RoIG11c3QgYmUgYXQgbGVhc3QgJyArIEJZVEVTX01JTiArICcsIHdhcyBnaXZlbiAnICsgZGlnZXN0TGVuZ3RoKVxuICAgIGFzc2VydChkaWdlc3RMZW5ndGggPD0gQllURVNfTUFYLCAnZGlnZXN0TGVuZ3RoIG11c3QgYmUgYXQgbW9zdCAnICsgQllURVNfTUFYICsgJywgd2FzIGdpdmVuICcgKyBkaWdlc3RMZW5ndGgpXG4gICAgaWYgKGtleSAhPSBudWxsKSBhc3NlcnQoa2V5Lmxlbmd0aCA+PSBLRVlCWVRFU19NSU4sICdrZXkgbXVzdCBiZSBhdCBsZWFzdCAnICsgS0VZQllURVNfTUlOICsgJywgd2FzIGdpdmVuICcgKyBrZXkubGVuZ3RoKVxuICAgIGlmIChrZXkgIT0gbnVsbCkgYXNzZXJ0KGtleS5sZW5ndGggPD0gS0VZQllURVNfTUFYLCAna2V5IG11c3QgYmUgYXQgbGVhc3QgJyArIEtFWUJZVEVTX01BWCArICcsIHdhcyBnaXZlbiAnICsga2V5Lmxlbmd0aClcbiAgICBpZiAoc2FsdCAhPSBudWxsKSBhc3NlcnQoc2FsdC5sZW5ndGggPT09IFNBTFRCWVRFUywgJ3NhbHQgbXVzdCBiZSBleGFjdGx5ICcgKyBTQUxUQllURVMgKyAnLCB3YXMgZ2l2ZW4gJyArIHNhbHQubGVuZ3RoKVxuICAgIGlmIChwZXJzb25hbCAhPSBudWxsKSBhc3NlcnQocGVyc29uYWwubGVuZ3RoID09PSBQRVJTT05BTEJZVEVTLCAncGVyc29uYWwgbXVzdCBiZSBleGFjdGx5ICcgKyBQRVJTT05BTEJZVEVTICsgJywgd2FzIGdpdmVuICcgKyBwZXJzb25hbC5sZW5ndGgpXG4gIH1cblxuICBpZiAoIWZyZWVMaXN0Lmxlbmd0aCkge1xuICAgIGZyZWVMaXN0LnB1c2goaGVhZClcbiAgICBoZWFkICs9IDIxNlxuICB9XG5cbiAgdGhpcy5kaWdlc3RMZW5ndGggPSBkaWdlc3RMZW5ndGhcbiAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZVxuICB0aGlzLnBvaW50ZXIgPSBmcmVlTGlzdC5wb3AoKVxuXG4gIHdhc20ubWVtb3J5LmZpbGwoMCwgMCwgNjQpXG4gIHdhc20ubWVtb3J5WzBdID0gdGhpcy5kaWdlc3RMZW5ndGhcbiAgd2FzbS5tZW1vcnlbMV0gPSBrZXkgPyBrZXkubGVuZ3RoIDogMFxuICB3YXNtLm1lbW9yeVsyXSA9IDEgLy8gZmFub3V0XG4gIHdhc20ubWVtb3J5WzNdID0gMSAvLyBkZXB0aFxuXG4gIGlmIChzYWx0KSB3YXNtLm1lbW9yeS5zZXQoc2FsdCwgMzIpXG4gIGlmIChwZXJzb25hbCkgd2FzbS5tZW1vcnkuc2V0KHBlcnNvbmFsLCA0OClcblxuICBpZiAodGhpcy5wb2ludGVyICsgMjE2ID4gd2FzbS5tZW1vcnkubGVuZ3RoKSB3YXNtLnJlYWxsb2ModGhpcy5wb2ludGVyICsgMjE2KSAvLyB3ZSBuZWVkIDIxNiBieXRlcyBmb3IgdGhlIHN0YXRlXG4gIHdhc20uZXhwb3J0cy5ibGFrZTJiX2luaXQodGhpcy5wb2ludGVyLCB0aGlzLmRpZ2VzdExlbmd0aClcblxuICBpZiAoa2V5KSB7XG4gICAgdGhpcy51cGRhdGUoa2V5KVxuICAgIHdhc20ubWVtb3J5LmZpbGwoMCwgaGVhZCwgaGVhZCArIGtleS5sZW5ndGgpIC8vIHdoaXRlb3V0IGtleVxuICAgIHdhc20ubWVtb3J5W3RoaXMucG9pbnRlciArIDIwMF0gPSAxMjhcbiAgfVxufVxuXG5cbkJsYWtlMmIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICBhc3NlcnQodGhpcy5maW5hbGl6ZWQgPT09IGZhbHNlLCAnSGFzaCBpbnN0YW5jZSBmaW5hbGl6ZWQnKVxuICBhc3NlcnQoaW5wdXQsICdpbnB1dCBtdXN0IGJlIFR5cGVkQXJyYXkgb3IgQnVmZmVyJylcblxuICBpZiAoaGVhZCArIGlucHV0Lmxlbmd0aCA+IHdhc20ubWVtb3J5Lmxlbmd0aCkgd2FzbS5yZWFsbG9jKGhlYWQgKyBpbnB1dC5sZW5ndGgpXG4gIHdhc20ubWVtb3J5LnNldChpbnB1dCwgaGVhZClcbiAgd2FzbS5leHBvcnRzLmJsYWtlMmJfdXBkYXRlKHRoaXMucG9pbnRlciwgaGVhZCwgaGVhZCArIGlucHV0Lmxlbmd0aClcbiAgcmV0dXJuIHRoaXNcbn1cblxuQmxha2UyYi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICBhc3NlcnQodGhpcy5maW5hbGl6ZWQgPT09IGZhbHNlLCAnSGFzaCBpbnN0YW5jZSBmaW5hbGl6ZWQnKVxuICB0aGlzLmZpbmFsaXplZCA9IHRydWVcblxuICBmcmVlTGlzdC5wdXNoKHRoaXMucG9pbnRlcilcbiAgd2FzbS5leHBvcnRzLmJsYWtlMmJfZmluYWwodGhpcy5wb2ludGVyKVxuXG4gIGlmICghZW5jIHx8IGVuYyA9PT0gJ2JpbmFyeScpIHtcbiAgICByZXR1cm4gd2FzbS5tZW1vcnkuc2xpY2UodGhpcy5wb2ludGVyICsgMTI4LCB0aGlzLnBvaW50ZXIgKyAxMjggKyB0aGlzLmRpZ2VzdExlbmd0aClcbiAgfVxuXG4gIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIGhleFNsaWNlKHdhc20ubWVtb3J5LCB0aGlzLnBvaW50ZXIgKyAxMjgsIHRoaXMuZGlnZXN0TGVuZ3RoKVxuICB9XG5cbiAgYXNzZXJ0KGVuYy5sZW5ndGggPj0gdGhpcy5kaWdlc3RMZW5ndGgsICdpbnB1dCBtdXN0IGJlIFR5cGVkQXJyYXkgb3IgQnVmZmVyJylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpZ2VzdExlbmd0aDsgaSsrKSB7XG4gICAgZW5jW2ldID0gd2FzbS5tZW1vcnlbdGhpcy5wb2ludGVyICsgMTI4ICsgaV1cbiAgfVxuXG4gIHJldHVybiBlbmNcbn1cblxuLy8gbGlic29kaXVtIGNvbXBhdFxuQmxha2UyYi5wcm90b3R5cGUuZmluYWwgPSBCbGFrZTJiLnByb3RvdHlwZS5kaWdlc3RcblxuQmxha2UyYi5XQVNNID0gd2FzbSAmJiB3YXNtLmJ1ZmZlclxuQmxha2UyYi5TVVBQT1JURUQgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICd1bmRlZmluZWQnXG5cbkJsYWtlMmIucmVhZHkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBub29wXG4gIGlmICghd2FzbSkgcmV0dXJuIGNiKG5ldyBFcnJvcignV2ViQXNzZW1ibHkgbm90IHN1cHBvcnRlZCcpKVxuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXQsIGNhbiBiZSByZW1vdmVkIGluIGEgbmV3IG1ham9yXG4gIHZhciBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlamVjdCwgcmVzb2x2ZSkge1xuICAgIHdhc20ub25sb2FkKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJlc29sdmUoKVxuICAgICAgZWxzZSByZWplY3QoKVxuICAgICAgY2IoZXJyKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHBcbn1cblxuQmxha2UyYi5wcm90b3R5cGUucmVhZHkgPSBCbGFrZTJiLnJlYWR5XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGxlbikge1xuICB2YXIgc3RyID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgc3RyICs9IHRvSGV4KGJ1ZltzdGFydCArIGldKVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCduYW5vYXNzZXJ0JylcbnZhciBiMndhc20gPSByZXF1aXJlKCdibGFrZTJiLXdhc20nKVxuXG4vLyA2NC1iaXQgdW5zaWduZWQgYWRkaXRpb25cbi8vIFNldHMgdlthLGErMV0gKz0gdltiLGIrMV1cbi8vIHYgc2hvdWxkIGJlIGEgVWludDMyQXJyYXlcbmZ1bmN0aW9uIEFERDY0QUEgKHYsIGEsIGIpIHtcbiAgdmFyIG8wID0gdlthXSArIHZbYl1cbiAgdmFyIG8xID0gdlthICsgMV0gKyB2W2IgKyAxXVxuICBpZiAobzAgPj0gMHgxMDAwMDAwMDApIHtcbiAgICBvMSsrXG4gIH1cbiAgdlthXSA9IG8wXG4gIHZbYSArIDFdID0gbzFcbn1cblxuLy8gNjQtYml0IHVuc2lnbmVkIGFkZGl0aW9uXG4vLyBTZXRzIHZbYSxhKzFdICs9IGJcbi8vIGIwIGlzIHRoZSBsb3cgMzIgYml0cyBvZiBiLCBiMSByZXByZXNlbnRzIHRoZSBoaWdoIDMyIGJpdHNcbmZ1bmN0aW9uIEFERDY0QUMgKHYsIGEsIGIwLCBiMSkge1xuICB2YXIgbzAgPSB2W2FdICsgYjBcbiAgaWYgKGIwIDwgMCkge1xuICAgIG8wICs9IDB4MTAwMDAwMDAwXG4gIH1cbiAgdmFyIG8xID0gdlthICsgMV0gKyBiMVxuICBpZiAobzAgPj0gMHgxMDAwMDAwMDApIHtcbiAgICBvMSsrXG4gIH1cbiAgdlthXSA9IG8wXG4gIHZbYSArIDFdID0gbzFcbn1cblxuLy8gTGl0dGxlLWVuZGlhbiBieXRlIGFjY2Vzc1xuZnVuY3Rpb24gQjJCX0dFVDMyIChhcnIsIGkpIHtcbiAgcmV0dXJuIChhcnJbaV0gXlxuICAoYXJyW2kgKyAxXSA8PCA4KSBeXG4gIChhcnJbaSArIDJdIDw8IDE2KSBeXG4gIChhcnJbaSArIDNdIDw8IDI0KSlcbn1cblxuLy8gRyBNaXhpbmcgZnVuY3Rpb25cbi8vIFRoZSBST1RScyBhcmUgaW5saW5lZCBmb3Igc3BlZWRcbmZ1bmN0aW9uIEIyQl9HIChhLCBiLCBjLCBkLCBpeCwgaXkpIHtcbiAgdmFyIHgwID0gbVtpeF1cbiAgdmFyIHgxID0gbVtpeCArIDFdXG4gIHZhciB5MCA9IG1baXldXG4gIHZhciB5MSA9IG1baXkgKyAxXVxuXG4gIEFERDY0QUEodiwgYSwgYikgLy8gdlthLGErMV0gKz0gdltiLGIrMV0gLi4uIGluIEpTIHdlIG11c3Qgc3RvcmUgYSB1aW50NjQgYXMgdHdvIHVpbnQzMnNcbiAgQURENjRBQyh2LCBhLCB4MCwgeDEpIC8vIHZbYSwgYSsxXSArPSB4IC4uLiB4MCBpcyB0aGUgbG93IDMyIGJpdHMgb2YgeCwgeDEgaXMgdGhlIGhpZ2ggMzIgYml0c1xuXG4gIC8vIHZbZCxkKzFdID0gKHZbZCxkKzFdIHhvciB2W2EsYSsxXSkgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgMzIgYml0c1xuICB2YXIgeG9yMCA9IHZbZF0gXiB2W2FdXG4gIHZhciB4b3IxID0gdltkICsgMV0gXiB2W2EgKyAxXVxuICB2W2RdID0geG9yMVxuICB2W2QgKyAxXSA9IHhvcjBcblxuICBBREQ2NEFBKHYsIGMsIGQpXG5cbiAgLy8gdltiLGIrMV0gPSAodltiLGIrMV0geG9yIHZbYyxjKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDI0IGJpdHNcbiAgeG9yMCA9IHZbYl0gXiB2W2NdXG4gIHhvcjEgPSB2W2IgKyAxXSBeIHZbYyArIDFdXG4gIHZbYl0gPSAoeG9yMCA+Pj4gMjQpIF4gKHhvcjEgPDwgOClcbiAgdltiICsgMV0gPSAoeG9yMSA+Pj4gMjQpIF4gKHhvcjAgPDwgOClcblxuICBBREQ2NEFBKHYsIGEsIGIpXG4gIEFERDY0QUModiwgYSwgeTAsIHkxKVxuXG4gIC8vIHZbZCxkKzFdID0gKHZbZCxkKzFdIHhvciB2W2EsYSsxXSkgcm90YXRlZCByaWdodCBieSAxNiBiaXRzXG4gIHhvcjAgPSB2W2RdIF4gdlthXVxuICB4b3IxID0gdltkICsgMV0gXiB2W2EgKyAxXVxuICB2W2RdID0gKHhvcjAgPj4+IDE2KSBeICh4b3IxIDw8IDE2KVxuICB2W2QgKyAxXSA9ICh4b3IxID4+PiAxNikgXiAoeG9yMCA8PCAxNilcblxuICBBREQ2NEFBKHYsIGMsIGQpXG5cbiAgLy8gdltiLGIrMV0gPSAodltiLGIrMV0geG9yIHZbYyxjKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDYzIGJpdHNcbiAgeG9yMCA9IHZbYl0gXiB2W2NdXG4gIHhvcjEgPSB2W2IgKyAxXSBeIHZbYyArIDFdXG4gIHZbYl0gPSAoeG9yMSA+Pj4gMzEpIF4gKHhvcjAgPDwgMSlcbiAgdltiICsgMV0gPSAoeG9yMCA+Pj4gMzEpIF4gKHhvcjEgPDwgMSlcbn1cblxuLy8gSW5pdGlhbGl6YXRpb24gVmVjdG9yXG52YXIgQkxBS0UyQl9JVjMyID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgMHhGM0JDQzkwOCwgMHg2QTA5RTY2NywgMHg4NENBQTczQiwgMHhCQjY3QUU4NSxcbiAgMHhGRTk0RjgyQiwgMHgzQzZFRjM3MiwgMHg1RjFEMzZGMSwgMHhBNTRGRjUzQSxcbiAgMHhBREU2ODJEMSwgMHg1MTBFNTI3RiwgMHgyQjNFNkMxRiwgMHg5QjA1Njg4QyxcbiAgMHhGQjQxQkQ2QiwgMHgxRjgzRDlBQiwgMHgxMzdFMjE3OSwgMHg1QkUwQ0QxOVxuXSlcblxudmFyIFNJR01BOCA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgMTQsIDEwLCA0LCA4LCA5LCAxNSwgMTMsIDYsIDEsIDEyLCAwLCAyLCAxMSwgNywgNSwgMyxcbiAgMTEsIDgsIDEyLCAwLCA1LCAyLCAxNSwgMTMsIDEwLCAxNCwgMywgNiwgNywgMSwgOSwgNCxcbiAgNywgOSwgMywgMSwgMTMsIDEyLCAxMSwgMTQsIDIsIDYsIDUsIDEwLCA0LCAwLCAxNSwgOCxcbiAgOSwgMCwgNSwgNywgMiwgNCwgMTAsIDE1LCAxNCwgMSwgMTEsIDEyLCA2LCA4LCAzLCAxMyxcbiAgMiwgMTIsIDYsIDEwLCAwLCAxMSwgOCwgMywgNCwgMTMsIDcsIDUsIDE1LCAxNCwgMSwgOSxcbiAgMTIsIDUsIDEsIDE1LCAxNCwgMTMsIDQsIDEwLCAwLCA3LCA2LCAzLCA5LCAyLCA4LCAxMSxcbiAgMTMsIDExLCA3LCAxNCwgMTIsIDEsIDMsIDksIDUsIDAsIDE1LCA0LCA4LCA2LCAyLCAxMCxcbiAgNiwgMTUsIDE0LCA5LCAxMSwgMywgMCwgOCwgMTIsIDIsIDEzLCA3LCAxLCA0LCAxMCwgNSxcbiAgMTAsIDIsIDgsIDQsIDcsIDYsIDEsIDUsIDE1LCAxMSwgOSwgMTQsIDMsIDEyLCAxMywgMCxcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgMTQsIDEwLCA0LCA4LCA5LCAxNSwgMTMsIDYsIDEsIDEyLCAwLCAyLCAxMSwgNywgNSwgM1xuXVxuXG4vLyBUaGVzZSBhcmUgb2Zmc2V0cyBpbnRvIGEgdWludDY0IGJ1ZmZlci5cbi8vIE11bHRpcGx5IHRoZW0gYWxsIGJ5IDIgdG8gbWFrZSB0aGVtIG9mZnNldHMgaW50byBhIHVpbnQzMiBidWZmZXIsXG4vLyBiZWNhdXNlIHRoaXMgaXMgSmF2YXNjcmlwdCBhbmQgd2UgZG9uJ3QgaGF2ZSB1aW50NjRzXG52YXIgU0lHTUE4MiA9IG5ldyBVaW50OEFycmF5KFNJR01BOC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKiAyIH0pKVxuXG4vLyBDb21wcmVzc2lvbiBmdW5jdGlvbi4gJ2xhc3QnIGZsYWcgaW5kaWNhdGVzIGxhc3QgYmxvY2suXG4vLyBOb3RlIHdlJ3JlIHJlcHJlc2VudGluZyAxNiB1aW50NjRzIGFzIDMyIHVpbnQzMnNcbnZhciB2ID0gbmV3IFVpbnQzMkFycmF5KDMyKVxudmFyIG0gPSBuZXcgVWludDMyQXJyYXkoMzIpXG5mdW5jdGlvbiBibGFrZTJiQ29tcHJlc3MgKGN0eCwgbGFzdCkge1xuICB2YXIgaSA9IDBcblxuICAvLyBpbml0IHdvcmsgdmFyaWFibGVzXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdltpXSA9IGN0eC5oW2ldXG4gICAgdltpICsgMTZdID0gQkxBS0UyQl9JVjMyW2ldXG4gIH1cblxuICAvLyBsb3cgNjQgYml0cyBvZiBvZmZzZXRcbiAgdlsyNF0gPSB2WzI0XSBeIGN0eC50XG4gIHZbMjVdID0gdlsyNV0gXiAoY3R4LnQgLyAweDEwMDAwMDAwMClcbiAgLy8gaGlnaCA2NCBiaXRzIG5vdCBzdXBwb3J0ZWQsIG9mZnNldCBtYXkgbm90IGJlIGhpZ2hlciB0aGFuIDIqKjUzLTFcblxuICAvLyBsYXN0IGJsb2NrIGZsYWcgc2V0ID9cbiAgaWYgKGxhc3QpIHtcbiAgICB2WzI4XSA9IH52WzI4XVxuICAgIHZbMjldID0gfnZbMjldXG4gIH1cblxuICAvLyBnZXQgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIG1baV0gPSBCMkJfR0VUMzIoY3R4LmIsIDQgKiBpKVxuICB9XG5cbiAgLy8gdHdlbHZlIHJvdW5kcyBvZiBtaXhpbmdcbiAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICBCMkJfRygwLCA4LCAxNiwgMjQsIFNJR01BODJbaSAqIDE2ICsgMF0sIFNJR01BODJbaSAqIDE2ICsgMV0pXG4gICAgQjJCX0coMiwgMTAsIDE4LCAyNiwgU0lHTUE4MltpICogMTYgKyAyXSwgU0lHTUE4MltpICogMTYgKyAzXSlcbiAgICBCMkJfRyg0LCAxMiwgMjAsIDI4LCBTSUdNQTgyW2kgKiAxNiArIDRdLCBTSUdNQTgyW2kgKiAxNiArIDVdKVxuICAgIEIyQl9HKDYsIDE0LCAyMiwgMzAsIFNJR01BODJbaSAqIDE2ICsgNl0sIFNJR01BODJbaSAqIDE2ICsgN10pXG4gICAgQjJCX0coMCwgMTAsIDIwLCAzMCwgU0lHTUE4MltpICogMTYgKyA4XSwgU0lHTUE4MltpICogMTYgKyA5XSlcbiAgICBCMkJfRygyLCAxMiwgMjIsIDI0LCBTSUdNQTgyW2kgKiAxNiArIDEwXSwgU0lHTUE4MltpICogMTYgKyAxMV0pXG4gICAgQjJCX0coNCwgMTQsIDE2LCAyNiwgU0lHTUE4MltpICogMTYgKyAxMl0sIFNJR01BODJbaSAqIDE2ICsgMTNdKVxuICAgIEIyQl9HKDYsIDgsIDE4LCAyOCwgU0lHTUE4MltpICogMTYgKyAxNF0sIFNJR01BODJbaSAqIDE2ICsgMTVdKVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBjdHguaFtpXSA9IGN0eC5oW2ldIF4gdltpXSBeIHZbaSArIDE2XVxuICB9XG59XG5cbi8vIHJldXNhYmxlIHBhcmFtZXRlcl9ibG9ja1xudmFyIHBhcmFtZXRlcl9ibG9jayA9IG5ldyBVaW50OEFycmF5KFtcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAgMDogb3V0bGVuLCBrZXlsZW4sIGZhbm91dCwgZGVwdGhcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAgNDogbGVhZiBsZW5ndGgsIHNlcXVlbnRpYWwgbW9kZVxuICAwLCAwLCAwLCAwLCAgICAgIC8vICA4OiBub2RlIG9mZnNldFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDEyOiBub2RlIG9mZnNldFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDE2OiBub2RlIGRlcHRoLCBpbm5lciBsZW5ndGgsIHJmdVxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDIwOiByZnVcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAyNDogcmZ1XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMjg6IHJmdVxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDMyOiBzYWx0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMzY6IHNhbHRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA0MDogc2FsdFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDQ0OiBzYWx0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gNDg6IHBlcnNvbmFsXG4gIDAsIDAsIDAsIDAsICAgICAgLy8gNTI6IHBlcnNvbmFsXG4gIDAsIDAsIDAsIDAsICAgICAgLy8gNTY6IHBlcnNvbmFsXG4gIDAsIDAsIDAsIDAgICAgICAgLy8gNjA6IHBlcnNvbmFsXG5dKVxuXG4vLyBDcmVhdGVzIGEgQkxBS0UyYiBoYXNoaW5nIGNvbnRleHRcbi8vIFJlcXVpcmVzIGFuIG91dHB1dCBsZW5ndGggYmV0d2VlbiAxIGFuZCA2NCBieXRlc1xuLy8gVGFrZXMgYW4gb3B0aW9uYWwgVWludDhBcnJheSBrZXlcbmZ1bmN0aW9uIEJsYWtlMmIgKG91dGxlbiwga2V5LCBzYWx0LCBwZXJzb25hbCkge1xuICAvLyB6ZXJvIG91dCBwYXJhbWV0ZXJfYmxvY2sgYmVmb3JlIHVzYWdlXG4gIHBhcmFtZXRlcl9ibG9jay5maWxsKDApXG4gIC8vIHN0YXRlLCAncGFyYW0gYmxvY2snXG5cbiAgdGhpcy5iID0gbmV3IFVpbnQ4QXJyYXkoMTI4KVxuICB0aGlzLmggPSBuZXcgVWludDMyQXJyYXkoMTYpXG4gIHRoaXMudCA9IDAgLy8gaW5wdXQgY291bnRcbiAgdGhpcy5jID0gMCAvLyBwb2ludGVyIHdpdGhpbiBidWZmZXJcbiAgdGhpcy5vdXRsZW4gPSBvdXRsZW4gLy8gb3V0cHV0IGxlbmd0aCBpbiBieXRlc1xuXG4gIHBhcmFtZXRlcl9ibG9ja1swXSA9IG91dGxlblxuICBpZiAoa2V5KSBwYXJhbWV0ZXJfYmxvY2tbMV0gPSBrZXkubGVuZ3RoXG4gIHBhcmFtZXRlcl9ibG9ja1syXSA9IDEgLy8gZmFub3V0XG4gIHBhcmFtZXRlcl9ibG9ja1szXSA9IDEgLy8gZGVwdGhcblxuICBpZiAoc2FsdCkgcGFyYW1ldGVyX2Jsb2NrLnNldChzYWx0LCAzMilcbiAgaWYgKHBlcnNvbmFsKSBwYXJhbWV0ZXJfYmxvY2suc2V0KHBlcnNvbmFsLCA0OClcblxuICAvLyBpbml0aWFsaXplIGhhc2ggc3RhdGVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdGhpcy5oW2ldID0gQkxBS0UyQl9JVjMyW2ldIF4gQjJCX0dFVDMyKHBhcmFtZXRlcl9ibG9jaywgaSAqIDQpXG4gIH1cblxuICAvLyBrZXkgdGhlIGhhc2gsIGlmIGFwcGxpY2FibGVcbiAgaWYgKGtleSkge1xuICAgIGJsYWtlMmJVcGRhdGUodGhpcywga2V5KVxuICAgIC8vIGF0IHRoZSBlbmRcbiAgICB0aGlzLmMgPSAxMjhcbiAgfVxufVxuXG5CbGFrZTJiLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgYXNzZXJ0KGlucHV0ICE9IG51bGwsICdpbnB1dCBtdXN0IGJlIFVpbnQ4QXJyYXkgb3IgQnVmZmVyJylcbiAgYmxha2UyYlVwZGF0ZSh0aGlzLCBpbnB1dClcbiAgcmV0dXJuIHRoaXNcbn1cblxuQmxha2UyYi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKG91dCkge1xuICB2YXIgYnVmID0gKCFvdXQgfHwgb3V0ID09PSAnYmluYXJ5JyB8fCBvdXQgPT09ICdoZXgnKSA/IG5ldyBVaW50OEFycmF5KHRoaXMub3V0bGVuKSA6IG91dFxuICBhc3NlcnQoYnVmLmxlbmd0aCA+PSB0aGlzLm91dGxlbiwgJ291dCBtdXN0IGhhdmUgYXQgbGVhc3Qgb3V0bGVuIGJ5dGVzIG9mIHNwYWNlJylcbiAgYmxha2UyYkZpbmFsKHRoaXMsIGJ1ZilcbiAgaWYgKG91dCA9PT0gJ2hleCcpIHJldHVybiBoZXhTbGljZShidWYpXG4gIHJldHVybiBidWZcbn1cblxuQmxha2UyYi5wcm90b3R5cGUuZmluYWwgPSBCbGFrZTJiLnByb3RvdHlwZS5kaWdlc3RcblxuQmxha2UyYi5yZWFkeSA9IGZ1bmN0aW9uIChjYikge1xuICBiMndhc20ucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIGNiKCkgLy8gaWdub3JlIHRoZSBlcnJvclxuICB9KVxufVxuXG4vLyBVcGRhdGVzIGEgQkxBS0UyYiBzdHJlYW1pbmcgaGFzaFxuLy8gUmVxdWlyZXMgaGFzaCBjb250ZXh0IGFuZCBVaW50OEFycmF5IChieXRlIGFycmF5KVxuZnVuY3Rpb24gYmxha2UyYlVwZGF0ZSAoY3R4LCBpbnB1dCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN0eC5jID09PSAxMjgpIHsgLy8gYnVmZmVyIGZ1bGwgP1xuICAgICAgY3R4LnQgKz0gY3R4LmMgLy8gYWRkIGNvdW50ZXJzXG4gICAgICBibGFrZTJiQ29tcHJlc3MoY3R4LCBmYWxzZSkgLy8gY29tcHJlc3MgKG5vdCBsYXN0KVxuICAgICAgY3R4LmMgPSAwIC8vIGNvdW50ZXIgdG8gemVyb1xuICAgIH1cbiAgICBjdHguYltjdHguYysrXSA9IGlucHV0W2ldXG4gIH1cbn1cblxuLy8gQ29tcGxldGVzIGEgQkxBS0UyYiBzdHJlYW1pbmcgaGFzaFxuLy8gUmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgbWVzc2FnZSBkaWdlc3RcbmZ1bmN0aW9uIGJsYWtlMmJGaW5hbCAoY3R4LCBvdXQpIHtcbiAgY3R4LnQgKz0gY3R4LmMgLy8gbWFyayBsYXN0IGJsb2NrIG9mZnNldFxuXG4gIHdoaWxlIChjdHguYyA8IDEyOCkgeyAvLyBmaWxsIHVwIHdpdGggemVyb3NcbiAgICBjdHguYltjdHguYysrXSA9IDBcbiAgfVxuICBibGFrZTJiQ29tcHJlc3MoY3R4LCB0cnVlKSAvLyBmaW5hbCBibG9jayBmbGFnID0gMVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3R4Lm91dGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gY3R4LmhbaSA+PiAyXSA+PiAoOCAqIChpICYgMykpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmKSB7XG4gIHZhciBzdHIgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykgc3RyICs9IHRvSGV4KGJ1ZltpXSlcbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbnZhciBQcm90byA9IEJsYWtlMmJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIYXNoIChvdXRsZW4sIGtleSwgc2FsdCwgcGVyc29uYWwsIG5vQXNzZXJ0KSB7XG4gIGlmIChub0Fzc2VydCAhPT0gdHJ1ZSkge1xuICAgIGFzc2VydChvdXRsZW4gPj0gQllURVNfTUlOLCAnb3V0bGVuIG11c3QgYmUgYXQgbGVhc3QgJyArIEJZVEVTX01JTiArICcsIHdhcyBnaXZlbiAnICsgb3V0bGVuKVxuICAgIGFzc2VydChvdXRsZW4gPD0gQllURVNfTUFYLCAnb3V0bGVuIG11c3QgYmUgYXQgbW9zdCAnICsgQllURVNfTUFYICsgJywgd2FzIGdpdmVuICcgKyBvdXRsZW4pXG4gICAgaWYgKGtleSAhPSBudWxsKSBhc3NlcnQoa2V5Lmxlbmd0aCA+PSBLRVlCWVRFU19NSU4sICdrZXkgbXVzdCBiZSBhdCBsZWFzdCAnICsgS0VZQllURVNfTUlOICsgJywgd2FzIGdpdmVuICcgKyBrZXkubGVuZ3RoKVxuICAgIGlmIChrZXkgIT0gbnVsbCkgYXNzZXJ0KGtleS5sZW5ndGggPD0gS0VZQllURVNfTUFYLCAna2V5IG11c3QgYmUgYXQgbGVhc3QgJyArIEtFWUJZVEVTX01BWCArICcsIHdhcyBnaXZlbiAnICsga2V5Lmxlbmd0aClcbiAgICBpZiAoc2FsdCAhPSBudWxsKSBhc3NlcnQoc2FsdC5sZW5ndGggPT09IFNBTFRCWVRFUywgJ3NhbHQgbXVzdCBiZSBleGFjdGx5ICcgKyBTQUxUQllURVMgKyAnLCB3YXMgZ2l2ZW4gJyArIHNhbHQubGVuZ3RoKVxuICAgIGlmIChwZXJzb25hbCAhPSBudWxsKSBhc3NlcnQocGVyc29uYWwubGVuZ3RoID09PSBQRVJTT05BTEJZVEVTLCAncGVyc29uYWwgbXVzdCBiZSBleGFjdGx5ICcgKyBQRVJTT05BTEJZVEVTICsgJywgd2FzIGdpdmVuICcgKyBwZXJzb25hbC5sZW5ndGgpXG4gIH1cblxuICByZXR1cm4gbmV3IFByb3RvKG91dGxlbiwga2V5LCBzYWx0LCBwZXJzb25hbClcbn1cblxubW9kdWxlLmV4cG9ydHMucmVhZHkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgYjJ3YXNtLnJlYWR5KGZ1bmN0aW9uICgpIHsgLy8gaWdub3JlIGVycm9yc1xuICAgIGNiKClcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMuV0FTTV9TVVBQT1JURUQgPSBiMndhc20uU1VQUE9SVEVEXG5tb2R1bGUuZXhwb3J0cy5XQVNNX0xPQURFRCA9IGZhbHNlXG5cbnZhciBCWVRFU19NSU4gPSBtb2R1bGUuZXhwb3J0cy5CWVRFU19NSU4gPSAxNlxudmFyIEJZVEVTX01BWCA9IG1vZHVsZS5leHBvcnRzLkJZVEVTX01BWCA9IDY0XG52YXIgQllURVMgPSBtb2R1bGUuZXhwb3J0cy5CWVRFUyA9IDMyXG52YXIgS0VZQllURVNfTUlOID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVNfTUlOID0gMTZcbnZhciBLRVlCWVRFU19NQVggPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFU19NQVggPSA2NFxudmFyIEtFWUJZVEVTID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVMgPSAzMlxudmFyIFNBTFRCWVRFUyA9IG1vZHVsZS5leHBvcnRzLlNBTFRCWVRFUyA9IDE2XG52YXIgUEVSU09OQUxCWVRFUyA9IG1vZHVsZS5leHBvcnRzLlBFUlNPTkFMQllURVMgPSAxNlxuXG5iMndhc20ucmVhZHkoZnVuY3Rpb24gKGVycikge1xuICBpZiAoIWVycikge1xuICAgIG1vZHVsZS5leHBvcnRzLldBU01fTE9BREVEID0gdHJ1ZVxuICAgIFByb3RvID0gYjJ3YXNtXG4gIH1cbn0pXG4iLCIiLCJmdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5hbGxvY1Vuc2FmZSkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWxsb2NVbnNhZmVcbiIsInZhciBidWZmZXJGaWxsID0gcmVxdWlyZSgnYnVmZmVyLWZpbGwnKVxudmFyIGFsbG9jVW5zYWZlID0gcmVxdWlyZSgnYnVmZmVyLWFsbG9jLXVuc2FmZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cblxuICBpZiAoQnVmZmVyLmFsbG9jKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBidWZmZXIgPSBhbGxvY1Vuc2FmZShzaXplKVxuXG4gIGlmIChzaXplID09PSAwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBidWZmZXJGaWxsKGJ1ZmZlciwgMClcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHJldHVybiBidWZmZXJGaWxsKGJ1ZmZlciwgZmlsbCwgZW5jb2RpbmcpXG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJyk7XG5cdH1cblxuXHRpZiAoYSA9PT0gYikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBhLmVxdWFscyhiKTtcblx0fVxuXG5cdGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoYVtpXSAhPT0gYltpXSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIi8qIE5vZGUuanMgNi40LjAgYW5kIHVwIGhhcyBmdWxsIHN1cHBvcnQgKi9cbnZhciBoYXNGdWxsU3VwcG9ydCA9IChmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZygnbGF0aW4xJykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2MgPyBCdWZmZXIuYWxsb2MoNCkgOiBuZXcgQnVmZmVyKDQpXG5cbiAgICBidWYuZmlsbCgnYWInLCAndWNzMicpXG5cbiAgICByZXR1cm4gKGJ1Zi50b1N0cmluZygnaGV4JykgPT09ICc2MTAwNjIwMCcpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSgpKVxuXG5mdW5jdGlvbiBpc1NpbmdsZUJ5dGUgKHZhbCkge1xuICByZXR1cm4gKHZhbC5sZW5ndGggPT09IDEgJiYgdmFsLmNoYXJDb2RlQXQoMCkgPCAyNTYpXG59XG5cbmZ1bmN0aW9uIGZpbGxXaXRoTnVtYmVyIChidWZmZXIsIHZhbCwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBidWZmZXIubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgYnVmZmVyLmZpbGwodmFsLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBmaWxsV2l0aEJ1ZmZlciAoYnVmZmVyLCB2YWwsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGJ1ZmZlci5sZW5ndGggOiBlbmQgPj4+IDBcblxuICB2YXIgcG9zID0gc3RhcnRcbiAgdmFyIGxlbiA9IHZhbC5sZW5ndGhcbiAgd2hpbGUgKHBvcyA8PSAoZW5kIC0gbGVuKSkge1xuICAgIHZhbC5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBsZW5cbiAgfVxuXG4gIGlmIChwb3MgIT09IGVuZCkge1xuICAgIHZhbC5jb3B5KGJ1ZmZlciwgcG9zLCAwLCBlbmQgLSBwb3MpXG4gIH1cblxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGZpbGwgKGJ1ZmZlciwgdmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICBpZiAoaGFzRnVsbFN1cHBvcnQpIHtcbiAgICByZXR1cm4gYnVmZmVyLmZpbGwodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZylcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmaWxsV2l0aE51bWJlcihidWZmZXIsIHZhbCwgc3RhcnQsIGVuZClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IGJ1ZmZlci5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gYnVmZmVyLmxlbmd0aFxuICAgIH1cblxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cblxuICAgIGlmIChlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgIGVuY29kaW5nID0gJ2JpbmFyeSdcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuXG4gICAgaWYgKHZhbCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBmaWxsV2l0aE51bWJlcihidWZmZXIsIDAsIHN0YXJ0LCBlbmQpXG4gICAgfVxuXG4gICAgaWYgKGlzU2luZ2xlQnl0ZSh2YWwpKSB7XG4gICAgICByZXR1cm4gZmlsbFdpdGhOdW1iZXIoYnVmZmVyLCB2YWwuY2hhckNvZGVBdCgwKSwgc3RhcnQsIGVuZClcbiAgICB9XG5cbiAgICB2YWwgPSBuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gZmlsbFdpdGhCdWZmZXIoYnVmZmVyLCB2YWwsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICAvLyBPdGhlciB2YWx1ZXMgKGUuZy4gdW5kZWZpbmVkLCBib29sZWFuLCBvYmplY3QpIHJlc3VsdHMgaW4gemVyby1maWxsXG4gIHJldHVybiBmaWxsV2l0aE51bWJlcihidWZmZXIsIDAsIHN0YXJ0LCBlbmQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmlsbFxuIiwidmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG52YXIgaXNNb2Rlcm4gPSAoXG4gIHR5cGVvZiBCdWZmZXIuYWxsb2MgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbidcbilcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAoaW5wdXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaW5wdXQpLnNsaWNlKDgsIC0xKSA9PT0gJ0FycmF5QnVmZmVyJ1xufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKG9iaiwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGJ5dGVPZmZzZXQgPj4+PSAwXG5cbiAgdmFyIG1heExlbmd0aCA9IG9iai5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldFxuXG4gIGlmIChtYXhMZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInb2Zmc2V0JyBpcyBvdXQgb2YgYm91bmRzXCIpXG4gIH1cblxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSBtYXhMZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPj4+PSAwXG5cbiAgICBpZiAobGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidsZW5ndGgnIGlzIG91dCBvZiBib3VuZHNcIilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNNb2Rlcm5cbiAgICA/IEJ1ZmZlci5mcm9tKG9iai5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgbGVuZ3RoKSlcbiAgICA6IG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkob2JqLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBsZW5ndGgpKSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICByZXR1cm4gaXNNb2Rlcm5cbiAgICA/IEJ1ZmZlci5mcm9tKHN0cmluZywgZW5jb2RpbmcpXG4gICAgOiBuZXcgQnVmZmVyKHN0cmluZywgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGJ1ZmZlckZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGlzQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBpc01vZGVyblxuICAgID8gQnVmZmVyLmZyb20odmFsdWUpXG4gICAgOiBuZXcgQnVmZmVyKHZhbHVlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlckZyb21cbiIsInZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIGJ1ZmZlckZyb20gPSByZXF1aXJlKCdidWZmZXItZnJvbScpXG5cbnZhciBTSUdOQUxfRkxVU0ggPSBidWZmZXJGcm9tKFswXSlcblxudmFyIEJ1bGsgPSBmdW5jdGlvbiAob3B0cywgd29ya2VyLCBmbHVzaCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVsaykpIHJldHVybiBuZXcgQnVsayhvcHRzLCB3b3JrZXIsIGZsdXNoKVxuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZsdXNoID0gd29ya2VyXG4gICAgd29ya2VyID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG5cbiAgc3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcywgb3B0cylcbiAgdGhpcy5fd29ya2VyID0gd29ya2VyXG4gIHRoaXMuX2ZsdXNoID0gZmx1c2hcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxufVxuXG5pbmhlcml0cyhCdWxrLCBzdHJlYW0uV3JpdGFibGUpXG5cbkJ1bGsub2JqID0gZnVuY3Rpb24gKG9wdHMsIHdvcmtlciwgZmx1c2gpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gQnVsay5vYmoobnVsbCwgb3B0cywgd29ya2VyKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBvcHRzLm9iamVjdE1vZGUgPSB0cnVlXG4gIHJldHVybiBuZXcgQnVsayhvcHRzLCB3b3JrZXIsIGZsdXNoKVxufVxuXG5CdWxrLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZGF0YSwgZW5jLCBjYikge1xuICBpZiAoIXRoaXMuX2ZsdXNoKSByZXR1cm4gc3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmVuZChudWxsLCBudWxsLCBkYXRhKVxuICBpZiAodHlwZW9mIGVuYyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZW5kKGRhdGEsIG51bGwsIGVuYylcbiAgaWYgKGRhdGEpIHRoaXMud3JpdGUoZGF0YSlcbiAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZykgdGhpcy53cml0ZShTSUdOQUxfRkxVU0gpXG4gIHJldHVybiBzdHJlYW0uV3JpdGFibGUucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNiKVxufVxuXG5CdWxrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicpXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuXG5CdWxrLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jLCBjYikge1xuICBpZiAoZGF0YSA9PT0gU0lHTkFMX0ZMVVNIKSB0aGlzLl9mbHVzaChjYilcbiAgZWxzZSB0aGlzLl93b3JrZXIoW2RhdGFdLCBjYilcbn1cblxuQnVsay5wcm90b3R5cGUuX3dyaXRldiA9IGZ1bmN0aW9uIChiYXRjaCwgY2IpIHtcbiAgdmFyIGxlbiA9IGJhdGNoLmxlbmd0aFxuICBpZiAoYmF0Y2hbYmF0Y2gubGVuZ3RoIC0gMV0uY2h1bmsgPT09IFNJR05BTF9GTFVTSCkge1xuICAgIGNiID0gdGhpcy5fZmx1c2hlcihjYilcbiAgICBpZiAoIS0tbGVuKSByZXR1cm4gY2IoKVxuICB9XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcnJbaV0gPSBiYXRjaFtpXS5jaHVua1xuICB0aGlzLl93b3JrZXIoYXJyLCBjYilcbn1cblxuQnVsay5wcm90b3R5cGUuX2ZsdXNoZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBzZWxmLl9mbHVzaChjYilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1bGtcbiIsIm1vZHVsZS5leHBvcnRzID0gY29kZWNzXG5cbnZhciBmcm9tQnVmZmVyID0gKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20pXG4gID8gQnVmZmVyLmZyb21cbiAgOiBCdWZmZXJcblxuY29kZWNzLmFzY2lpID0gY3JlYXRlU3RyaW5nKCdhc2NpaScpXG5jb2RlY3MudXRmOCA9IGNyZWF0ZVN0cmluZygndXRmLTgnKVxuY29kZWNzLmhleCA9IGNyZWF0ZVN0cmluZygnaGV4JylcbmNvZGVjcy5iYXNlNjQgPSBjcmVhdGVTdHJpbmcoJ2Jhc2U2NCcpXG5jb2RlY3MudWNzMiA9IGNyZWF0ZVN0cmluZygndWNzMicpXG5jb2RlY3MudXRmMTZsZSA9IGNyZWF0ZVN0cmluZygndXRmMTZsZScpXG5jb2RlY3MubmRqc29uID0gY3JlYXRlSlNPTih0cnVlKVxuY29kZWNzLmpzb24gPSBjcmVhdGVKU09OKGZhbHNlKVxuY29kZWNzLmJpbmFyeSA9IHtcbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGVCaW5hcnkgKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyA/IGZyb21CdWZmZXIob2JqLCAndXRmLTgnKSA6IG9ialxuICB9LFxuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZUJpbmFyeSAoYnVmKSB7XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG59XG5cbmZ1bmN0aW9uIGNvZGVjcyAoZm10KSB7XG4gIGlmICh0eXBlb2YgZm10ID09PSAnb2JqZWN0JyAmJiBmbXQgJiYgZm10LmVuY29kZSAmJiBmbXQuZGVjb2RlKSByZXR1cm4gZm10XG5cbiAgc3dpdGNoIChmbXQpIHtcbiAgICBjYXNlICduZGpzb24nOiByZXR1cm4gY29kZWNzLm5kanNvblxuICAgIGNhc2UgJ2pzb24nOiByZXR1cm4gY29kZWNzLmpzb25cbiAgICBjYXNlICdhc2NpaSc6IHJldHVybiBjb2RlY3MuYXNjaWlcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAndXRmOCc6IHJldHVybiBjb2RlY3MudXRmOFxuICAgIGNhc2UgJ2hleCc6IHJldHVybiBjb2RlY3MuaGV4XG4gICAgY2FzZSAnYmFzZTY0JzogcmV0dXJuIGNvZGVjcy5iYXNlNjRcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndWNzMic6IHJldHVybiBjb2RlY3MudWNzMlxuICAgIGNhc2UgJ3V0ZjE2LWxlJzpcbiAgICBjYXNlICd1dGYxNmxlJzogcmV0dXJuIGNvZGVjcy51dGYxNmxlXG4gIH1cblxuICByZXR1cm4gY29kZWNzLmJpbmFyeVxufVxuXG5mdW5jdGlvbiBjcmVhdGVKU09OIChuZXdsaW5lKSB7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBuZXdsaW5lID8gZW5jb2RlTkRKU09OIDogZW5jb2RlSlNPTixcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZUpTT04gKGJ1Zikge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYnVmLnRvU3RyaW5nKCkpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlSlNPTiAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkodmFsKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU5ESlNPTiAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkodmFsKSArICdcXG4nKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZyAodHlwZSkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlU3RyaW5nICh2YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykgdmFsID0gdmFsLnRvU3RyaW5nKClcbiAgICAgIHJldHVybiBmcm9tQnVmZmVyKHZhbCwgdHlwZSlcbiAgICB9LFxuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlU3RyaW5nIChidWYpIHtcbiAgICAgIHJldHVybiBidWYudG9TdHJpbmcodHlwZSlcbiAgICB9XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsImV4cG9ydHMuZnVsbFJvb3RzID0gZnVuY3Rpb24gKGluZGV4LCByZXN1bHQpIHtcbiAgaWYgKGluZGV4ICYgMSkgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG9ubHkgbG9vayB1cCByb290cyBmb3IgZGVwdGgoMCkgYmxvY2tzJylcbiAgaWYgKCFyZXN1bHQpIHJlc3VsdCA9IFtdXG5cbiAgaW5kZXggLz0gMlxuXG4gIHZhciBvZmZzZXQgPSAwXG4gIHZhciBmYWN0b3IgPSAxXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIWluZGV4KSByZXR1cm4gcmVzdWx0XG4gICAgd2hpbGUgKGZhY3RvciAqIDIgPD0gaW5kZXgpIGZhY3RvciAqPSAyXG4gICAgcmVzdWx0LnB1c2gob2Zmc2V0ICsgZmFjdG9yIC0gMSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyAyICogZmFjdG9yXG4gICAgaW5kZXggLT0gZmFjdG9yXG4gICAgZmFjdG9yID0gMVxuICB9XG59XG5cbmV4cG9ydHMuZGVwdGggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdmFyIGRlcHRoID0gMFxuXG4gIGluZGV4ICs9IDFcbiAgd2hpbGUgKCEoaW5kZXggJiAxKSkge1xuICAgIGRlcHRoKytcbiAgICBpbmRleCA9IHJpZ2h0U2hpZnQoaW5kZXgpXG4gIH1cblxuICByZXR1cm4gZGVwdGhcbn1cblxuZXhwb3J0cy5zaWJsaW5nID0gZnVuY3Rpb24gKGluZGV4LCBkZXB0aCkge1xuICBpZiAoIWRlcHRoKSBkZXB0aCA9IGV4cG9ydHMuZGVwdGgoaW5kZXgpXG4gIHZhciBvZmZzZXQgPSBleHBvcnRzLm9mZnNldChpbmRleCwgZGVwdGgpXG5cbiAgcmV0dXJuIGV4cG9ydHMuaW5kZXgoZGVwdGgsIG9mZnNldCAmIDEgPyBvZmZzZXQgLSAxIDogb2Zmc2V0ICsgMSlcbn1cblxuZXhwb3J0cy5wYXJlbnQgPSBmdW5jdGlvbiAoaW5kZXgsIGRlcHRoKSB7XG4gIGlmICghZGVwdGgpIGRlcHRoID0gZXhwb3J0cy5kZXB0aChpbmRleClcbiAgdmFyIG9mZnNldCA9IGV4cG9ydHMub2Zmc2V0KGluZGV4LCBkZXB0aClcblxuICByZXR1cm4gZXhwb3J0cy5pbmRleChkZXB0aCArIDEsIHJpZ2h0U2hpZnQob2Zmc2V0KSlcbn1cblxuZXhwb3J0cy5sZWZ0Q2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgsIGRlcHRoKSB7XG4gIGlmICghKGluZGV4ICYgMSkpIHJldHVybiAtMVxuICBpZiAoIWRlcHRoKSBkZXB0aCA9IGV4cG9ydHMuZGVwdGgoaW5kZXgpXG4gIHJldHVybiBleHBvcnRzLmluZGV4KGRlcHRoIC0gMSwgZXhwb3J0cy5vZmZzZXQoaW5kZXgsIGRlcHRoKSAqIDIpXG59XG5cbmV4cG9ydHMucmlnaHRDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCwgZGVwdGgpIHtcbiAgaWYgKCEoaW5kZXggJiAxKSkgcmV0dXJuIC0xXG4gIGlmICghZGVwdGgpIGRlcHRoID0gZXhwb3J0cy5kZXB0aChpbmRleClcbiAgcmV0dXJuIGV4cG9ydHMuaW5kZXgoZGVwdGggLSAxLCAxICsgKGV4cG9ydHMub2Zmc2V0KGluZGV4LCBkZXB0aCkgKiAyKSlcbn1cblxuZXhwb3J0cy5jaGlsZHJlbiA9IGZ1bmN0aW9uIChpbmRleCwgZGVwdGgpIHtcbiAgaWYgKCEoaW5kZXggJiAxKSkgcmV0dXJuIG51bGxcblxuICBpZiAoIWRlcHRoKSBkZXB0aCA9IGV4cG9ydHMuZGVwdGgoaW5kZXgpXG4gIHZhciBvZmZzZXQgPSBleHBvcnRzLm9mZnNldChpbmRleCwgZGVwdGgpICogMlxuXG4gIHJldHVybiBbXG4gICAgZXhwb3J0cy5pbmRleChkZXB0aCAtIDEsIG9mZnNldCksXG4gICAgZXhwb3J0cy5pbmRleChkZXB0aCAtIDEsIG9mZnNldCArIDEpXG4gIF1cbn1cblxuZXhwb3J0cy5sZWZ0U3BhbiA9IGZ1bmN0aW9uIChpbmRleCwgZGVwdGgpIHtcbiAgaWYgKCEoaW5kZXggJiAxKSkgcmV0dXJuIGluZGV4XG4gIGlmICghZGVwdGgpIGRlcHRoID0gZXhwb3J0cy5kZXB0aChpbmRleClcbiAgcmV0dXJuIGV4cG9ydHMub2Zmc2V0KGluZGV4LCBkZXB0aCkgKiB0d29Qb3coZGVwdGggKyAxKVxufVxuXG5leHBvcnRzLnJpZ2h0U3BhbiA9IGZ1bmN0aW9uIChpbmRleCwgZGVwdGgpIHtcbiAgaWYgKCEoaW5kZXggJiAxKSkgcmV0dXJuIGluZGV4XG4gIGlmICghZGVwdGgpIGRlcHRoID0gZXhwb3J0cy5kZXB0aChpbmRleClcbiAgcmV0dXJuIChleHBvcnRzLm9mZnNldChpbmRleCwgZGVwdGgpICsgMSkgKiB0d29Qb3coZGVwdGggKyAxKSAtIDJcbn1cblxuZXhwb3J0cy5jb3VudCA9IGZ1bmN0aW9uIChpbmRleCwgZGVwdGgpIHtcbiAgaWYgKCEoaW5kZXggJiAxKSkgcmV0dXJuIDFcbiAgaWYgKCFkZXB0aCkgZGVwdGggPSBleHBvcnRzLmRlcHRoKGluZGV4KVxuICByZXR1cm4gdHdvUG93KGRlcHRoICsgMSkgLSAxXG59XG5cbmV4cG9ydHMuc3BhbnMgPSBmdW5jdGlvbiAoaW5kZXgsIGRlcHRoKSB7XG4gIGlmICghKGluZGV4ICYgMSkpIHJldHVybiBbaW5kZXgsIGluZGV4XVxuICBpZiAoIWRlcHRoKSBkZXB0aCA9IGV4cG9ydHMuZGVwdGgoaW5kZXgpXG5cbiAgdmFyIG9mZnNldCA9IGV4cG9ydHMub2Zmc2V0KGluZGV4LCBkZXB0aClcbiAgdmFyIHdpZHRoID0gdHdvUG93KGRlcHRoICsgMSlcblxuICByZXR1cm4gW29mZnNldCAqIHdpZHRoLCAob2Zmc2V0ICsgMSkgKiB3aWR0aCAtIDJdXG59XG5cbmV4cG9ydHMuaW5kZXggPSBmdW5jdGlvbiAoZGVwdGgsIG9mZnNldCkge1xuICByZXR1cm4gKDEgKyAyICogb2Zmc2V0KSAqIHR3b1BvdyhkZXB0aCkgLSAxXG59XG5cbmV4cG9ydHMub2Zmc2V0ID0gZnVuY3Rpb24gKGluZGV4LCBkZXB0aCkge1xuICBpZiAoIShpbmRleCAmIDEpKSByZXR1cm4gaW5kZXggLyAyXG4gIGlmICghZGVwdGgpIGRlcHRoID0gZXhwb3J0cy5kZXB0aChpbmRleClcblxuICByZXR1cm4gKChpbmRleCArIDEpIC8gdHdvUG93KGRlcHRoKSAtIDEpIC8gMlxufVxuXG5leHBvcnRzLml0ZXJhdG9yID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHZhciBpdGUgPSBuZXcgSXRlcmF0b3IoKVxuICBpdGUuc2VlayhpbmRleCB8fCAwKVxuICByZXR1cm4gaXRlXG59XG5cbmZ1bmN0aW9uIHR3b1BvdyAobikge1xuICByZXR1cm4gbiA8IDMxID8gMSA8PCBuIDogKCgxIDw8IDMwKSAqICgxIDw8IChuIC0gMzApKSlcbn1cblxuZnVuY3Rpb24gcmlnaHRTaGlmdCAobikge1xuICByZXR1cm4gKG4gLSAobiAmIDEpKSAvIDJcbn1cblxuZnVuY3Rpb24gSXRlcmF0b3IgKGluZGV4KSB7XG4gIHRoaXMuaW5kZXggPSAwXG4gIHRoaXMub2Zmc2V0ID0gMFxuICB0aGlzLmZhY3RvciA9IDBcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdGhpcy5pbmRleCA9IGluZGV4XG4gIGlmICh0aGlzLmluZGV4ICYgMSkge1xuICAgIHRoaXMub2Zmc2V0ID0gZXhwb3J0cy5vZmZzZXQoaW5kZXgpXG4gICAgdGhpcy5mYWN0b3IgPSB0d29Qb3coZXhwb3J0cy5kZXB0aChpbmRleCkgKyAxKVxuICB9IGVsc2Uge1xuICAgIHRoaXMub2Zmc2V0ID0gaW5kZXggLyAyXG4gICAgdGhpcy5mYWN0b3IgPSAyXG4gIH1cbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLmlzTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEodGhpcy5vZmZzZXQgJiAxKVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuaXNSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICF0aGlzLmlzTGVmdCgpXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMub2Zmc2V0KSByZXR1cm4gdGhpcy5pbmRleFxuICB0aGlzLm9mZnNldC0tXG4gIHRoaXMuaW5kZXggLT0gdGhpcy5mYWN0b3JcbiAgcmV0dXJuIHRoaXMuaW5kZXhcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub2Zmc2V0KytcbiAgdGhpcy5pbmRleCArPSB0aGlzLmZhY3RvclxuICByZXR1cm4gdGhpcy5pbmRleFxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuc2libGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNMZWZ0KCkgPyB0aGlzLm5leHQoKSA6IHRoaXMucHJldigpXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm9mZnNldCAmIDEpIHtcbiAgICB0aGlzLmluZGV4IC09IHRoaXMuZmFjdG9yIC8gMlxuICAgIHRoaXMub2Zmc2V0ID0gKHRoaXMub2Zmc2V0IC0gMSkgLyAyXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pbmRleCArPSB0aGlzLmZhY3RvciAvIDJcbiAgICB0aGlzLm9mZnNldCAvPSAyXG4gIH1cbiAgdGhpcy5mYWN0b3IgKj0gMlxuICByZXR1cm4gdGhpcy5pbmRleFxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUubGVmdFNwYW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaW5kZXggPSB0aGlzLmluZGV4IC0gdGhpcy5mYWN0b3IgLyAyICsgMVxuICB0aGlzLm9mZnNldCA9IHRoaXMuaW5kZXggLyAyXG4gIHRoaXMuZmFjdG9yID0gMlxuICByZXR1cm4gdGhpcy5pbmRleFxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUucmlnaHRTcGFuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmluZGV4ID0gdGhpcy5pbmRleCArIHRoaXMuZmFjdG9yIC8gMiAtIDFcbiAgdGhpcy5vZmZzZXQgPSB0aGlzLmluZGV4IC8gMlxuICB0aGlzLmZhY3RvciA9IDJcbiAgcmV0dXJuIHRoaXMuaW5kZXhcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLmxlZnRDaGlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZmFjdG9yID09PSAyKSByZXR1cm4gdGhpcy5pbmRleFxuICB0aGlzLmZhY3RvciAvPSAyXG4gIHRoaXMuaW5kZXggLT0gdGhpcy5mYWN0b3IgLyAyXG4gIHRoaXMub2Zmc2V0ICo9IDJcbiAgcmV0dXJuIHRoaXMuaW5kZXhcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLnJpZ2h0Q2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmZhY3RvciA9PT0gMikgcmV0dXJuIHRoaXMuaW5kZXhcbiAgdGhpcy5mYWN0b3IgLz0gMlxuICB0aGlzLmluZGV4ICs9IHRoaXMuZmFjdG9yIC8gMlxuICB0aGlzLm9mZnNldCA9IDIgKiB0aGlzLm9mZnNldCArIDFcbiAgcmV0dXJuIHRoaXMuaW5kZXhcbn1cbiIsInZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnJvbTJcblxuZnJvbTIuY3RvciA9IGN0b3JcbmZyb20yLm9iaiA9IG9ialxuXG52YXIgUHJvdG8gPSBjdG9yKClcblxuZnVuY3Rpb24gdG9GdW5jdGlvbihsaXN0KSB7XG4gIGxpc3QgPSBsaXN0LnNsaWNlKClcbiAgcmV0dXJuIGZ1bmN0aW9uIChfLCBjYikge1xuICAgIHZhciBlcnIgPSBudWxsXG4gICAgdmFyIGl0ZW0gPSBsaXN0Lmxlbmd0aCA/IGxpc3Quc2hpZnQoKSA6IG51bGxcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBlcnIgPSBpdGVtXG4gICAgICBpdGVtID0gbnVsbFxuICAgIH1cblxuICAgIGNiKGVyciwgaXRlbSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmcm9tMihvcHRzLCByZWFkKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgIHJlYWQgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cblxuICB2YXIgcnMgPSBuZXcgUHJvdG8ob3B0cylcbiAgcnMuX2Zyb20gPSBBcnJheS5pc0FycmF5KHJlYWQpID8gdG9GdW5jdGlvbihyZWFkKSA6IChyZWFkIHx8IG5vb3ApXG4gIHJldHVybiByc1xufVxuXG5mdW5jdGlvbiBjdG9yKG9wdHMsIHJlYWQpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVhZCA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuXG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzKVxuXG4gIGluaGVyaXRzKENsYXNzLCBSZWFkYWJsZSlcbiAgZnVuY3Rpb24gQ2xhc3Mob3ZlcnJpZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2xhc3MpKSByZXR1cm4gbmV3IENsYXNzKG92ZXJyaWRlKVxuICAgIHRoaXMuX3JlYWRpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2NhbGxiYWNrID0gY2hlY2tcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCBvdmVycmlkZSB8fCBvcHRzKVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdmFyIGh3bSA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya1xuXG4gICAgZnVuY3Rpb24gY2hlY2soZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZGVzdHJveShlcnIpXG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHNlbGYucHVzaChudWxsKVxuICAgICAgc2VsZi5fcmVhZGluZyA9IGZhbHNlXG4gICAgICBpZiAoc2VsZi5wdXNoKGRhdGEpKSBzZWxmLl9yZWFkKGh3bSlcbiAgICB9XG4gIH1cblxuICBDbGFzcy5wcm90b3R5cGUuX2Zyb20gPSByZWFkIHx8IG5vb3BcbiAgQ2xhc3MucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkaW5nIHx8IHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICB0aGlzLl9yZWFkaW5nID0gdHJ1ZVxuICAgIHRoaXMuX2Zyb20oc2l6ZSwgdGhpcy5fY2FsbGJhY2spXG4gIH1cblxuICBDbGFzcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGVycikge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gQ2xhc3Ncbn1cblxuZnVuY3Rpb24gb2JqKG9wdHMsIHJlYWQpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICByZWFkID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG5cbiAgb3B0cyA9IGRlZmF1bHRzKG9wdHMpXG4gIG9wdHMub2JqZWN0TW9kZSA9IHRydWVcbiAgb3B0cy5oaWdoV2F0ZXJNYXJrID0gMTZcblxuICByZXR1cm4gZnJvbTIob3B0cywgcmVhZClcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBkZWZhdWx0cyhvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIHJldHVybiBvcHRzXG59XG4iLCJ2YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxudmFyIG1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpXG52YXIgYnVmZmVyQWxsb2MgPSByZXF1aXJlKCdidWZmZXItYWxsb2MtdW5zYWZlJylcblxubW9kdWxlLmV4cG9ydHMgPSBGZWVkXG5cbmZ1bmN0aW9uIEZlZWQgKHN0cmVhbSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmVlZCkpIHJldHVybiBuZXcgRmVlZChzdHJlYW0pXG4gIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuXG4gIHRoaXMua2V5ID0gbnVsbFxuICB0aGlzLmRpc2NvdmVyeUtleSA9IG51bGxcbiAgdGhpcy5zdHJlYW0gPSBzdHJlYW1cbiAgdGhpcy5wZWVyID0gbnVsbCAvLyBzdXBwb3J0IGEgcGVlciBvYmplY3QgdG8gYXZvaWQgZXZlbnQgZW1pdHRlciArIGNsb3N1cmVzIG92ZXJoZWFkXG5cbiAgdGhpcy5pZCA9IC0xXG4gIHRoaXMucmVtb3RlSWQgPSAtMVxuICB0aGlzLmhlYWRlciA9IDBcbiAgdGhpcy5oZWFkZXJMZW5ndGggPSAwXG4gIHRoaXMuY2xvc2VkID0gZmFsc2VcblxuICB0aGlzLl9idWZmZXIgPSBbXVxufVxuXG5pbmhlcml0cyhGZWVkLCBldmVudHMuRXZlbnRFbWl0dGVyKVxuXG5GZWVkLnByb3RvdHlwZS5oYW5kc2hha2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy5fc2VuZCgxLCBtZXNzYWdlcy5IYW5kc2hha2UsIG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy5fc2VuZCgyLCBtZXNzYWdlcy5JbmZvLCBtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS5oYXZlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbmQoMywgbWVzc2FnZXMuSGF2ZSwgbWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUudW5oYXZlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbmQoNCwgbWVzc2FnZXMuVW5oYXZlLCBtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS53YW50ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbmQoNSwgbWVzc2FnZXMuV2FudCwgbWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUudW53YW50ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbmQoNiwgbWVzc2FnZXMuVW53YW50LCBtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbmQoNywgbWVzc2FnZXMuUmVxdWVzdCwgbWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbmQoOCwgbWVzc2FnZXMuQ2FuY2VsLCBtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbmQoOSwgbWVzc2FnZXMuRGF0YSwgbWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUuZXh0ZW5zaW9uID0gZnVuY3Rpb24gKHR5cGUsIG1lc3NhZ2UpIHtcbiAgdmFyIGlkID0gdGhpcy5zdHJlYW0uZXh0ZW5zaW9ucy5pbmRleE9mKHR5cGUpXG4gIGlmIChpZCA9PT0gLTEpIHJldHVybiBmYWxzZVxuXG4gIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlciB8IDE1XG4gIHZhciBsZW4gPSB0aGlzLmhlYWRlckxlbmd0aCArIHZhcmludC5lbmNvZGluZ0xlbmd0aChpZCkgKyBtZXNzYWdlLmxlbmd0aFxuICB2YXIgYm94ID0gYnVmZmVyQWxsb2ModmFyaW50LmVuY29kaW5nTGVuZ3RoKGxlbikgKyBsZW4pXG4gIHZhciBvZmZzZXQgPSAwXG5cbiAgdmFyaW50LmVuY29kZShsZW4sIGJveCwgb2Zmc2V0KVxuICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuXG4gIHZhcmludC5lbmNvZGUoaGVhZGVyLCBib3gsIG9mZnNldClcbiAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcblxuICB2YXJpbnQuZW5jb2RlKGlkLCBib3gsIG9mZnNldClcbiAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcblxuICBtZXNzYWdlLmNvcHkoYm94LCBvZmZzZXQpXG4gIHJldHVybiB0aGlzLnN0cmVhbS5fcHVzaChib3gpXG59XG5cbkZlZWQucHJvdG90eXBlLnJlbW90ZVN1cHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuc3RyZWFtLnJlbW90ZVN1cHBvcnRzKG5hbWUpXG59XG5cbkZlZWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuc3RyZWFtLmRlc3Ryb3koZXJyKVxufVxuXG5GZWVkLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSB0aGlzLnN0cmVhbS5mZWVkcy5pbmRleE9mKHRoaXMpXG5cbiAgaWYgKGkgPiAtMSkge1xuICAgIHRoaXMuc3RyZWFtLmZlZWRzW2ldID0gdGhpcy5zdHJlYW0uZmVlZHNbdGhpcy5zdHJlYW0uZmVlZHMubGVuZ3RoIC0gMV1cbiAgICB0aGlzLnN0cmVhbS5mZWVkcy5wb3AoKVxuICAgIHRoaXMuc3RyZWFtLl9sb2NhbEZlZWRzW3RoaXMuaWRdID0gbnVsbFxuICAgIHRoaXMuaWQgPSAtMVxuXG4gICAgaWYgKHRoaXMuc3RyZWFtLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKHRoaXMuc3RyZWFtLmV4cGVjdGVkRmVlZHMgPD0gMCB8fCAtLXRoaXMuc3RyZWFtLmV4cGVjdGVkRmVlZHMpIHJldHVyblxuXG4gICAgdGhpcy5zdHJlYW0uX3ByZWZpbmFsaXplKClcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fb25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2xvc2VkKSByZXR1cm5cbiAgdGhpcy5jbG9zZWQgPSB0cnVlXG5cbiAgaWYgKCF0aGlzLnN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLmNsb3NlKClcbiAgICBpZiAodGhpcy5yZW1vdGVJZCA+IC0xKSB0aGlzLnN0cmVhbS5fcmVtb3RlRmVlZHNbdGhpcy5yZW1vdGVJZF0gPSBudWxsXG4gICAgdmFyIGhleCA9IHRoaXMuZGlzY292ZXJ5S2V5LnRvU3RyaW5nKCdoZXgnKVxuICAgIGlmICh0aGlzLnN0cmVhbS5fZmVlZHNbaGV4XSA9PT0gdGhpcykgZGVsZXRlIHRoaXMuc3RyZWFtLl9mZWVkc1toZXhdXG4gIH1cblxuICBpZiAodGhpcy5wZWVyKSB0aGlzLnBlZXIub25jbG9zZSgpXG4gIGVsc2UgdGhpcy5lbWl0KCdjbG9zZScpXG59XG5cbkZlZWQucHJvdG90eXBlLl9yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSlcblxuICBmdW5jdGlvbiByZXN1bWUgKCkge1xuICAgIHdoaWxlIChzZWxmLl9idWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YXIgbmV4dCA9IHNlbGYuX2J1ZmZlci5zaGlmdCgpXG4gICAgICBzZWxmLl9lbWl0KG5leHQudHlwZSwgbmV4dC5tZXNzYWdlKVxuICAgIH1cbiAgICBzZWxmLl9idWZmZXIgPSBudWxsXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX29uZXh0ZW5zaW9uID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuXG5cbiAgdmFyIGlkID0gdmFyaW50LmRlY29kZShkYXRhLCBzdGFydClcbiAgdmFyIHIgPSB0aGlzLnN0cmVhbS5yZW1vdGVFeHRlbnNpb25zXG4gIHZhciBsb2NhbElkID0gIXIgfHwgaWQgPj0gci5sZW5ndGggPyAtMSA6IHJbaWRdXG5cbiAgaWYgKGxvY2FsSWQgPT09IC0xKSByZXR1cm5cblxuICB2YXIgbWVzc2FnZSA9IGRhdGEuc2xpY2Uoc3RhcnQgKyB2YXJpbnQuZGVjb2RlLmJ5dGVzLCBlbmQpXG4gIHZhciBuYW1lID0gdGhpcy5zdHJlYW0uZXh0ZW5zaW9uc1tsb2NhbElkXVxuXG4gIGlmICh0aGlzLnBlZXIgJiYgdGhpcy5wZWVyLm9uZXh0ZW5zaW9uKSB0aGlzLnBlZXIub25leHRlbnNpb24obmFtZSwgbWVzc2FnZSlcbiAgZWxzZSB0aGlzLmVtaXQoJ2V4dGVuc2lvbicsIG5hbWUsIG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLl9vbm1lc3NhZ2UgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgc3RhcnQsIGVuZCkge1xuICB2YXIgbWVzc2FnZSA9IGRlY29kZU1lc3NhZ2UodHlwZSwgZGF0YSwgc3RhcnQsIGVuZClcbiAgaWYgKCFtZXNzYWdlIHx8IHRoaXMuY2xvc2VkKSByZXR1cm5cblxuICBpZiAodHlwZSA9PT0gMSkgcmV0dXJuIHRoaXMuc3RyZWFtLl9vbmhhbmRzaGFrZShtZXNzYWdlKVxuXG4gIGlmICghdGhpcy5fYnVmZmVyKSB7XG4gICAgdGhpcy5fZW1pdCh0eXBlLCBtZXNzYWdlKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHRoaXMuX2J1ZmZlci5sZW5ndGggPiAxNikge1xuICAgIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ1JlbW90ZSBzZW50IHRvbyBtYW55IG1lc3NhZ2VzIG9uIGFuIHVub3BlbmVkIGZlZWQnKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuX2J1ZmZlci5wdXNoKHt0eXBlOiB0eXBlLCBtZXNzYWdlOiBtZXNzYWdlfSlcbn1cblxuRmVlZC5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5wZWVyKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIDI6IHJldHVybiB0aGlzLnBlZXIub25pbmZvKG1lc3NhZ2UpXG4gICAgICBjYXNlIDM6IHJldHVybiB0aGlzLnBlZXIub25oYXZlKG1lc3NhZ2UpXG4gICAgICBjYXNlIDQ6IHJldHVybiB0aGlzLnBlZXIub251bmhhdmUobWVzc2FnZSlcbiAgICAgIGNhc2UgNTogcmV0dXJuIHRoaXMucGVlci5vbndhbnQobWVzc2FnZSlcbiAgICAgIGNhc2UgNjogcmV0dXJuIHRoaXMucGVlci5vbnVud2FudChtZXNzYWdlKVxuICAgICAgY2FzZSA3OiByZXR1cm4gdGhpcy5wZWVyLm9ucmVxdWVzdChtZXNzYWdlKVxuICAgICAgY2FzZSA4OiByZXR1cm4gdGhpcy5wZWVyLm9uY2FuY2VsKG1lc3NhZ2UpXG4gICAgICBjYXNlIDk6IHJldHVybiB0aGlzLnBlZXIub25kYXRhKG1lc3NhZ2UpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAyOiByZXR1cm4gdGhpcy5lbWl0KCdpbmZvJywgbWVzc2FnZSlcbiAgICAgIGNhc2UgMzogcmV0dXJuIHRoaXMuZW1pdCgnaGF2ZScsIG1lc3NhZ2UpXG4gICAgICBjYXNlIDQ6IHJldHVybiB0aGlzLmVtaXQoJ3VuaGF2ZScsIG1lc3NhZ2UpXG4gICAgICBjYXNlIDU6IHJldHVybiB0aGlzLmVtaXQoJ3dhbnQnLCBtZXNzYWdlKVxuICAgICAgY2FzZSA2OiByZXR1cm4gdGhpcy5lbWl0KCd1bndhbnQnLCBtZXNzYWdlKVxuICAgICAgY2FzZSA3OiByZXR1cm4gdGhpcy5lbWl0KCdyZXF1ZXN0JywgbWVzc2FnZSlcbiAgICAgIGNhc2UgODogcmV0dXJuIHRoaXMuZW1pdCgnY2FuY2VsJywgbWVzc2FnZSlcbiAgICAgIGNhc2UgOTogcmV0dXJuIHRoaXMuZW1pdCgnZGF0YScsIG1lc3NhZ2UpXG4gICAgfVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24gKHR5cGUsIGVuYywgbWVzc2FnZSkge1xuICB2YXIgaGVhZGVyID0gdGhpcy5oZWFkZXIgfCB0eXBlXG4gIHZhciBsZW4gPSB0aGlzLmhlYWRlckxlbmd0aCArIGVuYy5lbmNvZGluZ0xlbmd0aChtZXNzYWdlKVxuICB2YXIgYm94ID0gYnVmZmVyQWxsb2ModmFyaW50LmVuY29kaW5nTGVuZ3RoKGxlbikgKyBsZW4pXG4gIHZhciBvZmZzZXQgPSAwXG5cbiAgdmFyaW50LmVuY29kZShsZW4sIGJveCwgb2Zmc2V0KVxuICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuXG4gIHZhcmludC5lbmNvZGUoaGVhZGVyLCBib3gsIG9mZnNldClcbiAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcblxuICBlbmMuZW5jb2RlKG1lc3NhZ2UsIGJveCwgb2Zmc2V0KVxuXG4gIHJldHVybiB0aGlzLnN0cmVhbS5fcHVzaChib3gpXG59XG5cbmZ1bmN0aW9uIGRlY29kZU1lc3NhZ2UgKHR5cGUsIGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZGVjb2RlKG1lc3NhZ2VzLkhhbmRzaGFrZSwgZGF0YSwgc3RhcnQsIGVuZClcbiAgICBjYXNlIDI6IHJldHVybiBkZWNvZGUobWVzc2FnZXMuSW5mbywgZGF0YSwgc3RhcnQsIGVuZClcbiAgICBjYXNlIDM6IHJldHVybiBkZWNvZGUobWVzc2FnZXMuSGF2ZSwgZGF0YSwgc3RhcnQsIGVuZClcbiAgICBjYXNlIDQ6IHJldHVybiBkZWNvZGUobWVzc2FnZXMuVW5oYXZlLCBkYXRhLCBzdGFydCwgZW5kKVxuICAgIGNhc2UgNTogcmV0dXJuIGRlY29kZShtZXNzYWdlcy5XYW50LCBkYXRhLCBzdGFydCwgZW5kKVxuICAgIGNhc2UgNjogcmV0dXJuIGRlY29kZShtZXNzYWdlcy5VbndhbnQsIGRhdGEsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSA3OiByZXR1cm4gZGVjb2RlKG1lc3NhZ2VzLlJlcXVlc3QsIGRhdGEsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSA4OiByZXR1cm4gZGVjb2RlKG1lc3NhZ2VzLkNhbmNlbCwgZGF0YSwgc3RhcnQsIGVuZClcbiAgICBjYXNlIDk6IHJldHVybiBkZWNvZGUobWVzc2FnZXMuRGF0YSwgZGF0YSwgc3RhcnQsIGVuZClcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNvZGUgKGVuYywgZGF0YSwgc3RhcnQsIGVuZCkge1xuICB0cnkge1xuICAgIHJldHVybiBlbmMuZGVjb2RlKGRhdGEsIHN0YXJ0LCBlbmQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiIsInZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG52YXIgc29kaXVtID0gcmVxdWlyZSgnc29kaXVtLXVuaXZlcnNhbCcpXG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ3NvcnRlZC1pbmRleG9mJylcbnZhciBmZWVkID0gcmVxdWlyZSgnLi9mZWVkJylcbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKVxudmFyIGJ1ZmZlckFsbG9jID0gcmVxdWlyZSgnYnVmZmVyLWFsbG9jLXVuc2FmZScpXG52YXIgYnVmZmVyRnJvbSA9IHJlcXVpcmUoJ2J1ZmZlci1mcm9tJylcblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b2NvbFxuXG5mdW5jdGlvbiBQcm90b2NvbCAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvdG9jb2wpKSByZXR1cm4gbmV3IFByb3RvY29sKG9wdHMpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgc3RyZWFtLkR1cGxleC5jYWxsKHRoaXMpXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMuaWQgPSBvcHRzLmlkIHx8IHJhbmRvbUJ5dGVzKDMyKVxuICB0aGlzLmxpdmUgPSAhIW9wdHMubGl2ZVxuICB0aGlzLmFjayA9ICEhb3B0cy5hY2tcbiAgdGhpcy51c2VyRGF0YSA9IG9wdHMudXNlckRhdGEgfHwgbnVsbFxuICB0aGlzLnJlbW90ZUlkID0gbnVsbFxuICB0aGlzLnJlbW90ZUxpdmUgPSBmYWxzZVxuICB0aGlzLnJlbW90ZVVzZXJEYXRhID0gbnVsbFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgdGhpcy5lbmNyeXB0ZWQgPSBvcHRzLmVuY3J5cHQgIT09IGZhbHNlXG4gIHRoaXMua2V5ID0gbnVsbFxuICB0aGlzLmRpc2NvdmVyeUtleSA9IG51bGxcbiAgdGhpcy5yZW1vdGVEaXNjb3ZlcnlLZXkgPSBudWxsXG4gIHRoaXMuZmVlZHMgPSBbXVxuICB0aGlzLmV4cGVjdGVkRmVlZHMgPSBvcHRzLmV4cGVjdGVkRmVlZHMgfHwgMFxuICB0aGlzLmV4dGVuc2lvbnMgPSBvcHRzLmV4dGVuc2lvbnMgfHwgW11cbiAgdGhpcy5yZW1vdGVFeHRlbnNpb25zID0gbnVsbFxuXG4gIHRoaXMuX2xvY2FsRmVlZHMgPSBbXVxuICB0aGlzLl9yZW1vdGVGZWVkcyA9IFtdXG4gIHRoaXMuX2ZlZWRzID0ge31cblxuICB0aGlzLl9ub25jZSA9IG51bGxcbiAgdGhpcy5fcmVtb3RlTm9uY2UgPSBudWxsXG4gIHRoaXMuX3hvciA9IG51bGxcbiAgdGhpcy5fcmVtb3RlWG9yID0gbnVsbFxuICB0aGlzLl9uZWVkc0tleSA9IGZhbHNlXG4gIHRoaXMuX2xlbmd0aCA9IGJ1ZmZlckFsbG9jKHZhcmludC5lbmNvZGluZ0xlbmd0aCg4Mzg4NjA4KSlcbiAgdGhpcy5fbWlzc2luZyA9IDBcbiAgdGhpcy5fYnVmID0gbnVsbFxuICB0aGlzLl9wb2ludGVyID0gMFxuICB0aGlzLl9kYXRhID0gbnVsbFxuICB0aGlzLl9zdGFydCA9IDBcbiAgdGhpcy5fY2IgPSBudWxsXG4gIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICB0aGlzLl9rZWVwQWxpdmUgPSAwXG4gIHRoaXMuX3JlbW90ZUtlZXBBbGl2ZSA9IDBcbiAgdGhpcy5fbWF5YmVGaW5hbGl6ZSA9IG1heWJlRmluYWxpemVcblxuICBpZiAob3B0cy50aW1lb3V0ICE9PSAwICYmIG9wdHMudGltZW91dCAhPT0gZmFsc2UpIHRoaXMuc2V0VGltZW91dChvcHRzLnRpbWVvdXQgfHwgNTAwMCwgdGhpcy5fb250aW1lb3V0KVxuICB0aGlzLm9uKCdmaW5pc2gnLCB0aGlzLmZpbmFsaXplKVxuXG4gIGZ1bmN0aW9uIG1heWJlRmluYWxpemUgKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBzZWxmLmRlc3Ryb3koZXJyKVxuICAgIGlmICghc2VsZi5leHBlY3RlZEZlZWRzKSBzZWxmLmZpbmFsaXplKClcbiAgfVxufVxuXG5pbmhlcml0cyhQcm90b2NvbCwgc3RyZWFtLkR1cGxleClcblxuUHJvdG9jb2wucHJvdG90eXBlLl9wcmVmaW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmVtaXQoJ3ByZWZpbmFsaXplJywgdGhpcy5fbWF5YmVGaW5hbGl6ZSkpIHRoaXMuZmluYWxpemUoKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChtcywgb250aW1lb3V0KSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGlmIChvbnRpbWVvdXQpIHRoaXMub25jZSgndGltZW91dCcsIG9udGltZW91dClcblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLl9rZWVwQWxpdmUgPSAwXG4gIHRoaXMuX3JlbW90ZUtlZXBBbGl2ZSA9IDBcblxuICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKVxuICBpZiAoIW1zKSByZXR1cm5cblxuICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGtpY2ssIChtcyAvIDQpIHwgMClcbiAgaWYgKHRoaXMuX2ludGVydmFsLnVucmVmKSB0aGlzLl9pbnRlcnZhbC51bnJlZigpXG5cbiAgZnVuY3Rpb24ga2ljayAoKSB7XG4gICAgc2VsZi5fa2ljaygpXG4gIH1cbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLmZlZWQgPSBmdW5jdGlvbiAoa2V5LCBvcHRzKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIG51bGxcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICB2YXIgZGsgPSBvcHRzLmRpc2NvdmVyeUtleSB8fCBkaXNjb3ZlcnlLZXkoa2V5KVxuICB2YXIgY2ggPSB0aGlzLl9mZWVkKGRrKVxuXG4gIGlmIChjaC5pZCA+IC0xKSB7XG4gICAgaWYgKG9wdHMucGVlcikgY2gucGVlciA9IG9wdHMucGVlclxuICAgIHJldHVybiBjaFxuICB9XG5cbiAgaWYgKHRoaXMuX2xvY2FsRmVlZHMubGVuZ3RoID49IDEyOCkge1xuICAgIHRoaXMuX3Rvb01hbnlGZWVkcygpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNoLmlkID0gdGhpcy5fbG9jYWxGZWVkcy5wdXNoKGNoKSAtIDFcbiAgY2guaGVhZGVyID0gY2guaWQgPDwgNFxuICBjaC5oZWFkZXJMZW5ndGggPSB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoY2guaGVhZGVyKVxuICBjaC5rZXkgPSBrZXlcbiAgY2guZGlzY292ZXJ5S2V5ID0gZGtcbiAgaWYgKG9wdHMucGVlcikgY2gucGVlciA9IG9wdHMucGVlclxuXG4gIHRoaXMuZmVlZHMucHVzaChjaClcblxuICB2YXIgZmlyc3QgPSAhdGhpcy5rZXlcbiAgdmFyIGZlZWQgPSB7XG4gICAgZGlzY292ZXJ5S2V5OiBkayxcbiAgICBub25jZTogbnVsbFxuICB9XG5cbiAgaWYgKGZpcnN0KSB7XG4gICAgdGhpcy5rZXkgPSBrZXlcbiAgICB0aGlzLmRpc2NvdmVyeUtleSA9IGRrXG5cbiAgICBpZiAoIXRoaXMuX3NhbWVLZXkoKSkgcmV0dXJuIG51bGxcblxuICAgIGlmICh0aGlzLmVuY3J5cHRlZCkge1xuICAgICAgZmVlZC5ub25jZSA9IHRoaXMuX25vbmNlID0gcmFuZG9tQnl0ZXMoMjQpXG4gICAgICB0aGlzLl94b3IgPSBzb2RpdW0uY3J5cHRvX3N0cmVhbV94b3JfaW5zdGFuY2UodGhpcy5fbm9uY2UsIHRoaXMua2V5KVxuICAgICAgaWYgKHRoaXMuX3JlbW90ZU5vbmNlKSB7XG4gICAgICAgIHRoaXMuX3JlbW90ZVhvciA9IHNvZGl1bS5jcnlwdG9fc3RyZWFtX3hvcl9pbnN0YW5jZSh0aGlzLl9yZW1vdGVOb25jZSwgdGhpcy5rZXkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzS2V5KSB7XG4gICAgICB0aGlzLl9uZWVkc0tleSA9IGZhbHNlXG4gICAgICB0aGlzLl9yZXN1bWUoKVxuICAgIH1cbiAgfVxuXG4gIHZhciBib3ggPSBlbmNvZGVGZWVkKGZlZWQsIGNoLmlkKVxuICBpZiAoIWZlZWQubm9uY2UgJiYgdGhpcy5lbmNyeXB0ZWQpIHRoaXMuX3hvci51cGRhdGUoYm94LCBib3gpXG4gIHRoaXMuX2tlZXBBbGl2ZSA9IDBcbiAgdGhpcy5wdXNoKGJveClcblxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybiBudWxsXG5cbiAgaWYgKGZpcnN0KSB7XG4gICAgY2guaGFuZHNoYWtlKHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgbGl2ZTogdGhpcy5saXZlLFxuICAgICAgdXNlckRhdGE6IHRoaXMudXNlckRhdGEsXG4gICAgICBleHRlbnNpb25zOiB0aGlzLmV4dGVuc2lvbnMsXG4gICAgICBhY2s6IHRoaXMuYWNrXG4gICAgfSlcbiAgfVxuXG4gIGlmIChjaC5fYnVmZmVyLmxlbmd0aCkgY2guX3Jlc3VtZSgpXG4gIGVsc2UgY2guX2J1ZmZlciA9IG51bGxcblxuICByZXR1cm4gY2hcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSlcblxuICBmdW5jdGlvbiByZXN1bWUgKCkge1xuICAgIGlmICghc2VsZi5fZGF0YSkgcmV0dXJuXG5cbiAgICB2YXIgZGF0YSA9IHNlbGYuX2RhdGFcbiAgICB2YXIgc3RhcnQgPSBzZWxmLl9zdGFydFxuICAgIHZhciBjYiA9IHNlbGYuX2NiXG5cbiAgICBzZWxmLl9kYXRhID0gbnVsbFxuICAgIHNlbGYuX3N0YXJ0ID0gMFxuICAgIHNlbGYuX2NiID0gbnVsbFxuICAgIHNlbGYuX3BhcnNlKGRhdGEsIHN0YXJ0LCBjYilcbiAgfVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX2tpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9yZW1vdGVLZWVwQWxpdmUgPiA0KSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbClcbiAgICB0aGlzLmVtaXQoJ3RpbWVvdXQnKVxuICAgIHJldHVyblxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZlZWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoID0gdGhpcy5mZWVkc1tpXVxuICAgIGlmIChjaC5wZWVyKSBjaC5wZWVyLm9udGljaygpXG4gICAgZWxzZSBjaC5lbWl0KCd0aWNrJylcbiAgfVxuXG4gIHRoaXMuX3JlbW90ZUtlZXBBbGl2ZSsrXG5cbiAgaWYgKHRoaXMuX2tlZXBBbGl2ZSA+IDIpIHtcbiAgICB0aGlzLnBpbmcoKVxuICAgIHRoaXMuX2tlZXBBbGl2ZSA9IDBcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9rZWVwQWxpdmUrK1xuICB9XG59XG5cblByb3RvY29sLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMua2V5KSByZXR1cm4gdHJ1ZVxuICB2YXIgcGluZyA9IGJ1ZmZlckZyb20oWzBdKVxuICBpZiAodGhpcy5feG9yKSB0aGlzLl94b3IudXBkYXRlKHBpbmcsIHBpbmcpXG4gIHJldHVybiB0aGlzLnB1c2gocGluZylcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLl9jbG9zZSgpXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICB0aGlzLl9jbG9zZSgpXG4gIHRoaXMucHVzaChudWxsKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKVxuXG4gIHZhciBmZWVkcyA9IHRoaXMuZmVlZHNcbiAgdGhpcy5mZWVkcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmVlZHMubGVuZ3RoOyBpKyspIGZlZWRzW2ldLl9vbmNsb3NlKClcblxuICBpZiAodGhpcy5feG9yKSB7XG4gICAgdGhpcy5feG9yLmZpbmFsKClcbiAgICB0aGlzLl94b3IgPSBudWxsXG4gIH1cbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAvLyBkbyBub3RoaW5nLCB1c2VyIGJhY2stcHJlc3N1cmVzXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2tlZXBBbGl2ZSA9IDBcbiAgaWYgKHRoaXMuX3hvcikgdGhpcy5feG9yLnVwZGF0ZShkYXRhLCBkYXRhKVxuICByZXR1cm4gdGhpcy5wdXNoKGRhdGEpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jLCBjYikge1xuICB0aGlzLl9yZW1vdGVLZWVwQWxpdmUgPSAwXG4gIHRoaXMuX3BhcnNlKGRhdGEsIDAsIGNiKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX2ZlZWQgPSBmdW5jdGlvbiAoZGspIHtcbiAgdmFyIGhleCA9IGRrLnRvU3RyaW5nKCdoZXgnKVxuICB2YXIgY2ggPSB0aGlzLl9mZWVkc1toZXhdXG4gIGlmIChjaCkgcmV0dXJuIGNoXG4gIGNoID0gdGhpcy5fZmVlZHNbaGV4XSA9IGZlZWQodGhpcylcbiAgcmV0dXJuIGNoXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5yZW1vdGVTdXBwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBpID0gdGhpcy5leHRlbnNpb25zLmluZGV4T2YobmFtZSlcbiAgcmV0dXJuIGkgPiAtMSAmJiAhIXRoaXMucmVtb3RlRXh0ZW5zaW9ucyAmJiB0aGlzLnJlbW90ZUV4dGVuc2lvbnMuaW5kZXhPZihpKSA+IC0xXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fb25oYW5kc2hha2UgPSBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gIGlmICh0aGlzLnJlbW90ZUlkKSByZXR1cm5cblxuICB0aGlzLnJlbW90ZUlkID0gaGFuZHNoYWtlLmlkIHx8IHJhbmRvbUJ5dGVzKDMyKVxuICB0aGlzLnJlbW90ZUxpdmUgPSBoYW5kc2hha2UubGl2ZVxuICB0aGlzLnJlbW90ZVVzZXJEYXRhID0gaGFuZHNoYWtlLnVzZXJEYXRhXG4gIHRoaXMucmVtb3RlRXh0ZW5zaW9ucyA9IGluZGV4T2YodGhpcy5leHRlbnNpb25zLCBoYW5kc2hha2UuZXh0ZW5zaW9ucylcbiAgdGhpcy5yZW1vdGVBY2sgPSBoYW5kc2hha2UuYWNrXG5cbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX29ub3BlbiA9IGZ1bmN0aW9uIChpZCwgZGF0YSwgc3RhcnQsIGVuZCkge1xuICB2YXIgZmVlZCA9IGRlY29kZUZlZWQoZGF0YSwgc3RhcnQsIGVuZClcblxuICBpZiAoIWZlZWQpIHJldHVybiB0aGlzLl9iYWRGZWVkKClcblxuICBpZiAoIXRoaXMucmVtb3RlRGlzY292ZXJ5S2V5KSB7XG4gICAgdGhpcy5yZW1vdGVEaXNjb3ZlcnlLZXkgPSBmZWVkLmRpc2NvdmVyeUtleVxuICAgIGlmICghdGhpcy5fc2FtZUtleSgpKSByZXR1cm5cblxuICAgIGlmICh0aGlzLmVuY3J5cHRlZCAmJiAhdGhpcy5fcmVtb3RlTm9uY2UpIHtcbiAgICAgIGlmICghZmVlZC5ub25jZSkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdSZW1vdGUgZGlkIG5vdCBpbmNsdWRlIGEgbm9uY2UnKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLl9yZW1vdGVOb25jZSA9IGZlZWQubm9uY2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbmNyeXB0ZWQgJiYgdGhpcy5rZXkgJiYgIXRoaXMuX3JlbW90ZVhvcikge1xuICAgICAgdGhpcy5fcmVtb3RlWG9yID0gc29kaXVtLmNyeXB0b19zdHJlYW1feG9yX2luc3RhbmNlKHRoaXMuX3JlbW90ZU5vbmNlLCB0aGlzLmtleSlcbiAgICB9XG4gIH1cblxuICB0aGlzLl9yZW1vdGVGZWVkc1tpZF0gPSB0aGlzLl9mZWVkKGZlZWQuZGlzY292ZXJ5S2V5KVxuICBmZWVkLnJlbW90ZUlkID0gaWRcblxuICB0aGlzLmVtaXQoJ2ZlZWQnLCBmZWVkLmRpc2NvdmVyeUtleSlcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kIC0gc3RhcnQgPCAyKSByZXR1cm5cblxuICB2YXIgaGVhZGVyID0gZGVjb2RlSGVhZGVyKGRhdGEsIHN0YXJ0KVxuICBpZiAoaGVhZGVyID09PSAtMSkgcmV0dXJuIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ1JlbW90ZSBzZW50IGludmFsaWQgaGVhZGVyJykpXG5cbiAgc3RhcnQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gIHZhciBpZCA9IGhlYWRlciA+PiA0XG4gIHZhciB0eXBlID0gaGVhZGVyICYgMTVcblxuICBpZiAoaWQgPj0gMTI4KSByZXR1cm4gdGhpcy5fdG9vTWFueUZlZWRzKClcbiAgd2hpbGUgKHRoaXMuX3JlbW90ZUZlZWRzLmxlbmd0aCA8IGlkKSB0aGlzLl9yZW1vdGVGZWVkcy5wdXNoKG51bGwpXG5cbiAgdmFyIGNoID0gdGhpcy5fcmVtb3RlRmVlZHNbaWRdXG5cbiAgaWYgKHR5cGUgPT09IDApIHtcbiAgICBpZiAoY2gpIGNoLl9vbmNsb3NlKClcbiAgICByZXR1cm4gdGhpcy5fb25vcGVuKGlkLCBkYXRhLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgaWYgKCFjaCkgcmV0dXJuIHRoaXMuX2JhZEZlZWQoKVxuICBpZiAodHlwZSA9PT0gMTUpIHJldHVybiBjaC5fb25leHRlbnNpb24oZGF0YSwgc3RhcnQsIGVuZClcbiAgY2guX29ubWVzc2FnZSh0eXBlLCBkYXRhLCBzdGFydCwgZW5kKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBjYikge1xuICB2YXIgZGVjcnlwdGVkID0gISF0aGlzLl9yZW1vdGVYb3JcblxuICBpZiAoc3RhcnQpIHtcbiAgICBkYXRhID0gZGF0YS5zbGljZShzdGFydClcbiAgICBzdGFydCA9IDBcbiAgfVxuXG4gIGlmICh0aGlzLl9yZW1vdGVYb3IpIHRoaXMuX3JlbW90ZVhvci51cGRhdGUoZGF0YSwgZGF0YSlcblxuICB3aGlsZSAoc3RhcnQgPCBkYXRhLmxlbmd0aCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICBpZiAodGhpcy5fbWlzc2luZykgc3RhcnQgPSB0aGlzLl9wYXJzZU1lc3NhZ2UoZGF0YSwgc3RhcnQpXG4gICAgZWxzZSBzdGFydCA9IHRoaXMuX3BhcnNlTGVuZ3RoKGRhdGEsIHN0YXJ0KVxuXG4gICAgaWYgKHRoaXMuX25lZWRzS2V5KSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YVxuICAgICAgdGhpcy5fc3RhcnQgPSBzdGFydFxuICAgICAgdGhpcy5fY2IgPSBjYlxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFkZWNyeXB0ZWQgJiYgdGhpcy5fcmVtb3RlWG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2UoZGF0YSwgc3RhcnQsIGNiKVxuICAgIH1cbiAgfVxuXG4gIGNiKClcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9wYXJzZU1lc3NhZ2UgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQpIHtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgdGhpcy5fbWlzc2luZ1xuXG4gIGlmIChlbmQgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICB2YXIgcmV0ID0gZW5kXG5cbiAgICBpZiAodGhpcy5fYnVmKSB7XG4gICAgICBkYXRhLmNvcHkodGhpcy5fYnVmLCB0aGlzLl9wb2ludGVyLCBzdGFydClcbiAgICAgIGRhdGEgPSB0aGlzLl9idWZcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gZGF0YS5sZW5ndGhcbiAgICAgIHRoaXMuX2J1ZiA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLl9taXNzaW5nID0gMFxuICAgIHRoaXMuX3BvaW50ZXIgPSAwXG4gICAgaWYgKHRoaXMuZW5jcnlwdGVkICYmICF0aGlzLmtleSkgdGhpcy5fbmVlZHNLZXkgPSB0cnVlXG4gICAgdGhpcy5fb25tZXNzYWdlKGRhdGEsIHN0YXJ0LCBlbmQpXG5cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBpZiAoIXRoaXMuX2J1Zikge1xuICAgIHRoaXMuX2J1ZiA9IGJ1ZmZlckFsbG9jKHRoaXMuX21pc3NpbmcpXG4gICAgdGhpcy5fcG9pbnRlciA9IDBcbiAgfVxuXG4gIHZhciByZW0gPSBkYXRhLmxlbmd0aCAtIHN0YXJ0XG5cbiAgZGF0YS5jb3B5KHRoaXMuX2J1ZiwgdGhpcy5fcG9pbnRlciwgc3RhcnQpXG4gIHRoaXMuX3BvaW50ZXIgKz0gcmVtXG4gIHRoaXMuX21pc3NpbmcgLT0gcmVtXG5cbiAgcmV0dXJuIGRhdGEubGVuZ3RoXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fcGFyc2VMZW5ndGggPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQpIHtcbiAgd2hpbGUgKCF0aGlzLl9taXNzaW5nICYmIHN0YXJ0IDwgZGF0YS5sZW5ndGgpIHtcbiAgICB2YXIgYnl0ZSA9IHRoaXMuX2xlbmd0aFt0aGlzLl9wb2ludGVyKytdID0gZGF0YVtzdGFydCsrXVxuXG4gICAgaWYgKCEoYnl0ZSAmIDB4ODApKSB7XG4gICAgICB0aGlzLl9taXNzaW5nID0gdmFyaW50LmRlY29kZSh0aGlzLl9sZW5ndGgpXG4gICAgICB0aGlzLl9wb2ludGVyID0gMFxuICAgICAgaWYgKHRoaXMuX21pc3NpbmcgPiA4Mzg4NjA4KSByZXR1cm4gdGhpcy5fdG9vQmlnKGRhdGEubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXJ0XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BvaW50ZXIgPj0gdGhpcy5fbGVuZ3RoLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Rvb0JpZyhkYXRhLmxlbmd0aClcbiAgfVxuXG4gIHJldHVybiBzdGFydFxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3NhbWVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5kaXNjb3ZlcnlLZXkgfHwgIXRoaXMucmVtb3RlRGlzY292ZXJ5S2V5KSByZXR1cm4gdHJ1ZVxuICBpZiAodGhpcy5yZW1vdGVEaXNjb3ZlcnlLZXkudG9TdHJpbmcoJ2hleCcpID09PSB0aGlzLmRpc2NvdmVyeUtleS50b1N0cmluZygnaGV4JykpIHJldHVybiB0cnVlXG4gIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ0ZpcnN0IHNoYXJlZCBoeXBlcmNvcmUgbXVzdCBiZSB0aGUgc2FtZScpKVxuICByZXR1cm4gZmFsc2Vcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl90b29NYW55RmVlZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ09ubHkgMTI4IGZlZWRzIGN1cnJlbnRseSBzdXBwb3J0ZWQuIE9wZW4gYSBHaXRodWIgaXNzdWUgaWYgeW91IG5lZWQgbW9yZScpKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3Rvb0JpZyA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignUmVtb3RlIG1lc3NhZ2UgaXMgbGFyZ2VyIHRoYW4gOE1CIChtYXggYWxsb3dlZCknKSlcbiAgcmV0dXJuIGxlblxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX2JhZEZlZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ1JlbW90ZSBzZW50IGludmFsaWQgZmVlZCBtZXNzYWdlJykpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fb250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdSZW1vdGUgdGltZWQgb3V0JykpXG59XG5cbmZ1bmN0aW9uIGRlY29kZUhlYWRlciAoZGF0YSwgc3RhcnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdmFyaW50LmRlY29kZShkYXRhLCBzdGFydClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjb2RlRmVlZCAoZGF0YSwgc3RhcnQsIGVuZCkge1xuICB2YXIgZmVlZCA9IG51bGxcblxuICB0cnkge1xuICAgIGZlZWQgPSBtZXNzYWdlcy5GZWVkLmRlY29kZShkYXRhLCBzdGFydCwgZW5kKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKGZlZWQuZGlzY292ZXJ5S2V5Lmxlbmd0aCAhPT0gMzIpIHJldHVybiBudWxsXG4gIGlmIChmZWVkLm5vbmNlICYmIGZlZWQubm9uY2UubGVuZ3RoICE9PSAyNCkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZmVlZFxufVxuXG5mdW5jdGlvbiBlbmNvZGVGZWVkIChmZWVkLCBpZCkge1xuICB2YXIgaGVhZGVyID0gaWQgPDwgNFxuICB2YXIgbGVuID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGhlYWRlcikgKyBtZXNzYWdlcy5GZWVkLmVuY29kaW5nTGVuZ3RoKGZlZWQpXG4gIHZhciBib3ggPSBidWZmZXJBbGxvYyh2YXJpbnQuZW5jb2RpbmdMZW5ndGgobGVuKSArIGxlbilcbiAgdmFyIG9mZnNldCA9IDBcblxuICB2YXJpbnQuZW5jb2RlKGxlbiwgYm94LCBvZmZzZXQpXG4gIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG5cbiAgdmFyaW50LmVuY29kZShoZWFkZXIsIGJveCwgb2Zmc2V0KVxuICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuXG4gIG1lc3NhZ2VzLkZlZWQuZW5jb2RlKGZlZWQsIGJveCwgb2Zmc2V0KVxuICByZXR1cm4gYm94XG59XG5cbmZ1bmN0aW9uIGRpc2NvdmVyeUtleSAoa2V5KSB7XG4gIHZhciBidWYgPSBidWZmZXJBbGxvYygzMilcbiAgc29kaXVtLmNyeXB0b19nZW5lcmljaGFzaChidWYsIGJ1ZmZlckZyb20oJ2h5cGVyY29yZScpLCBrZXkpXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMgKG4pIHtcbiAgdmFyIGJ1ZiA9IGJ1ZmZlckFsbG9jKG4pXG4gIHNvZGl1bS5yYW5kb21ieXRlc19idWYoYnVmKVxuICByZXR1cm4gYnVmXG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgYXV0byBnZW5lcmF0ZWQgYnkgdGhlIHByb3RvY29sLWJ1ZmZlcnMgY2xpIHRvb2xcblxuLyogZXNsaW50LWRpc2FibGUgcXVvdGVzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG4vLyBSZW1lbWJlciB0byBgbnBtIGluc3RhbGwgLS1zYXZlIHByb3RvY29sLWJ1ZmZlcnMtZW5jb2RpbmdzYFxudmFyIGVuY29kaW5ncyA9IHJlcXVpcmUoJ3Byb3RvY29sLWJ1ZmZlcnMtZW5jb2RpbmdzJylcbnZhciB2YXJpbnQgPSBlbmNvZGluZ3MudmFyaW50XG52YXIgc2tpcCA9IGVuY29kaW5ncy5za2lwXG5cbnZhciBGZWVkID0gZXhwb3J0cy5GZWVkID0ge1xuICBidWZmZXI6IHRydWUsXG4gIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICBlbmNvZGU6IG51bGwsXG4gIGRlY29kZTogbnVsbFxufVxuXG52YXIgSGFuZHNoYWtlID0gZXhwb3J0cy5IYW5kc2hha2UgPSB7XG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gIGVuY29kZTogbnVsbCxcbiAgZGVjb2RlOiBudWxsXG59XG5cbnZhciBJbmZvID0gZXhwb3J0cy5JbmZvID0ge1xuICBidWZmZXI6IHRydWUsXG4gIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICBlbmNvZGU6IG51bGwsXG4gIGRlY29kZTogbnVsbFxufVxuXG52YXIgSGF2ZSA9IGV4cG9ydHMuSGF2ZSA9IHtcbiAgYnVmZmVyOiB0cnVlLFxuICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgZW5jb2RlOiBudWxsLFxuICBkZWNvZGU6IG51bGxcbn1cblxudmFyIFVuaGF2ZSA9IGV4cG9ydHMuVW5oYXZlID0ge1xuICBidWZmZXI6IHRydWUsXG4gIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICBlbmNvZGU6IG51bGwsXG4gIGRlY29kZTogbnVsbFxufVxuXG52YXIgV2FudCA9IGV4cG9ydHMuV2FudCA9IHtcbiAgYnVmZmVyOiB0cnVlLFxuICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgZW5jb2RlOiBudWxsLFxuICBkZWNvZGU6IG51bGxcbn1cblxudmFyIFVud2FudCA9IGV4cG9ydHMuVW53YW50ID0ge1xuICBidWZmZXI6IHRydWUsXG4gIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICBlbmNvZGU6IG51bGwsXG4gIGRlY29kZTogbnVsbFxufVxuXG52YXIgUmVxdWVzdCA9IGV4cG9ydHMuUmVxdWVzdCA9IHtcbiAgYnVmZmVyOiB0cnVlLFxuICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgZW5jb2RlOiBudWxsLFxuICBkZWNvZGU6IG51bGxcbn1cblxudmFyIENhbmNlbCA9IGV4cG9ydHMuQ2FuY2VsID0ge1xuICBidWZmZXI6IHRydWUsXG4gIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICBlbmNvZGU6IG51bGwsXG4gIGRlY29kZTogbnVsbFxufVxuXG52YXIgRGF0YSA9IGV4cG9ydHMuRGF0YSA9IHtcbiAgYnVmZmVyOiB0cnVlLFxuICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgZW5jb2RlOiBudWxsLFxuICBkZWNvZGU6IG51bGxcbn1cblxuZGVmaW5lRmVlZCgpXG5kZWZpbmVIYW5kc2hha2UoKVxuZGVmaW5lSW5mbygpXG5kZWZpbmVIYXZlKClcbmRlZmluZVVuaGF2ZSgpXG5kZWZpbmVXYW50KClcbmRlZmluZVVud2FudCgpXG5kZWZpbmVSZXF1ZXN0KClcbmRlZmluZUNhbmNlbCgpXG5kZWZpbmVEYXRhKClcblxuZnVuY3Rpb24gZGVmaW5lRmVlZCAoKSB7XG4gIHZhciBlbmMgPSBbXG4gICAgZW5jb2RpbmdzLmJ5dGVzXG4gIF1cblxuICBGZWVkLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgRmVlZC5lbmNvZGUgPSBlbmNvZGVcbiAgRmVlZC5kZWNvZGUgPSBkZWNvZGVcblxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoIWRlZmluZWQob2JqLmRpc2NvdmVyeUtleSkpIHRocm93IG5ldyBFcnJvcihcImRpc2NvdmVyeUtleSBpcyByZXF1aXJlZFwiKVxuICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmRpc2NvdmVyeUtleSlcbiAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIGlmIChkZWZpbmVkKG9iai5ub25jZSkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLm5vbmNlKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIGlmICghZGVmaW5lZChvYmouZGlzY292ZXJ5S2V5KSkgdGhyb3cgbmV3IEVycm9yKFwiZGlzY292ZXJ5S2V5IGlzIHJlcXVpcmVkXCIpXG4gICAgYnVmW29mZnNldCsrXSA9IDEwXG4gICAgZW5jWzBdLmVuY29kZShvYmouZGlzY292ZXJ5S2V5LCBidWYsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIGlmIChkZWZpbmVkKG9iai5ub25jZSkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxOFxuICAgICAgZW5jWzBdLmVuY29kZShvYmoubm9uY2UsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge1xuICAgICAgZGlzY292ZXJ5S2V5OiBudWxsLFxuICAgICAgbm9uY2U6IG51bGxcbiAgICB9XG4gICAgdmFyIGZvdW5kMCA9IGZhbHNlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgIGlmICghZm91bmQwKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgb2JqLmRpc2NvdmVyeUtleSA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGZvdW5kMCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBvYmoubm9uY2UgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVIYW5kc2hha2UgKCkge1xuICB2YXIgZW5jID0gW1xuICAgIGVuY29kaW5ncy5ieXRlcyxcbiAgICBlbmNvZGluZ3MuYm9vbCxcbiAgICBlbmNvZGluZ3Muc3RyaW5nXG4gIF1cblxuICBIYW5kc2hha2UuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICBIYW5kc2hha2UuZW5jb2RlID0gZW5jb2RlXG4gIEhhbmRzaGFrZS5kZWNvZGUgPSBkZWNvZGVcblxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoZGVmaW5lZChvYmouaWQpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5pZClcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5saXZlKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1sxXS5lbmNvZGluZ0xlbmd0aChvYmoubGl2ZSlcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai51c2VyRGF0YSkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLnVzZXJEYXRhKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmV4dGVuc2lvbnMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5leHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZGVmaW5lZChvYmouZXh0ZW5zaW9uc1tpXSkpIGNvbnRpbnVlXG4gICAgICAgIHZhciBsZW4gPSBlbmNbMl0uZW5jb2RpbmdMZW5ndGgob2JqLmV4dGVuc2lvbnNbaV0pXG4gICAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5hY2spKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzFdLmVuY29kaW5nTGVuZ3RoKG9iai5hY2spXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgaWYgKGRlZmluZWQob2JqLmlkKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDEwXG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5pZCwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmoubGl2ZSkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxNlxuICAgICAgZW5jWzFdLmVuY29kZShvYmoubGl2ZSwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzFdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmoudXNlckRhdGEpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMjZcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLnVzZXJEYXRhLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5leHRlbnNpb25zKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmouZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWRlZmluZWQob2JqLmV4dGVuc2lvbnNbaV0pKSBjb250aW51ZVxuICAgICAgICBidWZbb2Zmc2V0KytdID0gMzRcbiAgICAgICAgZW5jWzJdLmVuY29kZShvYmouZXh0ZW5zaW9uc1tpXSwgYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMl0uZW5jb2RlLmJ5dGVzXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5hY2spKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gNDBcbiAgICAgIGVuY1sxXS5lbmNvZGUob2JqLmFjaywgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzFdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmogPSB7XG4gICAgICBpZDogbnVsbCxcbiAgICAgIGxpdmU6IGZhbHNlLFxuICAgICAgdXNlckRhdGE6IG51bGwsXG4gICAgICBleHRlbnNpb25zOiBbXSxcbiAgICAgIGFjazogZmFsc2VcbiAgICB9XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgb2JqLmlkID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBvYmoubGl2ZSA9IGVuY1sxXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMV0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgb2JqLnVzZXJEYXRhID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBvYmouZXh0ZW5zaW9ucy5wdXNoKGVuY1syXS5kZWNvZGUoYnVmLCBvZmZzZXQpKVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzJdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgIG9iai5hY2sgPSBlbmNbMV0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzFdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVJbmZvICgpIHtcbiAgdmFyIGVuYyA9IFtcbiAgICBlbmNvZGluZ3MuYm9vbFxuICBdXG5cbiAgSW5mby5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gIEluZm8uZW5jb2RlID0gZW5jb2RlXG4gIEluZm8uZGVjb2RlID0gZGVjb2RlXG5cbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgIHZhciBsZW5ndGggPSAwXG4gICAgaWYgKGRlZmluZWQob2JqLnVwbG9hZGluZykpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLnVwbG9hZGluZylcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5kb3dubG9hZGluZykpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmRvd25sb2FkaW5nKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIGlmIChkZWZpbmVkKG9iai51cGxvYWRpbmcpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gOFxuICAgICAgZW5jWzBdLmVuY29kZShvYmoudXBsb2FkaW5nLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5kb3dubG9hZGluZykpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxNlxuICAgICAgZW5jWzBdLmVuY29kZShvYmouZG93bmxvYWRpbmcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge1xuICAgICAgdXBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIGRvd25sb2FkaW5nOiBmYWxzZVxuICAgIH1cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBvYmoudXBsb2FkaW5nID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBvYmouZG93bmxvYWRpbmcgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVIYXZlICgpIHtcbiAgdmFyIGVuYyA9IFtcbiAgICBlbmNvZGluZ3MudmFyaW50LFxuICAgIGVuY29kaW5ncy5ieXRlc1xuICBdXG5cbiAgSGF2ZS5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gIEhhdmUuZW5jb2RlID0gZW5jb2RlXG4gIEhhdmUuZGVjb2RlID0gZGVjb2RlXG5cbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgIHZhciBsZW5ndGggPSAwXG4gICAgaWYgKCFkZWZpbmVkKG9iai5zdGFydCkpIHRocm93IG5ldyBFcnJvcihcInN0YXJ0IGlzIHJlcXVpcmVkXCIpXG4gICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouc3RhcnQpXG4gICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICBpZiAoZGVmaW5lZChvYmoubGVuZ3RoKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmoubGVuZ3RoKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmJpdGZpZWxkKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1sxXS5lbmNvZGluZ0xlbmd0aChvYmouYml0ZmllbGQpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgaWYgKCFkZWZpbmVkKG9iai5zdGFydCkpIHRocm93IG5ldyBFcnJvcihcInN0YXJ0IGlzIHJlcXVpcmVkXCIpXG4gICAgYnVmW29mZnNldCsrXSA9IDhcbiAgICBlbmNbMF0uZW5jb2RlKG9iai5zdGFydCwgYnVmLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICBpZiAoZGVmaW5lZChvYmoubGVuZ3RoKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDE2XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5sZW5ndGgsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmJpdGZpZWxkKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDI2XG4gICAgICBlbmNbMV0uZW5jb2RlKG9iai5iaXRmaWVsZCwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzFdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmogPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGxlbmd0aDogMSxcbiAgICAgIGJpdGZpZWxkOiBudWxsXG4gICAgfVxuICAgIHZhciBmb3VuZDAgPSBmYWxzZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICBpZiAoIWZvdW5kMCkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIG9iai5zdGFydCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGZvdW5kMCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBvYmoubGVuZ3RoID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBvYmouYml0ZmllbGQgPSBlbmNbMV0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzFdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVVbmhhdmUgKCkge1xuICB2YXIgZW5jID0gW1xuICAgIGVuY29kaW5ncy52YXJpbnRcbiAgXVxuXG4gIFVuaGF2ZS5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gIFVuaGF2ZS5lbmNvZGUgPSBlbmNvZGVcbiAgVW5oYXZlLmRlY29kZSA9IGRlY29kZVxuXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmICghZGVmaW5lZChvYmouc3RhcnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCBpcyByZXF1aXJlZFwiKVxuICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLnN0YXJ0KVxuICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgaWYgKGRlZmluZWQob2JqLmxlbmd0aCkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmxlbmd0aClcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICBpZiAoIWRlZmluZWQob2JqLnN0YXJ0KSkgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQgaXMgcmVxdWlyZWRcIilcbiAgICBidWZbb2Zmc2V0KytdID0gOFxuICAgIGVuY1swXS5lbmNvZGUob2JqLnN0YXJ0LCBidWYsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIGlmIChkZWZpbmVkKG9iai5sZW5ndGgpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMTZcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLmxlbmd0aCwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmogPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGxlbmd0aDogMVxuICAgIH1cbiAgICB2YXIgZm91bmQwID0gZmFsc2VcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFmb3VuZDApIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBvYmouc3RhcnQgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBmb3VuZDAgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgb2JqLmxlbmd0aCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVdhbnQgKCkge1xuICB2YXIgZW5jID0gW1xuICAgIGVuY29kaW5ncy52YXJpbnRcbiAgXVxuXG4gIFdhbnQuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICBXYW50LmVuY29kZSA9IGVuY29kZVxuICBXYW50LmRlY29kZSA9IGRlY29kZVxuXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmICghZGVmaW5lZChvYmouc3RhcnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCBpcyByZXF1aXJlZFwiKVxuICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLnN0YXJ0KVxuICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgaWYgKGRlZmluZWQob2JqLmxlbmd0aCkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmxlbmd0aClcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICBpZiAoIWRlZmluZWQob2JqLnN0YXJ0KSkgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQgaXMgcmVxdWlyZWRcIilcbiAgICBidWZbb2Zmc2V0KytdID0gOFxuICAgIGVuY1swXS5lbmNvZGUob2JqLnN0YXJ0LCBidWYsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIGlmIChkZWZpbmVkKG9iai5sZW5ndGgpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMTZcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLmxlbmd0aCwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmogPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGxlbmd0aDogMFxuICAgIH1cbiAgICB2YXIgZm91bmQwID0gZmFsc2VcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFmb3VuZDApIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBvYmouc3RhcnQgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBmb3VuZDAgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgb2JqLmxlbmd0aCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVVud2FudCAoKSB7XG4gIHZhciBlbmMgPSBbXG4gICAgZW5jb2RpbmdzLnZhcmludFxuICBdXG5cbiAgVW53YW50LmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgVW53YW50LmVuY29kZSA9IGVuY29kZVxuICBVbndhbnQuZGVjb2RlID0gZGVjb2RlXG5cbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgIHZhciBsZW5ndGggPSAwXG4gICAgaWYgKCFkZWZpbmVkKG9iai5zdGFydCkpIHRocm93IG5ldyBFcnJvcihcInN0YXJ0IGlzIHJlcXVpcmVkXCIpXG4gICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouc3RhcnQpXG4gICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICBpZiAoZGVmaW5lZChvYmoubGVuZ3RoKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmoubGVuZ3RoKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIGlmICghZGVmaW5lZChvYmouc3RhcnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCBpcyByZXF1aXJlZFwiKVxuICAgIGJ1ZltvZmZzZXQrK10gPSA4XG4gICAgZW5jWzBdLmVuY29kZShvYmouc3RhcnQsIGJ1Ziwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgaWYgKGRlZmluZWQob2JqLmxlbmd0aCkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxNlxuICAgICAgZW5jWzBdLmVuY29kZShvYmoubGVuZ3RoLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgbGVuZ3RoOiAwXG4gICAgfVxuICAgIHZhciBmb3VuZDAgPSBmYWxzZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICBpZiAoIWZvdW5kMCkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIG9iai5zdGFydCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGZvdW5kMCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBvYmoubGVuZ3RoID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVxdWVzdCAoKSB7XG4gIHZhciBlbmMgPSBbXG4gICAgZW5jb2RpbmdzLnZhcmludCxcbiAgICBlbmNvZGluZ3MuYm9vbFxuICBdXG5cbiAgUmVxdWVzdC5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gIFJlcXVlc3QuZW5jb2RlID0gZW5jb2RlXG4gIFJlcXVlc3QuZGVjb2RlID0gZGVjb2RlXG5cbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgIHZhciBsZW5ndGggPSAwXG4gICAgaWYgKCFkZWZpbmVkKG9iai5pbmRleCkpIHRocm93IG5ldyBFcnJvcihcImluZGV4IGlzIHJlcXVpcmVkXCIpXG4gICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouaW5kZXgpXG4gICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICBpZiAoZGVmaW5lZChvYmouYnl0ZXMpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5ieXRlcylcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5oYXNoKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1sxXS5lbmNvZGluZ0xlbmd0aChvYmouaGFzaClcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5ub2RlcykpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLm5vZGVzKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIGlmICghZGVmaW5lZChvYmouaW5kZXgpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyByZXF1aXJlZFwiKVxuICAgIGJ1ZltvZmZzZXQrK10gPSA4XG4gICAgZW5jWzBdLmVuY29kZShvYmouaW5kZXgsIGJ1Ziwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgaWYgKGRlZmluZWQob2JqLmJ5dGVzKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDE2XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5ieXRlcywgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouaGFzaCkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAyNFxuICAgICAgZW5jWzFdLmVuY29kZShvYmouaGFzaCwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzFdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmoubm9kZXMpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMzJcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLm5vZGVzLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGluZGV4OiAwLFxuICAgICAgYnl0ZXM6IDAsXG4gICAgICBoYXNoOiBmYWxzZSxcbiAgICAgIG5vZGVzOiAwXG4gICAgfVxuICAgIHZhciBmb3VuZDAgPSBmYWxzZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICBpZiAoIWZvdW5kMCkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIG9iai5pbmRleCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGZvdW5kMCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBvYmouYnl0ZXMgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIG9iai5oYXNoID0gZW5jWzFdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBvYmoubm9kZXMgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDYW5jZWwgKCkge1xuICB2YXIgZW5jID0gW1xuICAgIGVuY29kaW5ncy52YXJpbnQsXG4gICAgZW5jb2RpbmdzLmJvb2xcbiAgXVxuXG4gIENhbmNlbC5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gIENhbmNlbC5lbmNvZGUgPSBlbmNvZGVcbiAgQ2FuY2VsLmRlY29kZSA9IGRlY29kZVxuXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmICghZGVmaW5lZChvYmouaW5kZXgpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyByZXF1aXJlZFwiKVxuICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmluZGV4KVxuICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgaWYgKGRlZmluZWQob2JqLmJ5dGVzKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouYnl0ZXMpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouaGFzaCkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMV0uZW5jb2RpbmdMZW5ndGgob2JqLmhhc2gpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgaWYgKCFkZWZpbmVkKG9iai5pbmRleCkpIHRocm93IG5ldyBFcnJvcihcImluZGV4IGlzIHJlcXVpcmVkXCIpXG4gICAgYnVmW29mZnNldCsrXSA9IDhcbiAgICBlbmNbMF0uZW5jb2RlKG9iai5pbmRleCwgYnVmLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICBpZiAoZGVmaW5lZChvYmouYnl0ZXMpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMTZcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLmJ5dGVzLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5oYXNoKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDI0XG4gICAgICBlbmNbMV0uZW5jb2RlKG9iai5oYXNoLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMV0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGluZGV4OiAwLFxuICAgICAgYnl0ZXM6IDAsXG4gICAgICBoYXNoOiBmYWxzZVxuICAgIH1cbiAgICB2YXIgZm91bmQwID0gZmFsc2VcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFmb3VuZDApIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBvYmouaW5kZXggPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBmb3VuZDAgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgb2JqLmJ5dGVzID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBvYmouaGFzaCA9IGVuY1sxXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMV0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZURhdGEgKCkge1xuICB2YXIgTm9kZSA9IERhdGEuTm9kZSA9IHtcbiAgICBidWZmZXI6IHRydWUsXG4gICAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gICAgZW5jb2RlOiBudWxsLFxuICAgIGRlY29kZTogbnVsbFxuICB9XG5cbiAgZGVmaW5lTm9kZSgpXG5cbiAgZnVuY3Rpb24gZGVmaW5lTm9kZSAoKSB7XG4gICAgdmFyIGVuYyA9IFtcbiAgICAgIGVuY29kaW5ncy52YXJpbnQsXG4gICAgICBlbmNvZGluZ3MuYnl0ZXNcbiAgICBdXG5cbiAgICBOb2RlLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgICBOb2RlLmVuY29kZSA9IGVuY29kZVxuICAgIE5vZGUuZGVjb2RlID0gZGVjb2RlXG5cbiAgICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gMFxuICAgICAgaWYgKCFkZWZpbmVkKG9iai5pbmRleCkpIHRocm93IG5ldyBFcnJvcihcImluZGV4IGlzIHJlcXVpcmVkXCIpXG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5pbmRleClcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgICBpZiAoIWRlZmluZWQob2JqLmhhc2gpKSB0aHJvdyBuZXcgRXJyb3IoXCJoYXNoIGlzIHJlcXVpcmVkXCIpXG4gICAgICB2YXIgbGVuID0gZW5jWzFdLmVuY29kaW5nTGVuZ3RoKG9iai5oYXNoKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICAgIGlmICghZGVmaW5lZChvYmouc2l6ZSkpIHRocm93IG5ldyBFcnJvcihcInNpemUgaXMgcmVxdWlyZWRcIilcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLnNpemUpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgICAgcmV0dXJuIGxlbmd0aFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICAgIGlmICghZGVmaW5lZChvYmouaW5kZXgpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyByZXF1aXJlZFwiKVxuICAgICAgYnVmW29mZnNldCsrXSA9IDhcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLmluZGV4LCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgICBpZiAoIWRlZmluZWQob2JqLmhhc2gpKSB0aHJvdyBuZXcgRXJyb3IoXCJoYXNoIGlzIHJlcXVpcmVkXCIpXG4gICAgICBidWZbb2Zmc2V0KytdID0gMThcbiAgICAgIGVuY1sxXS5lbmNvZGUob2JqLmhhc2gsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5lbmNvZGUuYnl0ZXNcbiAgICAgIGlmICghZGVmaW5lZChvYmouc2l6ZSkpIHRocm93IG5ldyBFcnJvcihcInNpemUgaXMgcmVxdWlyZWRcIilcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAyNFxuICAgICAgZW5jWzBdLmVuY29kZShvYmouc2l6ZSwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIGhhc2g6IG51bGwsXG4gICAgICAgIHNpemU6IDBcbiAgICAgIH1cbiAgICAgIHZhciBmb3VuZDAgPSBmYWxzZVxuICAgICAgdmFyIGZvdW5kMSA9IGZhbHNlXG4gICAgICB2YXIgZm91bmQyID0gZmFsc2VcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKCFmb3VuZDAgfHwgIWZvdW5kMSB8fCAhZm91bmQyKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgb2JqLmluZGV4ID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICAgIGZvdW5kMCA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBvYmouaGFzaCA9IGVuY1sxXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgICBmb3VuZDEgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgb2JqLnNpemUgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgICAgZm91bmQyID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVuYyA9IFtcbiAgICBlbmNvZGluZ3MudmFyaW50LFxuICAgIGVuY29kaW5ncy5ieXRlcyxcbiAgICBOb2RlXG4gIF1cblxuICBEYXRhLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgRGF0YS5lbmNvZGUgPSBlbmNvZGVcbiAgRGF0YS5kZWNvZGUgPSBkZWNvZGVcblxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoIWRlZmluZWQob2JqLmluZGV4KSkgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgcmVxdWlyZWRcIilcbiAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5pbmRleClcbiAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIGlmIChkZWZpbmVkKG9iai52YWx1ZSkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMV0uZW5jb2RpbmdMZW5ndGgob2JqLnZhbHVlKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLm5vZGVzKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFkZWZpbmVkKG9iai5ub2Rlc1tpXSkpIGNvbnRpbnVlXG4gICAgICAgIHZhciBsZW4gPSBlbmNbMl0uZW5jb2RpbmdMZW5ndGgob2JqLm5vZGVzW2ldKVxuICAgICAgICBsZW5ndGggKz0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGxlbilcbiAgICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLnNpZ25hdHVyZSkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMV0uZW5jb2RpbmdMZW5ndGgob2JqLnNpZ25hdHVyZSlcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICBpZiAoIWRlZmluZWQob2JqLmluZGV4KSkgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgcmVxdWlyZWRcIilcbiAgICBidWZbb2Zmc2V0KytdID0gOFxuICAgIGVuY1swXS5lbmNvZGUob2JqLmluZGV4LCBidWYsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIGlmIChkZWZpbmVkKG9iai52YWx1ZSkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxOFxuICAgICAgZW5jWzFdLmVuY29kZShvYmoudmFsdWUsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLm5vZGVzKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFkZWZpbmVkKG9iai5ub2Rlc1tpXSkpIGNvbnRpbnVlXG4gICAgICAgIGJ1ZltvZmZzZXQrK10gPSAyNlxuICAgICAgICB2YXJpbnQuZW5jb2RlKGVuY1syXS5lbmNvZGluZ0xlbmd0aChvYmoubm9kZXNbaV0pLCBidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcbiAgICAgICAgZW5jWzJdLmVuY29kZShvYmoubm9kZXNbaV0sIGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzJdLmVuY29kZS5ieXRlc1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouc2lnbmF0dXJlKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDM0XG4gICAgICBlbmNbMV0uZW5jb2RlKG9iai5zaWduYXR1cmUsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge1xuICAgICAgaW5kZXg6IDAsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIG5vZGVzOiBbXSxcbiAgICAgIHNpZ25hdHVyZTogbnVsbFxuICAgIH1cbiAgICB2YXIgZm91bmQwID0gZmFsc2VcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFmb3VuZDApIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBvYmouaW5kZXggPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBmb3VuZDAgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgb2JqLnZhbHVlID0gZW5jWzFdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICB2YXIgbGVuID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgICAgb2JqLm5vZGVzLnB1c2goZW5jWzJdLmRlY29kZShidWYsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKSlcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1syXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBvYmouc2lnbmF0dXJlID0gZW5jWzFdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lZCAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInIHx8ICFpc05hTih2YWwpKVxufVxuIiwidmFyIGVxdWFscyA9IHJlcXVpcmUoJ2J1ZmZlci1lcXVhbHMnKVxudmFyIGxvdyA9IHJlcXVpcmUoJ2xhc3Qtb25lLXdpbnMnKVxudmFyIHJlbW92ZSA9IHJlcXVpcmUoJ3Vub3JkZXJlZC1hcnJheS1yZW1vdmUnKVxudmFyIHNldCA9IHJlcXVpcmUoJ3Vub3JkZXJlZC1zZXQnKVxudmFyIG1lcmtsZSA9IHJlcXVpcmUoJ21lcmtsZS10cmVlLXN0cmVhbS9nZW5lcmF0b3InKVxudmFyIGZsYXQgPSByZXF1aXJlKCdmbGF0LXRyZWUnKVxudmFyIGJ1bGsgPSByZXF1aXJlKCdidWxrLXdyaXRlLXN0cmVhbScpXG52YXIgZnJvbSA9IHJlcXVpcmUoJ2Zyb20yJylcbnZhciBjb2RlY3MgPSByZXF1aXJlKCdjb2RlY3MnKVxudmFyIHRodW5reSA9IHJlcXVpcmUoJ3RodW5reScpXG52YXIgYmF0Y2hlciA9IHJlcXVpcmUoJ2F0b21pYy1iYXRjaGVyJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIHJhZiA9IHJlcXVpcmUoJ3JhbmRvbS1hY2Nlc3MtZmlsZScpXG52YXIgYml0ZmllbGQgPSByZXF1aXJlKCcuL2xpYi9iaXRmaWVsZCcpXG52YXIgc3BhcnNlQml0ZmllbGQgPSByZXF1aXJlKCdzcGFyc2UtYml0ZmllbGQnKVxudmFyIHRyZWVJbmRleCA9IHJlcXVpcmUoJy4vbGliL3RyZWUtaW5kZXgnKVxudmFyIHN0b3JhZ2UgPSByZXF1aXJlKCcuL2xpYi9zdG9yYWdlJylcbnZhciBjcnlwdG8gPSByZXF1aXJlKCcuL2xpYi9jcnlwdG8nKVxudmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKVxudmFyIGJ1ZmZlckZyb20gPSByZXF1aXJlKCdidWZmZXItZnJvbScpXG52YXIgYnVmZmVyQWxsb2MgPSByZXF1aXJlKCdidWZmZXItYWxsb2MtdW5zYWZlJylcbnZhciByZXBsaWNhdGUgPSBudWxsXG5cbm1vZHVsZS5leHBvcnRzID0gRmVlZFxuXG5mdW5jdGlvbiBGZWVkIChjcmVhdGVTdG9yYWdlLCBrZXksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZlZWQpKSByZXR1cm4gbmV3IEZlZWQoY3JlYXRlU3RvcmFnZSwga2V5LCBvcHRzKVxuICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcblxuICBpZiAodHlwZW9mIGNyZWF0ZVN0b3JhZ2UgPT09ICdzdHJpbmcnKSBjcmVhdGVTdG9yYWdlID0gZGVmYXVsdFN0b3JhZ2UoY3JlYXRlU3RvcmFnZSlcbiAgaWYgKHR5cGVvZiBjcmVhdGVTdG9yYWdlICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ1N0b3JhZ2Ugc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3Igc3RyaW5nJylcblxuICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIGtleSA9IGJ1ZmZlckZyb20oa2V5LCAnaGV4JylcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihrZXkpICYmICFvcHRzKSB7XG4gICAgb3B0cyA9IGtleVxuICAgIGtleSA9IG51bGxcbiAgfVxuXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIHNlY3JldEtleSA9IG9wdHMuc2VjcmV0S2V5IHx8IG51bGxcbiAgaWYgKHR5cGVvZiBzZWNyZXRLZXkgPT09ICdzdHJpbmcnKSBzZWNyZXRLZXkgPSBidWZmZXJGcm9tKHNlY3JldEtleSwgJ2hleCcpXG5cbiAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKVxuICB0aGlzLmxpdmUgPSBvcHRzLmxpdmUgIT09IGZhbHNlXG4gIHRoaXMuc3BhcnNlID0gISFvcHRzLnNwYXJzZVxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5ieXRlTGVuZ3RoID0gMFxuICB0aGlzLm1heFJlcXVlc3RzID0gb3B0cy5tYXhSZXF1ZXN0cyB8fCAxNlxuICB0aGlzLmtleSA9IGtleSB8fCBudWxsXG4gIHRoaXMuZGlzY292ZXJ5S2V5ID0gdGhpcy5rZXkgJiYgY3J5cHRvLmRpc2NvdmVyeUtleSh0aGlzLmtleSlcbiAgdGhpcy5zZWNyZXRLZXkgPSBzZWNyZXRLZXlcbiAgdGhpcy5iaXRmaWVsZCA9IG51bGxcbiAgdGhpcy50cmVlID0gbnVsbFxuICB0aGlzLndyaXRhYmxlID0gISFvcHRzLndyaXRhYmxlXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gIHRoaXMub3BlbmVkID0gZmFsc2VcbiAgdGhpcy5jbG9zZWQgPSBmYWxzZVxuICB0aGlzLmFsbG93UHVzaCA9ICEhb3B0cy5hbGxvd1B1c2hcbiAgdGhpcy5wZWVycyA9IFtdXG5cbiAgLy8gaG9va3NcbiAgdGhpcy5fb253cml0ZSA9IG9wdHMub253cml0ZSB8fCBudWxsXG5cbiAgdGhpcy5fcmVhZHkgPSB0aHVua3kob3BlbikgLy8gVE9ETzogaWYgb3BlbiBmYWlscywgZG8gbm90IHJlb3BlbiBuZXh0IHRpbWVcbiAgdGhpcy5faW5kZXhpbmcgPSAhIW9wdHMuaW5kZXhpbmdcbiAgdGhpcy5fY3JlYXRlSWZNaXNzaW5nID0gb3B0cy5jcmVhdGVJZk1pc3NpbmcgIT09IGZhbHNlXG4gIHRoaXMuX292ZXJ3cml0ZSA9ICEhb3B0cy5vdmVyd3JpdGVcbiAgdGhpcy5fc3RvcmVTZWNyZXRLZXkgPSBvcHRzLnN0b3JlU2VjcmV0S2V5ICE9PSBmYWxzZVxuICB0aGlzLl9tZXJrbGUgPSBudWxsXG4gIHRoaXMuX3N0b3JhZ2UgPSBzdG9yYWdlKGNyZWF0ZVN0b3JhZ2UsIG9wdHMuc3RvcmFnZUNhY2hlU2l6ZSlcbiAgdGhpcy5fYmF0Y2ggPSBiYXRjaGVyKHRoaXMuX29ud3JpdGUgPyB3b3JrSG9vayA6IHdvcmspXG5cbiAgdGhpcy5fd2FpdGluZyA9IFtdXG4gIHRoaXMuX3NlbGVjdGlvbnMgPSBbXVxuICB0aGlzLl9yZXNlcnZlZCA9IHNwYXJzZUJpdGZpZWxkKClcbiAgdGhpcy5fc3luY2VkID0gbnVsbFxuXG4gIHRoaXMuX2NvZGVjID0gdG9Db2RlYyhvcHRzLnZhbHVlRW5jb2RpbmcpXG4gIHRoaXMuX3N5bmMgPSBsb3coc3luYylcbiAgaWYgKCF0aGlzLnNwYXJzZSkgdGhpcy5kb3dubG9hZCh7c3RhcnQ6IDAsIGVuZDogLTF9KVxuXG4gIC8vIG9wZW4gaXQgcmlnaHQgYXdheS4gVE9ETzogZG8gbm90IHJlb3BlbiAoaS5lLCBzZXQgYSBmbGFnIG5vdCB0byByZXRyeSlcbiAgdGhpcy5fcmVhZHkob25lcnJvcilcblxuICBmdW5jdGlvbiBvbmVycm9yIChlcnIpIHtcbiAgICBpZiAoZXJyKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG5cbiAgZnVuY3Rpb24gd29ya0hvb2sgKHZhbHVlcywgY2IpIHtcbiAgICBzZWxmLl9hcHBlbmRIb29rKHZhbHVlcywgY2IpXG4gIH1cblxuICBmdW5jdGlvbiB3b3JrICh2YWx1ZXMsIGNiKSB7XG4gICAgc2VsZi5fYXBwZW5kKHZhbHVlcywgY2IpXG4gIH1cblxuICBmdW5jdGlvbiBzeW5jIChfLCBjYikge1xuICAgIHNlbGYuX3N5bmNCaXRmaWVsZChjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW4gKGNiKSB7XG4gICAgc2VsZi5fb3BlbihjYilcbiAgfVxufVxuXG5pbmhlcml0cyhGZWVkLCBldmVudHMuRXZlbnRFbWl0dGVyKVxuXG5GZWVkLmRpc2NvdmVyeUtleSA9IGNyeXB0by5kaXNjb3ZlcnlLZXlcblxuLy8gVE9ETzogaW5zdGVhZCBvZiB1c2luZyBhIGdldHRlciwgdXBkYXRlIG9uIHJlbW90ZS11cGRhdGUvYWRkL3JlbW92ZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlZWQucHJvdG90eXBlLCAncmVtb3RlTGVuZ3RoJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gMFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlbW90ZUxlbmd0aCA9IHRoaXMucGVlcnNbaV0ucmVtb3RlTGVuZ3RoXG4gICAgICBpZiAocmVtb3RlTGVuZ3RoID4gbGVuKSBsZW4gPSByZW1vdGVMZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIGxlblxuICB9XG59KVxuXG5GZWVkLnByb3RvdHlwZS5yZXBsaWNhdGUgPSBmdW5jdGlvbiAob3B0cykge1xuICAvLyBMYXp5IGxvYWQgcmVwbGljYXRpb24gZGVwc1xuICBpZiAoIXJlcGxpY2F0ZSkgcmVwbGljYXRlID0gcmVxdWlyZSgnLi9saWIvcmVwbGljYXRlJylcblxuICBpZiAoKCF0aGlzLl9zZWxlY3Rpb25zLmxlbmd0aCB8fCB0aGlzLl9zZWxlY3Rpb25zWzBdLmVuZCAhPT0gLTEpICYmICF0aGlzLnNwYXJzZSAmJiAhKG9wdHMgJiYgb3B0cy5saXZlKSkge1xuICAgIC8vIGhhY2shISBwcm9wZXIgZml4IGlzIHRvIHJlZmFjdG9yIC4vcmVwbGljYXRlIHRvICpub3QqIGNsZWFyIG91ciBub24tc3BhcnNlIHNlbGVjdGlvblxuICAgIHRoaXMuZG93bmxvYWQoe3N0YXJ0OiAwLCBlbmQ6IC0xfSlcbiAgfVxuXG4gIHJldHVybiByZXBsaWNhdGUodGhpcywgb3B0cyB8fCB7fSlcbn1cblxuRmVlZC5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAob25yZWFkeSkge1xuICB0aGlzLl9yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFlcnIpIG9ucmVhZHkoKVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobGVuLCBjYikge1xuICBpZiAodHlwZW9mIGxlbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMudXBkYXRlKC0xLCBsZW4pXG4gIGlmICh0eXBlb2YgbGVuICE9PSAnbnVtYmVyJykgbGVuID0gLTFcbiAgaWYgKCFjYikgY2IgPSBub29wXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAobGVuID09PSAtMSkgbGVuID0gc2VsZi5sZW5ndGggKyAxXG4gICAgaWYgKHNlbGYubGVuZ3RoID49IGxlbikgcmV0dXJuIGNiKG51bGwpXG5cbiAgICBpZiAoc2VsZi53cml0YWJsZSkgY2IgPSBzZWxmLl93cml0ZVN0YXRlUmVsb2FkZXIoY2IpXG5cbiAgICBzZWxmLl93YWl0aW5nLnB1c2goe1xuICAgICAgaGFzaDogdHJ1ZSxcbiAgICAgIGJ5dGVzOiAwLFxuICAgICAgaW5kZXg6IGxlbiAtIDEsXG4gICAgICB1cGRhdGU6IHRydWUsXG4gICAgICBjYWxsYmFjazogY2JcbiAgICB9KVxuXG4gICAgc2VsZi5fdXBkYXRlUGVlcnMoKVxuICB9KVxufVxuXG4vLyB3aWxsIHJlbG9hZCB0aGUgd3JpdGFibGUgc3RhdGUuIHVzZWQgYnkgLnVwZGF0ZSBvbiBhIHdyaXRhYmxlIHBlZXJcbkZlZWQucHJvdG90eXBlLl93cml0ZVN0YXRlUmVsb2FkZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIHNlbGYuX3Jvb3RzKHNlbGYubGVuZ3RoLCBmdW5jdGlvbiAoZXJyLCByb290cykge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHNlbGYuX21lcmtsZSA9IG1lcmtsZShjcnlwdG8sIHJvb3RzKVxuICAgICAgY2IobnVsbClcbiAgICB9KVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgZ2VuZXJhdGVkS2V5ID0gZmFsc2VcblxuICAvLyBUT0RPOiBjbGVhbiB1cCB0aGUgZHVwbGljYXRlIGNvZGUgYmVsb3cgLi4uXG5cbiAgdGhpcy5fc3RvcmFnZS5vcGVuS2V5KGZ1bmN0aW9uIChfLCBrZXkpIHtcbiAgICBpZiAoa2V5ICYmICFzZWxmLl9vdmVyd3JpdGUgJiYgIXNlbGYua2V5KSBzZWxmLmtleSA9IGtleVxuXG4gICAgaWYgKCFzZWxmLmtleSAmJiBzZWxmLmxpdmUpIHtcbiAgICAgIHZhciBrZXlQYWlyID0gY3J5cHRvLmtleVBhaXIoKVxuICAgICAgc2VsZi5zZWNyZXRLZXkgPSBrZXlQYWlyLnNlY3JldEtleVxuICAgICAgc2VsZi5rZXkgPSBrZXlQYWlyLnB1YmxpY0tleVxuICAgICAgZ2VuZXJhdGVkS2V5ID0gdHJ1ZVxuICAgIH1cblxuICAgIHNlbGYuZGlzY292ZXJ5S2V5ID0gc2VsZi5rZXkgJiYgY3J5cHRvLmRpc2NvdmVyeUtleShzZWxmLmtleSlcbiAgICBzZWxmLl9zdG9yYWdlLm9wZW4oe2tleTogc2VsZi5rZXksIGRpc2NvdmVyeUtleTogc2VsZi5kaXNjb3ZlcnlLZXl9LCBvbm9wZW4pXG4gIH0pXG5cbiAgZnVuY3Rpb24gb25vcGVuIChlcnIsIHN0YXRlKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIC8vIGlmIG5vIGtleSBidXQgd2UgaGF2ZSBkYXRhIGRvIGEgYml0ZmllbGQgcmVzZXQgc2luY2Ugd2UgY2Fubm90IHZlcmlmeSB0aGUgZGF0YS5cbiAgICBpZiAoIXN0YXRlLmtleSAmJiBzdGF0ZS5iaXRmaWVsZC5sZW5ndGgpIHtcbiAgICAgIHNlbGYuX292ZXJ3cml0ZSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fb3ZlcndyaXRlKSB7XG4gICAgICBzdGF0ZS5iaXRmaWVsZC5maWxsKDApXG4gICAgICBzdGF0ZS5rZXkgPSBzdGF0ZS5zZWNyZXRLZXkgPSBudWxsXG4gICAgfVxuXG4gICAgc2VsZi5iaXRmaWVsZCA9IGJpdGZpZWxkKHN0YXRlLmJpdGZpZWxkKVxuICAgIHNlbGYudHJlZSA9IHRyZWVJbmRleChzZWxmLmJpdGZpZWxkLnRyZWUpXG4gICAgc2VsZi5sZW5ndGggPSBzZWxmLnRyZWUuYmxvY2tzKClcblxuICAgIGlmIChzdGF0ZS5rZXkgJiYgc2VsZi5rZXkgJiYgIWVxdWFscyhzdGF0ZS5rZXksIHNlbGYua2V5KSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQW5vdGhlciBoeXBlcmNvcmUgaXMgc3RvcmVkIGhlcmUnKSlcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUua2V5KSBzZWxmLmtleSA9IHN0YXRlLmtleVxuICAgIGlmIChzdGF0ZS5zZWNyZXRLZXkpIHNlbGYuc2VjcmV0S2V5ID0gc3RhdGUuc2VjcmV0S2V5XG5cbiAgICAvLyB2ZXJpZnkga2V5IGFuZCBzZWNyZXRLZXkgZ28gdG9nZXRoZXJcbiAgICBpZiAoc2VsZi5rZXkgJiYgc2VsZi5zZWNyZXRLZXkpIHtcbiAgICAgIHZhciBjaGFsbGVuZ2UgPSBidWZmZXJBbGxvYygwKVxuICAgICAgaWYgKCFjcnlwdG8udmVyaWZ5KGNoYWxsZW5nZSwgY3J5cHRvLnNpZ24oY2hhbGxlbmdlLCBzZWxmLnNlY3JldEtleSksIHNlbGYua2V5KSkge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdLZXkgYW5kIHNlY3JldCBkbyBub3QgbWF0Y2gnKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNlbGYubGVuZ3RoKSByZXR1cm4gb25zaWduYXR1cmUobnVsbCwgbnVsbClcbiAgICBzZWxmLl9zdG9yYWdlLmdldFNpZ25hdHVyZShzZWxmLmxlbmd0aCAtIDEsIG9uc2lnbmF0dXJlKVxuXG4gICAgZnVuY3Rpb24gb25zaWduYXR1cmUgKF8sIHNpZykge1xuICAgICAgaWYgKHNlbGYubGVuZ3RoKSBzZWxmLmxpdmUgPSAhIXNpZ1xuXG4gICAgICBpZiAoKGdlbmVyYXRlZEtleSB8fCAhc2VsZi5rZXkpICYmICFzZWxmLl9jcmVhdGVJZk1pc3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignTm8gaHlwZXJjb3JlIGlzIHN0b3JlZCBoZXJlJykpXG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5rZXkgJiYgc2VsZi5saXZlKSB7XG4gICAgICAgIHZhciBrZXlQYWlyID0gY3J5cHRvLmtleVBhaXIoKVxuICAgICAgICBzZWxmLnNlY3JldEtleSA9IGtleVBhaXIuc2VjcmV0S2V5XG4gICAgICAgIHNlbGYua2V5ID0ga2V5UGFpci5wdWJsaWNLZXlcbiAgICAgIH1cblxuICAgICAgdmFyIHdyaXRhYmxlID0gISFzZWxmLnNlY3JldEtleSB8fCBzZWxmLmtleSA9PT0gbnVsbFxuXG4gICAgICBpZiAoIXdyaXRhYmxlICYmIHNlbGYud3JpdGFibGUpIHJldHVybiBjYihuZXcgRXJyb3IoJ0ZlZWQgaXMgbm90IHdyaXRhYmxlJykpXG4gICAgICBzZWxmLndyaXRhYmxlID0gd3JpdGFibGVcbiAgICAgIHNlbGYuZGlzY292ZXJ5S2V5ID0gc2VsZi5rZXkgJiYgY3J5cHRvLmRpc2NvdmVyeUtleShzZWxmLmtleSlcblxuICAgICAgaWYgKHNlbGYuX3N0b3JlU2VjcmV0S2V5ICYmICFzZWxmLnNlY3JldEtleSkge1xuICAgICAgICBzZWxmLl9zdG9yZVNlY3JldEtleSA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHZhciBzaG91bGRXcml0ZUtleSA9IGdlbmVyYXRlZEtleSB8fCAhc2FmZUJ1ZmZlckVxdWFscyhzZWxmLmtleSwgc3RhdGUua2V5KVxuICAgICAgdmFyIHNob3VsZFdyaXRlU2VjcmV0S2V5ID0gc2VsZi5fc3RvcmVTZWNyZXRLZXkgJiYgKGdlbmVyYXRlZEtleSB8fCAhc2FmZUJ1ZmZlckVxdWFscyhzZWxmLnNlY3JldEtleSwgc3RhdGUuc2VjcmV0S2V5KSlcblxuICAgICAgdmFyIG1pc3NpbmcgPSAxICtcbiAgICAgICAgKHNob3VsZFdyaXRlS2V5ID8gMSA6IDApICtcbiAgICAgICAgKHNob3VsZFdyaXRlU2VjcmV0S2V5ID8gMSA6IDApICtcbiAgICAgICAgKHNlbGYuX292ZXJ3cml0ZSA/IDEgOiAwKVxuICAgICAgdmFyIGVycm9yID0gbnVsbFxuXG4gICAgICBpZiAoc2hvdWxkV3JpdGVLZXkpIHNlbGYuX3N0b3JhZ2Uua2V5LndyaXRlKDAsIHNlbGYua2V5LCBkb25lKVxuICAgICAgaWYgKHNob3VsZFdyaXRlU2VjcmV0S2V5KSBzZWxmLl9zdG9yYWdlLnNlY3JldEtleS53cml0ZSgwLCBzZWxmLnNlY3JldEtleSwgZG9uZSlcblxuICAgICAgaWYgKHNlbGYuX292ZXJ3cml0ZSkgeyAvLyBUT0RPOiBzdXBwb3J0IHN0b3JhZ2UucmVzaXplIGZvciB0aGlzIGluc3RlYWRcbiAgICAgICAgc2VsZi5fc3RvcmFnZS5wdXRCaXRmaWVsZCgwLCBzdGF0ZS5iaXRmaWVsZCwgZG9uZSlcbiAgICAgIH1cblxuICAgICAgZG9uZShudWxsKVxuXG4gICAgICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICAgICAgaWYgKC0tbWlzc2luZykgcmV0dXJuXG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNiKGVycm9yKVxuICAgICAgICBzZWxmLl9yb290cyhzZWxmLmxlbmd0aCwgb25yb290cylcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25yb290cyAoZXJyLCByb290cykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgICAgIHNlbGYuX21lcmtsZSA9IG1lcmtsZShjcnlwdG8sIHJvb3RzKVxuICAgICAgICBzZWxmLmJ5dGVMZW5ndGggPSByb290cy5yZWR1Y2UoYWRkU2l6ZSwgMClcbiAgICAgICAgc2VsZi5vcGVuZWQgPSB0cnVlXG4gICAgICAgIHNlbGYuZW1pdCgncmVhZHknKVxuXG4gICAgICAgIGNiKG51bGwpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24gKHJhbmdlLCBjYikge1xuICBpZiAodHlwZW9mIHJhbmdlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5kb3dubG9hZChudWxsLCByYW5nZSlcbiAgaWYgKHR5cGVvZiByYW5nZSA9PT0gJ251bWJlcicpIHJhbmdlID0ge3N0YXJ0OiByYW5nZSwgZW5kOiByYW5nZSArIDF9XG4gIGlmICghcmFuZ2UpIHJhbmdlID0ge31cblxuICAvLyBUT0RPOiBpZiBubyBwZWVycywgY2hlY2sgaWYgcmFuZ2UgaXMgYWxyZWFkeSBzYXRpc2ZpZWQgYW5kIG5leHRUaWNrKGNiKSBpZiBzb1xuICAvLyB0aGlzLl91cGRhdGVQZWVycyBkb2VzIHRoaXMgZm9yIHVzIHdoZW4gdGhlcmUgaXMgYSBwZWVyIHRob3VnaCwgc28gbm90IGNyaXRpY2FsXG5cbiAgdmFyIHNlbCA9IHtcbiAgICBfaW5kZXg6IHRoaXMuX3NlbGVjdGlvbnMubGVuZ3RoLFxuICAgIGhhc2g6ICEhcmFuZ2UuaGFzaCxcbiAgICBpdGVyYXRvcjogbnVsbCxcbiAgICBzdGFydDogcmFuZ2Uuc3RhcnQgfHwgMCxcbiAgICBlbmQ6IHJhbmdlLmVuZCB8fCAtMSxcbiAgICBsaW5lYXI6ICEhcmFuZ2UubGluZWFyLFxuICAgIGNhbGxiYWNrOiBjYiB8fCBub29wXG4gIH1cblxuICB0aGlzLl9zZWxlY3Rpb25zLnB1c2goc2VsKVxuICB0aGlzLl91cGRhdGVQZWVycygpXG5cbiAgcmV0dXJuIHNlbFxufVxuXG5GZWVkLnByb3RvdHlwZS51bmRvd25sb2FkID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIGlmICh0eXBlb2YgcmFuZ2UgPT09ICdudW1iZXInKSByYW5nZSA9IHtzdGFydDogcmFuZ2UsIGVuZDogcmFuZ2UgKyAxfVxuICBpZiAoIXJhbmdlKSByYW5nZSA9IHt9XG5cbiAgaWYgKHJhbmdlLmNhbGxiYWNrICYmIHJhbmdlLl9pbmRleCA+IC0xKSB7XG4gICAgc2V0LnJlbW92ZSh0aGlzLl9zZWxlY3Rpb25zLCByYW5nZSlcbiAgICBuZXh0VGljayhyYW5nZS5jYWxsYmFjaywgbmV3IEVycm9yKCdEb3dubG9hZCB3YXMgY2FuY2VsbGVkJykpXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCB8fCAwXG4gIHZhciBlbmQgPSByYW5nZS5lbmQgfHwgLTFcbiAgdmFyIGhhc2ggPSAhIXJhbmdlLmhhc2hcbiAgdmFyIGxpbmVhciA9ICEhcmFuZ2UubGluZWFyXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHMgPSB0aGlzLl9zZWxlY3Rpb25zW2ldXG5cbiAgICBpZiAocy5zdGFydCA9PT0gc3RhcnQgJiYgcy5lbmQgPT09IGVuZCAmJiBzLmhhc2ggPT09IGhhc2ggJiYgcy5saW5lYXIgPT09IGxpbmVhcikge1xuICAgICAgc2V0LnJlbW92ZSh0aGlzLl9zZWxlY3Rpb25zLCBzKVxuICAgICAgbmV4dFRpY2socy5jYWxsYmFjaywgbmV3IEVycm9yKCdEb3dubG9hZCB3YXMgY2FuY2VsbGVkJykpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHJldHVybiB0aGlzLnRyZWUuZGlnZXN0KDIgKiBpbmRleClcbn1cblxuRmVlZC5wcm90b3R5cGUucHJvb2YgPSBmdW5jdGlvbiAoaW5kZXgsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMucHJvb2YoaW5kZXgsIG51bGwsIG9wdHMpXG4gIGlmICghdGhpcy5vcGVuZWQpIHJldHVybiB0aGlzLl9yZWFkeUFuZFByb29mKGluZGV4LCBvcHRzLCBjYilcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICB2YXIgcHJvb2YgPSB0aGlzLnRyZWUucHJvb2YoMiAqIGluZGV4LCBvcHRzKVxuICBpZiAoIXByb29mKSByZXR1cm4gY2IobmV3IEVycm9yKCdObyBwcm9vZiBhdmFpbGFibGUgZm9yIHRoaXMgaW5kZXgnKSlcblxuICB2YXIgbmVlZHNTaWcgPSB0aGlzLmxpdmUgJiYgISFwcm9vZi52ZXJpZmllZEJ5XG4gIHZhciBwZW5kaW5nID0gcHJvb2Yubm9kZXMubGVuZ3RoICsgKG5lZWRzU2lnID8gMSA6IDApXG4gIHZhciBlcnJvciA9IG51bGxcbiAgdmFyIHNpZ25hdHVyZSA9IG51bGxcbiAgdmFyIG5vZGVzID0gbmV3IEFycmF5KHByb29mLm5vZGVzLmxlbmd0aClcblxuICBpZiAoIXBlbmRpbmcpIHJldHVybiBjYihudWxsLCB7bm9kZXM6IG5vZGVzLCBzaWduYXR1cmU6IG51bGx9KVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvb2Yubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9zdG9yYWdlLmdldE5vZGUocHJvb2Yubm9kZXNbaV0sIG9ubm9kZSlcbiAgfVxuICBpZiAobmVlZHNTaWcpIHtcbiAgICB0aGlzLl9zdG9yYWdlLmdldFNpZ25hdHVyZShwcm9vZi52ZXJpZmllZEJ5IC8gMiAtIDEsIG9uc2lnbmF0dXJlKVxuICB9XG5cbiAgZnVuY3Rpb24gb25zaWduYXR1cmUgKGVyciwgc2lnKSB7XG4gICAgaWYgKHNpZykgc2lnbmF0dXJlID0gc2lnXG4gICAgb25ub2RlKGVyciwgbnVsbClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubm9kZSAoZXJyLCBub2RlKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcblxuICAgIGlmIChub2RlKSB7XG4gICAgICBub2Rlc1twcm9vZi5ub2Rlcy5pbmRleE9mKG5vZGUuaW5kZXgpXSA9IG5vZGVcbiAgICB9XG5cbiAgICBpZiAoLS1wZW5kaW5nKSByZXR1cm5cbiAgICBpZiAoZXJyb3IpIHJldHVybiBjYihlcnJvcilcbiAgICBjYihudWxsLCB7bm9kZXM6IG5vZGVzLCBzaWduYXR1cmU6IHNpZ25hdHVyZX0pXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3JlYWR5QW5kUHJvb2YgPSBmdW5jdGlvbiAoaW5kZXgsIG9wdHMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBzZWxmLnByb29mKGluZGV4LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhLCBwcm9vZiwgY2IpIHtcbiAgaWYgKCF0aGlzLm9wZW5lZCkgcmV0dXJuIHRoaXMuX3JlYWR5QW5kUHV0KGluZGV4LCBkYXRhLCBwcm9vZiwgY2IpXG4gIHRoaXMuX3B1dEJ1ZmZlcihpbmRleCwgdGhpcy5fY29kZWMuZW5jb2RlKGRhdGEpLCBwcm9vZiwgbnVsbCwgY2IpXG59XG5cbkZlZWQucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7ICAvLyBUT0RPOiB1c2Ugc2FtZSBhcmd1bWVudCBzY2hlbWUgYXMgZG93bmxvYWRcbiAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0ICsgMVxuXG4gIC8vIGNhbmNlbCB0aGVzZSByaWdodCBhd2F5IGFzIC5kb3dubG9hZCBkb2VzIG5vdCB3YWl0IGZvciByZWFkeVxuICBmb3IgKHZhciBpID0gdGhpcy5fc2VsZWN0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBzZWwgPSB0aGlzLl9zZWxlY3Rpb25zW2ldXG4gICAgaWYgKHN0YXJ0IDw9IHNlbC5zdGFydCAmJiBzZWwuZW5kIDw9IGVuZCkge1xuICAgICAgdGhpcy51bmRvd25sb2FkKHNlbClcbiAgICB9XG4gIH1cblxuICAvLyBkZWZlciB0aGUgbGFzdCBwYXJ0IHVudGlsIGFmdGVyIHJlYWR5IGFzIC5nZXQgZG9lcyB0aGF0IGFzIHdlbGxcbiAgaWYgKHRoaXMub3BlbmVkKSB0aGlzLl9jYW5jZWwoc3RhcnQsIGVuZClcbiAgZWxzZSB0aGlzLl9yZWFkeUFuZENhbmNlbChzdGFydCwgZW5kKVxufVxuXG5GZWVkLnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGkgPSAwXG5cbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXMuX3Jlc2VydmVkLnNldChpLCBmYWxzZSkgLy8gVE9ETzogc2VuZCBjYW5jZWwgbWVzc2FnZSBpZiBzZXQgcmV0dXJucyB0cnVlXG4gIH1cblxuICBmb3IgKGkgPSB0aGlzLl93YWl0aW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHcgPSB0aGlzLl93YWl0aW5nW2ldXG4gICAgaWYgKChzdGFydCA8PSB3LnN0YXJ0ICYmIHcuZW5kIDw9IGVuZCkgfHwgKHN0YXJ0IDw9IHcuaW5kZXggJiYgdy5pbmRleCA8IGVuZCkpIHtcbiAgICAgIHJlbW92ZSh0aGlzLl93YWl0aW5nLCBpKVxuICAgICAgaWYgKHcuY2FsbGJhY2spIG5leHRUaWNrKHcuY2FsbGJhY2ssIG5ldyBFcnJvcignUmVxdWVzdCBjYW5jZWxsZWQnKSlcbiAgICB9XG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgb3B0cywgY2IpIHsgLy8gVE9ETzogdXNlIHNhbWUgYXJndW1lbnQgc2NoZW1lIGFzIGRvd25sb2FkXG4gIGlmICh0eXBlb2YgZW5kID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5jbGVhcihzdGFydCwgc3RhcnQgKyAxLCBudWxsLCBlbmQpXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuY2xlYXIoc3RhcnQsIGVuZCwgbnVsbCwgb3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0ICsgMVxuICBpZiAoIWNiKSBjYiA9IG5vb3BcblxuICAvLyBUT0RPOiB0aGlzIG5lZWRzIHNvbWUgd29yay4gZnggd2UgY2FuIG9ubHkgY2FsYyBieXRlIG9mZnNldCBmb3IgYmxvY2tzIHdlIGtub3cgYWJvdXRcbiAgLy8gc28gaW50ZXJuYWxseSB3ZSBzaG91bGQgbWFrZSBzdXJlIHRvIG9ubHkgZG8gdGhhdC4gV2Ugc2hvdWxkIHVzZSB0aGUgbWVya2xlIHRyZWUgZm9yIHRoaXNcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGJ5dGVPZmZzZXQgPSBzdGFydCA9PT0gMCA/IDAgOiAodHlwZW9mIG9wdHMuYnl0ZU9mZnNldCA9PT0gJ251bWJlcicgPyBvcHRzLmJ5dGVPZmZzZXQgOiAtMSlcbiAgdmFyIGJ5dGVMZW5ndGggPSB0eXBlb2Ygb3B0cy5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJyA/IG9wdHMuYnl0ZUxlbmd0aCA6IC0xXG5cbiAgdGhpcy5fcmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICB2YXIgbW9kaWZpZWQgPSBmYWxzZVxuXG4gICAgLy8gVE9ETzogdXNlIGEgYnVmZmVyLmZpbGwgdGhpbmcgaGVyZSB0byBzcGVlZCB0aGlzIHVwIVxuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIGlmIChzZWxmLmJpdGZpZWxkLnNldChpLCBmYWxzZSkpIG1vZGlmaWVkID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmICghbW9kaWZpZWQpIHJldHVybiBuZXh0VGljayhjYilcblxuICAgIC8vIFRPRE86IHdyaXRlIHRvIGEgdG1wL3VwZGF0ZSBmaWxlIHRoYXQgd2Ugd2FudCB0byBkZWwgdGhpcyBpbmNhc2UgaXQgY3Jhc2hlcyB3aWxsIGRlbCdpbmdcblxuICAgIHNlbGYuX3VuYW5ub3VuY2Uoe3N0YXJ0OiBzdGFydCwgbGVuZ3RoOiBlbmQgLSBzdGFydH0pXG4gICAgaWYgKG9wdHMuZGVsZXRlID09PSBmYWxzZSB8fCBzZWxmLl9pbmRleGluZykgcmV0dXJuIHN5bmMoKVxuICAgIGlmIChieXRlT2Zmc2V0ID4gLTEpIHJldHVybiBvbnN0YXJ0Ynl0ZXMobnVsbCwgYnl0ZU9mZnNldClcbiAgICBzZWxmLl9zdG9yYWdlLmRhdGFPZmZzZXQoc3RhcnQsIFtdLCBvbnN0YXJ0Ynl0ZXMpXG5cbiAgICBmdW5jdGlvbiBzeW5jICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnY2xlYXInLCBzdGFydCwgZW5kKVxuICAgICAgc2VsZi5fc3luYyhudWxsLCBjYilcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbnN0YXJ0Ynl0ZXMgKGVyciwgb2Zmc2V0KSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgYnl0ZU9mZnNldCA9IG9mZnNldFxuICAgICAgaWYgKGJ5dGVMZW5ndGggPiAtMSkgcmV0dXJuIG9uZW5kYnl0ZXMobnVsbCwgYnl0ZUxlbmd0aCArIGJ5dGVPZmZzZXQpXG4gICAgICBpZiAoZW5kID09PSBzZWxmLmxlbmd0aCkgcmV0dXJuIG9uZW5kYnl0ZXMobnVsbCwgc2VsZi5ieXRlTGVuZ3RoKVxuICAgICAgc2VsZi5fc3RvcmFnZS5kYXRhT2Zmc2V0KGVuZCwgW10sIG9uZW5kYnl0ZXMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25lbmRieXRlcyAoZXJyLCBlbmQpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBpZiAoIXNlbGYuX3N0b3JhZ2UuZGF0YS5kZWwpIHJldHVybiBzeW5jKCkgLy8gTm90IGFsbCBkYXRhIHN0b3JhZ2UgaW1wbHMgZGVsXG4gICAgICBzZWxmLl9zdG9yYWdlLmRhdGEuZGVsKGJ5dGVPZmZzZXQsIGVuZCAtIGJ5dGVPZmZzZXQsIHN5bmMpXG4gICAgfVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5zaWduYXR1cmUgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLnNpZ25hdHVyZSh0aGlzLmxlbmd0aCAtIDEsIGluZGV4KVxuXG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHJldHVybiBjYihuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZSBhdmFpbGFibGUgZm9yIHRoaXMgaW5kZXgnKSlcblxuICB0aGlzLl9zdG9yYWdlLm5leHRTaWduYXR1cmUoaW5kZXgsIGNiKVxufVxuXG5GZWVkLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAoaW5kZXgsIHNpZ25hdHVyZSwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5yb290SGFzaGVzKGluZGV4LCBmdW5jdGlvbiAoZXJyLCByb290cykge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICB2YXIgY2hlY2tzdW0gPSBjcnlwdG8udHJlZShyb290cylcblxuICAgIGlmICghY3J5cHRvLnZlcmlmeShjaGVja3N1bSwgc2lnbmF0dXJlLCBzZWxmLmtleSkpIHtcbiAgICAgIGNiKG5ldyBFcnJvcignU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbCwgdHJ1ZSlcbiAgICB9XG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLnJvb3RIYXNoZXMgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIHRoaXMuX2dldFJvb3RzVG9WZXJpZnkoaW5kZXggKiAyICsgMiwge30sIFtdLCBjYilcbn1cblxuRmVlZC5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uIChieXRlcywgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5zZWVrKGJ5dGVzLCBudWxsLCBvcHRzKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBpZiAoIXRoaXMub3BlbmVkKSByZXR1cm4gdGhpcy5fcmVhZHlBbmRTZWVrKGJ5dGVzLCBvcHRzLCBjYilcblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLl9zZWVrKGJ5dGVzLCBmdW5jdGlvbiAoZXJyLCBpbmRleCwgb2Zmc2V0KSB7XG4gICAgaWYgKCFlcnIgJiYgaXNCbG9jayhpbmRleCkpIHJldHVybiBkb25lKGluZGV4IC8gMiwgb2Zmc2V0KVxuICAgIGlmIChvcHRzLndhaXQgPT09IGZhbHNlKSByZXR1cm4gY2IoZXJyIHx8IG5ldyBFcnJvcignVW5hYmxlIHRvIHNlZWsgdG8gdGhpcyBvZmZzZXQnKSlcblxuICAgIHZhciBzdGFydCA9IG9wdHMuc3RhcnQgfHwgMFxuICAgIHZhciBlbmQgPSBvcHRzLmVuZCB8fCAtMVxuXG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIHZhciBsZWZ0ID0gZmxhdC5sZWZ0U3BhbihpbmRleCkgLyAyXG4gICAgICB2YXIgcmlnaHQgPSBmbGF0LnJpZ2h0U3BhbihpbmRleCkgLyAyICsgMVxuXG4gICAgICBpZiAobGVmdCA+IHN0YXJ0KSBzdGFydCA9IGxlZnRcbiAgICAgIGlmIChyaWdodCA8IGVuZCB8fCBlbmQgPT09IC0xKSBlbmQgPSByaWdodFxuICAgIH1cblxuICAgIGlmIChlbmQgPiAtMSAmJiBlbmQgPD0gc3RhcnQpIHJldHVybiBjYihuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZWVrIHRvIHRoaXMgb2Zmc2V0JykpXG5cbiAgICBzZWxmLl93YWl0aW5nLnB1c2goe1xuICAgICAgaGFzaDogb3B0cy5oYXNoICE9PSBmYWxzZSxcbiAgICAgIGJ5dGVzOiBieXRlcyxcbiAgICAgIGluZGV4OiAtMSxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kLFxuICAgICAgY2FsbGJhY2s6IGNiIHx8IG5vb3BcbiAgICB9KVxuXG4gICAgc2VsZi5fdXBkYXRlUGVlcnMoKVxuICB9KVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGluZGV4LCBvZmZzZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucGVlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGYucGVlcnNbaV0uaGF2ZUJ5dGVzKGJ5dGVzKVxuICAgIH1cbiAgICBjYihudWxsLCBpbmRleCwgb2Zmc2V0KVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9zZWVrID0gZnVuY3Rpb24gKG9mZnNldCwgY2IpIHtcbiAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIGNiKG51bGwsIDAsIDApXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByb290cyA9IGZsYXQuZnVsbFJvb3RzKHRoaXMubGVuZ3RoICogMilcbiAgdmFyIG5lYXJlc3RSb290ID0gMFxuXG4gIGxvb3AobnVsbCwgbnVsbClcblxuICBmdW5jdGlvbiBvbnJvb3QgKHRvcCkge1xuICAgIGlmIChpc0Jsb2NrKHRvcCkpIHJldHVybiBjYihudWxsLCB0b3AsIG9mZnNldClcblxuICAgIHZhciBsZWZ0ID0gZmxhdC5sZWZ0Q2hpbGQodG9wKVxuICAgIHdoaWxlICghc2VsZi50cmVlLmdldChsZWZ0KSkge1xuICAgICAgaWYgKGlzQmxvY2sobGVmdCkpIHJldHVybiBjYihudWxsLCBuZWFyZXN0Um9vdCwgb2Zmc2V0KVxuICAgICAgbGVmdCA9IGZsYXQubGVmdENoaWxkKGxlZnQpXG4gICAgfVxuXG4gICAgc2VsZi5fc3RvcmFnZS5nZXROb2RlKGxlZnQsIG9ubGVmdGNoaWxkKVxuICB9XG5cbiAgZnVuY3Rpb24gb25sZWZ0Y2hpbGQgKGVyciwgbm9kZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAobm9kZS5zaXplID4gb2Zmc2V0KSB7XG4gICAgICBuZWFyZXN0Um9vdCA9IG5vZGUuaW5kZXhcbiAgICAgIG9ucm9vdChub2RlLmluZGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgLT0gbm9kZS5zaXplXG4gICAgICBvbnJvb3QoZmxhdC5zaWJsaW5nKG5vZGUuaW5kZXgpKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb3AgKGVyciwgbm9kZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUuc2l6ZSA+IG9mZnNldCkge1xuICAgICAgICBuZWFyZXN0Um9vdCA9IG5vZGUuaW5kZXhcbiAgICAgICAgcmV0dXJuIG9ucm9vdChub2RlLmluZGV4KVxuICAgICAgfVxuICAgICAgb2Zmc2V0IC09IG5vZGUuc2l6ZVxuICAgIH1cblxuICAgIGlmICghcm9vdHMubGVuZ3RoKSByZXR1cm4gY2IobmV3IEVycm9yKCdPdXQgb2YgYm91bmRzJykpXG4gICAgc2VsZi5fc3RvcmFnZS5nZXROb2RlKHJvb3RzLnNoaWZ0KCksIGxvb3ApXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3JlYWR5QW5kU2VlayA9IGZ1bmN0aW9uIChieXRlcywgb3B0cywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHNlbGYuc2VlayhieXRlcywgb3B0cywgY2IpXG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLl9nZXRCdWZmZXIgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIHRoaXMuX3N0b3JhZ2UuZ2V0RGF0YShpbmRleCwgY2IpXG59XG5cbkZlZWQucHJvdG90eXBlLl9wdXRCdWZmZXIgPSBmdW5jdGlvbiAoaW5kZXgsIGRhdGEsIHByb29mLCBmcm9tLCBjYikge1xuICAvLyBUT0RPOiB0aGlzIG5vZGVzIGluIHByb29mIGFyZSBub3QgaW5zdGFuY2VzIG9mIG91ciBOb2RlIHByb3RvdHlwZVxuICAvLyBidXQganVzdCBzaW1pbGFyLiBDaGVjayBpZiB0aGlzIGhhcyBhbnkgdjggcGVyZiBpbXBsaWNhdGlvbnMuXG5cbiAgLy8gVE9ETzogaWYgdGhlIHByb29mIGNvbnRhaW5zIGEgdmFsaWQgc2lnbmF0dXJlIEJVVCBmYWlscywgZW1pdCBhIGNyaXRpY2FsIGVycm9yXG4gIC8vIC0tPiBmZWVkIHNob3VsZCBiZSBjb25zaWRlcmVkIGRlYWRcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHRydXN0ZWQgPSAtMVxuICB2YXIgbWlzc2luZyA9IFtdXG4gIHZhciBuZXh0ID0gMiAqIGluZGV4XG4gIHZhciBpID0gZGF0YSA/IDAgOiAxXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAodGhpcy50cmVlLmdldChuZXh0KSkge1xuICAgICAgdHJ1c3RlZCA9IG5leHRcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgdmFyIHNpYiA9IGZsYXQuc2libGluZyhuZXh0KVxuICAgIG5leHQgPSBmbGF0LnBhcmVudChuZXh0KVxuXG4gICAgaWYgKGkgPCBwcm9vZi5ub2Rlcy5sZW5ndGggJiYgcHJvb2Yubm9kZXNbaV0uaW5kZXggPT09IHNpYikge1xuICAgICAgaSsrXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICghdGhpcy50cmVlLmdldChzaWIpKSBicmVha1xuICAgIG1pc3NpbmcucHVzaChzaWIpXG4gIH1cblxuICBpZiAodHJ1c3RlZCA9PT0gLTEgJiYgdGhpcy50cmVlLmdldChuZXh0KSkgdHJ1c3RlZCA9IG5leHRcblxuICB2YXIgZXJyb3IgPSBudWxsXG4gIHZhciB0cnVzdGVkTm9kZSA9IG51bGxcbiAgdmFyIG1pc3NpbmdOb2RlcyA9IG5ldyBBcnJheShtaXNzaW5nLmxlbmd0aClcbiAgdmFyIHBlbmRpbmcgPSBtaXNzaW5nLmxlbmd0aCArICh0cnVzdGVkID4gLTEgPyAxIDogMClcblxuICBmb3IgKGkgPSAwOyBpIDwgbWlzc2luZy5sZW5ndGg7IGkrKykgdGhpcy5fc3RvcmFnZS5nZXROb2RlKG1pc3NpbmdbaV0sIG9ubWlzc2luZylcbiAgaWYgKHRydXN0ZWQgPiAtMSkgdGhpcy5fc3RvcmFnZS5nZXROb2RlKHRydXN0ZWQsIG9udHJ1c3RlZClcbiAgaWYgKCFtaXNzaW5nLmxlbmd0aCAmJiB0cnVzdGVkID09PSAtMSkgb25taXNzaW5nbG9hZGVkKG51bGwpXG5cbiAgZnVuY3Rpb24gb250cnVzdGVkIChlcnIsIG5vZGUpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmIChub2RlKSB0cnVzdGVkTm9kZSA9IG5vZGVcbiAgICBpZiAoIS0tcGVuZGluZykgb25taXNzaW5nbG9hZGVkKGVycm9yKVxuICB9XG5cbiAgZnVuY3Rpb24gb25taXNzaW5nIChlcnIsIG5vZGUpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmIChub2RlKSBtaXNzaW5nTm9kZXNbbWlzc2luZy5pbmRleE9mKG5vZGUuaW5kZXgpXSA9IG5vZGVcbiAgICBpZiAoIS0tcGVuZGluZykgb25taXNzaW5nbG9hZGVkKGVycm9yKVxuICB9XG5cbiAgZnVuY3Rpb24gb25taXNzaW5nbG9hZGVkIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHNlbGYuX3ZlcmlmeUFuZFdyaXRlKGluZGV4LCBkYXRhLCBwcm9vZiwgbWlzc2luZ05vZGVzLCB0cnVzdGVkTm9kZSwgZnJvbSwgY2IpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3JlYWR5QW5kUHV0ID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhLCBwcm9vZiwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHNlbGYucHV0KGluZGV4LCBkYXRhLCBwcm9vZiwgY2IpXG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChpbmRleCwgZGF0YSwgbm9kZXMsIHNpZywgZnJvbSwgY2IpIHtcbiAgaWYgKCF0aGlzLl9vbndyaXRlKSByZXR1cm4gdGhpcy5fd3JpdGVBZnRlckhvb2soaW5kZXgsIGRhdGEsIG5vZGVzLCBzaWcsIGZyb20sIGNiKVxuICB0aGlzLl9vbndyaXRlKGluZGV4LCBkYXRhLCBmcm9tLCB3cml0ZUhvb2tEb25lKHRoaXMsIGluZGV4LCBkYXRhLCBub2Rlcywgc2lnLCBmcm9tLCBjYikpXG59XG5cbmZ1bmN0aW9uIHdyaXRlSG9va0RvbmUgKHNlbGYsIGluZGV4LCBkYXRhLCBub2Rlcywgc2lnLCBmcm9tLCBjYikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5fd3JpdGVBZnRlckhvb2soaW5kZXgsIGRhdGEsIG5vZGVzLCBzaWcsIGZyb20sIGNiKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl93cml0ZUFmdGVySG9vayA9IGZ1bmN0aW9uIChpbmRleCwgZGF0YSwgbm9kZXMsIHNpZywgZnJvbSwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwZW5kaW5nID0gbm9kZXMubGVuZ3RoICsgMSArIChzaWcgPyAxIDogMClcbiAgdmFyIGVycm9yID0gbnVsbFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHRoaXMuX3N0b3JhZ2UucHV0Tm9kZShub2Rlc1tpXS5pbmRleCwgbm9kZXNbaV0sIG9uZG9uZSlcbiAgaWYgKGRhdGEpIHRoaXMuX3N0b3JhZ2UucHV0RGF0YShpbmRleCwgZGF0YSwgbm9kZXMsIG9uZG9uZSlcbiAgZWxzZSBvbmRvbmUoKVxuICBpZiAoc2lnKSB0aGlzLl9zdG9yYWdlLnB1dFNpZ25hdHVyZShzaWcuaW5kZXgsIHNpZy5zaWduYXR1cmUsIG9uZG9uZSlcblxuICBmdW5jdGlvbiBvbmRvbmUgKGVycikge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKC0tcGVuZGluZykgcmV0dXJuXG4gICAgaWYgKGVycm9yKSByZXR1cm4gY2IoZXJyb3IpXG4gICAgc2VsZi5fd3JpdGVEb25lKGluZGV4LCBkYXRhLCBub2RlcywgZnJvbSwgY2IpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3dyaXRlRG9uZSA9IGZ1bmN0aW9uIChpbmRleCwgZGF0YSwgbm9kZXMsIGZyb20sIGNiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHRoaXMudHJlZS5zZXQobm9kZXNbaV0uaW5kZXgpXG4gIHRoaXMudHJlZS5zZXQoMiAqIGluZGV4KVxuXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuYml0ZmllbGQuc2V0KGluZGV4LCB0cnVlKSkgdGhpcy5lbWl0KCdkb3dubG9hZCcsIGluZGV4LCBkYXRhLCBmcm9tKVxuICAgIGlmICh0aGlzLnBlZXJzLmxlbmd0aCkgdGhpcy5fYW5ub3VuY2Uoe3N0YXJ0OiBpbmRleH0sIGZyb20pXG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgIGlmICghdGhpcy5fc3luY2VkKSB0aGlzLl9zeW5jZWQgPSB0aGlzLmJpdGZpZWxkLml0ZXJhdG9yKDAsIHRoaXMubGVuZ3RoKVxuICAgICAgaWYgKHRoaXMuX3N5bmNlZC5uZXh0KCkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3N5bmNlZC5yYW5nZSgwLCB0aGlzLmxlbmd0aClcbiAgICAgICAgdGhpcy5fc3luY2VkLnNlZWsoMClcbiAgICAgICAgaWYgKHRoaXMuX3N5bmNlZC5uZXh0KCkgPT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdzeW5jJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3N5bmMobnVsbCwgY2IpXG59XG5cbkZlZWQucHJvdG90eXBlLl92ZXJpZnlBbmRXcml0ZSA9IGZ1bmN0aW9uIChpbmRleCwgZGF0YSwgcHJvb2YsIGxvY2FsTm9kZXMsIHRydXN0ZWROb2RlLCBmcm9tLCBjYikge1xuICB2YXIgdmlzaXRlZCA9IFtdXG4gIHZhciByZW1vdGVOb2RlcyA9IHByb29mLm5vZGVzXG4gIHZhciB0b3AgPSBkYXRhID8gbmV3IHN0b3JhZ2UuTm9kZSgyICogaW5kZXgsIGNyeXB0by5kYXRhKGRhdGEpLCBkYXRhLmxlbmd0aCkgOiByZW1vdGVOb2Rlcy5zaGlmdCgpXG5cbiAgLy8gY2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBoYXNoIGZvciB0aGlzIG5vZGVcbiAgaWYgKHZlcmlmeU5vZGUodHJ1c3RlZE5vZGUsIHRvcCkpIHtcbiAgICB0aGlzLl93cml0ZShpbmRleCwgZGF0YSwgdmlzaXRlZCwgbnVsbCwgZnJvbSwgY2IpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBrZWVwIGhhc2hpbmcgd2l0aCBzaWJsaW5ncyB1bnRpbCB3ZSByZWFjaCBvciB0cnVzdGVkIG5vZGVcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbm9kZSA9IG51bGxcbiAgICB2YXIgbmV4dCA9IGZsYXQuc2libGluZyh0b3AuaW5kZXgpXG5cbiAgICBpZiAocmVtb3RlTm9kZXMubGVuZ3RoICYmIHJlbW90ZU5vZGVzWzBdLmluZGV4ID09PSBuZXh0KSB7XG4gICAgICBub2RlID0gcmVtb3RlTm9kZXMuc2hpZnQoKVxuICAgICAgdmlzaXRlZC5wdXNoKG5vZGUpXG4gICAgfSBlbHNlIGlmIChsb2NhbE5vZGVzLmxlbmd0aCAmJiBsb2NhbE5vZGVzWzBdLmluZGV4ID09PSBuZXh0KSB7XG4gICAgICBub2RlID0gbG9jYWxOb2Rlcy5zaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIGNhbm5vdCBjcmVhdGUgYW5vdGhlciBwYXJlbnQsIGkuZS4gdGhlc2Ugbm9kZXMgbXVzdCBiZSByb290cyBpbiB0aGUgdHJlZVxuICAgICAgdGhpcy5fdmVyaWZ5Um9vdHNBbmRXcml0ZShpbmRleCwgZGF0YSwgdG9wLCBwcm9vZiwgdmlzaXRlZCwgZnJvbSwgY2IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2aXNpdGVkLnB1c2godG9wKVxuICAgIHRvcCA9IG5ldyBzdG9yYWdlLk5vZGUoZmxhdC5wYXJlbnQodG9wLmluZGV4KSwgY3J5cHRvLnBhcmVudCh0b3AsIG5vZGUpLCB0b3Auc2l6ZSArIG5vZGUuc2l6ZSlcblxuICAgIC8vIHRoZSB0cmVlIGNoZWNrcyBvdXQsIHdyaXRlIHRoZSBkYXRhIGFuZCB0aGUgdmlzaXRlZCBub2Rlc1xuICAgIGlmICh2ZXJpZnlOb2RlKHRydXN0ZWROb2RlLCB0b3ApKSB7XG4gICAgICB0aGlzLl93cml0ZShpbmRleCwgZGF0YSwgdmlzaXRlZCwgbnVsbCwgZnJvbSwgY2IpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3ZlcmlmeVJvb3RzQW5kV3JpdGUgPSBmdW5jdGlvbiAoaW5kZXgsIGRhdGEsIHRvcCwgcHJvb2YsIG5vZGVzLCBmcm9tLCBjYikge1xuICB2YXIgcmVtb3RlTm9kZXMgPSBwcm9vZi5ub2Rlc1xuICB2YXIgbGFzdE5vZGUgPSByZW1vdGVOb2Rlcy5sZW5ndGggPyByZW1vdGVOb2Rlc1tyZW1vdGVOb2Rlcy5sZW5ndGggLSAxXS5pbmRleCA6IHRvcC5pbmRleFxuICB2YXIgdmVyaWZpZWRCeSA9IE1hdGgubWF4KGZsYXQucmlnaHRTcGFuKHRvcC5pbmRleCksIGZsYXQucmlnaHRTcGFuKGxhc3ROb2RlKSkgKyAyXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMuX2dldFJvb3RzVG9WZXJpZnkodmVyaWZpZWRCeSwgdG9wLCByZW1vdGVOb2RlcywgZnVuY3Rpb24gKGVyciwgcm9vdHMsIGV4dHJhTm9kZXMpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgdmFyIGNoZWNrc3VtID0gY3J5cHRvLnRyZWUocm9vdHMpXG4gICAgdmFyIHNpZ25hdHVyZSA9IG51bGxcblxuICAgIGlmIChzZWxmLmxlbmd0aCAmJiBzZWxmLmxpdmUgJiYgIXByb29mLnNpZ25hdHVyZSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignUmVtb3RlIGRpZCBub3QgaW5jbHVkZSBhIHNpZ25hdHVyZScpKVxuICAgIH1cblxuICAgIGlmIChwcm9vZi5zaWduYXR1cmUpIHsgLy8gY2hlY2sgc2lnbmF0dXJleFxuICAgICAgaWYgKCFjcnlwdG8udmVyaWZ5KGNoZWNrc3VtLCBwcm9vZi5zaWduYXR1cmUsIHNlbGYua2V5KSkge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdSZW1vdGUgc2lnbmF0dXJlIGNvdWxkIG5vdCBiZSB2ZXJpZmllZCcpKVxuICAgICAgfVxuXG4gICAgICBzaWduYXR1cmUgPSB7aW5kZXg6IHZlcmlmaWVkQnkgLyAyIC0gMSwgc2lnbmF0dXJlOiBwcm9vZi5zaWduYXR1cmV9XG4gICAgfSBlbHNlIHsgLy8gY2hlY2sgdHJlZSByb290XG4gICAgICBpZiAoIWVxdWFscyhjaGVja3N1bSwgc2VsZi5rZXkpKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1JlbW90ZSBjaGVja3N1bSBmYWlsZWQnKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLmxpdmUgPSAhIXNpZ25hdHVyZVxuXG4gICAgdmFyIGxlbmd0aCA9IHZlcmlmaWVkQnkgLyAyXG4gICAgaWYgKGxlbmd0aCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAvLyBUT0RPOiBvbmx5IGVtaXQgdGhpcyBhZnRlciB0aGUgaW5mbyBoYXMgYmVlbiBmbHVzaGVkIHRvIHN0b3JhZ2VcbiAgICAgIHNlbGYubGVuZ3RoID0gbGVuZ3RoXG4gICAgICBzZWxmLmJ5dGVMZW5ndGggPSByb290cy5yZWR1Y2UoYWRkU2l6ZSwgMClcbiAgICAgIGlmIChzZWxmLl9zeW5jZWQpIHNlbGYuX3N5bmNlZC5zZWVrKDAsIHNlbGYubGVuZ3RoKVxuICAgICAgc2VsZi5lbWl0KCdhcHBlbmQnKVxuICAgIH1cblxuICAgIHNlbGYuX3dyaXRlKGluZGV4LCBkYXRhLCBub2Rlcy5jb25jYXQoZXh0cmFOb2RlcyksIHNpZ25hdHVyZSwgZnJvbSwgY2IpXG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLl9nZXRSb290c1RvVmVyaWZ5ID0gZnVuY3Rpb24gKHZlcmlmaWVkQnksIHRvcCwgcmVtb3RlTm9kZXMsIGNiKSB7XG4gIHZhciBpbmRleGVzID0gZmxhdC5mdWxsUm9vdHModmVyaWZpZWRCeSlcbiAgdmFyIHJvb3RzID0gbmV3IEFycmF5KGluZGV4ZXMubGVuZ3RoKVxuICB2YXIgbm9kZXMgPSBbXVxuICB2YXIgZXJyb3IgPSBudWxsXG4gIHZhciBwZW5kaW5nID0gcm9vdHMubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGluZGV4ZXNbaV0gPT09IHRvcC5pbmRleCkge1xuICAgICAgbm9kZXMucHVzaCh0b3ApXG4gICAgICBvbm5vZGUobnVsbCwgdG9wKVxuICAgIH0gZWxzZSBpZiAocmVtb3RlTm9kZXMubGVuZ3RoICYmIGluZGV4ZXNbaV0gPT09IHJlbW90ZU5vZGVzWzBdLmluZGV4KSB7XG4gICAgICBub2Rlcy5wdXNoKHJlbW90ZU5vZGVzWzBdKVxuICAgICAgb25ub2RlKG51bGwsIHJlbW90ZU5vZGVzLnNoaWZ0KCkpXG4gICAgfSBlbHNlIGlmICh0aGlzLnRyZWUuZ2V0KGluZGV4ZXNbaV0pKSB7XG4gICAgICB0aGlzLl9zdG9yYWdlLmdldE5vZGUoaW5kZXhlc1tpXSwgb25ub2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICBvbm5vZGUobmV3IEVycm9yKCdNaXNzaW5nIHRyZWUgcm9vdHMgbmVlZGVkIGZvciB2ZXJpZnknKSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbm5vZGUgKGVyciwgbm9kZSkge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKG5vZGUpIHJvb3RzW2luZGV4ZXMuaW5kZXhPZihub2RlLmluZGV4KV0gPSBub2RlXG4gICAgaWYgKCEtLXBlbmRpbmcpIGRvbmUoZXJyb3IpXG4gIH1cblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgY2IobnVsbCwgcm9vdHMsIG5vZGVzKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9hbm5vdW5jZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBmcm9tKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZWVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwZWVyID0gdGhpcy5wZWVyc1tpXVxuICAgIGlmIChwZWVyICE9PSBmcm9tKSBwZWVyLmhhdmUobWVzc2FnZSlcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fdW5hbm5vdW5jZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZWVycy5sZW5ndGg7IGkrKykgdGhpcy5wZWVyc1tpXS51bmhhdmUobWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUuZG93bmxvYWRlZCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLmJpdGZpZWxkLnRvdGFsKHN0YXJ0LCBlbmQpXG59XG5cbkZlZWQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuYml0ZmllbGQuZ2V0KHN0YXJ0KVxuICB2YXIgdG90YWwgPSBlbmQgLSBzdGFydFxuICByZXR1cm4gdG90YWwgPT09IHRoaXMuYml0ZmllbGQudG90YWwoc3RhcnQsIGVuZClcbn1cblxuRmVlZC5wcm90b3R5cGUuaGVhZCA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmhlYWQoe30sIG9wdHMpXG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIGNiKG5ldyBFcnJvcignZmVlZCBpcyBlbXB0eScpKVxuICAgIGVsc2Ugc2VsZi5nZXQoc2VsZi5sZW5ndGggLSAxLCBjYilcbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmdldChpbmRleCwgbnVsbCwgb3B0cylcbiAgaWYgKCF0aGlzLm9wZW5lZCkgcmV0dXJuIHRoaXMuX3JlYWR5QW5kR2V0KGluZGV4LCBvcHRzLCBjYilcblxuICBpZiAob3B0cyAmJiBvcHRzLnRpbWVvdXQpIGNiID0gdGltZW91dENhbGxiYWNrKGNiLCBvcHRzLnRpbWVvdXQpXG5cbiAgaWYgKCF0aGlzLmJpdGZpZWxkLmdldChpbmRleCkpIHtcbiAgICBpZiAob3B0cyAmJiBvcHRzLndhaXQgPT09IGZhbHNlKSByZXR1cm4gY2IobmV3IEVycm9yKCdCbG9jayBub3QgZG93bmxvYWRlZCcpKVxuXG4gICAgdGhpcy5fd2FpdGluZy5wdXNoKHtieXRlczogMCwgaGFzaDogZmFsc2UsIGluZGV4OiBpbmRleCwgb3B0aW9uczogb3B0cywgY2FsbGJhY2s6IGNifSlcbiAgICB0aGlzLl91cGRhdGVQZWVycygpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAob3B0cyAmJiBvcHRzLnZhbHVlRW5jb2RpbmcpIGNiID0gd3JhcENvZGVjKHRvQ29kZWMob3B0cy52YWx1ZUVuY29kaW5nKSwgY2IpXG4gIGVsc2UgaWYgKHRoaXMuX2NvZGVjICE9PSBjb2RlY3MuYmluYXJ5KSBjYiA9IHdyYXBDb2RlYyh0aGlzLl9jb2RlYywgY2IpXG5cbiAgdGhpcy5fZ2V0QnVmZmVyKGluZGV4LCBjYilcbn1cblxuRmVlZC5wcm90b3R5cGUuX3JlYWR5QW5kR2V0ID0gZnVuY3Rpb24gKGluZGV4LCBvcHRzLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5nZXQoaW5kZXgsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5fdXBkYXRlUGVlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZWVycy5sZW5ndGg7IGkrKykgdGhpcy5wZWVyc1tpXS51cGRhdGUoKVxufVxuXG5GZWVkLnByb3RvdHlwZS5jcmVhdGVXcml0ZVN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiBidWxrLm9iaih3cml0ZSlcblxuICBmdW5jdGlvbiB3cml0ZSAoYmF0Y2gsIGNiKSB7XG4gICAgc2VsZi5fYmF0Y2goYmF0Y2gsIGNiKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLmNyZWF0ZVJlYWRTdHJlYW0gPSBmdW5jdGlvbiAob3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgc3RhcnQgPSBvcHRzLnN0YXJ0IHx8IDBcbiAgdmFyIGVuZCA9IHR5cGVvZiBvcHRzLmVuZCA9PT0gJ251bWJlcicgPyBvcHRzLmVuZCA6IC0xXG4gIHZhciBsaXZlID0gISFvcHRzLmxpdmVcbiAgdmFyIHNuYXBzaG90ID0gb3B0cy5zbmFwc2hvdCAhPT0gZmFsc2VcbiAgdmFyIGZpcnN0ID0gdHJ1ZVxuICB2YXIgcmFuZ2UgPSB0aGlzLmRvd25sb2FkKHtzdGFydDogc3RhcnQsIGVuZDogZW5kLCBsaW5lYXI6IHRydWV9KVxuXG4gIHJldHVybiBmcm9tLm9iaihyZWFkKS5vbignZW5kJywgY2xlYW51cCkub24oJ2Nsb3NlJywgY2xlYW51cClcblxuICBmdW5jdGlvbiByZWFkIChzaXplLCBjYikge1xuICAgIGlmICghc2VsZi5vcGVuZWQpIHJldHVybiBvcGVuKHNpemUsIGNiKVxuXG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICBpZiAobGl2ZSkgZW5kID0gSW5maW5pdHlcbiAgICAgICAgZWxzZSBpZiAoc25hcHNob3QpIGVuZCA9IHNlbGYubGVuZ3RoXG4gICAgICB9XG4gICAgICBpZiAob3B0cy50YWlsKSBzdGFydCA9IHNlbGYubGVuZ3RoXG4gICAgICBmaXJzdCA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID09PSBlbmQgfHwgKGVuZCA9PT0gLTEgJiYgc3RhcnQgPT09IHNlbGYubGVuZ3RoKSkgcmV0dXJuIGNiKG51bGwsIG51bGwpXG4gICAgc2VsZi5nZXQoc3RhcnQrKywgb3B0cywgY2IpXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICBpZiAoIXJhbmdlKSByZXR1cm5cbiAgICBzZWxmLnVuZG93bmxvYWQocmFuZ2UpXG4gICAgcmFuZ2UgPSBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBvcGVuIChzaXplLCBjYikge1xuICAgIHNlbGYuX3JlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZWFkKHNpemUsIGNiKVxuICAgIH0pXG4gIH1cbn1cblxuLy8gVE9ETzogd2hlbiBjYWxsaW5nIGZpbmFsaXplIG9uIGEgbGl2ZSBmZWVkIHdyaXRlIGFuIEVORF9PRl9GRUVEIGJsb2NrIChsZW5ndGggPT09IDA/KVxuRmVlZC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKCF0aGlzLmtleSkge1xuICAgIHRoaXMua2V5ID0gY3J5cHRvLnRyZWUodGhpcy5fbWVya2xlLnJvb3RzKVxuICAgIHRoaXMuZGlzY292ZXJ5S2V5ID0gY3J5cHRvLmRpc2NvdmVyeUtleSh0aGlzLmtleSlcbiAgfVxuICB0aGlzLl9zdG9yYWdlLmtleS53cml0ZSgwLCB0aGlzLmtleSwgY2IpXG59XG5cbkZlZWQucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChiYXRjaCwgY2IpIHtcbiAgdGhpcy5fYmF0Y2goQXJyYXkuaXNBcnJheShiYXRjaCkgPyBiYXRjaCA6IFtiYXRjaF0sIGNiIHx8IG5vb3ApXG59XG5cbkZlZWQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGNiKSB7XG4gIHRoaXMuX2JhdGNoKFtdLCBjYilcbn1cblxuRmVlZC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5fcmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSBmYWxzZVxuICAgIHNlbGYucmVhZGFibGUgPSBmYWxzZVxuICAgIHNlbGYuX3N0b3JhZ2UuY2xvc2UoZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFzZWxmLmNsb3NlZCAmJiAhZXJyKSB7XG4gICAgICAgIHNlbGYuY2xvc2VkID0gdHJ1ZVxuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgICAgIH1cbiAgICAgIGlmIChjYikgY2IoZXJyKVxuICAgIH0pXG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLl9hcHBlbmRIb29rID0gZnVuY3Rpb24gKGJhdGNoLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG1pc3NpbmcgPSBiYXRjaC5sZW5ndGhcbiAgdmFyIGVycm9yID0gbnVsbFxuXG4gIGlmICghbWlzc2luZykgcmV0dXJuIHRoaXMuX2FwcGVuZChiYXRjaCwgY2IpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9vbndyaXRlKGkgKyB0aGlzLmxlbmd0aCwgYmF0Y2hbaV0sIG51bGwsIGRvbmUpXG4gIH1cblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmICgtLW1pc3NpbmcpIHJldHVyblxuICAgIGlmIChlcnJvcikgcmV0dXJuIGNiKGVycm9yKVxuICAgIHNlbGYuX2FwcGVuZChiYXRjaCwgY2IpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX2FwcGVuZCA9IGZ1bmN0aW9uIChiYXRjaCwgY2IpIHtcbiAgaWYgKCF0aGlzLm9wZW5lZCkgcmV0dXJuIHRoaXMuX3JlYWR5QW5kQXBwZW5kKGJhdGNoLCBjYilcbiAgaWYgKCF0aGlzLndyaXRhYmxlKSByZXR1cm4gY2IobmV3IEVycm9yKCdUaGlzIGZlZWQgaXMgbm90IHdyaXRhYmxlLiBEaWQgeW91IGNyZWF0ZSBpdD8nKSlcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHBlbmRpbmcgPSB0aGlzLmxpdmUgJiYgYmF0Y2gubGVuZ3RoID8gMSArIGJhdGNoLmxlbmd0aCA6IGJhdGNoLmxlbmd0aFxuICB2YXIgb2Zmc2V0ID0gMFxuICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgaWYgKCFwZW5kaW5nKSByZXR1cm4gY2IoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2NvZGVjLmVuY29kZShiYXRjaFtpXSlcbiAgICB2YXIgbm9kZXMgPSB0aGlzLl9tZXJrbGUubmV4dChkYXRhKVxuXG4gICAgaWYgKHRoaXMuX2luZGV4aW5nKSBkb25lKG51bGwpXG4gICAgZWxzZSB0aGlzLl9zdG9yYWdlLmRhdGEud3JpdGUodGhpcy5ieXRlTGVuZ3RoICsgb2Zmc2V0LCBkYXRhLCBkb25lKVxuXG4gICAgaWYgKHRoaXMubGl2ZSAmJiBpID09PSBiYXRjaC5sZW5ndGggLSAxKSB7XG4gICAgICB2YXIgc2lnID0gY3J5cHRvLnNpZ24oY3J5cHRvLnRyZWUodGhpcy5fbWVya2xlLnJvb3RzKSwgdGhpcy5zZWNyZXRLZXkpXG4gICAgICB0aGlzLl9zdG9yYWdlLnB1dFNpZ25hdHVyZSh0aGlzLmxlbmd0aCArIGksIHNpZywgZG9uZSlcbiAgICB9XG5cbiAgICBwZW5kaW5nICs9IG5vZGVzLmxlbmd0aFxuICAgIG9mZnNldCArPSBkYXRhLmxlbmd0aFxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tqXVxuICAgICAgdGhpcy5fc3RvcmFnZS5wdXROb2RlKG5vZGUuaW5kZXgsIG5vZGUsIGRvbmUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAoLS1wZW5kaW5nKSByZXR1cm5cbiAgICBpZiAoZXJyb3IpIHJldHVybiBjYihlcnJvcilcblxuICAgIHZhciBzdGFydCA9IHNlbGYubGVuZ3RoXG5cbiAgICAvLyBUT0RPOiBvbmx5IGVtaXQgYXBwZW5kIGFuZCB1cGRhdGUgbGVuZ3RoIC8gYnl0ZUxlbmd0aCBhZnRlciB0aGUgaW5mbyBoYXMgYmVlbiBmbHVzaGVkIHRvIHN0b3JhZ2VcbiAgICBzZWxmLmJ5dGVMZW5ndGggKz0gb2Zmc2V0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZi5iaXRmaWVsZC5zZXQoc2VsZi5sZW5ndGgsIHRydWUpXG4gICAgICBzZWxmLnRyZWUuc2V0KDIgKiBzZWxmLmxlbmd0aCsrKVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2FwcGVuZCcpXG5cbiAgICB2YXIgbWVzc2FnZSA9IHNlbGYubGVuZ3RoIC0gc3RhcnQgPiAxID8ge3N0YXJ0OiBzdGFydCwgbGVuZ3RoOiBzZWxmLmxlbmd0aCAtIHN0YXJ0fSA6IHtzdGFydDogc3RhcnR9XG4gICAgaWYgKHNlbGYucGVlcnMubGVuZ3RoKSBzZWxmLl9hbm5vdW5jZShtZXNzYWdlKVxuXG4gICAgc2VsZi5fc3luYyhudWxsLCBjYilcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fcmVhZHlBbmRBcHBlbmQgPSBmdW5jdGlvbiAoYmF0Y2gsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBzZWxmLl9hcHBlbmQoYmF0Y2gsIGNiKVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5fcmVhZHlBbmRDYW5jZWwgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fY2FuY2VsKHN0YXJ0LCBlbmQpXG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLl9wb2xsV2FpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMuX3dhaXRpbmcubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuX3dhaXRpbmdbaV1cbiAgICBpZiAoIW5leHQuYnl0ZXMgJiYgIXRoaXMuYml0ZmllbGQuZ2V0KG5leHQuaW5kZXgpKSBjb250aW51ZVxuXG4gICAgcmVtb3ZlKHRoaXMuX3dhaXRpbmcsIGktLSlcbiAgICBsZW4tLVxuXG4gICAgaWYgKG5leHQuYnl0ZXMpIHRoaXMuc2VlayhuZXh0LmJ5dGVzLCBuZXh0LCBuZXh0LmNhbGxiYWNrKVxuICAgIGVsc2UgaWYgKG5leHQudXBkYXRlKSB0aGlzLnVwZGF0ZShuZXh0LmluZGV4ICsgMSwgbmV4dC5jYWxsYmFjaylcbiAgICBlbHNlIHRoaXMuZ2V0KG5leHQuaW5kZXgsIG5leHQub3B0aW9ucywgbmV4dC5jYWxsYmFjaylcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fc3luY0JpdGZpZWxkID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBtaXNzaW5nID0gdGhpcy5iaXRmaWVsZC5wYWdlcy51cGRhdGVzLmxlbmd0aFxuICB2YXIgbmV4dCA9IG51bGxcbiAgdmFyIGVycm9yID0gbnVsbFxuXG4gIC8vIEFsbCBkYXRhIC8gbm9kZXMgaGF2ZSBiZWVuIHdyaXR0ZW4gbm93LiBXZSBzdGlsbCBuZWVkIHRvIHVwZGF0ZSB0aGUgYml0ZmllbGRzIHRob3VnaFxuXG4gIC8vIFRPRE8gMTogaWYgdGhlIHByb2dyYW0gZmFpbHMgZHVyaW5nIHRoaXMgd3JpdGUgdGhlIGJpdGZpZWxkIG1pZ2h0IG5vdCBoYXZlIGJlZW4gZnVsbHkgd3JpdHRlblxuICAvLyBIT1dFVkVSLCB3ZSBjYW4gZWFzaWx5IHJlY292ZXIgZnJvbSB0aGlzIGJ5IHRyYXZlcnNpbmcgdGhlIHRyZWUgYW5kIGNoZWNraW5nIGlmIHRoZSBub2RlcyBleGlzdHNcbiAgLy8gb24gZGlzay4gU28gaWYgYSBnZXQgZmFpbHMsIGl0IHNob3VsZCB0cnkgYW5kIHJlY292ZXIgb25jZS5cblxuICAvLyBUT0RPIDI6IGlmIC53cml0YWJsZSBhcHBlbmQgYml0ZmllbGQgdXBkYXRlcyBpbnRvIGEgc2luZ2xlIGJ1ZmZlciBmb3IgZXh0cmEgcGVyZlxuICAvLyBBZGRlZCBiZW5lZml0IGlzIHRoYXQgaWYgdGhlIHByb2dyYW0gZXhpdHMgd2hpbGUgZmx1c2hpbmcgdGhlIGJpdGZpZWxkIHRoZSBmZWVkIHdpbGwgb25seSBnZXRcbiAgLy8gdHJ1bmNhdGVkIGFuZCBub3QgaGF2ZSBtaXNzaW5nIGNodW5rcyB3aGljaCBpcyB3aGF0IHlvdSBleHBlY3QuXG5cbiAgaWYgKCFtaXNzaW5nKSB7XG4gICAgdGhpcy5fcG9sbFdhaXRpbmcoKVxuICAgIHJldHVybiBjYihudWxsKVxuICB9XG5cbiAgd2hpbGUgKChuZXh0ID0gdGhpcy5iaXRmaWVsZC5wYWdlcy5sYXN0VXBkYXRlKCkpICE9PSBudWxsKSB7XG4gICAgdGhpcy5fc3RvcmFnZS5wdXRCaXRmaWVsZChuZXh0Lm9mZnNldCwgbmV4dC5idWZmZXIsIG9uZG9uZSlcbiAgfVxuXG4gIHRoaXMuX3BvbGxXYWl0aW5nKClcblxuICBmdW5jdGlvbiBvbmRvbmUgKGVycikge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKC0tbWlzc2luZykgcmV0dXJuXG4gICAgY2IoZXJyb3IpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3Jvb3RzID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB2YXIgcm9vdHMgPSBmbGF0LmZ1bGxSb290cygyICogaW5kZXgpXG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkocm9vdHMubGVuZ3RoKVxuICB2YXIgcGVuZGluZyA9IHJvb3RzLmxlbmd0aFxuICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgaWYgKCFwZW5kaW5nKSByZXR1cm4gY2IobnVsbCwgcmVzdWx0KVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9zdG9yYWdlLmdldE5vZGUocm9vdHNbaV0sIG9ubm9kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubm9kZSAoZXJyLCBub2RlKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAobm9kZSkgcmVzdWx0W3Jvb3RzLmluZGV4T2Yobm9kZS5pbmRleCldID0gbm9kZVxuICAgIGlmICgtLXBlbmRpbmcpIHJldHVyblxuICAgIGlmIChlcnJvcikgcmV0dXJuIGNiKGVycm9yKVxuICAgIGNiKG51bGwsIHJlc3VsdClcbiAgfVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIHZlcmlmeU5vZGUgKHRydXN0ZWQsIG5vZGUpIHtcbiAgcmV0dXJuIHRydXN0ZWQgJiYgdHJ1c3RlZC5pbmRleCA9PT0gbm9kZS5pbmRleCAmJiBlcXVhbHModHJ1c3RlZC5oYXNoLCBub2RlLmhhc2gpXG59XG5cbmZ1bmN0aW9uIGFkZFNpemUgKHNpemUsIG5vZGUpIHtcbiAgcmV0dXJuIHNpemUgKyBub2RlLnNpemVcbn1cblxuZnVuY3Rpb24gaXNCbG9jayAoaW5kZXgpIHtcbiAgcmV0dXJuIChpbmRleCAmIDEpID09PSAwXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdG9yYWdlIChkaXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHJhZihuYW1lLCB7ZGlyZWN0b3J5OiBkaXJ9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvQ29kZWMgKGVuYykge1xuICAvLyBTd2l0Y2ggdG8gbmRqc29uIGVuY29kaW5nIGlmIEpTT04gaXMgdXNlZC4gVGhhdCB3YXkgZGF0YSBmaWxlcyBwYXJzZSBsaWtlIG5kanNvbiBcXG8vXG4gIHJldHVybiBjb2RlY3MoZW5jID09PSAnanNvbicgPyAnbmRqc29uJyA6IGVuYylcbn1cblxuZnVuY3Rpb24gd3JhcENvZGVjIChlbmMsIGNiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyLCBidWYpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHRyeSB7XG4gICAgICBidWYgPSBlbmMuZGVjb2RlKGJ1ZilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpXG4gICAgfVxuICAgIGNiKG51bGwsIGJ1ZilcbiAgfVxufVxuXG5mdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2sgKGNiLCB0aW1lb3V0KSB7XG4gIHZhciBmYWlsZWQgPSBmYWxzZVxuICB2YXIgaWQgPSBzZXRUaW1lb3V0KG9udGltZW91dCwgdGltZW91dClcbiAgcmV0dXJuIGRvbmVcblxuICBmdW5jdGlvbiBvbnRpbWVvdXQgKCkge1xuICAgIGZhaWxlZCA9IHRydWVcbiAgICAvLyBUT0RPOiBtYWtlIGxpYnMvZXJyb3JzIGZvciBhbGwgdGhpcyBzdHVmZlxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0VUSU1FRE9VVCcpXG4gICAgZXJyLmNvZGUgPSAnRVRJTUVET1VUJ1xuICAgIGNiKGVycilcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVyciwgdmFsKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuXG4gICAgY2xlYXJUaW1lb3V0KGlkKVxuICAgIGNiKGVyciwgdmFsKVxuICB9XG59XG5cbi8vIGJ1ZmZlci1lcXVhbHMsIGJ1dCBoYW5kbGUgJ251bGwnIGJ1ZmZlciBwYXJhbWV0ZXJzLlxuZnVuY3Rpb24gc2FmZUJ1ZmZlckVxdWFscyAoYSwgYikge1xuICBpZiAoIWEpIHJldHVybiAhYlxuICBpZiAoIWIpIHJldHVybiAhYVxuICByZXR1cm4gZXF1YWxzKGEsIGIpXG59XG4iLCJ2YXIgZmxhdCA9IHJlcXVpcmUoJ2ZsYXQtdHJlZScpXG52YXIgcmxlID0gcmVxdWlyZSgnYml0ZmllbGQtcmxlJylcbnZhciBwYWdlciA9IHJlcXVpcmUoJ21lbW9yeS1wYWdlcicpXG52YXIgYml0ZmllbGQgPSByZXF1aXJlKCdzcGFyc2UtYml0ZmllbGQnKVxuXG52YXIgSU5ERVhfVVBEQVRFX01BU0sgPSBbNjMsIDIwNywgMjQzLCAyNTJdXG52YXIgSU5ERVhfSVRFUkFURV9NQVNLID0gWzAsIDE5MiwgMjQwLCAyNTJdXG52YXIgREFUQV9JVEVSQVRFX01BU0sgPSBbMTI4LCAxOTIsIDIyNCwgMjQwLCAyNDgsIDI1MiwgMjU0LCAyNTVdXG52YXIgREFUQV9VUERBVEVfTUFTSyA9IFsxMjcsIDE5MSwgMjIzLCAyMzksIDI0NywgMjUxLCAyNTMsIDI1NF1cbnZhciBNQVBfUEFSRU5UX1JJR0hUID0gbmV3IEFycmF5KDI1NilcbnZhciBNQVBfUEFSRU5UX0xFRlQgPSBuZXcgQXJyYXkoMjU2KVxudmFyIE5FWFRfREFUQV8wX0JJVCA9IG5ldyBBcnJheSgyNTYpXG52YXIgTkVYVF9JTkRFWF8wX0JJVCA9IG5ldyBBcnJheSgyNTYpXG52YXIgVE9UQUxfMV9CSVRTID0gbmV3IEFycmF5KDI1NilcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICB2YXIgYSA9IChpICYgKDE1IDw8IDQpKSA+PiA0XG4gIHZhciBiID0gaSAmIDE1XG4gIHZhciBuaWJibGUgPSBbMCwgMSwgMSwgMiwgMSwgMiwgMiwgMywgMSwgMiwgMiwgMywgMiwgMywgMywgNF1cbiAgTUFQX1BBUkVOVF9SSUdIVFtpXSA9ICgoYSA9PT0gMTUgPyAzIDogYSA9PT0gMCA/IDAgOiAxKSA8PCAyKSB8IChiID09PSAxNSA/IDMgOiBiID09PSAwID8gMCA6IDEpXG4gIE1BUF9QQVJFTlRfTEVGVFtpXSA9IE1BUF9QQVJFTlRfUklHSFRbaV0gPDwgNFxuICBORVhUX0RBVEFfMF9CSVRbaV0gPSBpID09PSAyNTUgPyAtMSA6ICg4IC0gTWF0aC5jZWlsKE1hdGgubG9nKDI1NiAtIGkpIC8gTWF0aC5sb2coMikpKVxuICBORVhUX0lOREVYXzBfQklUW2ldID0gaSA9PT0gMjU1ID8gLTEgOiBNYXRoLmZsb29yKE5FWFRfREFUQV8wX0JJVFtpXSAvIDIpXG4gIFRPVEFMXzFfQklUU1tpXSA9IG5pYmJsZVtpID4+IDRdICsgbmliYmxlW2kgJiAweDBGXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJpdGZpZWxkXG5cbmZ1bmN0aW9uIEJpdGZpZWxkIChidWZmZXIpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJpdGZpZWxkKSkgcmV0dXJuIG5ldyBCaXRmaWVsZChidWZmZXIpXG5cbiAgdGhpcy5wYWdlcyA9IHBhZ2VyKDMzMjgpXG5cbiAgaWYgKGJ1ZmZlcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAzMzI4KSB7XG4gICAgICB0aGlzLnBhZ2VzLnNldChpIC8gMzMyOCwgYnVmZmVyLnNsaWNlKGksIGkgKyAzMzI4KSlcbiAgICB9XG4gIH1cblxuICB0aGlzLmRhdGEgPSBiaXRmaWVsZCh7XG4gICAgcGFnZVNpemU6IDEwMjQsXG4gICAgcGFnZU9mZnNldDogMCxcbiAgICBwYWdlczogdGhpcy5wYWdlcyxcbiAgICB0cmFja1VwZGF0ZXM6IHRydWVcbiAgfSlcblxuICB0aGlzLnRyZWUgPSBiaXRmaWVsZCh7XG4gICAgcGFnZVNpemU6IDIwNDgsXG4gICAgcGFnZU9mZnNldDogMTAyNCxcbiAgICBwYWdlczogdGhpcy5wYWdlcyxcbiAgICB0cmFja1VwZGF0ZXM6IHRydWVcbiAgfSlcblxuICB0aGlzLmluZGV4ID0gYml0ZmllbGQoe1xuICAgIHBhZ2VTaXplOiAyNTYsXG4gICAgcGFnZU9mZnNldDogMTAyNCArIDIwNDgsXG4gICAgcGFnZXM6IHRoaXMucGFnZXMsXG4gICAgdHJhY2tVcGRhdGVzOiB0cnVlXG4gIH0pXG5cbiAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoXG4gIHRoaXMuX2l0ZXJhdG9yID0gZmxhdC5pdGVyYXRvcigwKVxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGksIHZhbHVlKSB7XG4gIHZhciBvID0gaSAmIDdcbiAgaSA9IChpIC0gbykgLyA4XG4gIHZhciB2ID0gdmFsdWUgPyB0aGlzLmRhdGEuZ2V0Qnl0ZShpKSB8ICgxMjggPj4gbykgOiB0aGlzLmRhdGEuZ2V0Qnl0ZShpKSAmIERBVEFfVVBEQVRFX01BU0tbb11cblxuICBpZiAoIXRoaXMuZGF0YS5zZXRCeXRlKGksIHYpKSByZXR1cm4gZmFsc2VcbiAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoXG4gIHRoaXMuX3NldEluZGV4KGksIHYpXG4gIHJldHVybiB0cnVlXG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldChpKVxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUudG90YWwgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmRhdGEubGVuZ3RoXG4gIGlmIChlbmQgPCBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKGVuZCA+IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICB0aGlzLl9leHBhbmQoZW5kKVxuICB9XG4gIHZhciBvID0gc3RhcnQgJiA3XG4gIHZhciBlID0gZW5kICYgN1xuICB2YXIgcG9zID0gKHN0YXJ0IC0gbykgLyA4XG4gIHZhciBsYXN0ID0gKGVuZCAtIGUpIC8gOFxuICB2YXIgbGVmdE1hc2sgPSAoMjU1IC0gKG8gPyBEQVRBX0lURVJBVEVfTUFTS1tvIC0gMV0gOiAwKSlcbiAgdmFyIHJpZ2h0TWFzayA9IChlID8gREFUQV9JVEVSQVRFX01BU0tbZSAtIDFdIDogMClcbiAgdmFyIGJ5dGUgPSB0aGlzLmRhdGEuZ2V0Qnl0ZShwb3MpXG4gIGlmIChwb3MgPT09IGxhc3QpIHtcbiAgICByZXR1cm4gVE9UQUxfMV9CSVRTW2J5dGUgJiBsZWZ0TWFzayAmIHJpZ2h0TWFza11cbiAgfVxuICB2YXIgdG90YWwgPSBUT1RBTF8xX0JJVFNbYnl0ZSAmIGxlZnRNYXNrXVxuICBmb3IgKHZhciBpID0gcG9zICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgIHRvdGFsICs9IFRPVEFMXzFfQklUU1t0aGlzLmRhdGEuZ2V0Qnl0ZShpKV1cbiAgfVxuICB0b3RhbCArPSBUT1RBTF8xX0JJVFNbdGhpcy5kYXRhLmdldEJ5dGUobGFzdCkgJiByaWdodE1hc2tdXG4gIHJldHVybiB0b3RhbFxufVxuXG4vLyBUT0RPOiB1c2UgdGhlIGluZGV4IHRvIHNwZWVkIHRoaXMgdXAgKmEgbG90KlxuQml0ZmllbGQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmxlLmVuY29kZSh0aGlzLmRhdGEudG9CdWZmZXIoKSlcbn1cblxuQml0ZmllbGQucHJvdG90eXBlLl9zZXRJbmRleCA9IGZ1bmN0aW9uIChpLCB2YWx1ZSkge1xuICAvLyAgICAgICAgICAgICAgICAgICAgKGEgKyBiIHwgYyArIGQgfCBlICsgZiB8IGcgKyBoKVxuICAvLyAtPiAoYSB8IGIgfCBjIHwgZCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlIHwgZiB8IGcgfCBoKVxuICAvL1xuXG4gIHZhciBvID0gaSAmIDNcbiAgaSA9IChpIC0gbykgLyA0XG5cbiAgdmFyIGJpdGZpZWxkID0gdGhpcy5pbmRleFxuICB2YXIgaXRlID0gdGhpcy5faXRlcmF0b3JcbiAgdmFyIHN0YXJ0ID0gMiAqIGlcbiAgdmFyIGJ5dGUgPSAoYml0ZmllbGQuZ2V0Qnl0ZShzdGFydCkgJiBJTkRFWF9VUERBVEVfTUFTS1tvXSkgfCAoZ2V0SW5kZXhWYWx1ZSh2YWx1ZSkgPj4gKDIgKiBvKSlcbiAgdmFyIGxlbiA9IGJpdGZpZWxkLmxlbmd0aFxuICB2YXIgbWF4TGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGggKiAyNTZcblxuICBpdGUuc2VlayhzdGFydClcblxuICB3aGlsZSAoaXRlLmluZGV4IDwgbWF4TGVuZ3RoICYmIGJpdGZpZWxkLnNldEJ5dGUoaXRlLmluZGV4LCBieXRlKSkge1xuICAgIGlmIChpdGUuaXNMZWZ0KCkpIHtcbiAgICAgIGJ5dGUgPSBNQVBfUEFSRU5UX0xFRlRbYnl0ZV0gfCBNQVBfUEFSRU5UX1JJR0hUW2JpdGZpZWxkLmdldEJ5dGUoaXRlLnNpYmxpbmcoKSldXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGUgPSBNQVBfUEFSRU5UX1JJR0hUW2J5dGVdIHwgTUFQX1BBUkVOVF9MRUZUW2JpdGZpZWxkLmdldEJ5dGUoaXRlLnNpYmxpbmcoKSldXG4gICAgfVxuICAgIGl0ZS5wYXJlbnQoKVxuICB9XG5cbiAgaWYgKGxlbiAhPT0gYml0ZmllbGQubGVuZ3RoKSB0aGlzLl9leHBhbmQobGVuKVxuXG4gIHJldHVybiBpdGUuaW5kZXggIT09IHN0YXJ0XG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gKGxlbikge1xuICB2YXIgcm9vdHMgPSBmbGF0LmZ1bGxSb290cygyICogbGVuKVxuICB2YXIgYml0ZmllbGQgPSB0aGlzLmluZGV4XG4gIHZhciBpdGUgPSB0aGlzLl9pdGVyYXRvclxuICB2YXIgYnl0ZSA9IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgaXRlLnNlZWsocm9vdHNbaV0pXG4gICAgYnl0ZSA9IGJpdGZpZWxkLmdldEJ5dGUoaXRlLmluZGV4KVxuXG4gICAgZG8ge1xuICAgICAgaWYgKGl0ZS5pc0xlZnQoKSkge1xuICAgICAgICBieXRlID0gTUFQX1BBUkVOVF9MRUZUW2J5dGVdIHwgTUFQX1BBUkVOVF9SSUdIVFtiaXRmaWVsZC5nZXRCeXRlKGl0ZS5zaWJsaW5nKCkpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnl0ZSA9IE1BUF9QQVJFTlRfUklHSFRbYnl0ZV0gfCBNQVBfUEFSRU5UX0xFRlRbYml0ZmllbGQuZ2V0Qnl0ZShpdGUuc2libGluZygpKV1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChzZXRCeXRlTm9BbGxvYyhiaXRmaWVsZCwgaXRlLnBhcmVudCgpLCBieXRlKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRCeXRlTm9BbGxvYyAoYml0ZmllbGQsIGksIGIpIHtcbiAgaWYgKDggKiBpID49IGJpdGZpZWxkLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBiaXRmaWVsZC5zZXRCeXRlKGksIGIpXG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBpdGUgPSBuZXcgSXRlcmF0b3IodGhpcylcblxuICBpdGUucmFuZ2Uoc3RhcnQgfHwgMCwgZW5kIHx8IHRoaXMubGVuZ3RoKVxuICBpdGUuc2VlaygwKVxuXG4gIHJldHVybiBpdGVcbn1cblxuZnVuY3Rpb24gSXRlcmF0b3IgKGJpdGZpZWxkKSB7XG4gIHRoaXMuc3RhcnQgPSAwXG4gIHRoaXMuZW5kID0gMFxuXG4gIHRoaXMuX2luZGV4RW5kID0gMFxuICB0aGlzLl9wb3MgPSAwXG4gIHRoaXMuX2J5dGUgPSAwXG4gIHRoaXMuX2JpdGZpZWxkID0gYml0ZmllbGRcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0XG4gIHRoaXMuZW5kID0gZW5kXG4gIHRoaXMuX2luZGV4RW5kID0gMiAqIE1hdGguY2VpbChlbmQgLyAzMilcblxuICBpZiAodGhpcy5lbmQgPiB0aGlzLl9iaXRmaWVsZC5sZW5ndGgpIHtcbiAgICB0aGlzLl9iaXRmaWVsZC5fZXhwYW5kKHRoaXMuZW5kKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIG9mZnNldCArPSB0aGlzLnN0YXJ0XG4gIGlmIChvZmZzZXQgPCB0aGlzLnN0YXJ0KSBvZmZzZXQgPSB0aGlzLnN0YXJ0XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmVuZCkge1xuICAgIHRoaXMuX3BvcyA9IC0xXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvID0gb2Zmc2V0ICYgN1xuXG4gIHRoaXMuX3BvcyA9IChvZmZzZXQgLSBvKSAvIDhcbiAgdGhpcy5fYnl0ZSA9IHRoaXMuX2JpdGZpZWxkLmRhdGEuZ2V0Qnl0ZSh0aGlzLl9wb3MpIHwgKG8gPyBEQVRBX0lURVJBVEVfTUFTS1tvIC0gMV0gOiAwKVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5yYW5kb20gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gdGhpcy5zZWVrKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpKSkubmV4dCgpXG4gIHJldHVybiBpID09PSAtMSA/IHRoaXMuc2VlaygwKS5uZXh0KCkgOiBpXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcG9zID09PSAtMSkgcmV0dXJuIC0xXG5cbiAgdmFyIGRhdGFCaXRmaWVsZCA9IHRoaXMuX2JpdGZpZWxkLmRhdGFcbiAgdmFyIGZyZWUgPSBORVhUX0RBVEFfMF9CSVRbdGhpcy5fYnl0ZV1cblxuICB3aGlsZSAoZnJlZSA9PT0gLTEpIHtcbiAgICB0aGlzLl9ieXRlID0gZGF0YUJpdGZpZWxkLmdldEJ5dGUoKyt0aGlzLl9wb3MpXG4gICAgZnJlZSA9IE5FWFRfREFUQV8wX0JJVFt0aGlzLl9ieXRlXVxuXG4gICAgaWYgKGZyZWUgPT09IC0xKSB7XG4gICAgICB0aGlzLl9wb3MgPSB0aGlzLl9za2lwQWhlYWQodGhpcy5fcG9zKVxuICAgICAgaWYgKHRoaXMuX3BvcyA9PT0gLTEpIHJldHVybiAtMVxuXG4gICAgICB0aGlzLl9ieXRlID0gZGF0YUJpdGZpZWxkLmdldEJ5dGUodGhpcy5fcG9zKVxuICAgICAgZnJlZSA9IE5FWFRfREFUQV8wX0JJVFt0aGlzLl9ieXRlXVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2J5dGUgfD0gREFUQV9JVEVSQVRFX01BU0tbZnJlZV1cblxuICB2YXIgbiA9IDggKiB0aGlzLl9wb3MgKyBmcmVlXG4gIHJldHVybiBuIDwgdGhpcy5lbmQgPyBuIDogLTFcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9wb3MgPT09IC0xKSByZXR1cm4gLTFcblxuICB2YXIgZnJlZSA9IE5FWFRfREFUQV8wX0JJVFt0aGlzLl9ieXRlXVxuICB2YXIgbiA9IDggKiB0aGlzLl9wb3MgKyBmcmVlXG4gIHJldHVybiBuIDwgdGhpcy5lbmQgPyBuIDogLTFcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLl9za2lwQWhlYWQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgdmFyIGluZGV4Qml0ZmllbGQgPSB0aGlzLl9iaXRmaWVsZC5pbmRleFxuICB2YXIgdHJlZUVuZCA9IHRoaXMuX2luZGV4RW5kXG4gIHZhciBpdGUgPSB0aGlzLl9iaXRmaWVsZC5faXRlcmF0b3JcbiAgdmFyIG8gPSBzdGFydCAmIDNcblxuICBpdGUuc2VlaygyICogKChzdGFydCAtIG8pIC8gNCkpXG5cbiAgdmFyIHRyZWVCeXRlID0gaW5kZXhCaXRmaWVsZC5nZXRCeXRlKGl0ZS5pbmRleCkgfCBJTkRFWF9JVEVSQVRFX01BU0tbb11cblxuICB3aGlsZSAoTkVYVF9JTkRFWF8wX0JJVFt0cmVlQnl0ZV0gPT09IC0xKSB7XG4gICAgaWYgKGl0ZS5pc0xlZnQoKSkge1xuICAgICAgaXRlLm5leHQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGUubmV4dCgpXG4gICAgICBpdGUucGFyZW50KClcbiAgICB9XG5cbiAgICBpZiAocmlnaHRTcGFuKGl0ZSkgPj0gdHJlZUVuZCkge1xuICAgICAgd2hpbGUgKHJpZ2h0U3BhbihpdGUpID49IHRyZWVFbmQgJiYgaXNQYXJlbnQoaXRlKSkgaXRlLmxlZnRDaGlsZCgpXG4gICAgICBpZiAocmlnaHRTcGFuKGl0ZSkgPj0gdHJlZUVuZCkgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgdHJlZUJ5dGUgPSBpbmRleEJpdGZpZWxkLmdldEJ5dGUoaXRlLmluZGV4KVxuICB9XG5cbiAgd2hpbGUgKGl0ZS5mYWN0b3IgPiAyKSB7XG4gICAgaWYgKE5FWFRfSU5ERVhfMF9CSVRbdHJlZUJ5dGVdIDwgMikgaXRlLmxlZnRDaGlsZCgpXG4gICAgZWxzZSBpdGUucmlnaHRDaGlsZCgpXG5cbiAgICB0cmVlQnl0ZSA9IGluZGV4Qml0ZmllbGQuZ2V0Qnl0ZShpdGUuaW5kZXgpXG4gIH1cblxuICB2YXIgZnJlZSA9IE5FWFRfSU5ERVhfMF9CSVRbdHJlZUJ5dGVdXG4gIGlmIChmcmVlID09PSAtMSkgZnJlZSA9IDRcblxuICB2YXIgbmV4dCA9IGl0ZS5pbmRleCAqIDIgKyBmcmVlXG5cbiAgcmV0dXJuIG5leHQgPD0gc3RhcnQgPyBzdGFydCArIDEgOiBuZXh0XG59XG5cbmZ1bmN0aW9uIHJpZ2h0U3BhbiAoaXRlKSB7XG4gIHJldHVybiBpdGUuaW5kZXggKyBpdGUuZmFjdG9yIC8gMiAtIDFcbn1cblxuZnVuY3Rpb24gaXNQYXJlbnQgKGl0ZSkge1xuICByZXR1cm4gaXRlLmluZGV4ICYgMVxufVxuXG5mdW5jdGlvbiBnZXRJbmRleFZhbHVlIChuKSB7XG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMjU1OiByZXR1cm4gMTkyXG4gICAgY2FzZSAwOiByZXR1cm4gMFxuICAgIGRlZmF1bHQ6IHJldHVybiA2NFxuICB9XG59XG4iLCJ2YXIgc29kaXVtID0gcmVxdWlyZSgnc29kaXVtLXVuaXZlcnNhbCcpXG52YXIgdWludDY0YmUgPSByZXF1aXJlKCd1aW50NjRiZScpXG52YXIgYnVmZmVyRnJvbSA9IHJlcXVpcmUoJ2J1ZmZlci1mcm9tJylcbnZhciBidWZmZXJBbGxvYyA9IHJlcXVpcmUoJ2J1ZmZlci1hbGxvYy11bnNhZmUnKVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXJrbGVfdHJlZSNTZWNvbmRfcHJlaW1hZ2VfYXR0YWNrXG52YXIgTEVBRl9UWVBFID0gYnVmZmVyRnJvbShbMF0pXG52YXIgUEFSRU5UX1RZUEUgPSBidWZmZXJGcm9tKFsxXSlcbnZhciBST09UX1RZUEUgPSBidWZmZXJGcm9tKFsyXSlcbnZhciBIWVBFUkNPUkUgPSBidWZmZXJGcm9tKCdoeXBlcmNvcmUnKVxuXG5leHBvcnRzLmtleVBhaXIgPSBmdW5jdGlvbiAoc2VlZCkge1xuICB2YXIgcHVibGljS2V5ID0gYnVmZmVyQWxsb2Moc29kaXVtLmNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICB2YXIgc2VjcmV0S2V5ID0gYnVmZmVyQWxsb2Moc29kaXVtLmNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuXG4gIGlmIChzZWVkKSBzb2RpdW0uY3J5cHRvX3NpZ25fc2VlZF9rZXlwYWlyKHB1YmxpY0tleSwgc2VjcmV0S2V5LCBzZWVkKVxuICBlbHNlIHNvZGl1bS5jcnlwdG9fc2lnbl9rZXlwYWlyKHB1YmxpY0tleSwgc2VjcmV0S2V5KVxuXG4gIHJldHVybiB7XG4gICAgcHVibGljS2V5OiBwdWJsaWNLZXksXG4gICAgc2VjcmV0S2V5OiBzZWNyZXRLZXlcbiAgfVxufVxuXG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbiAobWVzc2FnZSwgc2VjcmV0S2V5KSB7XG4gIHZhciBzaWduYXR1cmUgPSBidWZmZXJBbGxvYyhzb2RpdW0uY3J5cHRvX3NpZ25fQllURVMpXG4gIHNvZGl1bS5jcnlwdG9fc2lnbl9kZXRhY2hlZChzaWduYXR1cmUsIG1lc3NhZ2UsIHNlY3JldEtleSlcbiAgcmV0dXJuIHNpZ25hdHVyZVxufVxuXG5leHBvcnRzLnZlcmlmeSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICByZXR1cm4gc29kaXVtLmNyeXB0b19zaWduX3ZlcmlmeV9kZXRhY2hlZChzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSlcbn1cblxuZXhwb3J0cy5kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIGJsYWtlMmIoW1xuICAgIExFQUZfVFlQRSxcbiAgICBlbmNvZGVVSW50NjQoZGF0YS5sZW5ndGgpLFxuICAgIGRhdGFcbiAgXSlcbn1cblxuZXhwb3J0cy5sZWFmID0gZnVuY3Rpb24gKGxlYWYpIHtcbiAgcmV0dXJuIGV4cG9ydHMuZGF0YShsZWFmLmRhdGEpXG59XG5cbmV4cG9ydHMucGFyZW50ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKGEuaW5kZXggPiBiLmluZGV4KSB7XG4gICAgdmFyIHRtcCA9IGFcbiAgICBhID0gYlxuICAgIGIgPSB0bXBcbiAgfVxuXG4gIHJldHVybiBibGFrZTJiKFtcbiAgICBQQVJFTlRfVFlQRSxcbiAgICBlbmNvZGVVSW50NjQoYS5zaXplICsgYi5zaXplKSxcbiAgICBhLmhhc2gsXG4gICAgYi5oYXNoXG4gIF0pXG59XG5cbmV4cG9ydHMudHJlZSA9IGZ1bmN0aW9uIChyb290cykge1xuICB2YXIgYnVmZmVycyA9IG5ldyBBcnJheSgzICogcm9vdHMubGVuZ3RoICsgMSlcbiAgdmFyIGogPSAwXG5cbiAgYnVmZmVyc1tqKytdID0gUk9PVF9UWVBFXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByID0gcm9vdHNbaV1cbiAgICBidWZmZXJzW2orK10gPSByLmhhc2hcbiAgICBidWZmZXJzW2orK10gPSBlbmNvZGVVSW50NjQoci5pbmRleClcbiAgICBidWZmZXJzW2orK10gPSBlbmNvZGVVSW50NjQoci5zaXplKVxuICB9XG5cbiAgcmV0dXJuIGJsYWtlMmIoYnVmZmVycylcbn1cblxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciBidWYgPSBidWZmZXJBbGxvYyhuKVxuICBzb2RpdW0ucmFuZG9tYnl0ZXNfYnVmKGJ1ZilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5leHBvcnRzLmRpc2NvdmVyeUtleSA9IGZ1bmN0aW9uICh0cmVlKSB7XG4gIHZhciBkaWdlc3QgPSBidWZmZXJBbGxvYygzMilcbiAgc29kaXVtLmNyeXB0b19nZW5lcmljaGFzaChkaWdlc3QsIEhZUEVSQ09SRSwgdHJlZSlcbiAgcmV0dXJuIGRpZ2VzdFxufVxuXG5mdW5jdGlvbiBlbmNvZGVVSW50NjQgKG4pIHtcbiAgcmV0dXJuIHVpbnQ2NGJlLmVuY29kZShuLCBidWZmZXJBbGxvYyg4KSlcbn1cblxuZnVuY3Rpb24gYmxha2UyYiAoYnVmZmVycykge1xuICB2YXIgZGlnZXN0ID0gYnVmZmVyQWxsb2MoMzIpXG4gIHNvZGl1bS5jcnlwdG9fZ2VuZXJpY2hhc2hfYmF0Y2goZGlnZXN0LCBidWZmZXJzKVxuICByZXR1cm4gZGlnZXN0XG59XG4iLCJ2YXIgcHJvdG9jb2wgPSByZXF1aXJlKCdoeXBlcmNvcmUtcHJvdG9jb2wnKVxudmFyIGJpdGZpZWxkID0gcmVxdWlyZSgnc3BhcnNlLWJpdGZpZWxkJylcbnZhciBzZXQgPSByZXF1aXJlKCd1bm9yZGVyZWQtc2V0JylcbnZhciBybGUgPSByZXF1aXJlKCdiaXRmaWVsZC1ybGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcGxpY2F0ZVxuXG5mdW5jdGlvbiByZXBsaWNhdGUgKGZlZWQsIG9wdHMpIHtcbiAgdmFyIHN0cmVhbSA9IG9wdHMuc3RyZWFtXG5cbiAgaWYgKCFzdHJlYW0pIHtcbiAgICBpZiAoIW9wdHMuZXhwZWN0ZWRGZWVkcykgb3B0cy5leHBlY3RlZEZlZWRzID0gMVxuICAgIGlmICghb3B0cy5pZCkgb3B0cy5pZCA9IGZlZWQuaWRcbiAgICBzdHJlYW0gPSBwcm90b2NvbChvcHRzKVxuICB9XG5cbiAgZmVlZC5yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIHN0cmVhbS5kZXN0cm95KGVycilcbiAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICB2YXIgcGVlciA9IG5ldyBQZWVyKGZlZWQsIG9wdHMpXG4gICAgcGVlci5mZWVkID0gZmVlZFxuICAgIHBlZXIuc3RyZWFtID0gc3RyZWFtLmZlZWQoZmVlZC5rZXksIHtwZWVyOiBwZWVyfSlcblxuICAgIHBlZXIucmVtb3RlSWQgPSBzdHJlYW0ucmVtb3RlSWRcbiAgICBzdHJlYW0uc2V0TWF4TGlzdGVuZXJzKDApXG4gICAgc3RyZWFtLm9uKCdoYW5kc2hha2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBwZWVyLnJlbW90ZUlkID0gc3RyZWFtLnJlbW90ZUlkXG4gICAgfSlcblxuICAgIC8vIHN0cmVhbSBtaWdodCBnZXQgZGVzdHJveWVkIG9uIGZlZWQgaW5pdCBpbiBjYXNlIG9mIGNvbmYgZXJyb3JzXG4gICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgcGVlci5yZWFkeSgpXG4gIH0pXG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5mdW5jdGlvbiBQZWVyIChmZWVkLCBvcHRzKSB7XG4gIHRoaXMuZmVlZCA9IGZlZWRcbiAgdGhpcy5zdHJlYW0gPSBudWxsIC8vIHNldCBieSByZXBsaWNhdGUganVzdCBhZnRlciBjcmVhdGlvblxuICB0aGlzLnJlbW90ZUlkID0gbnVsbFxuICB0aGlzLnJlbW90ZUJpdGZpZWxkID0gbnVsbFxuICB0aGlzLnJlbW90ZUxlbmd0aCA9IDBcbiAgdGhpcy5yZW1vdGVXYW50ID0gZmFsc2VcbiAgdGhpcy5saXZlID0gISFvcHRzLmxpdmVcbiAgdGhpcy5zcGFyc2UgPSBmZWVkLnNwYXJzZVxuXG4gIHRoaXMucmVtb3RlRG93bmxvYWRpbmcgPSB0cnVlXG4gIHRoaXMuZG93bmxvYWRpbmcgPSB0eXBlb2Ygb3B0cy5kb3dubG9hZCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5kb3dubG9hZCA6ICFmZWVkLndyaXRhYmxlXG4gIHRoaXMudXBsb2FkaW5nID0gdHJ1ZVxuXG4gIHRoaXMubWF4UmVxdWVzdHMgPSBvcHRzLm1heFJlcXVlc3RzIHx8IGZlZWQubWF4UmVxdWVzdHMgfHwgMTZcbiAgdGhpcy5pbmZsaWdodFJlcXVlc3RzID0gW11cblxuICB0aGlzLl9pbmRleCA9IC0xXG4gIHRoaXMuX2xhc3RCeXRlcyA9IDBcbiAgdGhpcy5fZmlyc3QgPSB0cnVlXG4gIHRoaXMuX2Nsb3NlZCA9IGZhbHNlXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG4gIHRoaXMuX2RlZmF1bHREb3dubG9hZGluZyA9IHRoaXMuZG93bmxvYWRpbmdcbn1cblxuUGVlci5wcm90b3R5cGUub253YW50ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUT0RPOiByZXBseSB0byB0aGUgYWN0dWFsIHdhbnQgY29udGV4dFxuICB0aGlzLnJlbW90ZVdhbnQgPSB0cnVlXG4gIHZhciBybGUgPSB0aGlzLmZlZWQuYml0ZmllbGQuY29tcHJlc3MoKVxuICB0aGlzLnN0cmVhbS5oYXZlKHtzdGFydDogMCwgYml0ZmllbGQ6IHJsZX0pXG59XG5cblBlZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIC8vIElnbm9yZSB1bnJlcXVlc3RlZCBtZXNzYWdlcyB1bmxlc3Mgd2UgYWxsb3cgcHVzaFxuICAvLyBUT0RPOiB3b3VsZCBiZSBiZXR0ZXIgdG8gY2hlY2sgaWYgdGhlIGJ5dGUgcmFuZ2Ugd2FzIHJlcXVlc3RlZCBpbnN0ZWFkLCBidXQgdGhpcyB3b3JrcyBmaW5lXG4gIHZhciBhbGxvd1B1c2ggPSB0aGlzLmZlZWQuYWxsb3dQdXNoIHx8ICFkYXRhLnZhbHVlXG4gIGlmICghYWxsb3dQdXNoICYmICF0aGlzLmZlZWQuX3Jlc2VydmVkLmdldChkYXRhLmluZGV4KSkge1xuICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlIHRoaXMgYmxvY2ssIHNlbmQgYmFjayB1bmhhdmUgbWVzc2FnZSBmb3IgdGhpcyBpbmRleCxcbiAgICAvLyB0byBsZXQgdGhlIHJlbW90ZSBrbm93IHdlIHJlamVjdGVkIGl0LlxuICAgIC8vIFRPRE86IHdlIG1pZ2h0IHdhbnQgdG8gaGF2ZSBzb21lIFwidW53YW50ZWQgcHVzaFwiIHRocmVzaG9sZCB0byBwdW5pc2ggc3BhbW1lcnNcbiAgICBpZiAoIXNlbGYuZmVlZC5iaXRmaWVsZC5nZXQoZGF0YS5pbmRleCkpIHNlbGYudW5oYXZlKHtzdGFydDogZGF0YS5pbmRleH0pXG4gICAgc2VsZi5fY2xlYXIoZGF0YS5pbmRleCwgIWRhdGEudmFsdWUpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmZlZWQuX3B1dEJ1ZmZlcihkYXRhLmluZGV4LCBkYXRhLnZhbHVlLCBkYXRhLCB0aGlzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZGVzdHJveShlcnIpXG4gICAgc2VsZi5fY2xlYXIoZGF0YS5pbmRleCwgIWRhdGEudmFsdWUpXG4gIH0pXG59XG5cblBlZXIucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uIChpbmRleCwgaGFzaCkge1xuICAvLyBUT0RPOiBvcHRpbWl6ZSBtZSAobm8gc3BsaWNlIGFuZCBkbyBub3QgcnVuIHRocm91Z2ggYWxsIC4uLilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5pbmZsaWdodFJlcXVlc3RzW2ldLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgdGhpcy5pbmZsaWdodFJlcXVlc3RzLnNwbGljZShpLCAxKVxuICAgICAgaS0tXG4gICAgfVxuICB9XG5cbiAgdGhpcy5mZWVkLl9yZXNlcnZlZC5zZXQoaW5kZXgsIGZhbHNlKVxuICAvLyBUT0RPOiBvbmx5IHVwZGF0ZSBhbGwgaWYgd2UgaGF2ZSBvdmVybGFwcGluZyBzZWxlY3Rpb25zXG4gIHRoaXMuZmVlZC5fdXBkYXRlUGVlcnMoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5vbnJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICBpZiAocmVxdWVzdC5ieXRlcykgcmV0dXJuIHRoaXMuX29uYnl0ZXMocmVxdWVzdClcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG9wdHMgPSB7ZGlnZXN0OiByZXF1ZXN0Lm5vZGVzLCBoYXNoOiByZXF1ZXN0Lmhhc2h9XG5cbiAgdGhpcy5mZWVkLnByb29mKHJlcXVlc3QuaW5kZXgsIG9wdHMsIG9ucHJvb2YpXG5cbiAgZnVuY3Rpb24gb25wcm9vZiAoZXJyLCBwcm9vZikge1xuICAgIGlmIChlcnIpIHJldHVybiBzZWxmLmRlc3Ryb3koZXJyKVxuICAgIGlmIChyZXF1ZXN0Lmhhc2gpIG9udmFsdWUobnVsbCwgbnVsbClcbiAgICBlbHNlIGlmIChzZWxmLmZlZWQuYml0ZmllbGQuZ2V0KHJlcXVlc3QuaW5kZXgpKSBzZWxmLmZlZWQuX2dldEJ1ZmZlcihyZXF1ZXN0LmluZGV4LCBvbnZhbHVlKVxuXG4gICAgZnVuY3Rpb24gb252YWx1ZSAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZGVzdHJveShlcnIpXG5cbiAgICAgIGlmICghc2VsZi5yZW1vdGVCaXRmaWVsZCkgc2VsZi5yZW1vdGVCaXRmaWVsZCA9IGJpdGZpZWxkKClcblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICghc2VsZi5yZW1vdGVCaXRmaWVsZC5zZXQocmVxdWVzdC5pbmRleCwgdHJ1ZSkpIHJldHVyblxuICAgICAgICBzZWxmLmZlZWQuZW1pdCgndXBsb2FkJywgcmVxdWVzdC5pbmRleCwgdmFsdWUsIHNlbGYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi5yZW1vdGVCaXRmaWVsZC5nZXQocmVxdWVzdC5pbmRleCkpIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdC5pbmRleCArIDEgPiBzZWxmLnJlbW90ZUxlbmd0aCkge1xuICAgICAgICBzZWxmLnJlbW90ZUxlbmd0aCA9IHJlcXVlc3QuaW5kZXggKyAxXG4gICAgICAgIHNlbGYuX3VwZGF0ZUVuZCgpXG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3RyZWFtLmRhdGEoe1xuICAgICAgICBpbmRleDogcmVxdWVzdC5pbmRleCxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBub2RlczogcHJvb2Yubm9kZXMsXG4gICAgICAgIHNpZ25hdHVyZTogcHJvb2Yuc2lnbmF0dXJlXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25ieXRlcyA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMuZmVlZC5zZWVrKHJlcXVlc3QuYnl0ZXMsIHt3YWl0OiBmYWxzZX0sIGZ1bmN0aW9uIChlcnIsIGluZGV4KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmVxdWVzdC5ieXRlcyA9IDBcbiAgICAgIHNlbGYub25yZXF1ZXN0KHJlcXVlc3QpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBxdWljayduJ2RpcnR5IGZpbHRlciBmb3IgcGFyYWxsZWwgYnl0ZXMgcmVxdWVzdHNcbiAgICAvLyBpdCBkb2VzIG5vdCBtYXR0ZXIgdGhhdCB0aGlzIGRvZXNuJ3QgY2F0Y2ggQUxMIHBhcmFsbGVsIHJlcXVlc3RzIC0ganVzdCBhIGJhbmR3aWR0aCBvcHRpbWl6YXRpb25cbiAgICBpZiAoc2VsZi5fbGFzdEJ5dGVzID09PSByZXF1ZXN0LmJ5dGVzKSByZXR1cm5cbiAgICBzZWxmLl9sYXN0Qnl0ZXMgPSByZXF1ZXN0LmJ5dGVzXG5cbiAgICByZXF1ZXN0LmJ5dGVzID0gMFxuICAgIHJlcXVlc3QuaW5kZXggPSBpbmRleFxuICAgIHJlcXVlc3Qubm9kZXMgPSAwXG5cbiAgICBzZWxmLm9ucmVxdWVzdChyZXF1ZXN0KVxuICB9KVxufVxuXG5QZWVyLnByb3RvdHlwZS5vbnRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdmFyIGZpcnN0ID0gdGhpcy5pbmZsaWdodFJlcXVlc3RzWzBdXG4gIGlmICgtLWZpcnN0LnRpY2spIHJldHVyblxuXG4gIGlmIChmaXJzdC5oYXNoID8gdGhpcy5mZWVkLnRyZWUuZ2V0KDIgKiBmaXJzdC5pbmRleCkgOiB0aGlzLmZlZWQuYml0ZmllbGQuZ2V0KGZpcnN0LmluZGV4KSkge1xuICAgIC8vIHByb2IgYSBieXRlcyByZXNwb25zZVxuICAgIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5zaGlmdCgpXG4gICAgdGhpcy5mZWVkLl9yZXNlcnZlZC5zZXQoZmlyc3QuaW5kZXgsIGZhbHNlKVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignUmVxdWVzdCB0aW1lb3V0JykpXG59XG5cblBlZXIucHJvdG90eXBlLm9uaGF2ZSA9IGZ1bmN0aW9uIChoYXZlKSB7XG4gIHZhciB1cGRhdGVkID0gdGhpcy5fZmlyc3RcbiAgaWYgKHRoaXMuX2ZpcnN0KSB0aGlzLl9maXJzdCA9IGZhbHNlXG5cbiAgaWYgKGhhdmUuYml0ZmllbGQpIHsgLy8gVE9ETzogaGFuZGxlIHN0YXJ0ICE9PSAwXG4gICAgdGhpcy5yZW1vdGVCaXRmaWVsZCA9IGJpdGZpZWxkKHJsZS5kZWNvZGUoaGF2ZS5iaXRmaWVsZCkpXG4gICAgaWYgKHRoaXMucmVtb3RlQml0ZmllbGQubGVuZ3RoID4gdGhpcy5yZW1vdGVMZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtb3RlTGVuZ3RoID0gdGhpcy5yZW1vdGVCaXRmaWVsZC5sZW5ndGhcbiAgICAgIHdoaWxlICh0aGlzLnJlbW90ZUxlbmd0aCAmJiAhdGhpcy5yZW1vdGVCaXRmaWVsZC5nZXQodGhpcy5yZW1vdGVMZW5ndGggLSAxKSkgdGhpcy5yZW1vdGVMZW5ndGgtLVxuICAgICAgdXBkYXRlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCF0aGlzLnJlbW90ZUJpdGZpZWxkKSB0aGlzLnJlbW90ZUJpdGZpZWxkID0gYml0ZmllbGQoKVxuICAgIC8vIFRPRE86IGlmIGxlbiA+IHNvbWV0aGluZyBzaW1wbHkgY29weSBhIDBiMTExMS4uLiBidWZmZXIgdG8gdGhlIGJpdGZpZWxkXG5cbiAgICB2YXIgc3RhcnQgPSBoYXZlLnN0YXJ0XG4gICAgdmFyIGxlbiA9IGhhdmUubGVuZ3RoIHx8IDFcblxuICAgIHdoaWxlIChsZW4tLSkgdGhpcy5yZW1vdGVCaXRmaWVsZC5zZXQoc3RhcnQrKywgdHJ1ZSlcbiAgICBpZiAoc3RhcnQgPiB0aGlzLnJlbW90ZUxlbmd0aCkge1xuICAgICAgdGhpcy5yZW1vdGVMZW5ndGggPSBzdGFydFxuICAgICAgdXBkYXRlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBpZiAodXBkYXRlZCkge1xuICAgIHRoaXMuZmVlZC5lbWl0KCdyZW1vdGUtdXBkYXRlJywgdGhpcylcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZUVuZCgpXG4gIHRoaXMudXBkYXRlKClcbn1cblxuUGVlci5wcm90b3R5cGUuX3VwZGF0ZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubGl2ZSB8fCB0aGlzLmZlZWQuc3BhcnNlIHx8ICF0aGlzLmZlZWQuX3NlbGVjdGlvbnMubGVuZ3RoKSByZXR1cm5cblxuICB2YXIgc2VsID0gdGhpcy5mZWVkLl9zZWxlY3Rpb25zWzBdXG4gIHZhciByZW1vdGVMZW5ndGggPSB0aGlzLmZlZWQubGVuZ3RoIHx8IC0xXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZlZWQucGVlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5mZWVkLnBlZXJzW2ldLnJlbW90ZUxlbmd0aCA+IHJlbW90ZUxlbmd0aCkge1xuICAgICAgcmVtb3RlTGVuZ3RoID0gdGhpcy5mZWVkLnBlZXJzW2ldLnJlbW90ZUxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHNlbC5lbmQgPSByZW1vdGVMZW5ndGhcbn1cblxuUGVlci5wcm90b3R5cGUub25pbmZvID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgdGhpcy5yZW1vdGVEb3dubG9hZGluZyA9IGluZm8uZG93bmxvYWRpbmdcbiAgaWYgKGluZm8uZG93bmxvYWRpbmcgfHwgdGhpcy5saXZlKSByZXR1cm5cbiAgdGhpcy51cGRhdGUoKVxuICBpZiAodGhpcy5mZWVkLl9zZWxlY3Rpb25zLmxlbmd0aCAmJiB0aGlzLmRvd25sb2FkaW5nKSByZXR1cm5cbiAgdGhpcy5lbmQoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5vbnVuaGF2ZSA9IGZ1bmN0aW9uICh1bmhhdmUpIHtcbiAgaWYgKCF0aGlzLnJlbW90ZUJpdGZpZWxkKSByZXR1cm5cblxuICB2YXIgc3RhcnQgPSB1bmhhdmUuc3RhcnRcbiAgdmFyIGxlbiA9IHVuaGF2ZS5sZW5ndGggfHwgMVxuXG4gIHdoaWxlIChsZW4tLSkgdGhpcy5yZW1vdGVCaXRmaWVsZC5zZXQoc3RhcnQrKywgZmFsc2UpXG59XG5cblBlZXIucHJvdG90eXBlLm9udW53YW50ID1cblBlZXIucHJvdG90eXBlLm9uY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAvLyBUT0RPOiBpbXBsIGFsbCBvZiBtZVxufVxuXG5QZWVyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRlc3Ryb3koKVxufVxuXG5QZWVyLnByb3RvdHlwZS5oYXZlID0gZnVuY3Rpb24gKGhhdmUpIHsgLy8gY2FsbGVkIGJ5IGZlZWRcbiAgaWYgKHRoaXMuc3RyZWFtICYmIHRoaXMucmVtb3RlV2FudCkgdGhpcy5zdHJlYW0uaGF2ZShoYXZlKVxufVxuXG5QZWVyLnByb3RvdHlwZS51bmhhdmUgPSBmdW5jdGlvbiAodW5oYXZlKSB7IC8vIGNhbGxlZCBieSBmZWVkXG4gIGlmICh0aGlzLnN0cmVhbSAmJiB0aGlzLnJlbW90ZVdhbnQpIHRoaXMuc3RyZWFtLnVuaGF2ZSh1bmhhdmUpXG59XG5cblBlZXIucHJvdG90eXBlLmhhdmVCeXRlcyA9IGZ1bmN0aW9uIChieXRlcykgeyAvLyBjYWxsZWQgYnkgZmVlZFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmluZmxpZ2h0UmVxdWVzdHNbaV0uYnl0ZXMgPT09IGJ5dGVzKSB7XG4gICAgICB0aGlzLmZlZWQuX3Jlc2VydmVkLnNldCh0aGlzLmluZmxpZ2h0UmVxdWVzdHNbaV0uaW5kZXgsIGZhbHNlKVxuICAgICAgdGhpcy5pbmZsaWdodFJlcXVlc3RzLnNwbGljZShpLCAxKVxuICAgICAgaS0tXG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGUoKVxufVxuXG5QZWVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGRvIG5vdGhpbmdcbiAgd2hpbGUgKHRoaXMuX3VwZGF0ZSgpKSB7fVxufVxuXG5QZWVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgcmV0dXJuIHRydWUgaWYgbXV0YXRlZCBmYWxzZSBpZiBub3RcbiAgaWYgKCF0aGlzLmRvd25sb2FkaW5nIHx8ICF0aGlzLnJlbW90ZUJpdGZpZWxkKSByZXR1cm4gZmFsc2VcblxuICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZmVlZC5fc2VsZWN0aW9uc1xuICB2YXIgd2FpdGluZyA9IHRoaXMuZmVlZC5fd2FpdGluZ1xuICB2YXIgd2xlbiA9IHdhaXRpbmcubGVuZ3RoXG4gIHZhciBzbGVuID0gc2VsZWN0aW9ucy5sZW5ndGhcbiAgdmFyIGluZmxpZ2h0ID0gdGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aFxuICB2YXIgb2Zmc2V0ID0gMFxuICB2YXIgaSA9IDBcblxuICAvLyBUT0RPOiBsZXNzIGR1cGxpY2F0ZSBjb2RlIGhlcmVcbiAgLy8gVE9ETzogcmUtYWRkIHByaW9yaXR5IGxldmVsc1xuXG4gIHdoaWxlIChpbmZsaWdodCA8IHRoaXMubWF4UmVxdWVzdHMpIHtcbiAgICBvZmZzZXQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB3YWl0aW5nLmxlbmd0aClcblxuICAgIGZvciAoaSA9IDA7IGkgPCB3YWl0aW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHdhaXRpbmdbb2Zmc2V0KytdXG4gICAgICBpZiAob2Zmc2V0ID09PSB3YWl0aW5nLmxlbmd0aCkgb2Zmc2V0ID0gMFxuXG4gICAgICB0aGlzLl9kb3dubG9hZFdhaXRpbmcodylcbiAgICAgIGlmICh3YWl0aW5nLmxlbmd0aCAhPT0gd2xlbikgcmV0dXJuIHRydWUgLy8gbXV0YXRlZFxuICAgICAgaWYgKHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGggPj0gdGhpcy5tYXhSZXF1ZXN0cykgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChpbmZsaWdodCA9PT0gdGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aCkgYnJlYWtcbiAgICBpbmZsaWdodCA9IHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGhcbiAgfVxuXG4gIHdoaWxlIChpbmZsaWdodCA8IHRoaXMubWF4UmVxdWVzdHMpIHtcbiAgICBvZmZzZXQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzZWxlY3Rpb25zLmxlbmd0aClcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcyA9IHNlbGVjdGlvbnNbb2Zmc2V0KytdXG4gICAgICBpZiAob2Zmc2V0ID09PSBzZWxlY3Rpb25zLmxlbmd0aCkgb2Zmc2V0ID0gMFxuXG4gICAgICBpZiAoIXMuaXRlcmF0b3IpIHMuaXRlcmF0b3IgPSB0aGlzLmZlZWQuYml0ZmllbGQuaXRlcmF0b3Iocy5zdGFydCwgcy5lbmQpXG4gICAgICB0aGlzLl9kb3dubG9hZFJhbmdlKHMpXG4gICAgICBpZiAoc2VsZWN0aW9ucy5sZW5ndGggIT09IHNsZW4pIHJldHVybiB0cnVlIC8vIG11dGF0ZWRcbiAgICAgIGlmICh0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoID49IHRoaXMubWF4UmVxdWVzdHMpIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChpbmZsaWdodCA9PT0gdGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgaW5mbGlnaHQgPSB0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuUGVlci5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gIHNldC5hZGQodGhpcy5mZWVkLnBlZXJzLCB0aGlzKVxuICB0aGlzLnN0cmVhbS53YW50KHtzdGFydDogMH0pIC8vIFRPRE86IGRvbid0IGp1c3Qgc3Vic2NyaWJlIHRvICpFVkVSWVRISU5HKiBoZWhlXG4gIHRoaXMuZmVlZC5lbWl0KCdwZWVyLWFkZCcsIHRoaXMpXG59XG5cblBlZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmRvd25sb2FkaW5nICYmICF0aGlzLnJlbW90ZURvd25sb2FkaW5nICYmICF0aGlzLmxpdmUpIHtcbiAgICBpZiAoIXRoaXMuX2RlZmF1bHREb3dubG9hZGluZykge1xuICAgICAgdGhpcy5zdHJlYW0uaW5mbyh7ZG93bmxvYWRpbmc6IGZhbHNlLCB1cGxvYWRpbmc6IGZhbHNlfSlcbiAgICB9XG4gICAgdGhpcy5fY2xvc2UoKVxuICAgIHJldHVyblxuICB9XG4gIGlmICghdGhpcy5fY2xvc2VkKSB7XG4gICAgdGhpcy5fY2xvc2VkID0gdHJ1ZVxuICAgIHRoaXMuZG93bmxvYWRpbmcgPSBmYWxzZVxuICAgIHRoaXMuc3RyZWFtLmluZm8oe2Rvd25sb2FkaW5nOiBmYWxzZSwgdXBsb2FkaW5nOiB0cnVlfSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXRoaXMubGl2ZSkgdGhpcy5fY2xvc2UoKVxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2luZGV4ID09PSAtMSkgcmV0dXJuXG4gIGlmICghdGhpcy5fZGVzdHJveWVkKSB7XG4gICAgdGhpcy5zdHJlYW0uY2xvc2UoKVxuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgfVxuICBzZXQucmVtb3ZlKHRoaXMuZmVlZC5wZWVycywgdGhpcylcbiAgdGhpcy5faW5kZXggPSAtMVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuZmVlZC5fcmVzZXJ2ZWQuc2V0KHRoaXMuaW5mbGlnaHRSZXF1ZXN0c1tpXS5pbmRleCwgZmFsc2UpXG4gIH1cbiAgdGhpcy5fdXBkYXRlRW5kKClcbiAgdGhpcy5yZW1vdGVXYW50ID0gZmFsc2VcbiAgdGhpcy5mZWVkLl91cGRhdGVQZWVycygpXG4gIHRoaXMuZmVlZC5lbWl0KCdwZWVyLXJlbW92ZScsIHRoaXMpXG59XG5cblBlZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICh0aGlzLl9pbmRleCA9PT0gLTEgfHwgdGhpcy5fZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5zdHJlYW0uZGVzdHJveShlcnIpXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgdGhpcy5fY2xvc2UoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fZG93bmxvYWRXYWl0aW5nID0gZnVuY3Rpb24gKHdhaXQpIHtcbiAgaWYgKCF3YWl0LmJ5dGVzKSB7XG4gICAgaWYgKCF0aGlzLnJlbW90ZUJpdGZpZWxkLmdldCh3YWl0LmluZGV4KSB8fCAhdGhpcy5mZWVkLl9yZXNlcnZlZC5zZXQod2FpdC5pbmRleCwgdHJ1ZSkpIHJldHVyblxuICAgIHRoaXMuX3JlcXVlc3Qod2FpdC5pbmRleCwgMCwgZmFsc2UpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLl9kb3dubG9hZFJhbmdlKHdhaXQpXG59XG5cblBlZXIucHJvdG90eXBlLl9kb3dubG9hZFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIGlmICghcmFuZ2UuaXRlcmF0b3IpIHJhbmdlLml0ZXJhdG9yID0gdGhpcy5mZWVkLmJpdGZpZWxkLml0ZXJhdG9yKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpXG5cbiAgdmFyIHJlc2VydmVkID0gdGhpcy5mZWVkLl9yZXNlcnZlZFxuICB2YXIgaXRlID0gcmFuZ2UuaXRlcmF0b3JcbiAgdmFyIHdhbnRlZEVuZCA9IE1hdGgubWluKHJhbmdlLmVuZCA9PT0gLTEgPyB0aGlzLnJlbW90ZUxlbmd0aCA6IHJhbmdlLmVuZCwgdGhpcy5yZW1vdGVMZW5ndGgpXG5cbiAgaWYgKGl0ZS5lbmQgIT09IHdhbnRlZEVuZCkgaXRlLnJhbmdlKHJhbmdlLnN0YXJ0LCB3YW50ZWRFbmQpXG5cbiAgdmFyIGkgPSByYW5nZS5saW5lYXIgPyBpdGUubmV4dCgpIDogaXRlLnJhbmRvbSgpXG4gIHZhciByZXNldCA9IGZhbHNlXG4gIHZhciBzdGFydCA9IGlcblxuICBpZiAoaSA9PT0gLTEpIHtcbiAgICBpZiAoIXJhbmdlLmJ5dGVzICYmIGl0ZS5zZWVrKDApLm5leHQoKSA9PT0gLTEgJiYgKHJhbmdlLmVuZCA+IC0xICYmIHRoaXMucmVtb3RlTGVuZ3RoID49IHJhbmdlLmVuZCkpIHtcbiAgICAgIHNldC5yZW1vdmUodGhpcy5mZWVkLl9zZWxlY3Rpb25zLCByYW5nZSlcbiAgICAgIHJhbmdlLmNhbGxiYWNrKG51bGwpXG4gICAgICBpZiAoIXRoaXMubGl2ZSAmJiAhdGhpcy5zcGFyc2UgJiYgIXRoaXMuZmVlZC5fc2VsZWN0aW9ucy5sZW5ndGgpIHRoaXMuZW5kKClcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICB3aGlsZSAoIXRoaXMucmVtb3RlQml0ZmllbGQuZ2V0KGkpIHx8IChyYW5nZS5oYXNoICYmIHRoaXMuZmVlZC50cmVlLmdldCgyICogaSkpIHx8ICFyZXNlcnZlZC5zZXQoaSwgdHJ1ZSkpIHtcbiAgICBpID0gaXRlLm5leHQoKVxuICAgIHJlc2V0ID0gdHJ1ZVxuXG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgLy8gY2hlY2sgdGhpcyBpbmRleFxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoIXJhbmdlLmxpbmVhciAmJiBzdGFydCAhPT0gMCkge1xuICAgICAgLy8gcmV0cnkgZnJvbSB0aGUgYmVnaW5uaW5nIHNpbmNlIHdlIGFyZSBpdGVyYXRpbmcgcmFuZG9tbHkgYW5kIHN0YXJ0ZWQgIT09IDBcbiAgICAgIGkgPSBpdGUuc2VlaygwKS5uZXh0KClcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyB3ZSBoYXZlIGNoZWNrZWQgYWxsIGluZGV4ZXMuXG4gICAgLy8gaWYgd2UgYXJlIGxvb2tpbmcgZm9yIGhhc2hlcyB3ZSBzaG91bGQgY2hlY2sgaWYgd2UgaGF2ZSBhbGwgbm93IChmaXJzdCBjaGVjayBvbmx5IGNoZWNrcyBibG9ja3MpXG4gICAgaWYgKHJhbmdlLmhhc2gpIHtcbiAgICAgIC8vIHF1aWNrJ24nZGlydHkgY2hlY2sgaWYgaGF2ZSBhbGwgaGFzaGVzIC0gY2FuIGJlIG9wdGltaXplZCBiZSBjaGVja2luZyBvbmx5IHRyZWUgcm9vdHNcbiAgICAgIC8vIGJ1dCB3ZSBkb24ndCByZWFsbHkgcmVxdWVzdCBsb25nIHJhbmdlcyBvZiBoYXNoZXMgc28geW9sb1xuICAgICAgZm9yICh2YXIgaiA9IHJhbmdlLnN0YXJ0OyBqIDwgd2FudGVkRW5kOyBqKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmZlZWQudHJlZS5nZXQoMiAqIGopKSByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICghcmFuZ2UuYnl0ZXMpIHtcbiAgICAgICAgc2V0LnJlbW92ZSh0aGlzLmZlZWQuX3NlbGVjdGlvbnMsIHJhbmdlKVxuICAgICAgICByYW5nZS5jYWxsYmFjayhudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4aXQgdGhlIHVwZGF0ZSBsb29wIC0gbm90aGluZyB0byBkb1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHJlc2V0KSBpdGUuc2VlaygwKVxuXG4gIHRoaXMuX3JlcXVlc3QoaSwgcmFuZ2UuYnl0ZXMgfHwgMCwgcmFuZ2UuaGFzaClcbn1cblxuUGVlci5wcm90b3R5cGUuX3JlcXVlc3QgPSBmdW5jdGlvbiAoaW5kZXgsIGJ5dGVzLCBoYXNoKSB7XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIHRpY2s6IDYsXG4gICAgYnl0ZXM6IGJ5dGVzLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBoYXNoOiBoYXNoLFxuICAgIG5vZGVzOiB0aGlzLmZlZWQuZGlnZXN0KGluZGV4KVxuICB9XG5cbiAgdGhpcy5pbmZsaWdodFJlcXVlc3RzLnB1c2gocmVxdWVzdClcbiAgdGhpcy5zdHJlYW0ucmVxdWVzdChyZXF1ZXN0KVxufVxuIiwidmFyIHVpbnQ2NGJlID0gcmVxdWlyZSgndWludDY0YmUnKVxudmFyIGZsYXQgPSByZXF1aXJlKCdmbGF0LXRyZWUnKVxudmFyIGFscnUgPSByZXF1aXJlKCdhcnJheS1scnUnKVxudmFyIGJ1ZmZlckFsbG9jID0gcmVxdWlyZSgnYnVmZmVyLWFsbG9jLXVuc2FmZScpXG5cbm1vZHVsZS5leHBvcnRzID0gU3RvcmFnZVxuXG52YXIgbm9hcnIgPSBbXVxuXG5mdW5jdGlvbiBTdG9yYWdlIChjcmVhdGUsIGNhY2hlU2l6ZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RvcmFnZSkpIHJldHVybiBuZXcgU3RvcmFnZShjcmVhdGUsIGNhY2hlU2l6ZSlcbiAgY2FjaGVTaXplID0gdHlwZW9mIGNhY2hlU2l6ZSA9PT0gJ3VuZGVmaW5lZCcgPyA2NTUzNiA6IGNhY2hlU2l6ZVxuXG4gIHRoaXMuY2FjaGUgPSBjYWNoZVNpemUgPiAwID8gYWxydShjYWNoZVNpemUsIHtpbmRleGVkVmFsdWVzOiB0cnVlfSkgOiBudWxsXG4gIHRoaXMua2V5ID0gbnVsbFxuICB0aGlzLnNlY3JldEtleSA9IG51bGxcbiAgdGhpcy50cmVlID0gbnVsbFxuICB0aGlzLmRhdGEgPSBudWxsXG4gIHRoaXMuYml0ZmllbGQgPSBudWxsXG4gIHRoaXMuc2lnbmF0dXJlcyA9IG51bGxcbiAgdGhpcy5jcmVhdGUgPSBjcmVhdGVcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUucHV0RGF0YSA9IGZ1bmN0aW9uIChpbmRleCwgZGF0YSwgbm9kZXMsIGNiKSB7XG4gIGlmICghY2IpIGNiID0gbm9vcFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuIGNiKG51bGwpXG4gIHRoaXMuZGF0YU9mZnNldChpbmRleCwgbm9kZXMsIGZ1bmN0aW9uIChlcnIsIG9mZnNldCwgc2l6ZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKHNpemUgIT09IGRhdGEubGVuZ3RoKSByZXR1cm4gY2IobmV3IEVycm9yKCdVbmV4cGVjdGVkIGRhdGEgc2l6ZScpKVxuICAgIHNlbGYuZGF0YS53cml0ZShvZmZzZXQsIGRhdGEsIGNiKVxuICB9KVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5kYXRhT2Zmc2V0KGluZGV4LCBub2FyciwgZnVuY3Rpb24gKGVyciwgb2Zmc2V0LCBzaXplKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBzZWxmLmRhdGEucmVhZChvZmZzZXQsIHNpemUsIGNiKVxuICB9KVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5uZXh0U2lnbmF0dXJlID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLl9nZXRTaWduYXR1cmUoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIHNpZ25hdHVyZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKGlzQmxhbmsoc2lnbmF0dXJlKSkgcmV0dXJuIHNlbGYubmV4dFNpZ25hdHVyZShpbmRleCArIDEsIGNiKVxuICAgIGNiKG51bGwsIHsgaW5kZXg6IGluZGV4LCBzaWduYXR1cmU6IHNpZ25hdHVyZSB9KVxuICB9KVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5nZXRTaWduYXR1cmUgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIHRoaXMuX2dldFNpZ25hdHVyZShpbmRleCwgZnVuY3Rpb24gKGVyciwgc2lnbmF0dXJlKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoaXNCbGFuayhzaWduYXR1cmUpKSByZXR1cm4gY2IobmV3IEVycm9yKCdObyBzaWduYXR1cmUgZm91bmQnKSlcbiAgICBjYihudWxsLCBzaWduYXR1cmUpXG4gIH0pXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLl9nZXRTaWduYXR1cmUgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIHRoaXMuc2lnbmF0dXJlcy5yZWFkKDMyICsgNjQgKiBpbmRleCwgNjQsIGNiKVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5wdXRTaWduYXR1cmUgPSBmdW5jdGlvbiAoaW5kZXgsIHNpZ25hdHVyZSwgY2IpIHtcbiAgdGhpcy5zaWduYXR1cmVzLndyaXRlKDMyICsgNjQgKiBpbmRleCwgc2lnbmF0dXJlLCBjYilcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUuZGF0YU9mZnNldCA9IGZ1bmN0aW9uIChpbmRleCwgY2FjaGVkTm9kZXMsIGNiKSB7XG4gIHZhciByb290cyA9IGZsYXQuZnVsbFJvb3RzKDIgKiBpbmRleClcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBvZmZzZXQgPSAwXG4gIHZhciBwZW5kaW5nID0gcm9vdHMubGVuZ3RoXG4gIHZhciBlcnJvciA9IG51bGxcbiAgdmFyIGJsayA9IDIgKiBpbmRleFxuXG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSAxXG4gICAgb25ub2RlKG51bGwsIG51bGwpXG4gICAgcmV0dXJuXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBmaW5kTm9kZShjYWNoZWROb2Rlcywgcm9vdHNbaV0pXG4gICAgaWYgKG5vZGUpIG9ubm9kZShudWxsLCBub2RlKVxuICAgIGVsc2UgdGhpcy5nZXROb2RlKHJvb3RzW2ldLCBvbm5vZGUpXG4gIH1cblxuICBmdW5jdGlvbiBvbmxhc3QgKGVyciwgbm9kZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY2IobnVsbCwgb2Zmc2V0LCBub2RlLnNpemUpXG4gIH1cblxuICBmdW5jdGlvbiBvbm5vZGUgKGVyciwgbm9kZSkge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKG5vZGUpIG9mZnNldCArPSBub2RlLnNpemVcbiAgICBpZiAoLS1wZW5kaW5nKSByZXR1cm5cblxuICAgIGlmIChlcnJvcikgcmV0dXJuIGNiKGVycm9yKVxuXG4gICAgdmFyIGxhc3QgPSBmaW5kTm9kZShjYWNoZWROb2RlcywgYmxrKVxuICAgIGlmIChsYXN0KSBvbmxhc3QobnVsbCwgbGFzdClcbiAgICBlbHNlIHNlbGYuZ2V0Tm9kZShibGssIG9ubGFzdClcbiAgfVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICBpZiAodGhpcy5jYWNoZSkge1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmNhY2hlLmdldChpbmRleClcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2IobnVsbCwgY2FjaGVkKVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy50cmVlLnJlYWQoMzIgKyA0MCAqIGluZGV4LCA0MCwgZnVuY3Rpb24gKGVyciwgYnVmKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIHZhciBoYXNoID0gYnVmLnNsaWNlKDAsIDMyKVxuICAgIHZhciBzaXplID0gdWludDY0YmUuZGVjb2RlKGJ1ZiwgMzIpXG5cbiAgICBpZiAoIXNpemUgJiYgaXNCbGFuayhoYXNoKSkgcmV0dXJuIGNiKG5ldyBFcnJvcignTm8gbm9kZSBmb3VuZCcpKVxuXG4gICAgdmFyIHZhbCA9IG5ldyBOb2RlKGluZGV4LCBoYXNoLCBzaXplLCBudWxsKVxuICAgIGlmIChzZWxmLmNhY2hlKSBzZWxmLmNhY2hlLnNldChpbmRleCwgdmFsKVxuICAgIGNiKG51bGwsIHZhbClcbiAgfSlcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUucHV0Tm9kZSA9IGZ1bmN0aW9uIChpbmRleCwgbm9kZSwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBub29wXG5cbiAgLy8gVE9ETzogcmUtZW5hYmxlIHB1dCBjYWNoZS4gY3VycmVudGx5IHRoaXMgY2F1c2VzIGEgbWVtbGVha1xuICAvLyBiZWNhdXNlIG5vZGUuaGFzaCBpcyBhIHNsaWNlIG9mIHRoZSBiaWcgZGF0YSBidWZmZXIgb24gcmVwbGljYXRlXG4gIC8vIGlmICh0aGlzLmNhY2hlKSB0aGlzLmNhY2hlLnNldChpbmRleCwgbm9kZSlcblxuICB2YXIgYnVmID0gYnVmZmVyQWxsb2MoNDApXG5cbiAgbm9kZS5oYXNoLmNvcHkoYnVmLCAwKVxuICB1aW50NjRiZS5lbmNvZGUobm9kZS5zaXplLCBidWYsIDMyKVxuICB0aGlzLnRyZWUud3JpdGUoMzIgKyA0MCAqIGluZGV4LCBidWYsIGNiKVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5wdXRCaXRmaWVsZCA9IGZ1bmN0aW9uIChvZmZzZXQsIGRhdGEsIGNiKSB7XG4gIHRoaXMuYml0ZmllbGQud3JpdGUoMzIgKyBvZmZzZXQsIGRhdGEsIGNiKVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgdmFyIG1pc3NpbmcgPSA2XG4gIHZhciBlcnJvciA9IG51bGxcblxuICBjbG9zZSh0aGlzLmJpdGZpZWxkLCBkb25lKVxuICBjbG9zZSh0aGlzLnRyZWUsIGRvbmUpXG4gIGNsb3NlKHRoaXMuZGF0YSwgZG9uZSlcbiAgY2xvc2UodGhpcy5rZXksIGRvbmUpXG4gIGNsb3NlKHRoaXMuc2VjcmV0S2V5LCBkb25lKVxuICBjbG9zZSh0aGlzLnNpZ25hdHVyZXMsIGRvbmUpXG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAoLS1taXNzaW5nKSByZXR1cm5cbiAgICBjYihlcnJvcilcbiAgfVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5vcGVuS2V5ID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMub3BlbktleSh7fSwgb3B0cylcbiAgaWYgKCF0aGlzLmtleSkgdGhpcy5rZXkgPSB0aGlzLmNyZWF0ZSgna2V5Jywgb3B0cylcbiAgdGhpcy5rZXkucmVhZCgwLCAzMiwgY2IpXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5vcGVuKHt9LCBvcHRzKVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgZXJyb3IgPSBudWxsXG4gIHZhciBtaXNzaW5nID0gNVxuXG4gIGlmICghdGhpcy5rZXkpIHRoaXMua2V5ID0gdGhpcy5jcmVhdGUoJ2tleScsIG9wdHMpXG4gIGlmICghdGhpcy5zZWNyZXRLZXkpIHRoaXMuc2VjcmV0S2V5ID0gdGhpcy5jcmVhdGUoJ3NlY3JldF9rZXknLCBvcHRzKVxuICBpZiAoIXRoaXMudHJlZSkgdGhpcy50cmVlID0gdGhpcy5jcmVhdGUoJ3RyZWUnLCBvcHRzKVxuICBpZiAoIXRoaXMuZGF0YSkgdGhpcy5kYXRhID0gdGhpcy5jcmVhdGUoJ2RhdGEnLCBvcHRzKVxuICBpZiAoIXRoaXMuYml0ZmllbGQpIHRoaXMuYml0ZmllbGQgPSB0aGlzLmNyZWF0ZSgnYml0ZmllbGQnLCBvcHRzKVxuICBpZiAoIXRoaXMuc2lnbmF0dXJlcykgdGhpcy5zaWduYXR1cmVzID0gdGhpcy5jcmVhdGUoJ3NpZ25hdHVyZXMnLCBvcHRzKVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgYml0ZmllbGQ6IGJ1ZmZlckFsbG9jKDApLFxuICAgIHNlY3JldEtleTogbnVsbCxcbiAgICBrZXk6IG51bGxcbiAgfVxuXG4gIHRoaXMuYml0ZmllbGQud3JpdGUoMCwgaGVhZGVyKDAsIDMzMjgsIG51bGwpLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZWFkQWxsKHNlbGYuYml0ZmllbGQsIDMyLCAzMzI4LCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZGF0YSkgcmVzdWx0LmJpdGZpZWxkID0gZGF0YVxuICAgICAgZG9uZShlcnIpXG4gICAgfSlcbiAgfSlcblxuICB0aGlzLnNpZ25hdHVyZXMud3JpdGUoMCwgaGVhZGVyKDEsIDY0LCAnRWQyNTUxOScpLCBkb25lKVxuICB0aGlzLnRyZWUud3JpdGUoMCwgaGVhZGVyKDIsIDQwLCAnQkxBS0UyYicpLCBkb25lKVxuXG4gIC8vIFRPRE86IEltcHJvdmUgdGhlIGVycm9yIGhhbmRsaW5nIGhlcmUuXG4gIC8vIEkuZS4gaWYgc2VjcmV0S2V5IGxlbmd0aCA9PT0gNjQgYW5kIGl0IGZhaWxzLCBlcnJvclxuXG4gIHRoaXMuc2VjcmV0S2V5LnJlYWQoMCwgNjQsIGZ1bmN0aW9uIChfLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHJlc3VsdC5zZWNyZXRLZXkgPSBkYXRhXG4gICAgZG9uZShudWxsKVxuICB9KVxuXG4gIHRoaXMua2V5LnJlYWQoMCwgMzIsIGZ1bmN0aW9uIChfLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHJlc3VsdC5rZXkgPSBkYXRhXG4gICAgZG9uZShudWxsKVxuICB9KVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKC0tbWlzc2luZykgcmV0dXJuXG4gICAgaWYgKGVycm9yKSBjYihlcnJvcilcbiAgICBlbHNlIGNiKG51bGwsIHJlc3VsdClcbiAgfVxufVxuXG5TdG9yYWdlLk5vZGUgPSBOb2RlXG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gaGVhZGVyICh0eXBlLCBzaXplLCBuYW1lKSB7XG4gIHZhciBidWYgPSBidWZmZXJBbGxvYygzMilcbiAgYnVmLmZpbGwoMClcblxuICAvLyBtYWdpYyBudW1iZXJcbiAgYnVmWzBdID0gNVxuICBidWZbMV0gPSAyXG4gIGJ1ZlsyXSA9IDg3XG4gIGJ1ZlszXSA9IHR5cGVcblxuICAvLyB2ZXJzaW9uXG4gIGJ1Zls0XSA9IDBcblxuICAvLyBibG9jayBzaXplXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKHNpemUsIDUpXG5cbiAgaWYgKG5hbWUpIHtcbiAgICAvLyBhbGdvIG5hbWVcbiAgICBidWZbN10gPSBuYW1lLmxlbmd0aFxuICAgIGJ1Zi53cml0ZShuYW1lLCA4KVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBOb2RlIChpbmRleCwgaGFzaCwgc2l6ZSkge1xuICB0aGlzLmluZGV4ID0gaW5kZXhcbiAgdGhpcy5oYXNoID0gaGFzaFxuICB0aGlzLnNpemUgPSBzaXplXG59XG5cbmZ1bmN0aW9uIGZpbmROb2RlIChub2RlcywgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5pbmRleCA9PT0gaW5kZXgpIHJldHVybiBub2Rlc1tpXVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIGlzQmxhbmsgKGJ1Zikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChidWZbaV0pIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNsb3NlIChzdCwgY2IpIHtcbiAgaWYgKHN0LmNsb3NlKSBzdC5jbG9zZShjYilcbiAgZWxzZSBjYigpXG59XG5cbmZ1bmN0aW9uIHN0YXRBbmRSZWFkQWxsIChzdCwgb2Zmc2V0LCBjYikge1xuICBzdC5zdGF0KGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IobnVsbCwgYnVmZmVyQWxsb2MoMCkpXG4gICAgc3QucmVhZChvZmZzZXQsIHN0YXQuc2l6ZSAtIG9mZnNldCwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRBbGwgKHN0LCBvZmZzZXQsIHBhZ2VTaXplLCBjYikge1xuICBpZiAodHlwZW9mIHN0Lmxlbmd0aCA9PT0gJ251bWJlcicgJiYgc3QubGVuZ3RoID4gLTEpIHJldHVybiBzdC5yZWFkKG9mZnNldCwgc3QubGVuZ3RoIC0gb2Zmc2V0LCBjYilcbiAgaWYgKHN0LnN0YXRhYmxlID09PSB0cnVlKSByZXR1cm4gc3RhdEFuZFJlYWRBbGwoc3QsIG9mZnNldCwgY2IpXG5cbiAgdmFyIGJ1ZnMgPSBbXVxuXG4gIHN0LnJlYWQob2Zmc2V0LCBwYWdlU2l6ZSwgbG9vcClcblxuICBmdW5jdGlvbiBsb29wIChlcnIsIGJ1Zikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihudWxsLCBCdWZmZXIuY29uY2F0KGJ1ZnMpKVxuICAgIGJ1ZnMucHVzaChidWYpXG4gICAgc3QucmVhZChvZmZzZXQgKyBidWZzLmxlbmd0aCAqIHBhZ2VTaXplLCBwYWdlU2l6ZSwgbG9vcClcbiAgfVxufVxuIiwidmFyIGZsYXQgPSByZXF1aXJlKCdmbGF0LXRyZWUnKVxudmFyIGJpdGZpZWxkID0gcmVxdWlyZSgnc3BhcnNlLWJpdGZpZWxkJylcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlSW5kZXhcblxuZnVuY3Rpb24gVHJlZUluZGV4IChiaXRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmVlSW5kZXgpKSByZXR1cm4gbmV3IFRyZWVJbmRleChiaXRzKVxuICB0aGlzLmJpdGZpZWxkID0gYml0cyB8fCBiaXRmaWVsZCgpXG59XG5cblRyZWVJbmRleC5wcm90b3R5cGUucHJvb2YgPSBmdW5jdGlvbiAoaW5kZXgsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICB2YXIgbm9kZXMgPSBbXVxuICB2YXIgcmVtb3RlVHJlZSA9IG9wdHMudHJlZSB8fCBuZXcgVHJlZUluZGV4KClcbiAgdmFyIGRpZ2VzdCA9IG9wdHMuZGlnZXN0IHx8IDBcblxuICBpZiAoIXRoaXMuZ2V0KGluZGV4KSkgcmV0dXJuIG51bGxcbiAgaWYgKG9wdHMuaGFzaCkgbm9kZXMucHVzaChpbmRleCkgLy8gYWx3YXlzIHJldHVybiBoYXNoIC0gbm8gbWF0dGVyIHdoYXQgdGhlIGRpZ2VzdCBzYXlzXG4gIGlmIChkaWdlc3QgPT09IDEpIHJldHVybiB7bm9kZXM6IG5vZGVzLCB2ZXJpZmllZEJ5OiAwfVxuXG4gIHZhciByb290cyA9IG51bGxcbiAgdmFyIHNpYmxpbmcgPSBpbmRleFxuICB2YXIgbmV4dCA9IGluZGV4XG4gIHZhciBoYXNSb290ID0gZGlnZXN0ICYgMVxuICBkaWdlc3QgPSByaWdodFNoaWZ0KGRpZ2VzdClcblxuICB3aGlsZSAoZGlnZXN0KSB7XG4gICAgaWYgKGRpZ2VzdCA9PT0gMSAmJiBoYXNSb290KSB7XG4gICAgICBpZiAodGhpcy5nZXQobmV4dCkpIHJlbW90ZVRyZWUuc2V0KG5leHQpXG5cbiAgICAgIC8vIGhhdmluZyBhIHJvb3QgaW1wbGllcyBoYXZpbmcgcHJldiByb290cyBhcyB3ZWxsXG4gICAgICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBvcHRpbWl6ZWQgYXdheSBiZSBvbmx5IHNlbmRpbmcgXCJuZXdlclwiIHJvb3RzLFxuICAgICAgLy8gd2hlbiBzZW5kaW5nIHJvb3RzXG4gICAgICBpZiAoZmxhdC5zaWJsaW5nKG5leHQpIDwgbmV4dCkgbmV4dCA9IGZsYXQuc2libGluZyhuZXh0KVxuICAgICAgcm9vdHMgPSBmbGF0LmZ1bGxSb290cyhmbGF0LnJpZ2h0U3BhbihuZXh0KSArIDIpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmdldChyb290c1tpXSkpIHJlbW90ZVRyZWUuc2V0KHJvb3RzW2ldKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBzaWJsaW5nID0gZmxhdC5zaWJsaW5nKG5leHQpXG4gICAgaWYgKGRpZ2VzdCAmIDEpIHtcbiAgICAgIGlmICh0aGlzLmdldChzaWJsaW5nKSkgcmVtb3RlVHJlZS5zZXQoc2libGluZylcbiAgICB9XG4gICAgbmV4dCA9IGZsYXQucGFyZW50KG5leHQpXG4gICAgZGlnZXN0ID0gcmlnaHRTaGlmdChkaWdlc3QpXG4gIH1cblxuICBuZXh0ID0gaW5kZXhcblxuICB3aGlsZSAoIXJlbW90ZVRyZWUuZ2V0KG5leHQpKSB7XG4gICAgc2libGluZyA9IGZsYXQuc2libGluZyhuZXh0KVxuICAgIGlmICghdGhpcy5nZXQoc2libGluZykpIHtcbiAgICAgIC8vIG5leHQgaXMgYSBsb2NhbCByb290XG4gICAgICB2YXIgdmVyaWZpZWRCeSA9IHRoaXMudmVyaWZpZWRCeShuZXh0KVxuICAgICAgYWRkRnVsbFJvb3RzKHZlcmlmaWVkQnksIG5vZGVzLCBuZXh0LCByZW1vdGVUcmVlKVxuICAgICAgcmV0dXJuIHtub2Rlczogbm9kZXMsIHZlcmlmaWVkQnk6IHZlcmlmaWVkQnl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmVtb3RlVHJlZS5nZXQoc2libGluZykpIG5vZGVzLnB1c2goc2libGluZylcbiAgICB9XG5cbiAgICBuZXh0ID0gZmxhdC5wYXJlbnQobmV4dClcbiAgfVxuXG4gIHJldHVybiB7bm9kZXM6IG5vZGVzLCB2ZXJpZmllZEJ5OiAwfVxufVxuXG5UcmVlSW5kZXgucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICBpZiAodGhpcy5nZXQoaW5kZXgpKSByZXR1cm4gMVxuXG4gIHZhciBkaWdlc3QgPSAwXG4gIHZhciBuZXh0ID0gZmxhdC5zaWJsaW5nKGluZGV4KVxuICB2YXIgbWF4ID0gTWF0aC5tYXgobmV4dCArIDIsIHRoaXMuYml0ZmllbGQubGVuZ3RoKSAvLyBUT0RPOiBtYWtlIHRoaXMgbGVzcyAuLi4gaGFja3lcblxuICB2YXIgYml0ID0gMlxuICB2YXIgZGVwdGggPSBmbGF0LmRlcHRoKGluZGV4KVxuICB2YXIgcGFyZW50ID0gZmxhdC5wYXJlbnQobmV4dCwgZGVwdGgrKylcblxuICB3aGlsZSAoZmxhdC5yaWdodFNwYW4obmV4dCkgPCBtYXggfHwgZmxhdC5sZWZ0U3BhbihwYXJlbnQpID4gMCkge1xuICAgIGlmICh0aGlzLmdldChuZXh0KSkge1xuICAgICAgZGlnZXN0IHw9IGJpdFxuICAgIH1cbiAgICBpZiAodGhpcy5nZXQocGFyZW50KSkge1xuICAgICAgZGlnZXN0IHw9ICgyICogYml0ICsgMSlcbiAgICAgIGlmIChkaWdlc3QgKyAxID09PSA0ICogYml0KSByZXR1cm4gMVxuICAgICAgcmV0dXJuIGRpZ2VzdFxuICAgIH1cbiAgICBuZXh0ID0gZmxhdC5zaWJsaW5nKHBhcmVudClcbiAgICBwYXJlbnQgPSBmbGF0LnBhcmVudChuZXh0LCBkZXB0aCsrKVxuICAgIGJpdCAqPSAyXG4gIH1cblxuICByZXR1cm4gZGlnZXN0XG59XG5cblRyZWVJbmRleC5wcm90b3R5cGUuYmxvY2tzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9wID0gMFxuICB2YXIgbmV4dCA9IDBcbiAgdmFyIG1heCA9IHRoaXMuYml0ZmllbGQubGVuZ3RoXG5cbiAgd2hpbGUgKGZsYXQucmlnaHRTcGFuKG5leHQpIDwgbWF4KSB7XG4gICAgbmV4dCA9IGZsYXQucGFyZW50KG5leHQpXG4gICAgaWYgKHRoaXMuZ2V0KG5leHQpKSB0b3AgPSBuZXh0XG4gIH1cblxuICByZXR1cm4gKHRoaXMuZ2V0KHRvcCkgPyB0aGlzLnZlcmlmaWVkQnkodG9wKSA6IDApIC8gMlxufVxuXG5UcmVlSW5kZXgucHJvdG90eXBlLnJvb3RzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZmxhdC5mdWxsUm9vdHMoMiAqIHRoaXMuYmxvY2tzKCkpXG59XG5cblRyZWVJbmRleC5wcm90b3R5cGUudmVyaWZpZWRCeSA9IGZ1bmN0aW9uIChpbmRleCwgbm9kZXMpIHtcbiAgdmFyIGhhc0luZGV4ID0gdGhpcy5nZXQoaW5kZXgpXG4gIGlmICghaGFzSW5kZXgpIHJldHVybiAwXG5cbiAgLy8gZmluZCByb290IG9mIGN1cnJlbnQgdHJlZVxuXG4gIHZhciBkZXB0aCA9IGZsYXQuZGVwdGgoaW5kZXgpXG4gIHZhciB0b3AgPSBpbmRleFxuICB2YXIgcGFyZW50ID0gZmxhdC5wYXJlbnQodG9wLCBkZXB0aCsrKVxuICB3aGlsZSAodGhpcy5nZXQocGFyZW50KSAmJiB0aGlzLmdldChmbGF0LnNpYmxpbmcodG9wKSkpIHtcbiAgICB0b3AgPSBwYXJlbnRcbiAgICBwYXJlbnQgPSBmbGF0LnBhcmVudCh0b3AsIGRlcHRoKyspXG4gIH1cblxuICAvLyBleHBhbmQgcmlnaHQgZG93blxuXG4gIGRlcHRoLS1cbiAgd2hpbGUgKGRlcHRoKSB7XG4gICAgdG9wID0gZmxhdC5sZWZ0Q2hpbGQoZmxhdC5pbmRleChkZXB0aCwgZmxhdC5vZmZzZXQodG9wLCBkZXB0aCkgKyAxKSwgZGVwdGgpXG4gICAgZGVwdGgtLVxuXG4gICAgd2hpbGUgKCF0aGlzLmdldCh0b3ApICYmIGRlcHRoKSB0b3AgPSBmbGF0LmxlZnRDaGlsZCh0b3AsIGRlcHRoLS0pXG4gICAgaWYgKG5vZGVzICYmIHRoaXMuZ2V0KHRvcCkpIG5vZGVzLnB1c2godG9wKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZ2V0KHRvcCkgPyB0b3AgKyAyIDogdG9wXG59XG5cblRyZWVJbmRleC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHJldHVybiB0aGlzLmJpdGZpZWxkLmdldChpbmRleClcbn1cblxuVHJlZUluZGV4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgaWYgKCF0aGlzLmJpdGZpZWxkLnNldChpbmRleCwgdHJ1ZSkpIHJldHVybiBmYWxzZVxuICB3aGlsZSAodGhpcy5iaXRmaWVsZC5nZXQoZmxhdC5zaWJsaW5nKGluZGV4KSkpIHtcbiAgICBpbmRleCA9IGZsYXQucGFyZW50KGluZGV4KVxuICAgIGlmICghdGhpcy5iaXRmaWVsZC5zZXQoaW5kZXgsIHRydWUpKSBicmVha1xuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHJpZ2h0U2hpZnQgKG4pIHtcbiAgcmV0dXJuIChuIC0gKG4gJiAxKSkgLyAyXG59XG5cbmZ1bmN0aW9uIGFkZEZ1bGxSb290cyAodmVyaWZpZWRCeSwgbm9kZXMsIHJvb3QsIHJlbW90ZVRyZWUpIHtcbiAgdmFyIHJvb3RzID0gZmxhdC5mdWxsUm9vdHModmVyaWZpZWRCeSlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyb290c1tpXSAhPT0gcm9vdCAmJiAhcmVtb3RlVHJlZS5nZXQocm9vdHNbaV0pKSBub2Rlcy5wdXNoKHJvb3RzW2ldKVxuICB9XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAod29yaykge1xuICB2YXIgcGVuZGluZyA9IG51bGxcbiAgdmFyIGNhbGxiYWNrID0gbnVsbFxuICB2YXIgY2FsbGJhY2tzID0gbnVsbFxuICB2YXIgbmV4dCA9IG51bGxcblxuICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgY2IpIHtcbiAgICBuZXh0ID0gdmFsXG4gICAgdXBkYXRlKGNiIHx8IG5vb3ApXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUgKGNiKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXBlbmRpbmcpIHBlbmRpbmcgPSBbXVxuICAgICAgcGVuZGluZy5wdXNoKGNiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHZhbCA9IG5leHRcbiAgICBuZXh0ID0gbnVsbFxuICAgIGNhbGxiYWNrID0gY2JcbiAgICB3b3JrKHZhbCwgZG9uZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgIHZhciBjYiA9IGNhbGxiYWNrXG4gICAgdmFyIGNicyA9IGNhbGxiYWNrc1xuICAgIGNhbGxiYWNrcyA9IG51bGxcbiAgICBjYWxsYmFjayA9IG51bGxcblxuICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICBjYWxsYmFja3MgPSBwZW5kaW5nXG4gICAgICBwZW5kaW5nID0gbnVsbFxuICAgICAgdXBkYXRlKG5vb3ApXG4gICAgfVxuXG4gICAgaWYgKGNicykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIGNic1tpXShlcnIpXG4gICAgfVxuICAgIGNiKGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBub29wIChfKSB7fVxuIiwibW9kdWxlLmV4cG9ydHMgPSBQYWdlclxuXG5mdW5jdGlvbiBQYWdlciAocGFnZVNpemUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhZ2VyKSkgcmV0dXJuIG5ldyBQYWdlcihwYWdlU2l6ZSlcblxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy51cGRhdGVzID0gW11cbiAgdGhpcy5wYWdlcyA9IG5ldyBBcnJheSgxNilcbiAgdGhpcy5wYWdlU2l6ZSA9IHBhZ2VTaXplIHx8IDEwMjRcbn1cblxuUGFnZXIucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAocGFnZSkge1xuICBpZiAocGFnZS51cGRhdGVkIHx8ICF0aGlzLnVwZGF0ZXMpIHJldHVyblxuICBwYWdlLnVwZGF0ZWQgPSB0cnVlXG4gIHRoaXMudXBkYXRlcy5wdXNoKHBhZ2UpXG59XG5cblBhZ2VyLnByb3RvdHlwZS5sYXN0VXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudXBkYXRlcyB8fCAhdGhpcy51cGRhdGVzLmxlbmd0aCkgcmV0dXJuIG51bGxcbiAgdmFyIHBhZ2UgPSB0aGlzLnVwZGF0ZXMucG9wKClcbiAgcGFnZS51cGRhdGVkID0gZmFsc2VcbiAgcmV0dXJuIHBhZ2Vcbn1cblxuUGFnZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpLCBub0FsbG9jYXRlKSB7XG4gIGlmIChpID49IHRoaXMucGFnZXMubGVuZ3RoKSB7XG4gICAgaWYgKG5vQWxsb2NhdGUpIHJldHVyblxuICAgIHRoaXMucGFnZXMgPSBncm93KHRoaXMucGFnZXMsIGksIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzW2ldXG5cbiAgaWYgKCFwYWdlICYmICFub0FsbG9jYXRlKSB7XG4gICAgcGFnZSA9IHRoaXMucGFnZXNbaV0gPSBuZXcgUGFnZShpLCBhbGxvYyh0aGlzLnBhZ2VTaXplKSlcbiAgICBpZiAoaSA+PSB0aGlzLmxlbmd0aCkgdGhpcy5sZW5ndGggPSBpICsgMVxuICB9XG5cbiAgcmV0dXJuIHBhZ2Vcbn1cblxuUGFnZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpLCBidWYpIHtcbiAgaWYgKGkgPj0gdGhpcy5wYWdlcy5sZW5ndGgpIHRoaXMucGFnZXMgPSBncm93KHRoaXMucGFnZXMsIGksIHRoaXMubGVuZ3RoKVxuICBpZiAoaSA+PSB0aGlzLmxlbmd0aCkgdGhpcy5sZW5ndGggPSBpICsgMVxuXG4gIGlmICghYnVmKSB7XG4gICAgdGhpcy5wYWdlc1tpXSA9IHVuZGVmaW5lZFxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzW2ldXG4gIHZhciBiID0gdHJ1bmNhdGUoYnVmLCB0aGlzLnBhZ2VTaXplKVxuXG4gIGlmIChwYWdlKSBwYWdlLmJ1ZmZlciA9IGJcbiAgZWxzZSB0aGlzLnBhZ2VzW2ldID0gbmV3IFBhZ2UoaSwgYilcbn1cblxuUGFnZXIucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGlzdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgdmFyIGVtcHR5ID0gYWxsb2ModGhpcy5wYWdlU2l6ZSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0W2ldID0gdGhpcy5wYWdlc1tpXSA/IHRoaXMucGFnZXNbaV0uYnVmZmVyIDogZW1wdHlcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGxpc3QpXG59XG5cbmZ1bmN0aW9uIGdyb3cgKGxpc3QsIGluZGV4LCBsZW4pIHtcbiAgdmFyIG5sZW4gPSBsaXN0Lmxlbmd0aCAqIDJcbiAgd2hpbGUgKG5sZW4gPD0gaW5kZXgpIG5sZW4gKj0gMlxuXG4gIHZhciB0d2ljZSA9IG5ldyBBcnJheShubGVuKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB0d2ljZVtpXSA9IGxpc3RbaV1cbiAgcmV0dXJuIHR3aWNlXG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlIChidWYsIGxlbikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gbGVuKSByZXR1cm4gYnVmXG4gIGlmIChidWYubGVuZ3RoID4gbGVuKSByZXR1cm4gYnVmLnNsaWNlKDAsIGxlbilcbiAgdmFyIGNweSA9IGFsbG9jKGxlbilcbiAgYnVmLmNvcHkoY3B5KVxuICByZXR1cm4gY3B5XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplKSB7XG4gIGlmIChCdWZmZXIuYWxsb2MpIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSlcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSlcbiAgYnVmLmZpbGwoMClcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBQYWdlIChpLCBidWYpIHtcbiAgdGhpcy5vZmZzZXQgPSBpICogYnVmLmxlbmd0aFxuICB0aGlzLmJ1ZmZlciA9IGJ1ZlxuICB0aGlzLnVwZGF0ZWQgPSBmYWxzZVxufVxuIiwiLy8gYSBtb3JlIGxvdyBsZXZlbCBpbnRlcmZhY2UgdG8gdGhlIG1lcmtsZSB0cmVlIHN0cmVhbS5cbi8vIHVzZWZ1bCBmb3IgY2VydGFpbiBhcHBsaWNhdGlvbnMgdGhlIHJlcXVpcmUgbm9uLXN0cmVhbXkgYWNjZXNzIHRvIHRoZSBhbGdvcy5cbi8vIHZlcnNpb25lZCBieSB0aGUgc2FtZSBzZW12ZXIgYXMgdGhlIHN0cmVhbSBpbnRlcmZhY2UuXG5cbnZhciBmbGF0ID0gcmVxdWlyZSgnZmxhdC10cmVlJylcblxubW9kdWxlLmV4cG9ydHMgPSBNZXJrbGVHZW5lcmF0b3JcblxuZnVuY3Rpb24gTWVya2xlR2VuZXJhdG9yIChvcHRzLCByb290cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWVya2xlR2VuZXJhdG9yKSkgcmV0dXJuIG5ldyBNZXJrbGVHZW5lcmF0b3Iob3B0cywgcm9vdHMpXG4gIGlmICghb3B0cyB8fCAhb3B0cy5sZWFmIHx8ICFvcHRzLnBhcmVudCkgdGhyb3cgbmV3IEVycm9yKCdvcHRzLmxlYWYgYW5kIG9wdHMucGFyZW50IHJlcXVpcmVkJylcblxuICB0aGlzLnJvb3RzID0gcm9vdHMgfHwgb3B0cy5yb290cyB8fCBbXVxuICB0aGlzLmJsb2NrcyA9IHRoaXMucm9vdHMubGVuZ3RoID8gMSArIGZsYXQucmlnaHRTcGFuKHRoaXMucm9vdHNbdGhpcy5yb290cy5sZW5ndGggLSAxXS5pbmRleCkgLyAyIDogMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb290cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByID0gdGhpcy5yb290c1tpXVxuICAgIGlmIChyICYmICFyLnBhcmVudCkgci5wYXJlbnQgPSBmbGF0LnBhcmVudChyLmluZGV4KVxuICB9XG5cbiAgdGhpcy5fbGVhZiA9IG9wdHMubGVhZlxuICB0aGlzLl9wYXJlbnQgPSBvcHRzLnBhcmVudFxufVxuXG5NZXJrbGVHZW5lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoZGF0YSwgbm9kZXMpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEpXG4gIGlmICghbm9kZXMpIG5vZGVzID0gW11cblxuICB2YXIgaW5kZXggPSAyICogdGhpcy5ibG9ja3MrK1xuXG4gIHZhciBsZWFmID0ge1xuICAgIGluZGV4OiBpbmRleCxcbiAgICBwYXJlbnQ6IGZsYXQucGFyZW50KGluZGV4KSxcbiAgICBoYXNoOiBudWxsLFxuICAgIHNpemU6IGRhdGEubGVuZ3RoLFxuICAgIGRhdGE6IGRhdGFcbiAgfVxuXG4gIGxlYWYuaGFzaCA9IHRoaXMuX2xlYWYobGVhZiwgdGhpcy5yb290cylcbiAgdGhpcy5yb290cy5wdXNoKGxlYWYpXG4gIG5vZGVzLnB1c2gobGVhZilcblxuICB3aGlsZSAodGhpcy5yb290cy5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGxlZnQgPSB0aGlzLnJvb3RzW3RoaXMucm9vdHMubGVuZ3RoIC0gMl1cbiAgICB2YXIgcmlnaHQgPSB0aGlzLnJvb3RzW3RoaXMucm9vdHMubGVuZ3RoIC0gMV1cblxuICAgIGlmIChsZWZ0LnBhcmVudCAhPT0gcmlnaHQucGFyZW50KSBicmVha1xuXG4gICAgdGhpcy5yb290cy5wb3AoKVxuICAgIHRoaXMucm9vdHNbdGhpcy5yb290cy5sZW5ndGggLSAxXSA9IGxlYWYgPSB7XG4gICAgICBpbmRleDogbGVmdC5wYXJlbnQsXG4gICAgICBwYXJlbnQ6IGZsYXQucGFyZW50KGxlZnQucGFyZW50KSxcbiAgICAgIGhhc2g6IHRoaXMuX3BhcmVudChsZWZ0LCByaWdodCksXG4gICAgICBzaXplOiBsZWZ0LnNpemUgKyByaWdodC5zaXplLFxuICAgICAgZGF0YTogbnVsbFxuICAgIH1cbiAgICBub2Rlcy5wdXNoKGxlYWYpXG4gIH1cblxuICByZXR1cm4gbm9kZXNcbn1cbiIsImFzc2VydC5ub3RFcXVhbCA9IG5vdEVxdWFsXG5hc3NlcnQubm90T2sgPSBub3RPa1xuYXNzZXJ0LmVxdWFsID0gZXF1YWxcbmFzc2VydC5vayA9IGFzc2VydFxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydFxuXG5mdW5jdGlvbiBlcXVhbCAoYSwgYiwgbSkge1xuICBhc3NlcnQoYSA9PSBiLCBtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufVxuXG5mdW5jdGlvbiBub3RFcXVhbCAoYSwgYiwgbSkge1xuICBhc3NlcnQoYSAhPSBiLCBtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufVxuXG5mdW5jdGlvbiBub3RPayAodCwgbSkge1xuICBhc3NlcnQoIXQsIG0pXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodCwgbSkge1xuICBpZiAoIXQpIHRocm93IG5ldyBFcnJvcihtIHx8ICdBc3NlcnRpb25FcnJvcicpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbnZhciBzdmFyaW50ID0gcmVxdWlyZSgnc2lnbmVkLXZhcmludCcpXG5cbmV4cG9ydHMubWFrZSA9IGVuY29kZXJcblxuZXhwb3J0cy5uYW1lID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChleHBvcnRzW2tleXNbaV1dID09PSBlbmMpIHJldHVybiBrZXlzW2ldXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0cy5za2lwID0gZnVuY3Rpb24gKHR5cGUsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHZhcmludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpXG4gICAgICByZXR1cm4gb2Zmc2V0ICsgdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIG9mZnNldCArIDhcblxuICAgIGNhc2UgMjpcbiAgICAgIHZhciBsZW4gPSB2YXJpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KVxuICAgICAgcmV0dXJuIG9mZnNldCArIHZhcmludC5kZWNvZGUuYnl0ZXMgKyBsZW5cblxuICAgIGNhc2UgMzpcbiAgICBjYXNlIDQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dyb3VwcyBhcmUgbm90IHN1cHBvcnRlZCcpXG5cbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNFxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHdpcmUgdHlwZTogJyArIHR5cGUpXG59XG5cbmV4cG9ydHMuYnl0ZXMgPSBlbmNvZGVyKDIsXG4gIGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgbGVuID0gYnVmZmVyTGVuZ3RoKHZhbClcblxuICAgIHZhcmludC5lbmNvZGUobGVuLCBidWZmZXIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB2YWwuY29weShidWZmZXIsIG9mZnNldClcbiAgICBlbHNlIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgbGVuKVxuICAgIG9mZnNldCArPSBsZW5cblxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZmZXJcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICAgIHZhciBsZW4gPSB2YXJpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG5cbiAgICB2YXIgdmFsID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKVxuICAgIG9mZnNldCArPSB2YWwubGVuZ3RoXG5cbiAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoICh2YWwpIHtcbiAgICB2YXIgbGVuID0gYnVmZmVyTGVuZ3RoKHZhbClcbiAgICByZXR1cm4gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGxlbikgKyBsZW5cbiAgfVxuKVxuXG5leHBvcnRzLnN0cmluZyA9IGVuY29kZXIoMixcbiAgZnVuY3Rpb24gZW5jb2RlICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpXG5cbiAgICB2YXJpbnQuZW5jb2RlKGxlbiwgYnVmZmVyLCBvZmZzZXQsICd1dGYtOCcpXG4gICAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcblxuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgbGVuKVxuICAgIG9mZnNldCArPSBsZW5cblxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZmZXJcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICAgIHZhciBsZW4gPSB2YXJpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG5cbiAgICB2YXIgdmFsID0gYnVmZmVyLnRvU3RyaW5nKCd1dGYtOCcsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKVxuICAgIG9mZnNldCArPSBsZW5cblxuICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiB2YWxcbiAgfSxcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKHZhbCkge1xuICAgIHZhciBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpXG4gICAgcmV0dXJuIHZhcmludC5lbmNvZGluZ0xlbmd0aChsZW4pICsgbGVuXG4gIH1cbilcblxuZXhwb3J0cy5ib29sID0gZW5jb2RlcigwLFxuICBmdW5jdGlvbiBlbmNvZGUgKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbCA/IDEgOiAwXG4gICAgZW5jb2RlLmJ5dGVzID0gMVxuICAgIHJldHVybiBidWZmZXJcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciBib29sID0gYnVmZmVyW29mZnNldF0gPiAwXG4gICAgZGVjb2RlLmJ5dGVzID0gMVxuICAgIHJldHVybiBib29sXG4gIH0sXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG4pXG5cbmV4cG9ydHMuaW50MzIgPSBlbmNvZGVyKDAsXG4gIGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIHZhcmludC5lbmNvZGUodmFsIDwgMCA/IHZhbCArIDQyOTQ5NjcyOTYgOiB2YWwsIGJ1ZmZlciwgb2Zmc2V0KVxuICAgIGVuY29kZS5ieXRlcyA9IHZhcmludC5lbmNvZGUuYnl0ZXNcbiAgICByZXR1cm4gYnVmZmVyXG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICBkZWNvZGUuYnl0ZXMgPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgcmV0dXJuIHZhbCA+IDIxNDc0ODM2NDcgPyB2YWwgLSA0Mjk0OTY3Mjk2IDogdmFsXG4gIH0sXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoICh2YWwpIHtcbiAgICByZXR1cm4gdmFyaW50LmVuY29kaW5nTGVuZ3RoKHZhbCA8IDAgPyB2YWwgKyA0Mjk0OTY3Mjk2IDogdmFsKVxuICB9XG4pXG5cbmV4cG9ydHMuaW50NjQgPSBlbmNvZGVyKDAsXG4gIGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICB2YXIgbGFzdCA9IG9mZnNldCArIDlcbiAgICAgIHZhcmludC5lbmNvZGUodmFsICogLTEsIGJ1ZmZlciwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXMgLSAxXG4gICAgICBidWZmZXJbb2Zmc2V0XSA9IGJ1ZmZlcltvZmZzZXRdIHwgMHg4MFxuICAgICAgd2hpbGUgKG9mZnNldCA8IGxhc3QgLSAxKSB7XG4gICAgICAgIG9mZnNldCsrXG4gICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gMHhmZlxuICAgICAgfVxuICAgICAgYnVmZmVyW2xhc3RdID0gMHgwMVxuICAgICAgZW5jb2RlLmJ5dGVzID0gMTBcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyaW50LmVuY29kZSh2YWwsIGJ1ZmZlciwgb2Zmc2V0KVxuICAgICAgZW5jb2RlLmJ5dGVzID0gdmFyaW50LmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyXG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICBpZiAodmFsID49IE1hdGgucG93KDIsIDYzKSkge1xuICAgICAgdmFyIGxpbWl0ID0gOVxuICAgICAgd2hpbGUgKGJ1ZmZlcltvZmZzZXQgKyBsaW1pdCAtIDFdID09PSAweGZmKSBsaW1pdC0tXG4gICAgICBsaW1pdCA9IGxpbWl0IHx8IDlcbiAgICAgIHZhciBzdWJzZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGltaXQpXG4gICAgICBidWZmZXIuY29weShzdWJzZXQsIDAsIG9mZnNldCwgb2Zmc2V0ICsgbGltaXQpXG4gICAgICBzdWJzZXRbbGltaXQgLSAxXSA9IHN1YnNldFtsaW1pdCAtIDFdICYgMHg3ZlxuICAgICAgdmFsID0gLTEgKiB2YXJpbnQuZGVjb2RlKHN1YnNldCwgMClcbiAgICAgIGRlY29kZS5ieXRlcyA9IDEwXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY29kZS5ieXRlcyA9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICB9XG4gICAgcmV0dXJuIHZhbFxuICB9LFxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA8IDAgPyAxMCA6IHZhcmludC5lbmNvZGluZ0xlbmd0aCh2YWwpXG4gIH1cbilcblxuZXhwb3J0cy5zaW50MzIgPVxuZXhwb3J0cy5zaW50NjQgPSBlbmNvZGVyKDAsXG4gIHN2YXJpbnQuZW5jb2RlLFxuICBzdmFyaW50LmRlY29kZSxcbiAgc3ZhcmludC5lbmNvZGluZ0xlbmd0aFxuKVxuXG5leHBvcnRzLnVpbnQzMiA9XG5leHBvcnRzLnVpbnQ2NCA9XG5leHBvcnRzLmVudW0gPVxuZXhwb3J0cy52YXJpbnQgPSBlbmNvZGVyKDAsXG4gIHZhcmludC5lbmNvZGUsXG4gIHZhcmludC5kZWNvZGUsXG4gIHZhcmludC5lbmNvZGluZ0xlbmd0aFxuKVxuXG4vLyB3ZSBjYW5ub3QgcmVwcmVzZW50IHRoZXNlIGluIGphdmFzY3JpcHQgc28gd2UganVzdCB1c2UgYnVmZmVyc1xuZXhwb3J0cy5maXhlZDY0ID1cbmV4cG9ydHMuc2ZpeGVkNjQgPSBlbmNvZGVyKDEsXG4gIGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KVxuICAgIGVuY29kZS5ieXRlcyA9IDhcbiAgICByZXR1cm4gYnVmZmVyXG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgOClcbiAgICBkZWNvZGUuYnl0ZXMgPSA4XG4gICAgcmV0dXJuIHZhbFxuICB9LFxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDhcbiAgfVxuKVxuXG5leHBvcnRzLmRvdWJsZSA9IGVuY29kZXIoMSxcbiAgZnVuY3Rpb24gZW5jb2RlICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgYnVmZmVyLndyaXRlRG91YmxlTEUodmFsLCBvZmZzZXQpXG4gICAgZW5jb2RlLmJ5dGVzID0gOFxuICAgIHJldHVybiBidWZmZXJcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciB2YWwgPSBidWZmZXIucmVhZERvdWJsZUxFKG9mZnNldClcbiAgICBkZWNvZGUuYnl0ZXMgPSA4XG4gICAgcmV0dXJuIHZhbFxuICB9LFxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDhcbiAgfVxuKVxuXG5leHBvcnRzLmZpeGVkMzIgPSBlbmNvZGVyKDUsXG4gIGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHZhbCwgb2Zmc2V0KVxuICAgIGVuY29kZS5ieXRlcyA9IDRcbiAgICByZXR1cm4gYnVmZmVyXG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpXG4gICAgZGVjb2RlLmJ5dGVzID0gNFxuICAgIHJldHVybiB2YWxcbiAgfSxcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKCkge1xuICAgIHJldHVybiA0XG4gIH1cbilcblxuZXhwb3J0cy5zZml4ZWQzMiA9IGVuY29kZXIoNSxcbiAgZnVuY3Rpb24gZW5jb2RlICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgYnVmZmVyLndyaXRlSW50MzJMRSh2YWwsIG9mZnNldClcbiAgICBlbmNvZGUuYnl0ZXMgPSA0XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbCA9IGJ1ZmZlci5yZWFkSW50MzJMRShvZmZzZXQpXG4gICAgZGVjb2RlLmJ5dGVzID0gNFxuICAgIHJldHVybiB2YWxcbiAgfSxcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKCkge1xuICAgIHJldHVybiA0XG4gIH1cbilcblxuZXhwb3J0cy5mbG9hdCA9IGVuY29kZXIoNSxcbiAgZnVuY3Rpb24gZW5jb2RlICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgYnVmZmVyLndyaXRlRmxvYXRMRSh2YWwsIG9mZnNldClcbiAgICBlbmNvZGUuYnl0ZXMgPSA0XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbCA9IGJ1ZmZlci5yZWFkRmxvYXRMRShvZmZzZXQpXG4gICAgZGVjb2RlLmJ5dGVzID0gNFxuICAgIHJldHVybiB2YWxcbiAgfSxcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKCkge1xuICAgIHJldHVybiA0XG4gIH1cbilcblxuZnVuY3Rpb24gZW5jb2RlciAodHlwZSwgZW5jb2RlLCBkZWNvZGUsIGVuY29kaW5nTGVuZ3RoKSB7XG4gIGVuY29kZS5ieXRlcyA9IGRlY29kZS5ieXRlcyA9IDBcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RpbmdMZW5ndGg6IGVuY29kaW5nTGVuZ3RoXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVmZmVyTGVuZ3RoICh2YWwpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWwpID8gdmFsLmxlbmd0aCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3JhbmRvbS1hY2Nlc3MtZmlsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBicm93c2VyJylcbn1cbiIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG52YXIgTk9UX1JFQURBQkxFID0gZGVmYXVsdEltcGwobmV3IEVycm9yKCdOb3QgcmVhZGFibGUnKSlcbnZhciBOT1RfV1JJVEFCTEUgPSBkZWZhdWx0SW1wbChuZXcgRXJyb3IoJ05vdCB3cml0YWJsZScpKVxudmFyIE5PVF9ERUxFVEFCTEUgPSBkZWZhdWx0SW1wbChuZXcgRXJyb3IoJ05vdCBkZWxldGFibGUnKSlcbnZhciBOT1RfU1RBVEFCTEUgPSBkZWZhdWx0SW1wbChuZXcgRXJyb3IoJ05vdCBzdGF0YWJsZScpKVxudmFyIE5PX09QRU5fUkVBREFCTEUgPSBkZWZhdWx0SW1wbChuZXcgRXJyb3IoJ05vIHJlYWRvbmx5IG9wZW4nKSlcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21BY2Nlc3NcblxuZnVuY3Rpb24gUmFuZG9tQWNjZXNzIChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5kb21BY2Nlc3MpKSByZXR1cm4gbmV3IFJhbmRvbUFjY2VzcyhvcHRzKVxuICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcblxuICB0aGlzLl9xdWV1ZWQgPSBbXVxuICB0aGlzLl9wZW5kaW5nID0gMFxuICB0aGlzLl9uZWVkc09wZW4gPSB0cnVlXG5cbiAgdGhpcy5vcGVuZWQgPSBmYWxzZVxuICB0aGlzLmNsb3NlZCA9IGZhbHNlXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICBpZiAob3B0cykge1xuICAgIGlmIChvcHRzLm9wZW5SZWFkb25seSkgdGhpcy5fb3BlblJlYWRvbmx5ID0gb3B0cy5vcGVuUmVhZG9ubHlcbiAgICBpZiAob3B0cy5vcGVuKSB0aGlzLl9vcGVuID0gb3B0cy5vcGVuXG4gICAgaWYgKG9wdHMucmVhZCkgdGhpcy5fcmVhZCA9IG9wdHMucmVhZFxuICAgIGlmIChvcHRzLndyaXRlKSB0aGlzLl93cml0ZSA9IG9wdHMud3JpdGVcbiAgICBpZiAob3B0cy5kZWwpIHRoaXMuX2RlbCA9IG9wdHMuZGVsXG4gICAgaWYgKG9wdHMuc3RhdCkgdGhpcy5fc3RhdCA9IG9wdHMuc3RhdFxuICAgIGlmIChvcHRzLmNsb3NlKSB0aGlzLl9jbG9zZSA9IG9wdHMuY2xvc2VcbiAgICBpZiAob3B0cy5kZXN0cm95KSB0aGlzLl9kZXN0cm95ID0gb3B0cy5kZXN0cm95XG4gIH1cblxuICB0aGlzLnByZWZlclJlYWRvbmx5ID0gdGhpcy5fb3BlblJlYWRvbmx5ICE9PSBOT19PUEVOX1JFQURBQkxFXG4gIHRoaXMucmVhZGFibGUgPSB0aGlzLl9yZWFkICE9PSBOT1RfUkVBREFCTEVcbiAgdGhpcy53cml0YWJsZSA9IHRoaXMuX3dyaXRlICE9PSBOT1RfV1JJVEFCTEVcbiAgdGhpcy5kZWxldGFibGUgPSB0aGlzLl9kZWwgIT09IE5PVF9ERUxFVEFCTEVcbiAgdGhpcy5zdGF0YWJsZSA9IHRoaXMuX3N0YXQgIT09IE5PVF9TVEFUQUJMRVxufVxuXG5pbmhlcml0cyhSYW5kb21BY2Nlc3MsIGV2ZW50cy5FdmVudEVtaXR0ZXIpXG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKHRoaXMub3BlbmVkICYmICF0aGlzLl9uZWVkc09wZW4pIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsKVxuICBxdWV1ZUFuZFJ1bih0aGlzLCBuZXcgUmVxdWVzdCh0aGlzLCAwLCAwLCAwLCBudWxsLCBjYikpXG59XG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuX29wZW4gPSBkZWZhdWx0SW1wbChudWxsKVxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5fb3BlblJlYWRvbmx5ID0gTk9fT1BFTl9SRUFEQUJMRVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCBzaXplLCBjYikge1xuICB0aGlzLnJ1bihuZXcgUmVxdWVzdCh0aGlzLCAxLCBvZmZzZXQsIHNpemUsIG51bGwsIGNiKSlcbn1cblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5fcmVhZCA9IE5PVF9SRUFEQUJMRVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG9mZnNldCwgZGF0YSwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBub29wXG4gIG9wZW5Xcml0YWJsZSh0aGlzKVxuICB0aGlzLnJ1bihuZXcgUmVxdWVzdCh0aGlzLCAyLCBvZmZzZXQsIGRhdGEubGVuZ3RoLCBkYXRhLCBjYikpXG59XG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuX3dyaXRlID0gTk9UX1dSSVRBQkxFXG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKG9mZnNldCwgc2l6ZSwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBub29wXG4gIG9wZW5Xcml0YWJsZSh0aGlzKVxuICB0aGlzLnJ1bihuZXcgUmVxdWVzdCh0aGlzLCAzLCBvZmZzZXQsIHNpemUsIG51bGwsIGNiKSlcbn1cblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5fZGVsID0gTk9UX0RFTEVUQUJMRVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLnN0YXQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdGhpcy5ydW4obmV3IFJlcXVlc3QodGhpcywgNCwgMCwgMCwgbnVsbCwgY2IpKVxufVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLl9zdGF0ID0gTk9UX1NUQVRBQkxFXG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBub29wXG4gIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2IsIG51bGwpXG4gIHF1ZXVlQW5kUnVuKHRoaXMsIG5ldyBSZXF1ZXN0KHRoaXMsIDUsIDAsIDAsIG51bGwsIGNiKSlcbn1cblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5fY2xvc2UgPSBkZWZhdWx0SW1wbChudWxsKVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBub29wXG4gIGlmICghdGhpcy5jbG9zZWQpIHRoaXMuY2xvc2Uobm9vcClcbiAgcXVldWVBbmRSdW4odGhpcywgbmV3IFJlcXVlc3QodGhpcywgNiwgMCwgMCwgbnVsbCwgY2IpKVxufVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLl9kZXN0cm95ID0gZGVmYXVsdEltcGwobnVsbClcblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAocmVxKSB7XG4gIGlmICh0aGlzLl9uZWVkc09wZW4pIHRoaXMub3Blbihub29wKVxuICBpZiAodGhpcy5fcXVldWVkLmxlbmd0aCkgdGhpcy5fcXVldWVkLnB1c2gocmVxKVxuICBlbHNlIHJlcS5fcnVuKClcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBSZXF1ZXN0IChzZWxmLCB0eXBlLCBvZmZzZXQsIHNpemUsIGRhdGEsIGNiKSB7XG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5vZmZzZXQgPSBvZmZzZXRcbiAgdGhpcy5kYXRhID0gZGF0YVxuICB0aGlzLnNpemUgPSBzaXplXG4gIHRoaXMuc3RvcmFnZSA9IHNlbGZcblxuICB0aGlzLl9zeW5jID0gZmFsc2VcbiAgdGhpcy5fY2FsbGJhY2sgPSBjYlxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5fdW5xdWV1ZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHJhID0gdGhpcy5zdG9yYWdlXG4gIHZhciBxdWV1ZWQgPSByYS5fcXVldWVkXG5cbiAgaWYgKCFlcnIpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBpZiAoIXJhLm9wZW5lZCkge1xuICAgICAgICAgIHJhLm9wZW5lZCA9IHRydWVcbiAgICAgICAgICByYS5lbWl0KCdvcGVuJylcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIDU6XG4gICAgICAgIGlmICghcmEuY2xvc2VkKSB7XG4gICAgICAgICAgcmEuY2xvc2VkID0gdHJ1ZVxuICAgICAgICAgIHJhLmVtaXQoJ2Nsb3NlJylcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIDY6XG4gICAgICAgIGlmICghcmEuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmEuZGVzdHJveWVkID0gdHJ1ZVxuICAgICAgICAgIHJhLmVtaXQoJ2Rlc3Ryb3knKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXVlZC5sZW5ndGggJiYgcXVldWVkWzBdID09PSB0aGlzKSBxdWV1ZWQuc2hpZnQoKVxuICBpZiAoIS0tcmEuX3BlbmRpbmcgJiYgcXVldWVkLmxlbmd0aCkgcXVldWVkWzBdLl9ydW4oKVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIsIHZhbCkge1xuICBpZiAodGhpcy5fc3luYykgcmV0dXJuIG5leHRUaWNrKHRoaXMsIGVyciwgdmFsKVxuICB0aGlzLl91bnF1ZXVlKGVycilcbiAgdGhpcy5fY2FsbGJhY2soZXJyLCB2YWwpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLl9vcGVuQW5kTm90Q2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmEgPSB0aGlzLnN0b3JhZ2VcbiAgaWYgKHJhLm9wZW5lZCAmJiAhcmEuY2xvc2VkKSByZXR1cm4gdHJ1ZVxuICBpZiAoIXJhLm9wZW5lZCkgbmV4dFRpY2sodGhpcywgbmV3IEVycm9yKCdOb3Qgb3BlbmVkJykpXG4gIGVsc2UgaWYgKHJhLmNsb3NlZCkgbmV4dFRpY2sodGhpcywgbmV3IEVycm9yKCdDbG9zZWQnKSlcbiAgcmV0dXJuIGZhbHNlXG59XG5cblJlcXVlc3QucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmEgPSB0aGlzLnN0b3JhZ2VcblxuICBpZiAocmEub3BlbmVkICYmICFyYS5fbmVlZHNPcGVuKSByZXR1cm4gbmV4dFRpY2sodGhpcywgbnVsbClcbiAgaWYgKHJhLmNsb3NlZCkgcmV0dXJuIG5leHRUaWNrKHRoaXMsIG5ldyBFcnJvcignQ2xvc2VkJykpXG5cbiAgcmEuX25lZWRzT3BlbiA9IGZhbHNlXG4gIGlmIChyYS5wcmVmZXJSZWFkb25seSkgcmEuX29wZW5SZWFkb25seSh0aGlzKVxuICBlbHNlIHJhLl9vcGVuKHRoaXMpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLl9ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByYSA9IHRoaXMuc3RvcmFnZVxuICByYS5fcGVuZGluZysrXG5cbiAgdGhpcy5fc3luYyA9IHRydWVcblxuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHRoaXMuX29wZW4oKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgMTpcbiAgICAgIGlmICh0aGlzLl9vcGVuQW5kTm90Q2xvc2VkKCkpIHJhLl9yZWFkKHRoaXMpXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAyOlxuICAgICAgaWYgKHRoaXMuX29wZW5BbmROb3RDbG9zZWQoKSkgcmEuX3dyaXRlKHRoaXMpXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAzOlxuICAgICAgaWYgKHRoaXMuX29wZW5BbmROb3RDbG9zZWQoKSkgcmEuX2RlbCh0aGlzKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgNDpcbiAgICAgIGlmICh0aGlzLl9vcGVuQW5kTm90Q2xvc2VkKCkpIHJhLl9zdGF0KHRoaXMpXG4gICAgICBicmVha1xuXG4gICAgY2FzZSA1OlxuICAgICAgaWYgKHJhLmNsb3NlZCB8fCAhcmEub3BlbmVkKSBuZXh0VGljayh0aGlzLCBudWxsKVxuICAgICAgZWxzZSByYS5fY2xvc2UodGhpcylcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIDY6XG4gICAgICBpZiAocmEuZGVzdHJveWVkKSBuZXh0VGljayh0aGlzLCBudWxsKVxuICAgICAgZWxzZSByYS5fZGVzdHJveSh0aGlzKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHRoaXMuX3N5bmMgPSBmYWxzZVxufVxuXG5mdW5jdGlvbiBxdWV1ZUFuZFJ1biAoc2VsZiwgcmVxKSB7XG4gIHNlbGYuX3F1ZXVlZC5wdXNoKHJlcSlcbiAgaWYgKCFzZWxmLl9wZW5kaW5nKSByZXEuX3J1bigpXG59XG5cbmZ1bmN0aW9uIG9wZW5Xcml0YWJsZSAoc2VsZikge1xuICBpZiAoc2VsZi5wcmVmZXJSZWFkb25seSkge1xuICAgIHNlbGYuX25lZWRzT3BlbiA9IHRydWVcbiAgICBzZWxmLnByZWZlclJlYWRvbmx5ID0gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0SW1wbCAoZXJyKSB7XG4gIHJldHVybiBvdmVycmlkYWJsZVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRhYmxlIChyZXEpIHtcbiAgICBuZXh0VGljayhyZXEsIGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayAocmVxLCBlcnIsIHZhbCkge1xuICBwcm9jZXNzLm5leHRUaWNrKG5leHRUaWNrQ2FsbGJhY2ssIHJlcSwgZXJyLCB2YWwpXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrQ2FsbGJhY2sgKHJlcSwgZXJyLCB2YWwpIHtcbiAgcmVxLmNhbGxiYWNrKGVyciwgdmFsKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCJ2YXIgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlICh2LCBiLCBvKSB7XG4gIHYgPSB2ID49IDAgPyB2KjIgOiB2Ki0yIC0gMVxuICB2YXIgciA9IHZhcmludC5lbmNvZGUodiwgYiwgbylcbiAgZW5jb2RlLmJ5dGVzID0gdmFyaW50LmVuY29kZS5ieXRlc1xuICByZXR1cm4gclxufVxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUgKGIsIG8pIHtcbiAgdmFyIHYgPSB2YXJpbnQuZGVjb2RlKGIsIG8pXG4gIGRlY29kZS5ieXRlcyA9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgcmV0dXJuIHYgJiAxID8gKHYrMSkgLyAtMiA6IHYgLyAyXG59XG5cbmV4cG9ydHMuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gdmFyaW50LmVuY29kaW5nTGVuZ3RoKHYgPj0gMCA/IHYqMiA6IHYqLTIgLSAxKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxsYmFja1xuXG5mdW5jdGlvbiBfYWRkIChhLCBiKSB7XG4gIHZhciBybCA9IGEubCArIGIubFxuICB2YXIgYTIgPSB7XG4gICAgaDogYS5oICsgYi5oICsgKHJsIC8gMiA+Pj4gMzEpID4+PiAwLFxuICAgIGw6IHJsID4+PiAwXG4gIH1cbiAgYS5oID0gYTIuaFxuICBhLmwgPSBhMi5sXG59XG5cbmZ1bmN0aW9uIF94b3IgKGEsIGIpIHtcbiAgYS5oIF49IGIuaFxuICBhLmggPj4+PSAwXG4gIGEubCBePSBiLmxcbiAgYS5sID4+Pj0gMFxufVxuXG5mdW5jdGlvbiBfcm90bCAoYSwgbikge1xuICB2YXIgYTIgPSB7XG4gICAgaDogYS5oIDw8IG4gfCBhLmwgPj4+ICgzMiAtIG4pLFxuICAgIGw6IGEubCA8PCBuIHwgYS5oID4+PiAoMzIgLSBuKVxuICB9XG4gIGEuaCA9IGEyLmhcbiAgYS5sID0gYTIubFxufVxuXG5mdW5jdGlvbiBfcm90bDMyIChhKSB7XG4gIHZhciBhbCA9IGEubFxuICBhLmwgPSBhLmhcbiAgYS5oID0gYWxcbn1cblxuZnVuY3Rpb24gX2NvbXByZXNzICh2MCwgdjEsIHYyLCB2Mykge1xuICBfYWRkKHYwLCB2MSlcbiAgX2FkZCh2MiwgdjMpXG4gIF9yb3RsKHYxLCAxMylcbiAgX3JvdGwodjMsIDE2KVxuICBfeG9yKHYxLCB2MClcbiAgX3hvcih2MywgdjIpXG4gIF9yb3RsMzIodjApXG4gIF9hZGQodjIsIHYxKVxuICBfYWRkKHYwLCB2MylcbiAgX3JvdGwodjEsIDE3KVxuICBfcm90bCh2MywgMjEpXG4gIF94b3IodjEsIHYyKVxuICBfeG9yKHYzLCB2MClcbiAgX3JvdGwzMih2Milcbn1cblxuZnVuY3Rpb24gX2dldF9pbnQgKGEsIG9mZnNldCkge1xuICByZXR1cm4gKGFbb2Zmc2V0ICsgM10gPDwgMjQpIHwgKGFbb2Zmc2V0ICsgMl0gPDwgMTYpIHwgKGFbb2Zmc2V0ICsgMV0gPDwgOCkgfCBhW29mZnNldF1cbn1cblxuZnVuY3Rpb24gZmFsbGJhY2sgKG91dCwgbSwga2V5KSB7IC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2plZGlzY3QxL3NpcGhhc2gtanMgdG8gdXNlIHVpbnQ4YXJyYXlzXG4gIHZhciBrMCA9IHtoOiBfZ2V0X2ludChrZXksIDQpLCBsOiBfZ2V0X2ludChrZXksIDApfVxuICB2YXIgazEgPSB7aDogX2dldF9pbnQoa2V5LCAxMiksIGw6IF9nZXRfaW50KGtleSwgOCl9XG4gIHZhciB2MCA9IHtoOiBrMC5oLCBsOiBrMC5sfVxuICB2YXIgdjIgPSBrMFxuICB2YXIgdjEgPSB7aDogazEuaCwgbDogazEubH1cbiAgdmFyIHYzID0gazFcbiAgdmFyIG1pXG4gIHZhciBtcCA9IDBcbiAgdmFyIG1sID0gbS5sZW5ndGhcbiAgdmFyIG1sNyA9IG1sIC0gN1xuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKDgpKVxuXG4gIF94b3IodjAsIHtoOiAweDczNmY2ZDY1LCBsOiAweDcwNzM2NTc1fSlcbiAgX3hvcih2MSwge2g6IDB4NjQ2ZjcyNjEsIGw6IDB4NmU2NDZmNmR9KVxuICBfeG9yKHYyLCB7aDogMHg2Yzc5Njc2NSwgbDogMHg2ZTY1NzI2MX0pXG4gIF94b3IodjMsIHtoOiAweDc0NjU2NDYyLCBsOiAweDc5NzQ2NTczfSlcblxuICB3aGlsZSAobXAgPCBtbDcpIHtcbiAgICBtaSA9IHtoOiBfZ2V0X2ludChtLCBtcCArIDQpLCBsOiBfZ2V0X2ludChtLCBtcCl9XG4gICAgX3hvcih2MywgbWkpXG4gICAgX2NvbXByZXNzKHYwLCB2MSwgdjIsIHYzKVxuICAgIF9jb21wcmVzcyh2MCwgdjEsIHYyLCB2MylcbiAgICBfeG9yKHYwLCBtaSlcbiAgICBtcCArPSA4XG4gIH1cblxuICBidWZbN10gPSBtbFxuICB2YXIgaWMgPSAwXG4gIHdoaWxlIChtcCA8IG1sKSB7XG4gICAgYnVmW2ljKytdID0gbVttcCsrXVxuICB9XG4gIHdoaWxlIChpYyA8IDcpIHtcbiAgICBidWZbaWMrK10gPSAwXG4gIH1cblxuICBtaSA9IHtcbiAgICBoOiBidWZbN10gPDwgMjQgfCBidWZbNl0gPDwgMTYgfCBidWZbNV0gPDwgOCB8IGJ1Zls0XSxcbiAgICBsOiBidWZbM10gPDwgMjQgfCBidWZbMl0gPDwgMTYgfCBidWZbMV0gPDwgOCB8IGJ1ZlswXVxuICB9XG5cbiAgX3hvcih2MywgbWkpXG4gIF9jb21wcmVzcyh2MCwgdjEsIHYyLCB2MylcbiAgX2NvbXByZXNzKHYwLCB2MSwgdjIsIHYzKVxuICBfeG9yKHYwLCBtaSlcbiAgX3hvcih2MiwgeyBoOiAwLCBsOiAweGZmIH0pXG4gIF9jb21wcmVzcyh2MCwgdjEsIHYyLCB2MylcbiAgX2NvbXByZXNzKHYwLCB2MSwgdjIsIHYzKVxuICBfY29tcHJlc3ModjAsIHYxLCB2MiwgdjMpXG4gIF9jb21wcmVzcyh2MCwgdjEsIHYyLCB2MylcblxuICB2YXIgaCA9IHYwXG4gIF94b3IoaCwgdjEpXG4gIF94b3IoaCwgdjIpXG4gIF94b3IoaCwgdjMpXG5cbiAgb3V0WzBdID0gaC5sICYgMHhmZlxuICBvdXRbMV0gPSAoaC5sID4+IDgpICYgMHhmZlxuICBvdXRbMl0gPSAoaC5sID4+IDE2KSAmIDB4ZmZcbiAgb3V0WzNdID0gKGgubCA+PiAyNCkgJiAweGZmXG4gIG91dFs0XSA9IGguaCAmIDB4ZmZcbiAgb3V0WzVdID0gKGguaCA+PiA4KSAmIDB4ZmZcbiAgb3V0WzZdID0gKGguaCA+PiAxNikgJiAweGZmXG4gIG91dFs3XSA9IChoLmggPj4gMjQpICYgMHhmZlxufVxuIiwidmFyIHdhc20gPSByZXF1aXJlKCcuL3NpcGhhc2gyNCcpXG52YXIgZmFsbGJhY2sgPSByZXF1aXJlKCcuL2ZhbGxiYWNrJylcbnZhciBhc3NlcnQgPSByZXF1aXJlKCduYW5vYXNzZXJ0JylcblxubW9kdWxlLmV4cG9ydHMgPSBzaXBoYXNoMjRcblxudmFyIEJZVEVTID0gc2lwaGFzaDI0LkJZVEVTID0gOFxudmFyIEtFWUJZVEVTID0gc2lwaGFzaDI0LktFWUJZVEVTID0gMTZcbnZhciBtb2QgPSB3YXNtKClcblxuc2lwaGFzaDI0LldBU01fU1VQUE9SVEVEID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSAndW5kZWZpbmVkJ1xuc2lwaGFzaDI0LldBU01fTE9BREVEID0gZmFsc2VcblxuaWYgKG1vZCkge1xuICBtb2Qub25sb2FkKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzaXBoYXNoMjQuV0FTTV9MT0FERUQgPSAhZXJyXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHNpcGhhc2gyNCAoZGF0YSwga2V5LCBvdXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghb3V0KSBvdXQgPSBuZXcgVWludDhBcnJheSg4KVxuXG4gIGlmIChub0Fzc2VydCAhPT0gdHJ1ZSkge1xuICAgIGFzc2VydChvdXQubGVuZ3RoID49IEJZVEVTLCAnb3V0cHV0IG11c3QgYmUgYXQgbGVhc3QgJyArIEJZVEVTKVxuICAgIGFzc2VydChrZXkubGVuZ3RoID49IEtFWUJZVEVTLCAna2V5IG11c3QgYmUgYXQgbGVhc3QgJyArIEtFWUJZVEVTKVxuICB9XG5cbiAgaWYgKG1vZCAmJiBtb2QuZXhwb3J0cykge1xuICAgIGlmIChkYXRhLmxlbmd0aCArIDI0ID4gbW9kLm1lbW9yeS5sZW5ndGgpIG1vZC5yZWFsbG9jKGRhdGEubGVuZ3RoICsgMjQpXG4gICAgbW9kLm1lbW9yeS5zZXQoa2V5LCA4KVxuICAgIG1vZC5tZW1vcnkuc2V0KGRhdGEsIDI0KVxuICAgIG1vZC5leHBvcnRzLnNpcGhhc2goMjQsIGRhdGEubGVuZ3RoKVxuICAgIG91dC5zZXQobW9kLm1lbW9yeS5zdWJhcnJheSgwLCA4KSlcbiAgfSBlbHNlIHtcbiAgICBmYWxsYmFjayhvdXQsIGRhdGEsIGtleSlcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBsb2FkV2ViQXNzZW1ibHlcblxubG9hZFdlYkFzc2VtYmx5LnN1cHBvcnRlZCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ3VuZGVmaW5lZCdcblxuZnVuY3Rpb24gbG9hZFdlYkFzc2VtYmx5IChvcHRzKSB7XG4gIGlmICghbG9hZFdlYkFzc2VtYmx5LnN1cHBvcnRlZCkgcmV0dXJuIG51bGxcblxuICB2YXIgaW1wID0gb3B0cyAmJiBvcHRzLmltcG9ydHNcbiAgdmFyIHdhc20gPSB0b1VpbnQ4QXJyYXkoJ0FHRnpiUUVBQUFBQkJnRmdBbjkvQUFNQ0FRQUZCUUVCQ3BCT0J4UUNCbTFsYlc5eWVRSUFCM05wY0doaGMyZ0FBQXJkQ0FIYUNBSUlmZ0ovUXZYS3pZUFhyTnUzOHdBaEFrTHQzcEh6bHN6Y3QrUUFJUU5DNGVTVjg5YnMyYnpzQUNFRVF2UEswY3Vuak5teTlBQWhCVUVJS1FNQUlRZEJFQ2tEQUNFSUlBR3RRamlHSVFZZ0FVRUhjU0VMSUFBZ0FXb2dDMnNoQ2lBRklBaUZJUVVnQkNBSGhTRUVJQU1nQ0lVaEF5QUNJQWVGSVFJQ1FBTkFJQUFnQ2tZTkFTQUFLUU1BSVFrZ0JTQUpoU0VGSUFJZ0Ezd2hBaUFEUWcySklRTWdBeUFDaFNFRElBSkNJSWtoQWlBRUlBVjhJUVFnQlVJUWlTRUZJQVVnQklVaEJTQUNJQVY4SVFJZ0JVSVZpU0VGSUFVZ0FvVWhCU0FFSUFOOElRUWdBMElSaVNFRElBTWdCSVVoQXlBRVFpQ0pJUVFnQWlBRGZDRUNJQU5DRFlraEF5QURJQUtGSVFNZ0FrSWdpU0VDSUFRZ0JYd2hCQ0FGUWhDSklRVWdCU0FFaFNFRklBSWdCWHdoQWlBRlFoV0pJUVVnQlNBQ2hTRUZJQVFnQTN3aEJDQURRaEdKSVFNZ0F5QUVoU0VESUFSQ0lJa2hCQ0FDSUFtRklRSWdBRUVJYWlFQURBQUxDd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQWdDdzRIQndZRkJBTUNBUUFMSUFZZ0FERUFCa0l3aG9RaEJnc2dCaUFBTVFBRlFpaUdoQ0VHQ3lBR0lBQXhBQVJDSUlhRUlRWUxJQVlnQURFQUEwSVlob1FoQmdzZ0JpQUFNUUFDUWhDR2hDRUdDeUFHSUFBeEFBRkNDSWFFSVFZTElBWWdBREVBQUlRaEJnc2dCU0FHaFNFRklBSWdBM3doQWlBRFFnMkpJUU1nQXlBQ2hTRURJQUpDSUlraEFpQUVJQVY4SVFRZ0JVSVFpU0VGSUFVZ0JJVWhCU0FDSUFWOElRSWdCVUlWaVNFRklBVWdBb1VoQlNBRUlBTjhJUVFnQTBJUmlTRURJQU1nQklVaEF5QUVRaUNKSVFRZ0FpQURmQ0VDSUFOQ0RZa2hBeUFESUFLRklRTWdBa0lnaVNFQ0lBUWdCWHdoQkNBRlFoQ0pJUVVnQlNBRWhTRUZJQUlnQlh3aEFpQUZRaFdKSVFVZ0JTQUNoU0VGSUFRZ0Ezd2hCQ0FEUWhHSklRTWdBeUFFaFNFRElBUkNJSWtoQkNBQ0lBYUZJUUlnQkVML0FZVWhCQ0FDSUFOOElRSWdBMElOaVNFRElBTWdBb1VoQXlBQ1FpQ0pJUUlnQkNBRmZDRUVJQVZDRUlraEJTQUZJQVNGSVFVZ0FpQUZmQ0VDSUFWQ0ZZa2hCU0FGSUFLRklRVWdCQ0FEZkNFRUlBTkNFWWtoQXlBRElBU0ZJUU1nQkVJZ2lTRUVJQUlnQTN3aEFpQURRZzJKSVFNZ0F5QUNoU0VESUFKQ0lJa2hBaUFFSUFWOElRUWdCVUlRaVNFRklBVWdCSVVoQlNBQ0lBVjhJUUlnQlVJVmlTRUZJQVVnQW9VaEJTQUVJQU44SVFRZ0EwSVJpU0VESUFNZ0JJVWhBeUFFUWlDSklRUWdBaUFEZkNFQ0lBTkNEWWtoQXlBRElBS0ZJUU1nQWtJZ2lTRUNJQVFnQlh3aEJDQUZRaENKSVFVZ0JTQUVoU0VGSUFJZ0JYd2hBaUFGUWhXSklRVWdCU0FDaFNFRklBUWdBM3doQkNBRFFoR0pJUU1nQXlBRWhTRURJQVJDSUlraEJDQUNJQU44SVFJZ0EwSU5pU0VESUFNZ0FvVWhBeUFDUWlDSklRSWdCQ0FGZkNFRUlBVkNFSWtoQlNBRklBU0ZJUVVnQWlBRmZDRUNJQVZDRllraEJTQUZJQUtGSVFVZ0JDQURmQ0VFSUFOQ0VZa2hBeUFESUFTRklRTWdCRUlnaVNFRVFRQWdBaUFESUFRZ0JZV0ZoVGNEQUFzPScpXG4gIHZhciByZWFkeSA9IG51bGxcblxuICB2YXIgbW9kID0ge1xuICAgIGJ1ZmZlcjogd2FzbSxcbiAgICBtZW1vcnk6IG51bGwsXG4gICAgZXhwb3J0czogbnVsbCxcbiAgICByZWFsbG9jOiByZWFsbG9jLFxuICAgIG9ubG9hZDogb25sb2FkXG4gIH1cblxuICBvbmxvYWQoZnVuY3Rpb24gKCkge30pXG5cbiAgcmV0dXJuIG1vZFxuXG4gIGZ1bmN0aW9uIHJlYWxsb2MgKHNpemUpIHtcbiAgICBtb2QuZXhwb3J0cy5tZW1vcnkuZ3JvdyhNYXRoLm1heCgwLCBNYXRoLmNlaWwoTWF0aC5hYnMoc2l6ZSAtIG1vZC5tZW1vcnkubGVuZ3RoKSAvIDY1NTM2KSkpXG4gICAgbW9kLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBvbmxvYWQgKGNiKSB7XG4gICAgaWYgKG1vZC5leHBvcnRzKSByZXR1cm4gY2IoKVxuXG4gICAgaWYgKHJlYWR5KSB7XG4gICAgICByZWFkeS50aGVuKGNiLmJpbmQobnVsbCwgbnVsbCkpLmNhdGNoKGNiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMnKVxuICAgICAgc2V0dXAoe2luc3RhbmNlOiBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZSh3YXNtKSwgaW1wKX0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZWFkeSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc20sIGltcCkudGhlbihzZXR1cClcbiAgICB9XG5cbiAgICBvbmxvYWQoY2IpXG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cCAodykge1xuICAgIG1vZC5leHBvcnRzID0gdy5pbnN0YW5jZS5leHBvcnRzXG4gICAgbW9kLm1lbW9yeSA9IG1vZC5leHBvcnRzLm1lbW9yeSAmJiBtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyICYmIG5ldyBVaW50OEFycmF5KG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9VaW50OEFycmF5IChzKSB7XG4gIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF0b2Iocykuc3BsaXQoJycpLm1hcChjaGFyQ29kZUF0KSlcbiAgcmV0dXJuIG5ldyAocmVxdWlyZSgnYnVmJyArICdmZXInKS5CdWZmZXIpKHMsICdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiBjaGFyQ29kZUF0IChjKSB7XG4gIHJldHVybiBjLmNoYXJDb2RlQXQoMClcbn1cbiIsInZhciBibGFrZTJiID0gcmVxdWlyZSgnYmxha2UyYicpXG5cbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9QUklNSVRJVkUgPSAnYmxha2UyYidcbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9CWVRFU19NSU4gPSBibGFrZTJiLkJZVEVTX01JTlxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX0JZVEVTX01BWCA9IGJsYWtlMmIuQllURVNfTUFYXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfQllURVMgPSBibGFrZTJiLkJZVEVTXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfS0VZQllURVNfTUlOID0gYmxha2UyYi5LRVlCWVRFU19NSU5cbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9LRVlCWVRFU19NQVggPSBibGFrZTJiLktFWUJZVEVTX01BWFxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX0tFWUJZVEVTID0gYmxha2UyYi5LRVlCWVRFU1xubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX1dBU01fU1VQUE9SVEVEID0gYmxha2UyYi5XQVNNX1NVUFBPUlRFRFxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX1dBU01fTE9BREVEID0gZmFsc2VcblxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoID0gZnVuY3Rpb24gKG91dHB1dCwgaW5wdXQsIGtleSkge1xuICBibGFrZTJiKG91dHB1dC5sZW5ndGgsIGtleSkudXBkYXRlKGlucHV0KS5maW5hbChvdXRwdXQpXG59XG5cbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9yZWFkeSA9IGJsYWtlMmIucmVhZHlcblxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX2JhdGNoID0gZnVuY3Rpb24gKG91dHB1dCwgaW5wdXRBcnJheSwga2V5KSB7XG4gIHZhciBjdHggPSBibGFrZTJiKG91dHB1dC5sZW5ndGgsIGtleSlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY3R4LnVwZGF0ZShpbnB1dEFycmF5W2ldKVxuICB9XG4gIGN0eC5maW5hbChvdXRwdXQpXG59XG5cbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9pbnN0YW5jZSA9IGZ1bmN0aW9uIChrZXksIG91dGxlbikge1xuICBpZiAob3V0bGVuID09IG51bGwpIG91dGxlbiA9IG1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9CWVRFU1xuICByZXR1cm4gYmxha2UyYihvdXRsZW4sIGtleSlcbn1cblxuYmxha2UyYi5yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gIG1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9XQVNNX0xPQURFRCA9IGJsYWtlMmIuV0FTTV9MT0FERURcbn0pXG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbmFub2Fzc2VydCcpXG52YXIgcmFuZG9tYnl0ZXNfYnVmID0gcmVxdWlyZSgnLi9yYW5kb21ieXRlcycpLnJhbmRvbWJ5dGVzX2J1ZlxudmFyIGJsYWtlMmIgPSByZXF1aXJlKCdibGFrZTJiJylcblxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9QUklNSVRJVkUgPSAnYmxha2UyYidcbm1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfQllURVNfTUlOID0gMTZcbm1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfQllURVNfTUFYID0gNjRcbm1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfQ09OVEVYVEJZVEVTID0gOFxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9LRVlCWVRFUyA9IDMyXG5cbmZ1bmN0aW9uIFNUT1JFNjRfTEUoZGVzdCwgaW50KSB7XG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICBkZXN0WzBdID0gaW50ICYgMHhGRlxuICB3aGlsZSAoKytpIDwgOCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGRlc3RbaV0gPSAoaW50IC8gbXVsKSAmIDB4RkZcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX2Rlcml2ZV9mcm9tX2tleSA9IGZ1bmN0aW9uIGNyeXB0b19rZGZfZGVyaXZlX2Zyb21fa2V5IChzdWJrZXksIHN1YmtleV9pZCwgY3R4LCBrZXkpIHtcbiAgYXNzZXJ0KHN1YmtleS5sZW5ndGggPj0gbW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9CWVRFU19NSU4sICdzdWJrZXkgbXVzdCBiZSBhdCBsZWFzdCBjcnlwdG9fa2RmX0JZVEVTX01JTicpXG4gIGFzc2VydChzdWJrZXlfaWQgPj0gMCAmJiBzdWJrZXlfaWQgPD0gMHgxZmZmZmZmZmZmZmZmZiwgJ3N1YmtleV9pZCBtdXN0IGJlIHNhZmUgaW50ZWdlcicpXG4gIGFzc2VydChjdHgubGVuZ3RoID49IG1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfQ09OVEVYVEJZVEVTLCAnY29udGV4dCBtdXN0IGJlIGF0IGxlYXN0IGNyeXB0b19rZGZfQ09OVEVYVEJZVEVTJylcblxuICB2YXIgY3R4X3BhZGRlZCA9IG5ldyBVaW50OEFycmF5KGJsYWtlMmIuUEVSU09OQUxCWVRFUylcbiAgdmFyIHNhbHQgPSBuZXcgVWludDhBcnJheShibGFrZTJiLlNBTFRCWVRFUylcblxuICBjdHhfcGFkZGVkLnNldChjdHgsIDAsIG1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfQ09OVEVYVEJZVEVTKVxuICBTVE9SRTY0X0xFKHNhbHQsIHN1YmtleV9pZClcblxuICB2YXIgb3V0bGVuID0gTWF0aC5taW4oc3Via2V5Lmxlbmd0aCwgbW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9CWVRFU19NQVgpXG4gIGJsYWtlMmIob3V0bGVuLCBrZXkuc3ViYXJyYXkoMCwgbW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9LRVlCWVRFUyksIHNhbHQsIGN0eF9wYWRkZWQsIHRydWUpXG4gICAgLmZpbmFsKHN1YmtleSlcbn1cblxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9rZXlnZW4gPSBmdW5jdGlvbiBjcnlwdG9fa2RmX2tleWdlbiAob3V0KSB7XG4gIGFzc2VydChvdXQubGVuZ3RoID49IG1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfS0VZQllURVMsICdvdXQubGVuZ3RoIG11c3QgYmUgY3J5cHRvX2tkZl9LRVlCWVRFUycpXG4gIHJhbmRvbWJ5dGVzX2J1ZihvdXQuc3ViYXJyYXkoMCwgbW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9LRVlCWVRFUykpXG59XG4iLCJ2YXIgc2lwaGFzaCA9IHJlcXVpcmUoJ3NpcGhhc2gyNCcpXG5cbmV4cG9ydHMuY3J5cHRvX3Nob3J0aGFzaF9QUklNSVRJVkUgPSAnc2lwaGFzaDI0J1xuZXhwb3J0cy5jcnlwdG9fc2hvcnRoYXNoX0JZVEVTID0gc2lwaGFzaC5CWVRFU1xuZXhwb3J0cy5jcnlwdG9fc2hvcnRoYXNoX0tFWUJZVEVTID0gc2lwaGFzaC5LRVlCWVRFU1xuZXhwb3J0cy5jcnlwdG9fc2hvcnRoYXNoX1dBU01fU1VQUE9SVEVEID0gc2lwaGFzaC5XQVNNX1NVUFBPUlRFRFxuZXhwb3J0cy5jcnlwdG9fc2hvcnRoYXNoX1dBU01fTE9BREVEID0gc2lwaGFzaC5XQVNNX0xPQURFRFxuZXhwb3J0cy5jcnlwdG9fc2hvcnRoYXNoID0gc2hvcnRoYXNoXG5cbmZ1bmN0aW9uIHNob3J0aGFzaCAob3V0LCBkYXRhLCBrZXksIG5vQXNzZXJ0KSB7XG4gIHNpcGhhc2goZGF0YSwga2V5LCBvdXQsIG5vQXNzZXJ0KVxufVxuIiwidmFyIHhzYWxzYTIwID0gcmVxdWlyZSgneHNhbHNhMjAnKVxuXG5leHBvcnRzLmNyeXB0b19zdHJlYW1fS0VZQllURVMgPSAzMlxuZXhwb3J0cy5jcnlwdG9fc3RyZWFtX05PTkNFQllURVMgPSAyNFxuZXhwb3J0cy5jcnlwdG9fc3RyZWFtX1BSSU1JVElWRSA9ICd4c2Fsc2EyMCdcblxuZXhwb3J0cy5jcnlwdG9fc3RyZWFtID0gZnVuY3Rpb24gKG91dCwgbm9uY2UsIGtleSkge1xuICBvdXQuZmlsbCgwKVxuICBleHBvcnRzLmNyeXB0b19zdHJlYW1feG9yKG91dCwgb3V0LCBub25jZSwga2V5KVxufVxuXG5leHBvcnRzLmNyeXB0b19zdHJlYW1feG9yID0gZnVuY3Rpb24gKG91dCwgaW5wLCBub25jZSwga2V5KSB7XG4gIHZhciB4b3IgPSB4c2Fsc2EyMChub25jZSwga2V5KVxuICB4b3IudXBkYXRlKGlucCwgb3V0KVxuICB4b3IuZmluYWwoKVxufVxuXG5leHBvcnRzLmNyeXB0b19zdHJlYW1feG9yX2luc3RhbmNlID0gZnVuY3Rpb24gKG5vbmNlLCBrZXkpIHtcbiAgcmV0dXJuIG5ldyBYT1Iobm9uY2UsIGtleSlcbn1cblxuZnVuY3Rpb24gWE9SIChub25jZSwga2V5KSB7XG4gIHRoaXMuX2luc3RhbmNlID0geHNhbHNhMjAobm9uY2UsIGtleSlcbn1cblxuWE9SLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob3V0LCBpbnApIHtcbiAgdGhpcy5faW5zdGFuY2UudXBkYXRlKGlucCwgb3V0KVxufVxuXG5YT1IucHJvdG90eXBlLmZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9pbnN0YW5jZS5maW5hbGl6ZSgpXG4gIHRoaXMuX2luc3RhbmNlID0gbnVsbFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZGNoZXN0L3R3ZWV0bmFjbC1qcy9ibG9iLzZkY2JjYWY1ZjVjYmZkMzEzZjJkY2ZlNzYzZGIzNWM4MjhjOGZmNWIvbmFjbC1mYXN0LmpzLlxuXG52YXIgc29kaXVtID0gbW9kdWxlLmV4cG9ydHNcbnZhciBjcyA9IHJlcXVpcmUoJy4vY3J5cHRvX3N0cmVhbScpXG5cbi8vIFBvcnRlZCBpbiAyMDE0IGJ5IERtaXRyeSBDaGVzdG55a2ggYW5kIERldmkgTWFuZGlyaS5cbi8vIFB1YmxpYyBkb21haW4uXG4vL1xuLy8gSW1wbGVtZW50YXRpb24gZGVyaXZlZCBmcm9tIFR3ZWV0TmFDbCB2ZXJzaW9uIDIwMTQwNDI3LlxuLy8gU2VlIGZvciBkZXRhaWxzOiBodHRwOi8vdHdlZXRuYWNsLmNyLnlwLnRvL1xuXG52YXIgZ2YgPSBmdW5jdGlvbihpbml0KSB7XG4gIHZhciBpLCByID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gIGlmIChpbml0KSBmb3IgKGkgPSAwOyBpIDwgaW5pdC5sZW5ndGg7IGkrKykgcltpXSA9IGluaXRbaV07XG4gIHJldHVybiByO1xufTtcblxuLy8gYWxzbyBmb3J3YXJkZWQgYXQgdGhlIGJvdHRvbSBidXQgcmFuZG9tYnl0ZXMgaXMgbm9uLWVudW1lcmFibGVcbnZhciByYW5kb21ieXRlcyA9IHJlcXVpcmUoJy4vcmFuZG9tYnl0ZXMnKS5yYW5kb21ieXRlc1xuXG52YXIgXzAgPSBuZXcgVWludDhBcnJheSgxNik7XG52YXIgXzkgPSBuZXcgVWludDhBcnJheSgzMik7IF85WzBdID0gOTtcblxudmFyIGdmMCA9IGdmKCksXG4gICAgZ2YxID0gZ2YoWzFdKSxcbiAgICBfMTIxNjY1ID0gZ2YoWzB4ZGI0MSwgMV0pLFxuICAgIEQgPSBnZihbMHg3OGEzLCAweDEzNTksIDB4NGRjYSwgMHg3NWViLCAweGQ4YWIsIDB4NDE0MSwgMHgwYTRkLCAweDAwNzAsIDB4ZTg5OCwgMHg3Nzc5LCAweDQwNzksIDB4OGNjNywgMHhmZTczLCAweDJiNmYsIDB4NmNlZSwgMHg1MjAzXSksXG4gICAgRDIgPSBnZihbMHhmMTU5LCAweDI2YjIsIDB4OWI5NCwgMHhlYmQ2LCAweGIxNTYsIDB4ODI4MywgMHgxNDlhLCAweDAwZTAsIDB4ZDEzMCwgMHhlZWYzLCAweDgwZjIsIDB4MTk4ZSwgMHhmY2U3LCAweDU2ZGYsIDB4ZDlkYywgMHgyNDA2XSksXG4gICAgWCA9IGdmKFsweGQ1MWEsIDB4OGYyNSwgMHgyZDYwLCAweGM5NTYsIDB4YTdiMiwgMHg5NTI1LCAweGM3NjAsIDB4NjkyYywgMHhkYzVjLCAweGZkZDYsIDB4ZTIzMSwgMHhjMGE0LCAweDUzZmUsIDB4Y2Q2ZSwgMHgzNmQzLCAweDIxNjldKSxcbiAgICBZID0gZ2YoWzB4NjY1OCwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2Nl0pLFxuICAgIEkgPSBnZihbMHhhMGIwLCAweDRhMGUsIDB4MWIyNywgMHhjNGVlLCAweGU0NzgsIDB4YWQyZiwgMHgxODA2LCAweDJmNDMsIDB4ZDdhNywgMHgzZGZiLCAweDAwOTksIDB4MmI0ZCwgMHhkZjBiLCAweDRmYzEsIDB4MjQ4MCwgMHgyYjgzXSk7XG5cbmZ1bmN0aW9uIHRzNjQoeCwgaSwgaCwgbCkge1xuICB4W2ldICAgPSAoaCA+PiAyNCkgJiAweGZmO1xuICB4W2krMV0gPSAoaCA+PiAxNikgJiAweGZmO1xuICB4W2krMl0gPSAoaCA+PiAgOCkgJiAweGZmO1xuICB4W2krM10gPSBoICYgMHhmZjtcbiAgeFtpKzRdID0gKGwgPj4gMjQpICAmIDB4ZmY7XG4gIHhbaSs1XSA9IChsID4+IDE2KSAgJiAweGZmO1xuICB4W2krNl0gPSAobCA+PiAgOCkgICYgMHhmZjtcbiAgeFtpKzddID0gbCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIHZuKHgsIHhpLCB5LCB5aSwgbikge1xuICB2YXIgaSxkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZCB8PSB4W3hpK2ldXnlbeWkraV07XG4gIHJldHVybiAoMSAmICgoZCAtIDEpID4+PiA4KSkgLSAxO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzE2KHgsIHhpLCB5LCB5aSkge1xuICByZXR1cm4gdm4oeCx4aSx5LHlpLDE2KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8zMih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwzMik7XG59XG5cbi8qXG4qIFBvcnQgb2YgQW5kcmV3IE1vb24ncyBQb2x5MTMwNS1kb25uYS0xNi4gUHVibGljIGRvbWFpbi5cbiogaHR0cHM6Ly9naXRodWIuY29tL2Zsb29keWJlcnJ5L3BvbHkxMzA1LWRvbm5hXG4qL1xuXG52YXIgcG9seTEzMDUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMuaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHRoaXMucGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgdGhpcy5maW4gPSAwO1xuXG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDc7XG5cbiAgdDAgPSBrZXlbIDBdICYgMHhmZiB8IChrZXlbIDFdICYgMHhmZikgPDwgODsgdGhpcy5yWzBdID0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gIHQxID0ga2V5WyAyXSAmIDB4ZmYgfCAoa2V5WyAzXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICB0MiA9IGtleVsgNF0gJiAweGZmIHwgKGtleVsgNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWYwMztcbiAgdDMgPSBrZXlbIDZdICYgMHhmZiB8IChrZXlbIDddICYgMHhmZikgPDwgODsgdGhpcy5yWzNdID0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gIHQ0ID0ga2V5WyA4XSAmIDB4ZmYgfCAoa2V5WyA5XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls0XSA9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgwMGZmO1xuICB0aGlzLnJbNV0gPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZlO1xuICB0NSA9IGtleVsxMF0gJiAweGZmIHwgKGtleVsxMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgdDYgPSBrZXlbMTJdICYgMHhmZiB8IChrZXlbMTNdICYgMHhmZikgPDwgODsgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmODE7XG4gIHQ3ID0ga2V5WzE0XSAmIDB4ZmYgfCAoa2V5WzE1XSAmIDB4ZmYpIDw8IDg7IHRoaXMucls4XSA9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICB0aGlzLnJbOV0gPSAoKHQ3ID4+PiAgNSkpICYgMHgwMDdmO1xuXG4gIHRoaXMucGFkWzBdID0ga2V5WzE2XSAmIDB4ZmYgfCAoa2V5WzE3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzFdID0ga2V5WzE4XSAmIDB4ZmYgfCAoa2V5WzE5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzJdID0ga2V5WzIwXSAmIDB4ZmYgfCAoa2V5WzIxXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzNdID0ga2V5WzIyXSAmIDB4ZmYgfCAoa2V5WzIzXSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzRdID0ga2V5WzI0XSAmIDB4ZmYgfCAoa2V5WzI1XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzVdID0ga2V5WzI2XSAmIDB4ZmYgfCAoa2V5WzI3XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzZdID0ga2V5WzI4XSAmIDB4ZmYgfCAoa2V5WzI5XSAmIDB4ZmYpIDw8IDg7XG4gIHRoaXMucGFkWzddID0ga2V5WzMwXSAmIDB4ZmYgfCAoa2V5WzMxXSAmIDB4ZmYpIDw8IDg7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuYmxvY2tzID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGhpYml0ID0gdGhpcy5maW4gPyAwIDogKDEgPDwgMTEpO1xuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3LCBjO1xuICB2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDk7XG5cbiAgdmFyIGgwID0gdGhpcy5oWzBdLFxuICAgICAgaDEgPSB0aGlzLmhbMV0sXG4gICAgICBoMiA9IHRoaXMuaFsyXSxcbiAgICAgIGgzID0gdGhpcy5oWzNdLFxuICAgICAgaDQgPSB0aGlzLmhbNF0sXG4gICAgICBoNSA9IHRoaXMuaFs1XSxcbiAgICAgIGg2ID0gdGhpcy5oWzZdLFxuICAgICAgaDcgPSB0aGlzLmhbN10sXG4gICAgICBoOCA9IHRoaXMuaFs4XSxcbiAgICAgIGg5ID0gdGhpcy5oWzldO1xuXG4gIHZhciByMCA9IHRoaXMuclswXSxcbiAgICAgIHIxID0gdGhpcy5yWzFdLFxuICAgICAgcjIgPSB0aGlzLnJbMl0sXG4gICAgICByMyA9IHRoaXMuclszXSxcbiAgICAgIHI0ID0gdGhpcy5yWzRdLFxuICAgICAgcjUgPSB0aGlzLnJbNV0sXG4gICAgICByNiA9IHRoaXMucls2XSxcbiAgICAgIHI3ID0gdGhpcy5yWzddLFxuICAgICAgcjggPSB0aGlzLnJbOF0sXG4gICAgICByOSA9IHRoaXMucls5XTtcblxuICB3aGlsZSAoYnl0ZXMgPj0gMTYpIHtcbiAgICB0MCA9IG1bbXBvcysgMF0gJiAweGZmIHwgKG1bbXBvcysgMV0gJiAweGZmKSA8PCA4OyBoMCArPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgICB0MSA9IG1bbXBvcysgMl0gJiAweGZmIHwgKG1bbXBvcysgM10gJiAweGZmKSA8PCA4OyBoMSArPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgICB0MiA9IG1bbXBvcysgNF0gJiAweGZmIHwgKG1bbXBvcysgNV0gJiAweGZmKSA8PCA4OyBoMiArPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgIDYpKSAmIDB4MWZmZjtcbiAgICB0MyA9IG1bbXBvcysgNl0gJiAweGZmIHwgKG1bbXBvcysgN10gJiAweGZmKSA8PCA4OyBoMyArPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgICB0NCA9IG1bbXBvcysgOF0gJiAweGZmIHwgKG1bbXBvcysgOV0gJiAweGZmKSA8PCA4OyBoNCArPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZjtcbiAgICBoNSArPSAoKHQ0ID4+PiAgMSkpICYgMHgxZmZmO1xuICAgIHQ1ID0gbVttcG9zKzEwXSAmIDB4ZmYgfCAobVttcG9zKzExXSAmIDB4ZmYpIDw8IDg7IGg2ICs9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICAgIHQ2ID0gbVttcG9zKzEyXSAmIDB4ZmYgfCAobVttcG9zKzEzXSAmIDB4ZmYpIDw8IDg7IGg3ICs9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZmZmO1xuICAgIHQ3ID0gbVttcG9zKzE0XSAmIDB4ZmYgfCAobVttcG9zKzE1XSAmIDB4ZmYpIDw8IDg7IGg4ICs9ICgodDYgPj4+ICA4KSB8ICh0NyA8PCAgOCkpICYgMHgxZmZmO1xuICAgIGg5ICs9ICgodDcgPj4+IDUpKSB8IGhpYml0O1xuXG4gICAgYyA9IDA7XG5cbiAgICBkMCA9IGM7XG4gICAgZDAgKz0gaDAgKiByMDtcbiAgICBkMCArPSBoMSAqICg1ICogcjkpO1xuICAgIGQwICs9IGgyICogKDUgKiByOCk7XG4gICAgZDAgKz0gaDMgKiAoNSAqIHI3KTtcbiAgICBkMCArPSBoNCAqICg1ICogcjYpO1xuICAgIGMgPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuICAgIGQwICs9IGg1ICogKDUgKiByNSk7XG4gICAgZDAgKz0gaDYgKiAoNSAqIHI0KTtcbiAgICBkMCArPSBoNyAqICg1ICogcjMpO1xuICAgIGQwICs9IGg4ICogKDUgKiByMik7XG4gICAgZDAgKz0gaDkgKiAoNSAqIHIxKTtcbiAgICBjICs9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG5cbiAgICBkMSA9IGM7XG4gICAgZDEgKz0gaDAgKiByMTtcbiAgICBkMSArPSBoMSAqIHIwO1xuICAgIGQxICs9IGgyICogKDUgKiByOSk7XG4gICAgZDEgKz0gaDMgKiAoNSAqIHI4KTtcbiAgICBkMSArPSBoNCAqICg1ICogcjcpO1xuICAgIGMgPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuICAgIGQxICs9IGg1ICogKDUgKiByNik7XG4gICAgZDEgKz0gaDYgKiAoNSAqIHI1KTtcbiAgICBkMSArPSBoNyAqICg1ICogcjQpO1xuICAgIGQxICs9IGg4ICogKDUgKiByMyk7XG4gICAgZDEgKz0gaDkgKiAoNSAqIHIyKTtcbiAgICBjICs9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG5cbiAgICBkMiA9IGM7XG4gICAgZDIgKz0gaDAgKiByMjtcbiAgICBkMiArPSBoMSAqIHIxO1xuICAgIGQyICs9IGgyICogcjA7XG4gICAgZDIgKz0gaDMgKiAoNSAqIHI5KTtcbiAgICBkMiArPSBoNCAqICg1ICogcjgpO1xuICAgIGMgPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuICAgIGQyICs9IGg1ICogKDUgKiByNyk7XG4gICAgZDIgKz0gaDYgKiAoNSAqIHI2KTtcbiAgICBkMiArPSBoNyAqICg1ICogcjUpO1xuICAgIGQyICs9IGg4ICogKDUgKiByNCk7XG4gICAgZDIgKz0gaDkgKiAoNSAqIHIzKTtcbiAgICBjICs9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG5cbiAgICBkMyA9IGM7XG4gICAgZDMgKz0gaDAgKiByMztcbiAgICBkMyArPSBoMSAqIHIyO1xuICAgIGQzICs9IGgyICogcjE7XG4gICAgZDMgKz0gaDMgKiByMDtcbiAgICBkMyArPSBoNCAqICg1ICogcjkpO1xuICAgIGMgPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuICAgIGQzICs9IGg1ICogKDUgKiByOCk7XG4gICAgZDMgKz0gaDYgKiAoNSAqIHI3KTtcbiAgICBkMyArPSBoNyAqICg1ICogcjYpO1xuICAgIGQzICs9IGg4ICogKDUgKiByNSk7XG4gICAgZDMgKz0gaDkgKiAoNSAqIHI0KTtcbiAgICBjICs9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG5cbiAgICBkNCA9IGM7XG4gICAgZDQgKz0gaDAgKiByNDtcbiAgICBkNCArPSBoMSAqIHIzO1xuICAgIGQ0ICs9IGgyICogcjI7XG4gICAgZDQgKz0gaDMgKiByMTtcbiAgICBkNCArPSBoNCAqIHIwO1xuICAgIGMgPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuICAgIGQ0ICs9IGg1ICogKDUgKiByOSk7XG4gICAgZDQgKz0gaDYgKiAoNSAqIHI4KTtcbiAgICBkNCArPSBoNyAqICg1ICogcjcpO1xuICAgIGQ0ICs9IGg4ICogKDUgKiByNik7XG4gICAgZDQgKz0gaDkgKiAoNSAqIHI1KTtcbiAgICBjICs9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG5cbiAgICBkNSA9IGM7XG4gICAgZDUgKz0gaDAgKiByNTtcbiAgICBkNSArPSBoMSAqIHI0O1xuICAgIGQ1ICs9IGgyICogcjM7XG4gICAgZDUgKz0gaDMgKiByMjtcbiAgICBkNSArPSBoNCAqIHIxO1xuICAgIGMgPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuICAgIGQ1ICs9IGg1ICogcjA7XG4gICAgZDUgKz0gaDYgKiAoNSAqIHI5KTtcbiAgICBkNSArPSBoNyAqICg1ICogcjgpO1xuICAgIGQ1ICs9IGg4ICogKDUgKiByNyk7XG4gICAgZDUgKz0gaDkgKiAoNSAqIHI2KTtcbiAgICBjICs9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG5cbiAgICBkNiA9IGM7XG4gICAgZDYgKz0gaDAgKiByNjtcbiAgICBkNiArPSBoMSAqIHI1O1xuICAgIGQ2ICs9IGgyICogcjQ7XG4gICAgZDYgKz0gaDMgKiByMztcbiAgICBkNiArPSBoNCAqIHIyO1xuICAgIGMgPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuICAgIGQ2ICs9IGg1ICogcjE7XG4gICAgZDYgKz0gaDYgKiByMDtcbiAgICBkNiArPSBoNyAqICg1ICogcjkpO1xuICAgIGQ2ICs9IGg4ICogKDUgKiByOCk7XG4gICAgZDYgKz0gaDkgKiAoNSAqIHI3KTtcbiAgICBjICs9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG5cbiAgICBkNyA9IGM7XG4gICAgZDcgKz0gaDAgKiByNztcbiAgICBkNyArPSBoMSAqIHI2O1xuICAgIGQ3ICs9IGgyICogcjU7XG4gICAgZDcgKz0gaDMgKiByNDtcbiAgICBkNyArPSBoNCAqIHIzO1xuICAgIGMgPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuICAgIGQ3ICs9IGg1ICogcjI7XG4gICAgZDcgKz0gaDYgKiByMTtcbiAgICBkNyArPSBoNyAqIHIwO1xuICAgIGQ3ICs9IGg4ICogKDUgKiByOSk7XG4gICAgZDcgKz0gaDkgKiAoNSAqIHI4KTtcbiAgICBjICs9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG5cbiAgICBkOCA9IGM7XG4gICAgZDggKz0gaDAgKiByODtcbiAgICBkOCArPSBoMSAqIHI3O1xuICAgIGQ4ICs9IGgyICogcjY7XG4gICAgZDggKz0gaDMgKiByNTtcbiAgICBkOCArPSBoNCAqIHI0O1xuICAgIGMgPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuICAgIGQ4ICs9IGg1ICogcjM7XG4gICAgZDggKz0gaDYgKiByMjtcbiAgICBkOCArPSBoNyAqIHIxO1xuICAgIGQ4ICs9IGg4ICogcjA7XG4gICAgZDggKz0gaDkgKiAoNSAqIHI5KTtcbiAgICBjICs9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG5cbiAgICBkOSA9IGM7XG4gICAgZDkgKz0gaDAgKiByOTtcbiAgICBkOSArPSBoMSAqIHI4O1xuICAgIGQ5ICs9IGgyICogcjc7XG4gICAgZDkgKz0gaDMgKiByNjtcbiAgICBkOSArPSBoNCAqIHI1O1xuICAgIGMgPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuICAgIGQ5ICs9IGg1ICogcjQ7XG4gICAgZDkgKz0gaDYgKiByMztcbiAgICBkOSArPSBoNyAqIHIyO1xuICAgIGQ5ICs9IGg4ICogcjE7XG4gICAgZDkgKz0gaDkgKiByMDtcbiAgICBjICs9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG5cbiAgICBjID0gKCgoYyA8PCAyKSArIGMpKSB8IDA7XG4gICAgYyA9IChjICsgZDApIHwgMDtcbiAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgYyA9IChjID4+PiAxMyk7XG4gICAgZDEgKz0gYztcblxuICAgIGgwID0gZDA7XG4gICAgaDEgPSBkMTtcbiAgICBoMiA9IGQyO1xuICAgIGgzID0gZDM7XG4gICAgaDQgPSBkNDtcbiAgICBoNSA9IGQ1O1xuICAgIGg2ID0gZDY7XG4gICAgaDcgPSBkNztcbiAgICBoOCA9IGQ4O1xuICAgIGg5ID0gZDk7XG5cbiAgICBtcG9zICs9IDE2O1xuICAgIGJ5dGVzIC09IDE2O1xuICB9XG4gIHRoaXMuaFswXSA9IGgwO1xuICB0aGlzLmhbMV0gPSBoMTtcbiAgdGhpcy5oWzJdID0gaDI7XG4gIHRoaXMuaFszXSA9IGgzO1xuICB0aGlzLmhbNF0gPSBoNDtcbiAgdGhpcy5oWzVdID0gaDU7XG4gIHRoaXMuaFs2XSA9IGg2O1xuICB0aGlzLmhbN10gPSBoNztcbiAgdGhpcy5oWzhdID0gaDg7XG4gIHRoaXMuaFs5XSA9IGg5O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKG1hYywgbWFjcG9zKSB7XG4gIHZhciBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdmFyIGMsIG1hc2ssIGYsIGk7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICBpID0gdGhpcy5sZWZ0b3ZlcjtcbiAgICB0aGlzLmJ1ZmZlcltpKytdID0gMTtcbiAgICBmb3IgKDsgaSA8IDE2OyBpKyspIHRoaXMuYnVmZmVyW2ldID0gMDtcbiAgICB0aGlzLmZpbiA9IDE7XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgfVxuXG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgIHRoaXMuaFtpXSArPSBjO1xuICAgIGMgPSB0aGlzLmhbaV0gPj4+IDEzO1xuICAgIHRoaXMuaFtpXSAmPSAweDFmZmY7XG4gIH1cbiAgdGhpcy5oWzBdICs9IChjICogNSk7XG4gIGMgPSB0aGlzLmhbMF0gPj4+IDEzO1xuICB0aGlzLmhbMF0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMV0gKz0gYztcbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsyXSArPSBjO1xuXG4gIGdbMF0gPSB0aGlzLmhbMF0gKyA1O1xuICBjID0gZ1swXSA+Pj4gMTM7XG4gIGdbMF0gJj0gMHgxZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgIGdbaV0gPSB0aGlzLmhbaV0gKyBjO1xuICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICBnW2ldICY9IDB4MWZmZjtcbiAgfVxuICBnWzldIC09ICgxIDw8IDEzKTtcblxuICBtYXNrID0gKGMgXiAxKSAtIDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSBnW2ldICY9IG1hc2s7XG4gIG1hc2sgPSB+bWFzaztcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHRoaXMuaFtpXSA9ICh0aGlzLmhbaV0gJiBtYXNrKSB8IGdbaV07XG5cbiAgdGhpcy5oWzBdID0gKCh0aGlzLmhbMF0gICAgICAgKSB8ICh0aGlzLmhbMV0gPDwgMTMpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMV0gPSAoKHRoaXMuaFsxXSA+Pj4gIDMpIHwgKHRoaXMuaFsyXSA8PCAxMCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsyXSA9ICgodGhpcy5oWzJdID4+PiAgNikgfCAodGhpcy5oWzNdIDw8ICA3KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzNdID0gKCh0aGlzLmhbM10gPj4+ICA5KSB8ICh0aGlzLmhbNF0gPDwgIDQpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNF0gPSAoKHRoaXMuaFs0XSA+Pj4gMTIpIHwgKHRoaXMuaFs1XSA8PCAgMSkgfCAodGhpcy5oWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gIHRoaXMuaFs1XSA9ICgodGhpcy5oWzZdID4+PiAgMikgfCAodGhpcy5oWzddIDw8IDExKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzZdID0gKCh0aGlzLmhbN10gPj4+ICA1KSB8ICh0aGlzLmhbOF0gPDwgIDgpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbN10gPSAoKHRoaXMuaFs4XSA+Pj4gIDgpIHwgKHRoaXMuaFs5XSA8PCAgNSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG5cbiAgZiA9IHRoaXMuaFswXSArIHRoaXMucGFkWzBdO1xuICB0aGlzLmhbMF0gPSBmICYgMHhmZmZmO1xuICBmb3IgKGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgZiA9ICgoKHRoaXMuaFtpXSArIHRoaXMucGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgIHRoaXMuaFtpXSA9IGYgJiAweGZmZmY7XG4gIH1cblxuICBtYWNbbWFjcG9zKyAwXSA9ICh0aGlzLmhbMF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMV0gPSAodGhpcy5oWzBdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDJdID0gKHRoaXMuaFsxXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAzXSA9ICh0aGlzLmhbMV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNF0gPSAodGhpcy5oWzJdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDVdID0gKHRoaXMuaFsyXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA2XSA9ICh0aGlzLmhbM10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgN10gPSAodGhpcy5oWzNdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDhdID0gKHRoaXMuaFs0XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA5XSA9ICh0aGlzLmhbNF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMF0gPSAodGhpcy5oWzVdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTFdID0gKHRoaXMuaFs1XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEyXSA9ICh0aGlzLmhbNl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxM10gPSAodGhpcy5oWzZdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTRdID0gKHRoaXMuaFs3XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE1XSA9ICh0aGlzLmhbN10gPj4+IDgpICYgMHhmZjtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaSwgd2FudDtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIHdhbnQgPSAoMTYgLSB0aGlzLmxlZnRvdmVyKTtcbiAgICBpZiAod2FudCA+IGJ5dGVzKVxuICAgICAgd2FudCA9IGJ5dGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YW50OyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgdGhpcy5sZWZ0b3ZlciArPSB3YW50O1xuICAgIGlmICh0aGlzLmxlZnRvdmVyIDwgMTYpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ibG9ja3ModGhpcy5idWZmZXIsIDAsIDE2KTtcbiAgICB0aGlzLmxlZnRvdmVyID0gMDtcbiAgfVxuXG4gIGlmIChieXRlcyA+PSAxNikge1xuICAgIHdhbnQgPSBieXRlcyAtIChieXRlcyAlIDE2KTtcbiAgICB0aGlzLmJsb2NrcyhtLCBtcG9zLCB3YW50KTtcbiAgICBtcG9zICs9IHdhbnQ7XG4gICAgYnl0ZXMgLT0gd2FudDtcbiAgfVxuXG4gIGlmIChieXRlcykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIHRoaXMubGVmdG92ZXIgKz0gYnl0ZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1feG9yIChjLCBjcG9zLCBtLCBtcG9zLCBjbGVuLCBuLCBrKSB7XG4gIGNzLmNyeXB0b19zdHJlYW1feG9yKGMsIG0sIG4sIGspXG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW0gKGMsIGNwb3MsIGNsZW4sIG4sIGspIHtcbiAgY3MuY3J5cHRvX3N0cmVhbShjLCBuLCBrKVxufVxuXG5mdW5jdGlvbiBjcnlwdG9fb25ldGltZWF1dGgob3V0LCBvdXRwb3MsIG0sIG1wb3MsIG4sIGspIHtcbiAgdmFyIHMgPSBuZXcgcG9seTEzMDUoayk7XG4gIHMudXBkYXRlKG0sIG1wb3MsIG4pO1xuICBzLmZpbmlzaChvdXQsIG91dHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5KGgsIGhwb3MsIG0sIG1wb3MsIG4sIGspIHtcbiAgdmFyIHggPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGNyeXB0b19vbmV0aW1lYXV0aCh4LDAsbSxtcG9zLG4sayk7XG4gIHJldHVybiBjcnlwdG9fdmVyaWZ5XzE2KGgsaHBvcyx4LDApO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94KGMsbSxkLG4saykge1xuICB2YXIgaTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtX3hvcihjLDAsbSwwLGQsbixrKTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKGMsIDE2LCBjLCAzMiwgZCAtIDMyLCBjKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIGNbaV0gPSAwO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveF9vcGVuKG0sYyxkLG4saykge1xuICB2YXIgaTtcbiAgdmFyIHggPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGlmIChkIDwgMzIpIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbSh4LDAsMzIsbixrKTtcbiAgaWYgKGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoYywgMTYsYywgMzIsZCAtIDMyLHgpICE9PSAwKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKG0sMCxjLDAsZCxuLGspO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgbVtpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBzZXQyNTUxOShyLCBhKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgcltpXSA9IGFbaV18MDtcbn1cblxuZnVuY3Rpb24gY2FyMjU1MTkobykge1xuICB2YXIgaSwgdiwgYyA9IDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdiA9IG9baV0gKyBjICsgNjU1MzU7XG4gICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICBvW2ldID0gdiAtIGMgKiA2NTUzNjtcbiAgfVxuICBvWzBdICs9IGMtMSArIDM3ICogKGMtMSk7XG59XG5cbmZ1bmN0aW9uIHNlbDI1NTE5KHAsIHEsIGIpIHtcbiAgdmFyIHQsIGMgPSB+KGItMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHQgPSBjICYgKHBbaV0gXiBxW2ldKTtcbiAgICBwW2ldIF49IHQ7XG4gICAgcVtpXSBePSB0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhY2syNTUxOShvLCBuKSB7XG4gIHZhciBpLCBqLCBiO1xuICB2YXIgbSA9IGdmKCksIHQgPSBnZigpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgdFtpXSA9IG5baV07XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgY2FyMjU1MTkodCk7XG4gIGZvciAoaiA9IDA7IGogPCAyOyBqKyspIHtcbiAgICBtWzBdID0gdFswXSAtIDB4ZmZlZDtcbiAgICBmb3IgKGkgPSAxOyBpIDwgMTU7IGkrKykge1xuICAgICAgbVtpXSA9IHRbaV0gLSAweGZmZmYgLSAoKG1baS0xXT4+MTYpICYgMSk7XG4gICAgICBtW2ktMV0gJj0gMHhmZmZmO1xuICAgIH1cbiAgICBtWzE1XSA9IHRbMTVdIC0gMHg3ZmZmIC0gKChtWzE0XT4+MTYpICYgMSk7XG4gICAgYiA9IChtWzE1XT4+MTYpICYgMTtcbiAgICBtWzE0XSAmPSAweGZmZmY7XG4gICAgc2VsMjU1MTkodCwgbSwgMS1iKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIG9bMippXSA9IHRbaV0gJiAweGZmO1xuICAgIG9bMippKzFdID0gdFtpXT4+ODtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXEyNTUxOShhLCBiKSB7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBwYWNrMjU1MTkoYywgYSk7XG4gIHBhY2syNTUxOShkLCBiKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMzIoYywgMCwgZCwgMCk7XG59XG5cbmZ1bmN0aW9uIHBhcjI1NTE5KGEpIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShkLCBhKTtcbiAgcmV0dXJuIGRbMF0gJiAxO1xufVxuXG5mdW5jdGlvbiB1bnBhY2syNTUxOShvLCBuKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IG5bMippXSArIChuWzIqaSsxXSA8PCA4KTtcbiAgb1sxNV0gJj0gMHg3ZmZmO1xufVxuXG5mdW5jdGlvbiBBKG8sIGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gYVtpXSArIGJbaV07XG59XG5cbmZ1bmN0aW9uIFoobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldIC0gYltpXTtcbn1cblxuZnVuY3Rpb24gTShvLCBhLCBiKSB7XG4gIHZhciB2LCBjLFxuICAgICB0MCA9IDAsICB0MSA9IDAsICB0MiA9IDAsICB0MyA9IDAsICB0NCA9IDAsICB0NSA9IDAsICB0NiA9IDAsICB0NyA9IDAsXG4gICAgIHQ4ID0gMCwgIHQ5ID0gMCwgdDEwID0gMCwgdDExID0gMCwgdDEyID0gMCwgdDEzID0gMCwgdDE0ID0gMCwgdDE1ID0gMCxcbiAgICB0MTYgPSAwLCB0MTcgPSAwLCB0MTggPSAwLCB0MTkgPSAwLCB0MjAgPSAwLCB0MjEgPSAwLCB0MjIgPSAwLCB0MjMgPSAwLFxuICAgIHQyNCA9IDAsIHQyNSA9IDAsIHQyNiA9IDAsIHQyNyA9IDAsIHQyOCA9IDAsIHQyOSA9IDAsIHQzMCA9IDAsXG4gICAgYjAgPSBiWzBdLFxuICAgIGIxID0gYlsxXSxcbiAgICBiMiA9IGJbMl0sXG4gICAgYjMgPSBiWzNdLFxuICAgIGI0ID0gYls0XSxcbiAgICBiNSA9IGJbNV0sXG4gICAgYjYgPSBiWzZdLFxuICAgIGI3ID0gYls3XSxcbiAgICBiOCA9IGJbOF0sXG4gICAgYjkgPSBiWzldLFxuICAgIGIxMCA9IGJbMTBdLFxuICAgIGIxMSA9IGJbMTFdLFxuICAgIGIxMiA9IGJbMTJdLFxuICAgIGIxMyA9IGJbMTNdLFxuICAgIGIxNCA9IGJbMTRdLFxuICAgIGIxNSA9IGJbMTVdO1xuXG4gIHYgPSBhWzBdO1xuICB0MCArPSB2ICogYjA7XG4gIHQxICs9IHYgKiBiMTtcbiAgdDIgKz0gdiAqIGIyO1xuICB0MyArPSB2ICogYjM7XG4gIHQ0ICs9IHYgKiBiNDtcbiAgdDUgKz0gdiAqIGI1O1xuICB0NiArPSB2ICogYjY7XG4gIHQ3ICs9IHYgKiBiNztcbiAgdDggKz0gdiAqIGI4O1xuICB0OSArPSB2ICogYjk7XG4gIHQxMCArPSB2ICogYjEwO1xuICB0MTEgKz0gdiAqIGIxMTtcbiAgdDEyICs9IHYgKiBiMTI7XG4gIHQxMyArPSB2ICogYjEzO1xuICB0MTQgKz0gdiAqIGIxNDtcbiAgdDE1ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzFdO1xuICB0MSArPSB2ICogYjA7XG4gIHQyICs9IHYgKiBiMTtcbiAgdDMgKz0gdiAqIGIyO1xuICB0NCArPSB2ICogYjM7XG4gIHQ1ICs9IHYgKiBiNDtcbiAgdDYgKz0gdiAqIGI1O1xuICB0NyArPSB2ICogYjY7XG4gIHQ4ICs9IHYgKiBiNztcbiAgdDkgKz0gdiAqIGI4O1xuICB0MTAgKz0gdiAqIGI5O1xuICB0MTEgKz0gdiAqIGIxMDtcbiAgdDEyICs9IHYgKiBiMTE7XG4gIHQxMyArPSB2ICogYjEyO1xuICB0MTQgKz0gdiAqIGIxMztcbiAgdDE1ICs9IHYgKiBiMTQ7XG4gIHQxNiArPSB2ICogYjE1O1xuICB2ID0gYVsyXTtcbiAgdDIgKz0gdiAqIGIwO1xuICB0MyArPSB2ICogYjE7XG4gIHQ0ICs9IHYgKiBiMjtcbiAgdDUgKz0gdiAqIGIzO1xuICB0NiArPSB2ICogYjQ7XG4gIHQ3ICs9IHYgKiBiNTtcbiAgdDggKz0gdiAqIGI2O1xuICB0OSArPSB2ICogYjc7XG4gIHQxMCArPSB2ICogYjg7XG4gIHQxMSArPSB2ICogYjk7XG4gIHQxMiArPSB2ICogYjEwO1xuICB0MTMgKz0gdiAqIGIxMTtcbiAgdDE0ICs9IHYgKiBiMTI7XG4gIHQxNSArPSB2ICogYjEzO1xuICB0MTYgKz0gdiAqIGIxNDtcbiAgdDE3ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzNdO1xuICB0MyArPSB2ICogYjA7XG4gIHQ0ICs9IHYgKiBiMTtcbiAgdDUgKz0gdiAqIGIyO1xuICB0NiArPSB2ICogYjM7XG4gIHQ3ICs9IHYgKiBiNDtcbiAgdDggKz0gdiAqIGI1O1xuICB0OSArPSB2ICogYjY7XG4gIHQxMCArPSB2ICogYjc7XG4gIHQxMSArPSB2ICogYjg7XG4gIHQxMiArPSB2ICogYjk7XG4gIHQxMyArPSB2ICogYjEwO1xuICB0MTQgKz0gdiAqIGIxMTtcbiAgdDE1ICs9IHYgKiBiMTI7XG4gIHQxNiArPSB2ICogYjEzO1xuICB0MTcgKz0gdiAqIGIxNDtcbiAgdDE4ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzRdO1xuICB0NCArPSB2ICogYjA7XG4gIHQ1ICs9IHYgKiBiMTtcbiAgdDYgKz0gdiAqIGIyO1xuICB0NyArPSB2ICogYjM7XG4gIHQ4ICs9IHYgKiBiNDtcbiAgdDkgKz0gdiAqIGI1O1xuICB0MTAgKz0gdiAqIGI2O1xuICB0MTEgKz0gdiAqIGI3O1xuICB0MTIgKz0gdiAqIGI4O1xuICB0MTMgKz0gdiAqIGI5O1xuICB0MTQgKz0gdiAqIGIxMDtcbiAgdDE1ICs9IHYgKiBiMTE7XG4gIHQxNiArPSB2ICogYjEyO1xuICB0MTcgKz0gdiAqIGIxMztcbiAgdDE4ICs9IHYgKiBiMTQ7XG4gIHQxOSArPSB2ICogYjE1O1xuICB2ID0gYVs1XTtcbiAgdDUgKz0gdiAqIGIwO1xuICB0NiArPSB2ICogYjE7XG4gIHQ3ICs9IHYgKiBiMjtcbiAgdDggKz0gdiAqIGIzO1xuICB0OSArPSB2ICogYjQ7XG4gIHQxMCArPSB2ICogYjU7XG4gIHQxMSArPSB2ICogYjY7XG4gIHQxMiArPSB2ICogYjc7XG4gIHQxMyArPSB2ICogYjg7XG4gIHQxNCArPSB2ICogYjk7XG4gIHQxNSArPSB2ICogYjEwO1xuICB0MTYgKz0gdiAqIGIxMTtcbiAgdDE3ICs9IHYgKiBiMTI7XG4gIHQxOCArPSB2ICogYjEzO1xuICB0MTkgKz0gdiAqIGIxNDtcbiAgdDIwICs9IHYgKiBiMTU7XG4gIHYgPSBhWzZdO1xuICB0NiArPSB2ICogYjA7XG4gIHQ3ICs9IHYgKiBiMTtcbiAgdDggKz0gdiAqIGIyO1xuICB0OSArPSB2ICogYjM7XG4gIHQxMCArPSB2ICogYjQ7XG4gIHQxMSArPSB2ICogYjU7XG4gIHQxMiArPSB2ICogYjY7XG4gIHQxMyArPSB2ICogYjc7XG4gIHQxNCArPSB2ICogYjg7XG4gIHQxNSArPSB2ICogYjk7XG4gIHQxNiArPSB2ICogYjEwO1xuICB0MTcgKz0gdiAqIGIxMTtcbiAgdDE4ICs9IHYgKiBiMTI7XG4gIHQxOSArPSB2ICogYjEzO1xuICB0MjAgKz0gdiAqIGIxNDtcbiAgdDIxICs9IHYgKiBiMTU7XG4gIHYgPSBhWzddO1xuICB0NyArPSB2ICogYjA7XG4gIHQ4ICs9IHYgKiBiMTtcbiAgdDkgKz0gdiAqIGIyO1xuICB0MTAgKz0gdiAqIGIzO1xuICB0MTEgKz0gdiAqIGI0O1xuICB0MTIgKz0gdiAqIGI1O1xuICB0MTMgKz0gdiAqIGI2O1xuICB0MTQgKz0gdiAqIGI3O1xuICB0MTUgKz0gdiAqIGI4O1xuICB0MTYgKz0gdiAqIGI5O1xuICB0MTcgKz0gdiAqIGIxMDtcbiAgdDE4ICs9IHYgKiBiMTE7XG4gIHQxOSArPSB2ICogYjEyO1xuICB0MjAgKz0gdiAqIGIxMztcbiAgdDIxICs9IHYgKiBiMTQ7XG4gIHQyMiArPSB2ICogYjE1O1xuICB2ID0gYVs4XTtcbiAgdDggKz0gdiAqIGIwO1xuICB0OSArPSB2ICogYjE7XG4gIHQxMCArPSB2ICogYjI7XG4gIHQxMSArPSB2ICogYjM7XG4gIHQxMiArPSB2ICogYjQ7XG4gIHQxMyArPSB2ICogYjU7XG4gIHQxNCArPSB2ICogYjY7XG4gIHQxNSArPSB2ICogYjc7XG4gIHQxNiArPSB2ICogYjg7XG4gIHQxNyArPSB2ICogYjk7XG4gIHQxOCArPSB2ICogYjEwO1xuICB0MTkgKz0gdiAqIGIxMTtcbiAgdDIwICs9IHYgKiBiMTI7XG4gIHQyMSArPSB2ICogYjEzO1xuICB0MjIgKz0gdiAqIGIxNDtcbiAgdDIzICs9IHYgKiBiMTU7XG4gIHYgPSBhWzldO1xuICB0OSArPSB2ICogYjA7XG4gIHQxMCArPSB2ICogYjE7XG4gIHQxMSArPSB2ICogYjI7XG4gIHQxMiArPSB2ICogYjM7XG4gIHQxMyArPSB2ICogYjQ7XG4gIHQxNCArPSB2ICogYjU7XG4gIHQxNSArPSB2ICogYjY7XG4gIHQxNiArPSB2ICogYjc7XG4gIHQxNyArPSB2ICogYjg7XG4gIHQxOCArPSB2ICogYjk7XG4gIHQxOSArPSB2ICogYjEwO1xuICB0MjAgKz0gdiAqIGIxMTtcbiAgdDIxICs9IHYgKiBiMTI7XG4gIHQyMiArPSB2ICogYjEzO1xuICB0MjMgKz0gdiAqIGIxNDtcbiAgdDI0ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEwXTtcbiAgdDEwICs9IHYgKiBiMDtcbiAgdDExICs9IHYgKiBiMTtcbiAgdDEyICs9IHYgKiBiMjtcbiAgdDEzICs9IHYgKiBiMztcbiAgdDE0ICs9IHYgKiBiNDtcbiAgdDE1ICs9IHYgKiBiNTtcbiAgdDE2ICs9IHYgKiBiNjtcbiAgdDE3ICs9IHYgKiBiNztcbiAgdDE4ICs9IHYgKiBiODtcbiAgdDE5ICs9IHYgKiBiOTtcbiAgdDIwICs9IHYgKiBiMTA7XG4gIHQyMSArPSB2ICogYjExO1xuICB0MjIgKz0gdiAqIGIxMjtcbiAgdDIzICs9IHYgKiBiMTM7XG4gIHQyNCArPSB2ICogYjE0O1xuICB0MjUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTFdO1xuICB0MTEgKz0gdiAqIGIwO1xuICB0MTIgKz0gdiAqIGIxO1xuICB0MTMgKz0gdiAqIGIyO1xuICB0MTQgKz0gdiAqIGIzO1xuICB0MTUgKz0gdiAqIGI0O1xuICB0MTYgKz0gdiAqIGI1O1xuICB0MTcgKz0gdiAqIGI2O1xuICB0MTggKz0gdiAqIGI3O1xuICB0MTkgKz0gdiAqIGI4O1xuICB0MjAgKz0gdiAqIGI5O1xuICB0MjEgKz0gdiAqIGIxMDtcbiAgdDIyICs9IHYgKiBiMTE7XG4gIHQyMyArPSB2ICogYjEyO1xuICB0MjQgKz0gdiAqIGIxMztcbiAgdDI1ICs9IHYgKiBiMTQ7XG4gIHQyNiArPSB2ICogYjE1O1xuICB2ID0gYVsxMl07XG4gIHQxMiArPSB2ICogYjA7XG4gIHQxMyArPSB2ICogYjE7XG4gIHQxNCArPSB2ICogYjI7XG4gIHQxNSArPSB2ICogYjM7XG4gIHQxNiArPSB2ICogYjQ7XG4gIHQxNyArPSB2ICogYjU7XG4gIHQxOCArPSB2ICogYjY7XG4gIHQxOSArPSB2ICogYjc7XG4gIHQyMCArPSB2ICogYjg7XG4gIHQyMSArPSB2ICogYjk7XG4gIHQyMiArPSB2ICogYjEwO1xuICB0MjMgKz0gdiAqIGIxMTtcbiAgdDI0ICs9IHYgKiBiMTI7XG4gIHQyNSArPSB2ICogYjEzO1xuICB0MjYgKz0gdiAqIGIxNDtcbiAgdDI3ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEzXTtcbiAgdDEzICs9IHYgKiBiMDtcbiAgdDE0ICs9IHYgKiBiMTtcbiAgdDE1ICs9IHYgKiBiMjtcbiAgdDE2ICs9IHYgKiBiMztcbiAgdDE3ICs9IHYgKiBiNDtcbiAgdDE4ICs9IHYgKiBiNTtcbiAgdDE5ICs9IHYgKiBiNjtcbiAgdDIwICs9IHYgKiBiNztcbiAgdDIxICs9IHYgKiBiODtcbiAgdDIyICs9IHYgKiBiOTtcbiAgdDIzICs9IHYgKiBiMTA7XG4gIHQyNCArPSB2ICogYjExO1xuICB0MjUgKz0gdiAqIGIxMjtcbiAgdDI2ICs9IHYgKiBiMTM7XG4gIHQyNyArPSB2ICogYjE0O1xuICB0MjggKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTRdO1xuICB0MTQgKz0gdiAqIGIwO1xuICB0MTUgKz0gdiAqIGIxO1xuICB0MTYgKz0gdiAqIGIyO1xuICB0MTcgKz0gdiAqIGIzO1xuICB0MTggKz0gdiAqIGI0O1xuICB0MTkgKz0gdiAqIGI1O1xuICB0MjAgKz0gdiAqIGI2O1xuICB0MjEgKz0gdiAqIGI3O1xuICB0MjIgKz0gdiAqIGI4O1xuICB0MjMgKz0gdiAqIGI5O1xuICB0MjQgKz0gdiAqIGIxMDtcbiAgdDI1ICs9IHYgKiBiMTE7XG4gIHQyNiArPSB2ICogYjEyO1xuICB0MjcgKz0gdiAqIGIxMztcbiAgdDI4ICs9IHYgKiBiMTQ7XG4gIHQyOSArPSB2ICogYjE1O1xuICB2ID0gYVsxNV07XG4gIHQxNSArPSB2ICogYjA7XG4gIHQxNiArPSB2ICogYjE7XG4gIHQxNyArPSB2ICogYjI7XG4gIHQxOCArPSB2ICogYjM7XG4gIHQxOSArPSB2ICogYjQ7XG4gIHQyMCArPSB2ICogYjU7XG4gIHQyMSArPSB2ICogYjY7XG4gIHQyMiArPSB2ICogYjc7XG4gIHQyMyArPSB2ICogYjg7XG4gIHQyNCArPSB2ICogYjk7XG4gIHQyNSArPSB2ICogYjEwO1xuICB0MjYgKz0gdiAqIGIxMTtcbiAgdDI3ICs9IHYgKiBiMTI7XG4gIHQyOCArPSB2ICogYjEzO1xuICB0MjkgKz0gdiAqIGIxNDtcbiAgdDMwICs9IHYgKiBiMTU7XG5cbiAgdDAgICs9IDM4ICogdDE2O1xuICB0MSAgKz0gMzggKiB0MTc7XG4gIHQyICArPSAzOCAqIHQxODtcbiAgdDMgICs9IDM4ICogdDE5O1xuICB0NCAgKz0gMzggKiB0MjA7XG4gIHQ1ICArPSAzOCAqIHQyMTtcbiAgdDYgICs9IDM4ICogdDIyO1xuICB0NyAgKz0gMzggKiB0MjM7XG4gIHQ4ICArPSAzOCAqIHQyNDtcbiAgdDkgICs9IDM4ICogdDI1O1xuICB0MTAgKz0gMzggKiB0MjY7XG4gIHQxMSArPSAzOCAqIHQyNztcbiAgdDEyICs9IDM4ICogdDI4O1xuICB0MTMgKz0gMzggKiB0Mjk7XG4gIHQxNCArPSAzOCAqIHQzMDtcbiAgLy8gdDE1IGxlZnQgYXMgaXNcblxuICAvLyBmaXJzdCBjYXJcbiAgYyA9IDE7XG4gIHYgPSAgdDAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDYgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDcgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDggKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDkgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNSA9IHYgLSBjICogNjU1MzY7XG4gIHQwICs9IGMtMSArIDM3ICogKGMtMSk7XG5cbiAgLy8gc2Vjb25kIGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICBvWyAwXSA9IHQwO1xuICBvWyAxXSA9IHQxO1xuICBvWyAyXSA9IHQyO1xuICBvWyAzXSA9IHQzO1xuICBvWyA0XSA9IHQ0O1xuICBvWyA1XSA9IHQ1O1xuICBvWyA2XSA9IHQ2O1xuICBvWyA3XSA9IHQ3O1xuICBvWyA4XSA9IHQ4O1xuICBvWyA5XSA9IHQ5O1xuICBvWzEwXSA9IHQxMDtcbiAgb1sxMV0gPSB0MTE7XG4gIG9bMTJdID0gdDEyO1xuICBvWzEzXSA9IHQxMztcbiAgb1sxNF0gPSB0MTQ7XG4gIG9bMTVdID0gdDE1O1xufVxuXG5mdW5jdGlvbiBTKG8sIGEpIHtcbiAgTShvLCBhLCBhKTtcbn1cblxuZnVuY3Rpb24gaW52MjU1MTkobywgaSkge1xuICB2YXIgYyA9IGdmKCk7XG4gIHZhciBhO1xuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgY1thXSA9IGlbYV07XG4gIGZvciAoYSA9IDI1MzsgYSA+PSAwOyBhLS0pIHtcbiAgICBTKGMsIGMpO1xuICAgIGlmKGEgIT09IDIgJiYgYSAhPT0gNCkgTShjLCBjLCBpKTtcbiAgfVxuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgb1thXSA9IGNbYV07XG59XG5cbmZ1bmN0aW9uIHBvdzI1MjMobywgaSkge1xuICB2YXIgYyA9IGdmKCk7XG4gIHZhciBhO1xuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgY1thXSA9IGlbYV07XG4gIGZvciAoYSA9IDI1MDsgYSA+PSAwOyBhLS0pIHtcbiAgICAgIFMoYywgYyk7XG4gICAgICBpZihhICE9PSAxKSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCkge1xuICBjaGVjayhxLCBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUylcbiAgY2hlY2sobiwgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMpXG4gIGNoZWNrKHAsIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKVxuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDgwKSwgciwgaTtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpO1xuICBmb3IgKGkgPSAwOyBpIDwgMzE7IGkrKykgeltpXSA9IG5baV07XG4gIHpbMzFdPShuWzMxXSYxMjcpfDY0O1xuICB6WzBdJj0yNDg7XG4gIHVucGFjazI1NTE5KHgscCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgYltpXT14W2ldO1xuICAgIGRbaV09YVtpXT1jW2ldPTA7XG4gIH1cbiAgYVswXT1kWzBdPTE7XG4gIGZvciAoaT0yNTQ7IGk+PTA7IC0taSkge1xuICAgIHI9KHpbaT4+PjNdPj4+KGkmNykpJjE7XG4gICAgc2VsMjU1MTkoYSxiLHIpO1xuICAgIHNlbDI1NTE5KGMsZCxyKTtcbiAgICBBKGUsYSxjKTtcbiAgICBaKGEsYSxjKTtcbiAgICBBKGMsYixkKTtcbiAgICBaKGIsYixkKTtcbiAgICBTKGQsZSk7XG4gICAgUyhmLGEpO1xuICAgIE0oYSxjLGEpO1xuICAgIE0oYyxiLGUpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIFMoYixhKTtcbiAgICBaKGMsZCxmKTtcbiAgICBNKGEsYyxfMTIxNjY1KTtcbiAgICBBKGEsYSxkKTtcbiAgICBNKGMsYyxhKTtcbiAgICBNKGEsZCxmKTtcbiAgICBNKGQsYix4KTtcbiAgICBTKGIsZSk7XG4gICAgc2VsMjU1MTkoYSxiLHIpO1xuICAgIHNlbDI1NTE5KGMsZCxyKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHhbaSsxNl09YVtpXTtcbiAgICB4W2krMzJdPWNbaV07XG4gICAgeFtpKzQ4XT1iW2ldO1xuICAgIHhbaSs2NF09ZFtpXTtcbiAgfVxuICB2YXIgeDMyID0geC5zdWJhcnJheSgzMik7XG4gIHZhciB4MTYgPSB4LnN1YmFycmF5KDE2KTtcbiAgaW52MjU1MTkoeDMyLHgzMik7XG4gIE0oeDE2LHgxNix4MzIpO1xuICBwYWNrMjU1MTkocSx4MTYpO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NjYWxhcm11bHRfYmFzZShxLCBuKSB7XG4gIHJldHVybiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBfOSk7XG59XG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG5mdW5jdGlvbiBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pIHtcbiAgdmFyIHdoID0gbmV3IEludDMyQXJyYXkoMTYpLCB3bCA9IG5ldyBJbnQzMkFycmF5KDE2KSxcbiAgICAgIGJoMCwgYmgxLCBiaDIsIGJoMywgYmg0LCBiaDUsIGJoNiwgYmg3LFxuICAgICAgYmwwLCBibDEsIGJsMiwgYmwzLCBibDQsIGJsNSwgYmw2LCBibDcsXG4gICAgICB0aCwgdGwsIGksIGosIGgsIGwsIGEsIGIsIGMsIGQ7XG5cbiAgdmFyIGFoMCA9IGhoWzBdLFxuICAgICAgYWgxID0gaGhbMV0sXG4gICAgICBhaDIgPSBoaFsyXSxcbiAgICAgIGFoMyA9IGhoWzNdLFxuICAgICAgYWg0ID0gaGhbNF0sXG4gICAgICBhaDUgPSBoaFs1XSxcbiAgICAgIGFoNiA9IGhoWzZdLFxuICAgICAgYWg3ID0gaGhbN10sXG5cbiAgICAgIGFsMCA9IGhsWzBdLFxuICAgICAgYWwxID0gaGxbMV0sXG4gICAgICBhbDIgPSBobFsyXSxcbiAgICAgIGFsMyA9IGhsWzNdLFxuICAgICAgYWw0ID0gaGxbNF0sXG4gICAgICBhbDUgPSBobFs1XSxcbiAgICAgIGFsNiA9IGhsWzZdLFxuICAgICAgYWw3ID0gaGxbN107XG5cbiAgdmFyIHBvcyA9IDA7XG4gIHdoaWxlIChuID49IDEyOCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBqID0gOCAqIGkgKyBwb3M7XG4gICAgICB3aFtpXSA9IChtW2orMF0gPDwgMjQpIHwgKG1baisxXSA8PCAxNikgfCAobVtqKzJdIDw8IDgpIHwgbVtqKzNdO1xuICAgICAgd2xbaV0gPSAobVtqKzRdIDw8IDI0KSB8IChtW2orNV0gPDwgMTYpIHwgKG1bais2XSA8PCA4KSB8IG1bais3XTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGJoMCA9IGFoMDtcbiAgICAgIGJoMSA9IGFoMTtcbiAgICAgIGJoMiA9IGFoMjtcbiAgICAgIGJoMyA9IGFoMztcbiAgICAgIGJoNCA9IGFoNDtcbiAgICAgIGJoNSA9IGFoNTtcbiAgICAgIGJoNiA9IGFoNjtcbiAgICAgIGJoNyA9IGFoNztcblxuICAgICAgYmwwID0gYWwwO1xuICAgICAgYmwxID0gYWwxO1xuICAgICAgYmwyID0gYWwyO1xuICAgICAgYmwzID0gYWwzO1xuICAgICAgYmw0ID0gYWw0O1xuICAgICAgYmw1ID0gYWw1O1xuICAgICAgYmw2ID0gYWw2O1xuICAgICAgYmw3ID0gYWw3O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBhaDc7XG4gICAgICBsID0gYWw3O1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWExXG4gICAgICBoID0gKChhaDQgPj4+IDE0KSB8IChhbDQgPDwgKDMyLTE0KSkpIF4gKChhaDQgPj4+IDE4KSB8IChhbDQgPDwgKDMyLTE4KSkpIF4gKChhbDQgPj4+ICg0MS0zMikpIHwgKGFoNCA8PCAoMzItKDQxLTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsNCA+Pj4gMTQpIHwgKGFoNCA8PCAoMzItMTQpKSkgXiAoKGFsNCA+Pj4gMTgpIHwgKGFoNCA8PCAoMzItMTgpKSkgXiAoKGFoNCA+Pj4gKDQxLTMyKSkgfCAoYWw0IDw8ICgzMi0oNDEtMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIENoXG4gICAgICBoID0gKGFoNCAmIGFoNSkgXiAofmFoNCAmIGFoNik7XG4gICAgICBsID0gKGFsNCAmIGFsNSkgXiAofmFsNCAmIGFsNik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gS1xuICAgICAgaCA9IEtbaSoyXTtcbiAgICAgIGwgPSBLW2kqMisxXTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyB3XG4gICAgICBoID0gd2hbaSUxNl07XG4gICAgICBsID0gd2xbaSUxNl07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICB0aCA9IGMgJiAweGZmZmYgfCBkIDw8IDE2O1xuICAgICAgdGwgPSBhICYgMHhmZmZmIHwgYiA8PCAxNjtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTBcbiAgICAgIGggPSAoKGFoMCA+Pj4gMjgpIHwgKGFsMCA8PCAoMzItMjgpKSkgXiAoKGFsMCA+Pj4gKDM0LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhbDAgPj4+ICgzOS0zMikpIHwgKGFoMCA8PCAoMzItKDM5LTMyKSkpKTtcbiAgICAgIGwgPSAoKGFsMCA+Pj4gMjgpIHwgKGFoMCA8PCAoMzItMjgpKSkgXiAoKGFoMCA+Pj4gKDM0LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzQtMzIpKSkpIF4gKChhaDAgPj4+ICgzOS0zMikpIHwgKGFsMCA8PCAoMzItKDM5LTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBNYWpcbiAgICAgIGggPSAoYWgwICYgYWgxKSBeIChhaDAgJiBhaDIpIF4gKGFoMSAmIGFoMik7XG4gICAgICBsID0gKGFsMCAmIGFsMSkgXiAoYWwwICYgYWwyKSBeIChhbDEgJiBhbDIpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBiaDM7XG4gICAgICBsID0gYmwzO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgYmgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgYmwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgICBhaDEgPSBiaDA7XG4gICAgICBhaDIgPSBiaDE7XG4gICAgICBhaDMgPSBiaDI7XG4gICAgICBhaDQgPSBiaDM7XG4gICAgICBhaDUgPSBiaDQ7XG4gICAgICBhaDYgPSBiaDU7XG4gICAgICBhaDcgPSBiaDY7XG4gICAgICBhaDAgPSBiaDc7XG5cbiAgICAgIGFsMSA9IGJsMDtcbiAgICAgIGFsMiA9IGJsMTtcbiAgICAgIGFsMyA9IGJsMjtcbiAgICAgIGFsNCA9IGJsMztcbiAgICAgIGFsNSA9IGJsNDtcbiAgICAgIGFsNiA9IGJsNTtcbiAgICAgIGFsNyA9IGJsNjtcbiAgICAgIGFsMCA9IGJsNztcblxuICAgICAgaWYgKGklMTYgPT09IDE1KSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgaCA9IHdoW2pdO1xuICAgICAgICAgIGwgPSB3bFtqXTtcblxuICAgICAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgICAgIGggPSB3aFsoais5KSUxNl07XG4gICAgICAgICAgbCA9IHdsWyhqKzkpJTE2XTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTBcbiAgICAgICAgICB0aCA9IHdoWyhqKzEpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzEpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMSkgfCAodGwgPDwgKDMyLTEpKSkgXiAoKHRoID4+PiA4KSB8ICh0bCA8PCAoMzItOCkpKSBeICh0aCA+Pj4gNyk7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDEpIHwgKHRoIDw8ICgzMi0xKSkpIF4gKCh0bCA+Pj4gOCkgfCAodGggPDwgKDMyLTgpKSkgXiAoKHRsID4+PiA3KSB8ICh0aCA8PCAoMzItNykpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICAvLyBzaWdtYTFcbiAgICAgICAgICB0aCA9IHdoWyhqKzE0KSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxNCklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxOSkgfCAodGwgPDwgKDMyLTE5KSkpIF4gKCh0bCA+Pj4gKDYxLTMyKSkgfCAodGggPDwgKDMyLSg2MS0zMikpKSkgXiAodGggPj4+IDYpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxOSkgfCAodGggPDwgKDMyLTE5KSkpIF4gKCh0aCA+Pj4gKDYxLTMyKSkgfCAodGwgPDwgKDMyLSg2MS0zMikpKSkgXiAoKHRsID4+PiA2KSB8ICh0aCA8PCAoMzItNikpKTtcblxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgICAgIHdoW2pdID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgICAgICAgIHdsW2pdID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkXG4gICAgaCA9IGFoMDtcbiAgICBsID0gYWwwO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzBdO1xuICAgIGwgPSBobFswXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzBdID0gYWgwID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzBdID0gYWwwID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMTtcbiAgICBsID0gYWwxO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzFdO1xuICAgIGwgPSBobFsxXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzFdID0gYWgxID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzFdID0gYWwxID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMjtcbiAgICBsID0gYWwyO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzJdO1xuICAgIGwgPSBobFsyXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzJdID0gYWgyID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzJdID0gYWwyID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoMztcbiAgICBsID0gYWwzO1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzNdO1xuICAgIGwgPSBobFszXTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzNdID0gYWgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzNdID0gYWwzID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNDtcbiAgICBsID0gYWw0O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzRdO1xuICAgIGwgPSBobFs0XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzRdID0gYWg0ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzRdID0gYWw0ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNTtcbiAgICBsID0gYWw1O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzVdO1xuICAgIGwgPSBobFs1XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzVdID0gYWg1ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzVdID0gYWw1ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNjtcbiAgICBsID0gYWw2O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzZdO1xuICAgIGwgPSBobFs2XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzZdID0gYWg2ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzZdID0gYWw2ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgaCA9IGFoNztcbiAgICBsID0gYWw3O1xuXG4gICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgaCA9IGhoWzddO1xuICAgIGwgPSBobFs3XTtcblxuICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICBiICs9IGEgPj4+IDE2O1xuICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgZCArPSBjID4+PiAxNjtcblxuICAgIGhoWzddID0gYWg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpO1xuICAgIGhsWzddID0gYWw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpO1xuXG4gICAgcG9zICs9IDEyODtcbiAgICBuIC09IDEyODtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9faGFzaChvdXQsIG0sIG4pIHtcbiAgdmFyIGhoID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICBobCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgeCA9IG5ldyBVaW50OEFycmF5KDI1NiksXG4gICAgICBpLCBiID0gbjtcblxuICBoaFswXSA9IDB4NmEwOWU2Njc7XG4gIGhoWzFdID0gMHhiYjY3YWU4NTtcbiAgaGhbMl0gPSAweDNjNmVmMzcyO1xuICBoaFszXSA9IDB4YTU0ZmY1M2E7XG4gIGhoWzRdID0gMHg1MTBlNTI3ZjtcbiAgaGhbNV0gPSAweDliMDU2ODhjO1xuICBoaFs2XSA9IDB4MWY4M2Q5YWI7XG4gIGhoWzddID0gMHg1YmUwY2QxOTtcblxuICBobFswXSA9IDB4ZjNiY2M5MDg7XG4gIGhsWzFdID0gMHg4NGNhYTczYjtcbiAgaGxbMl0gPSAweGZlOTRmODJiO1xuICBobFszXSA9IDB4NWYxZDM2ZjE7XG4gIGhsWzRdID0gMHhhZGU2ODJkMTtcbiAgaGxbNV0gPSAweDJiM2U2YzFmO1xuICBobFs2XSA9IDB4ZmI0MWJkNmI7XG4gIGhsWzddID0gMHgxMzdlMjE3OTtcblxuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIG0sIG4pO1xuICBuICU9IDEyODtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gbVtiLW4raV07XG4gIHhbbl0gPSAxMjg7XG5cbiAgbiA9IDI1Ni0xMjgqKG48MTEyPzE6MCk7XG4gIHhbbi05XSA9IDA7XG4gIHRzNjQoeCwgbi04LCAgKGIgLyAweDIwMDAwMDAwKSB8IDAsIGIgPDwgMyk7XG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgeCwgbik7XG5cbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykgdHM2NChvdXQsIDgqaSwgaGhbaV0sIGhsW2ldKTtcblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWRkKHAsIHEpIHtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpLFxuICAgICAgZyA9IGdmKCksIGggPSBnZigpLCB0ID0gZ2YoKTtcblxuICBaKGEsIHBbMV0sIHBbMF0pO1xuICBaKHQsIHFbMV0sIHFbMF0pO1xuICBNKGEsIGEsIHQpO1xuICBBKGIsIHBbMF0sIHBbMV0pO1xuICBBKHQsIHFbMF0sIHFbMV0pO1xuICBNKGIsIGIsIHQpO1xuICBNKGMsIHBbM10sIHFbM10pO1xuICBNKGMsIGMsIEQyKTtcbiAgTShkLCBwWzJdLCBxWzJdKTtcbiAgQShkLCBkLCBkKTtcbiAgWihlLCBiLCBhKTtcbiAgWihmLCBkLCBjKTtcbiAgQShnLCBkLCBjKTtcbiAgQShoLCBiLCBhKTtcblxuICBNKHBbMF0sIGUsIGYpO1xuICBNKHBbMV0sIGgsIGcpO1xuICBNKHBbMl0sIGcsIGYpO1xuICBNKHBbM10sIGUsIGgpO1xufVxuXG5mdW5jdGlvbiBjc3dhcChwLCBxLCBiKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2VsMjU1MTkocFtpXSwgcVtpXSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gIHZhciB0eCA9IGdmKCksIHR5ID0gZ2YoKSwgemkgPSBnZigpO1xuICBpbnYyNTUxOSh6aSwgcFsyXSk7XG4gIE0odHgsIHBbMF0sIHppKTtcbiAgTSh0eSwgcFsxXSwgemkpO1xuICBwYWNrMjU1MTkociwgdHkpO1xuICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbn1cblxuZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gIHZhciBiLCBpO1xuICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICBzZXQyNTUxOShwWzFdLCBnZjEpO1xuICBzZXQyNTUxOShwWzJdLCBnZjEpO1xuICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICBmb3IgKGkgPSAyNTU7IGkgPj0gMDsgLS1pKSB7XG4gICAgYiA9IChzWyhpLzgpfDBdID4+IChpJjcpKSAmIDE7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gICAgYWRkKHEsIHApO1xuICAgIGFkZChwLCBwKTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgdmFyIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHNldDI1NTE5KHFbMF0sIFgpO1xuICBzZXQyNTUxOShxWzFdLCBZKTtcbiAgc2V0MjU1MTkocVsyXSwgZ2YxKTtcbiAgTShxWzNdLCBYLCBZKTtcbiAgc2NhbGFybXVsdChwLCBxLCBzKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHNlZWRlZCkge1xuICBjaGVjayhwaywgc29kaXVtLmNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICBjaGVjayhzaywgc29kaXVtLmNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuXG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcbiAgdmFyIGk7XG5cbiAgaWYgKCFzZWVkZWQpIHJhbmRvbWJ5dGVzKHNrLCAzMik7XG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHNjYWxhcmJhc2UocCwgZCk7XG4gIHBhY2socGssIHApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBza1tpKzMyXSA9IHBrW2ldO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fc2VlZF9rZXlwYWlyIChwaywgc2ssIHNlZWQpIHtcbiAgY2hlY2soc2VlZCwgc29kaXVtLmNyeXB0b19zaWduX1NFRURCWVRFUylcbiAgc2VlZC5jb3B5KHNrKVxuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgdHJ1ZSlcbn1cblxudmFyIEwgPSBuZXcgRmxvYXQ2NEFycmF5KFsweGVkLCAweGQzLCAweGY1LCAweDVjLCAweDFhLCAweDYzLCAweDEyLCAweDU4LCAweGQ2LCAweDljLCAweGY3LCAweGEyLCAweGRlLCAweGY5LCAweGRlLCAweDE0LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDEwXSk7XG5cbmZ1bmN0aW9uIG1vZEwociwgeCkge1xuICB2YXIgY2FycnksIGksIGosIGs7XG4gIGZvciAoaSA9IDYzOyBpID49IDMyOyAtLWkpIHtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChqID0gaSAtIDMyLCBrID0gaSAtIDEyOyBqIDwgazsgKytqKSB7XG4gICAgICB4W2pdICs9IGNhcnJ5IC0gMTYgKiB4W2ldICogTFtqIC0gKGkgLSAzMildO1xuICAgICAgY2FycnkgPSAoeFtqXSArIDEyOCkgPj4gODtcbiAgICAgIHhbal0gLT0gY2FycnkgKiAyNTY7XG4gICAgfVxuICAgIHhbal0gKz0gY2Fycnk7XG4gICAgeFtpXSA9IDA7XG4gIH1cbiAgY2FycnkgPSAwO1xuICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgIHhbal0gKz0gY2FycnkgLSAoeFszMV0gPj4gNCkgKiBMW2pdO1xuICAgIGNhcnJ5ID0geFtqXSA+PiA4O1xuICAgIHhbal0gJj0gMjU1O1xuICB9XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB4W2pdIC09IGNhcnJ5ICogTFtqXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICB4W2krMV0gKz0geFtpXSA+PiA4O1xuICAgIHJbaV0gPSB4W2ldICYgMjU1O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZShyKSB7XG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gcltpXTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHJbaV0gPSAwO1xuICBtb2RMKHIsIHgpO1xufVxuXG4vLyBOb3RlOiBkaWZmZXJlbmNlIGZyb20gQyAtIHNtbGVuIHJldHVybmVkLCBub3QgcGFzc2VkIGFzIGFyZ3VtZW50LlxuZnVuY3Rpb24gY3J5cHRvX3NpZ24oc20sIG0sIHNrKSB7XG4gIGNoZWNrKHNtLCBjcnlwdG9fc2lnbl9CWVRFUyArIG0ubGVuZ3RoKVxuICBjaGVjayhtLCAwKVxuICBjaGVjayhzaywgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gIHZhciBuID0gbS5sZW5ndGhcblxuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KSwgciA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIGksIGosIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgY3J5cHRvX2hhc2goZCwgc2ssIDMyKTtcbiAgZFswXSAmPSAyNDg7XG4gIGRbMzFdICY9IDEyNztcbiAgZFszMV0gfD0gNjQ7XG5cbiAgdmFyIHNtbGVuID0gbiArIDY0O1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBzbVs2NCArIGldID0gbVtpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHNtWzMyICsgaV0gPSBkWzMyICsgaV07XG5cbiAgY3J5cHRvX2hhc2gociwgc20uc3ViYXJyYXkoMzIpLCBuKzMyKTtcbiAgcmVkdWNlKHIpO1xuICBzY2FsYXJiYXNlKHAsIHIpO1xuICBwYWNrKHNtLCBwKTtcblxuICBmb3IgKGkgPSAzMjsgaSA8IDY0OyBpKyspIHNtW2ldID0gc2tbaV07XG4gIGNyeXB0b19oYXNoKGgsIHNtLCBuICsgNjQpO1xuICByZWR1Y2UoaCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgeFtpXSA9IHJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHtcbiAgICAgIHhbaStqXSArPSBoW2ldICogZFtqXTtcbiAgICB9XG4gIH1cblxuICBtb2RMKHNtLnN1YmFycmF5KDMyKSwgeCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX2RldGFjaGVkKHNpZywgbSwgc2spIHtcbiAgdmFyIHNtID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGggKyBjcnlwdG9fc2lnbl9CWVRFUylcbiAgY3J5cHRvX3NpZ24oc20sIG0sIHNrKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNyeXB0b19zaWduX0JZVEVTOyBpKyspIHNpZ1tpXSA9IHNtW2ldXG59XG5cbmZ1bmN0aW9uIHVucGFja25lZyhyLCBwKSB7XG4gIHZhciB0ID0gZ2YoKSwgY2hrID0gZ2YoKSwgbnVtID0gZ2YoKSxcbiAgICAgIGRlbiA9IGdmKCksIGRlbjIgPSBnZigpLCBkZW40ID0gZ2YoKSxcbiAgICAgIGRlbjYgPSBnZigpO1xuXG4gIHNldDI1NTE5KHJbMl0sIGdmMSk7XG4gIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICBTKG51bSwgclsxXSk7XG4gIE0oZGVuLCBudW0sIEQpO1xuICBaKG51bSwgbnVtLCByWzJdKTtcbiAgQShkZW4sIHJbMl0sIGRlbik7XG5cbiAgUyhkZW4yLCBkZW4pO1xuICBTKGRlbjQsIGRlbjIpO1xuICBNKGRlbjYsIGRlbjQsIGRlbjIpO1xuICBNKHQsIGRlbjYsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcblxuICBwb3cyNTIzKHQsIHQpO1xuICBNKHQsIHQsIG51bSk7XG4gIE0odCwgdCwgZGVuKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHJbMF0sIHQsIGRlbik7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSBNKHJbMF0sIHJbMF0sIEkpO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgcmV0dXJuIC0xO1xuXG4gIGlmIChwYXIyNTUxOShyWzBdKSA9PT0gKHBbMzFdPj43KSkgWihyWzBdLCBnZjAsIHJbMF0pO1xuXG4gIE0oclszXSwgclswXSwgclsxXSk7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9vcGVuKG1zZywgc20sIHBrKSB7XG4gIGNoZWNrKG1zZywgc20ubGVuZ3RoIC0gY3J5cHRvX3NpZ25fQllURVMpXG4gIGNoZWNrKHNtLCBjcnlwdG9fc2lnbl9CWVRFUylcbiAgY2hlY2socGssIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICB2YXIgbiA9IHNtLmxlbmd0aFxuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KHNtLmxlbmd0aClcblxuICB2YXIgaSwgbWxlbjtcbiAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgzMiksIGggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldLFxuICAgICAgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBtbGVuID0gLTE7XG4gIGlmIChuIDwgNjQpIHJldHVybiBmYWxzZTtcblxuICBpZiAodW5wYWNrbmVnKHEsIHBrKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1baV0gPSBzbVtpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIG1baSszMl0gPSBwa1tpXTtcbiAgY3J5cHRvX2hhc2goaCwgbSwgbik7XG4gIHJlZHVjZShoKTtcbiAgc2NhbGFybXVsdChwLCBxLCBoKTtcblxuICBzY2FsYXJiYXNlKHEsIHNtLnN1YmFycmF5KDMyKSk7XG4gIGFkZChwLCBxKTtcbiAgcGFjayh0LCBwKTtcblxuICBuIC09IDY0O1xuICBpZiAoY3J5cHRvX3ZlcmlmeV8zMihzbSwgMCwgdCwgMCkpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtc2dbaV0gPSBzbVtpICsgNjRdO1xuICBtbGVuID0gbjtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX3ZlcmlmeV9kZXRhY2hlZCAoc2lnLCBtLCBwaykge1xuICBjaGVjayhzaWcsIGNyeXB0b19zaWduX0JZVEVTKVxuICB2YXIgc20gPSBuZXcgVWludDhBcnJheShtLmxlbmd0aCArIGNyeXB0b19zaWduX0JZVEVTKVxuICB2YXIgaSA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGNyeXB0b19zaWduX0JZVEVTOyBpKyspIHNtW2ldID0gc2lnW2ldXG4gIGZvciAoaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBzbVtpICsgY3J5cHRvX3NpZ25fQllURVNdID0gbVtpXVxuICByZXR1cm4gY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgcGspXG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfZGV0YWNoZWQgKG8sIG1hYywgbXNnLCBuLCBrKSB7XG4gIGNoZWNrKG1hYywgc29kaXVtLmNyeXB0b19zZWNyZXRib3hfTUFDQllURVMpXG4gIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShtc2cubGVuZ3RoICsgbWFjLmxlbmd0aClcbiAgY3J5cHRvX3NlY3JldGJveF9lYXN5KHRtcCwgbXNnLCBuLCBrKVxuICBvLnNldCh0bXAuc3ViYXJyYXkoMCwgbXNnLmxlbmd0aCkpXG4gIG1hYy5zZXQodG1wLnN1YmFycmF5KG1zZy5sZW5ndGgpKVxufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X29wZW5fZGV0YWNoZWQgKG1zZywgbywgbWFjLCBuLCBrKSB7XG4gIGNoZWNrKG1hYywgc29kaXVtLmNyeXB0b19zZWNyZXRib3hfTUFDQllURVMpXG4gIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShvLmxlbmd0aCArIG1hYy5sZW5ndGgpXG4gIHRtcC5zZXQobylcbiAgdG1wLnNldChtYWMsIG1zZy5sZW5ndGgpXG4gIHJldHVybiBjcnlwdG9fc2VjcmV0Ym94X29wZW5fZWFzeShtc2csIHRtcCwgbiwgaylcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveF9lYXN5KG8sIG1zZywgbiwgaykge1xuICBjaGVjayhtc2csIDApXG4gIGNoZWNrKG8sIG1zZy5sZW5ndGggKyBzb2RpdW0uY3J5cHRvX3NlY3JldGJveF9NQUNCWVRFUylcbiAgY2hlY2sobiwgY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTKVxuICBjaGVjayhrLCBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTKVxuXG4gIHZhciBpXG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShtLmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIG1baStjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFU10gPSBtc2dbaV07XG4gIGNyeXB0b19zZWNyZXRib3goYywgbSwgbS5sZW5ndGgsIG4sIGspO1xuICBmb3IgKGkgPSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUzsgaSA8IGMubGVuZ3RoOyBpKyspIG9baSAtIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTXSA9IGNbaV1cbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveF9vcGVuX2Vhc3kobXNnLCBib3gsIG4sIGspIHtcbiAgY2hlY2soYm94LCBzb2RpdW0uY3J5cHRvX3NlY3JldGJveF9NQUNCWVRFUylcbiAgY2hlY2sobXNnLCBib3gubGVuZ3RoIC0gc29kaXVtLmNyeXB0b19zZWNyZXRib3hfTUFDQllURVMpXG4gIGNoZWNrKG4sIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUylcbiAgY2hlY2soaywgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUylcblxuICB2YXIgaVxuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTICsgYm94Lmxlbmd0aCk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoYy5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpIDwgYm94Lmxlbmd0aDsgaSsrKSBjW2krY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVNdID0gYm94W2ldO1xuICBpZiAoYy5sZW5ndGggPCAzMikgcmV0dXJuIGZhbHNlO1xuICBpZiAoY3J5cHRvX3NlY3JldGJveF9vcGVuKG0sIGMsIGMubGVuZ3RoLCBuLCBrKSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoaSA9IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTOyBpIDwgbS5sZW5ndGg7IGkrKykgbXNnW2kgLSBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFU10gPSBtW2ldXG4gIHJldHVybiB0cnVlXG59XG5cbnZhciBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTID0gMjQsXG4gICAgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyA9IDE2LFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfTk9OQ0VCWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbiAgICBjcnlwdG9fYm94X1pFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTLFxuICAgIGNyeXB0b19ib3hfQk9YWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsXG4gICAgY3J5cHRvX3NpZ25fQllURVMgPSA2NCxcbiAgICBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fU0VFREJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2hhc2hfQllURVMgPSA2NDtcblxuc29kaXVtLm1lbXplcm8gPSBmdW5jdGlvbiAobGVuLCBvZmZzZXQpIHtcbiAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IGxlbjsgaSsrKSBhcnJbaV0gPSAwO1xufVxuXG5zb2RpdW0uY3J5cHRvX3NpZ25fQllURVMgPSBjcnlwdG9fc2lnbl9CWVRFU1xuc29kaXVtLmNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTID0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVNcbnNvZGl1bS5jcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyA9IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTXG5zb2RpdW0uY3J5cHRvX3NpZ25fU0VFREJZVEVTID0gY3J5cHRvX3NpZ25fU0VFREJZVEVTXG5zb2RpdW0uY3J5cHRvX3NpZ25fa2V5cGFpciA9IGNyeXB0b19zaWduX2tleXBhaXJcbnNvZGl1bS5jcnlwdG9fc2lnbl9zZWVkX2tleXBhaXIgPSBjcnlwdG9fc2lnbl9zZWVkX2tleXBhaXJcbnNvZGl1bS5jcnlwdG9fc2lnbiA9IGNyeXB0b19zaWduXG5zb2RpdW0uY3J5cHRvX3NpZ25fb3BlbiA9IGNyeXB0b19zaWduX29wZW5cbnNvZGl1bS5jcnlwdG9fc2lnbl9kZXRhY2hlZCA9IGNyeXB0b19zaWduX2RldGFjaGVkXG5zb2RpdW0uY3J5cHRvX3NpZ25fdmVyaWZ5X2RldGFjaGVkID0gY3J5cHRvX3NpZ25fdmVyaWZ5X2RldGFjaGVkXG5cbmZvcndhcmQocmVxdWlyZSgnLi9jcnlwdG9fZ2VuZXJpY2hhc2gnKSlcbmZvcndhcmQocmVxdWlyZSgnLi9jcnlwdG9fa2RmJykpXG5mb3J3YXJkKHJlcXVpcmUoJy4vY3J5cHRvX3Nob3J0aGFzaCcpKVxuZm9yd2FyZChyZXF1aXJlKCcuL3JhbmRvbWJ5dGVzJykpXG5mb3J3YXJkKHJlcXVpcmUoJy4vY3J5cHRvX3N0cmVhbScpKVxuXG5zb2RpdW0uY3J5cHRvX3NjYWxhcm11bHRfQllURVMgPSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFU1xuc29kaXVtLmNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTID0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVNcbnNvZGl1bS5jcnlwdG9fc2NhbGFybXVsdF9iYXNlID0gY3J5cHRvX3NjYWxhcm11bHRfYmFzZVxuc29kaXVtLmNyeXB0b19zY2FsYXJtdWx0ID0gY3J5cHRvX3NjYWxhcm11bHRcblxuc29kaXVtLmNyeXB0b19zZWNyZXRib3hfS0VZQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTLFxuc29kaXVtLmNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbnNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X01BQ0JZVEVTID0gMTZcbnNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X2Vhc3kgPSBjcnlwdG9fc2VjcmV0Ym94X2Vhc3lcbnNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X29wZW5fZWFzeSA9IGNyeXB0b19zZWNyZXRib3hfb3Blbl9lYXN5XG5zb2RpdW0uY3J5cHRvX3NlY3JldGJveF9kZXRhY2hlZCA9IGNyeXB0b19zZWNyZXRib3hfZGV0YWNoZWRcbnNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X29wZW5fZGV0YWNoZWQgPSBjcnlwdG9fc2VjcmV0Ym94X29wZW5fZGV0YWNoZWRcblxuZnVuY3Rpb24gY2xlYW51cChhcnIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycltpXSA9IDA7XG59XG5cbmZ1bmN0aW9uIGNoZWNrIChidWYsIGxlbikge1xuICBpZiAoIWJ1ZiB8fCAobGVuICYmIGJ1Zi5sZW5ndGggPCBsZW4pKSB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBidWZmZXInICsgKGxlbiA/ICcgb2YgbGVuZ3RoICcgKyBsZW4gOiAnJykpXG59XG5cbmZ1bmN0aW9uIGZvcndhcmQgKHN1Ym1vZHVsZSkge1xuICBPYmplY3Qua2V5cyhzdWJtb2R1bGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBtb2R1bGUuZXhwb3J0c1twcm9wXSA9IHN1Ym1vZHVsZVtwcm9wXVxuICB9KVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ25hbm9hc3NlcnQnKVxudmFyIHJhbmRvbWJ5dGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFFVT1RBID0gNjU1MzYgLy8gbGltaXQgZm9yIFF1b3RhRXhjZWVkZWRFeGNlcHRpb25cbiAgdmFyIGNyeXB0byA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gY3J5cHRvID0gKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKSA6IG51bGxcblxuICBmdW5jdGlvbiBicm93c2VyQnl0ZXMgKG91dCwgbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSArPSBRVU9UQSkge1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhvdXQuc3ViYXJyYXkoaSwgaSArIE1hdGgubWluKG4gLSBpLCBRVU9UQSkpKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vZGVCeXRlcyAob3V0LCBuKSB7XG4gICAgb3V0LnNldChjcnlwdG8ucmFuZG9tQnl0ZXMobikpXG4gIH1cblxuICBmdW5jdGlvbiBub0ltcGwgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGF2YWlsYWJsZScpXG4gIH1cblxuICBpZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICByZXR1cm4gYnJvd3NlckJ5dGVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm9kZS5qcy5cbiAgICBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuICAgIGlmIChjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICByZXR1cm4gbm9kZUJ5dGVzXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vSW1wbFxufSkoKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdyYW5kb21ieXRlcycsIHtcbiAgdmFsdWU6IHJhbmRvbWJ5dGVzXG59KVxuXG5tb2R1bGUuZXhwb3J0cy5yYW5kb21ieXRlc19idWYgPSBmdW5jdGlvbiAob3V0KSB7XG4gIGFzc2VydChvdXQsICdvdXQgbXVzdCBiZSBnaXZlbicpXG4gIHJhbmRvbWJ5dGVzKG91dCwgb3V0Lmxlbmd0aClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnc29kaXVtLWphdmFzY3JpcHQnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbmRleE9mXG5cbmZ1bmN0aW9uIGluZGV4T2YgKGxlZnQsIHJpZ2h0KSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkocmlnaHQubGVuZ3RoKVxuICB2YXIgaSA9IDBcbiAgdmFyIGogPSAwXG5cbiAgd2hpbGUgKGkgPCBsZWZ0Lmxlbmd0aCAmJiBqIDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgdmFyIGEgPSBsZWZ0W2ldXG4gICAgdmFyIGIgPSByaWdodFtqXVxuXG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJlc3VsdFtqKytdID0gaVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgIGkrK1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICByZXN1bHRbaisrXSA9IC0xXG4gICAgY29udGludWVcbiAgfVxuXG4gIGZvciAoOyBqIDwgcmlnaHQubGVuZ3RoOyBqKyspIHJlc3VsdFtqXSA9IC0xXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwidmFyIHBhZ2VyID0gcmVxdWlyZSgnbWVtb3J5LXBhZ2VyJylcblxubW9kdWxlLmV4cG9ydHMgPSBCaXRmaWVsZFxuXG5mdW5jdGlvbiBCaXRmaWVsZCAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQml0ZmllbGQpKSByZXR1cm4gbmV3IEJpdGZpZWxkKG9wdHMpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob3B0cykpIG9wdHMgPSB7YnVmZmVyOiBvcHRzfVxuXG4gIHRoaXMucGFnZU9mZnNldCA9IG9wdHMucGFnZU9mZnNldCB8fCAwXG4gIHRoaXMucGFnZVNpemUgPSBvcHRzLnBhZ2VTaXplIHx8IDEwMjRcbiAgdGhpcy5wYWdlcyA9IG9wdHMucGFnZXMgfHwgcGFnZXIodGhpcy5wYWdlU2l6ZSlcblxuICB0aGlzLmJ5dGVMZW5ndGggPSB0aGlzLnBhZ2VzLmxlbmd0aCAqIHRoaXMucGFnZVNpemVcbiAgdGhpcy5sZW5ndGggPSA4ICogdGhpcy5ieXRlTGVuZ3RoXG5cbiAgaWYgKCFwb3dlck9mVHdvKHRoaXMucGFnZVNpemUpKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYWdlIHNpemUgc2hvdWxkIGJlIGEgcG93ZXIgb2YgdHdvJylcblxuICB0aGlzLl90cmFja1VwZGF0ZXMgPSAhIW9wdHMudHJhY2tVcGRhdGVzXG4gIHRoaXMuX3BhZ2VNYXNrID0gdGhpcy5wYWdlU2l6ZSAtIDFcblxuICBpZiAob3B0cy5idWZmZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdHMuYnVmZmVyLmxlbmd0aDsgaSArPSB0aGlzLnBhZ2VTaXplKSB7XG4gICAgICB0aGlzLnBhZ2VzLnNldChpIC8gdGhpcy5wYWdlU2l6ZSwgb3B0cy5idWZmZXIuc2xpY2UoaSwgaSArIHRoaXMucGFnZVNpemUpKVxuICAgIH1cbiAgICB0aGlzLmJ5dGVMZW5ndGggPSBvcHRzLmJ1ZmZlci5sZW5ndGhcbiAgICB0aGlzLmxlbmd0aCA9IDggKiB0aGlzLmJ5dGVMZW5ndGhcbiAgfVxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGkpIHtcbiAgdmFyIG8gPSBpICYgN1xuICB2YXIgaiA9IChpIC0gbykgLyA4XG5cbiAgcmV0dXJuICEhKHRoaXMuZ2V0Qnl0ZShqKSAmICgxMjggPj4gbykpXG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24gKGkpIHtcbiAgdmFyIG8gPSBpICYgdGhpcy5fcGFnZU1hc2tcbiAgdmFyIGogPSAoaSAtIG8pIC8gdGhpcy5wYWdlU2l6ZVxuICB2YXIgcGFnZSA9IHRoaXMucGFnZXMuZ2V0KGosIHRydWUpXG5cbiAgcmV0dXJuIHBhZ2UgPyBwYWdlLmJ1ZmZlcltvICsgdGhpcy5wYWdlT2Zmc2V0XSA6IDBcbn1cblxuQml0ZmllbGQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpLCB2KSB7XG4gIHZhciBvID0gaSAmIDdcbiAgdmFyIGogPSAoaSAtIG8pIC8gOFxuICB2YXIgYiA9IHRoaXMuZ2V0Qnl0ZShqKVxuXG4gIHJldHVybiB0aGlzLnNldEJ5dGUoaiwgdiA/IGIgfCAoMTI4ID4+IG8pIDogYiAmICgyNTUgXiAoMTI4ID4+IG8pKSlcbn1cblxuQml0ZmllbGQucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWxsID0gYWxsb2ModGhpcy5wYWdlcy5sZW5ndGggKiB0aGlzLnBhZ2VTaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYWdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0ID0gdGhpcy5wYWdlcy5nZXQoaSwgdHJ1ZSlcbiAgICB2YXIgYWxsT2Zmc2V0ID0gaSAqIHRoaXMucGFnZVNpemVcbiAgICBpZiAobmV4dCkgbmV4dC5idWZmZXIuY29weShhbGwsIGFsbE9mZnNldCwgdGhpcy5wYWdlT2Zmc2V0LCB0aGlzLnBhZ2VPZmZzZXQgKyB0aGlzLnBhZ2VTaXplKVxuICB9XG5cbiAgcmV0dXJuIGFsbFxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUuc2V0Qnl0ZSA9IGZ1bmN0aW9uIChpLCBiKSB7XG4gIHZhciBvID0gaSAmIHRoaXMuX3BhZ2VNYXNrXG4gIHZhciBqID0gKGkgLSBvKSAvIHRoaXMucGFnZVNpemVcbiAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzLmdldChqLCBmYWxzZSlcblxuICBvICs9IHRoaXMucGFnZU9mZnNldFxuXG4gIGlmIChwYWdlLmJ1ZmZlcltvXSA9PT0gYikgcmV0dXJuIGZhbHNlXG4gIHBhZ2UuYnVmZmVyW29dID0gYlxuXG4gIGlmIChpID49IHRoaXMuYnl0ZUxlbmd0aCkge1xuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGkgKyAxXG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGggKiA4XG4gIH1cblxuICBpZiAodGhpcy5fdHJhY2tVcGRhdGVzKSB0aGlzLnBhZ2VzLnVwZGF0ZWQocGFnZSlcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBhbGxvYyAobikge1xuICBpZiAoQnVmZmVyLmFsbG9jKSByZXR1cm4gQnVmZmVyLmFsbG9jKG4pXG4gIHZhciBiID0gbmV3IEJ1ZmZlcihuKVxuICBiLmZpbGwoMClcbiAgcmV0dXJuIGJcbn1cblxuZnVuY3Rpb24gcG93ZXJPZlR3byAoeCkge1xuICByZXR1cm4gISh4ICYgKHggLSAxKSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbmV4dFRpY2sgPSBuZXh0VGlja0FyZ3NcbnByb2Nlc3MubmV4dFRpY2sodXBncmFkZSwgNDIpIC8vIHBhc3MgNDIgYW5kIHNlZSBpZiB1cGdyYWRlIGlzIGNhbGxlZCB3aXRoIGl0XG5cbm1vZHVsZS5leHBvcnRzID0gdGh1bmt5XG5cbmZ1bmN0aW9uIHRodW5reSAoZm4pIHtcbiAgdmFyIHN0YXRlID0gcnVuXG4gIHJldHVybiB0aHVua1xuXG4gIGZ1bmN0aW9uIHRodW5rIChjYWxsYmFjaykge1xuICAgIHN0YXRlKGNhbGxiYWNrIHx8IG5vb3ApXG4gIH1cblxuICBmdW5jdGlvbiBydW4gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0YWNrID0gW2NhbGxiYWNrXVxuICAgIHN0YXRlID0gd2FpdFxuICAgIGZuKGRvbmUpXG5cbiAgICBmdW5jdGlvbiB3YWl0IChjYWxsYmFjaykge1xuICAgICAgc3RhY2sucHVzaChjYWxsYmFjaylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzXG4gICAgICBzdGF0ZSA9IGlzRXJyb3IoZXJyKSA/IHJ1biA6IGZpbmlzaGVkXG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSBmaW5pc2hlZChzdGFjay5zaGlmdCgpKVxuXG4gICAgICBmdW5jdGlvbiBmaW5pc2hlZCAoY2FsbGJhY2spIHtcbiAgICAgICAgbmV4dFRpY2soYXBwbHksIGNhbGxiYWNrLCBhcmdzKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yIChlcnIpIHsgLy8gaW5saW5lZCBmcm9tIHV0aWwgc28gdGhpcyB3b3JrcyBpbiB0aGUgYnJvd3NlclxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikgPT09ICdbb2JqZWN0IEVycm9yXSdcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBhcHBseSAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncylcbn1cblxuZnVuY3Rpb24gdXBncmFkZSAodmFsKSB7XG4gIGlmICh2YWwgPT09IDQyKSBuZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2tcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2tBcmdzIChmbiwgYSwgYikge1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBmbihhLCBiKVxuICB9KVxufVxuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwidmFyIGJ1ZmZlckFsbG9jID0gcmVxdWlyZSgnYnVmZmVyLWFsbG9jJylcblxudmFyIFVJTlRfMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpXG5cbmV4cG9ydHMuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiA4XG59XG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bSwgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKCFidWYpIGJ1ZiA9IGJ1ZmZlckFsbG9jKDgpXG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgdmFyIHRvcCA9IE1hdGguZmxvb3IobnVtIC8gVUlOVF8zMl9NQVgpXG4gIHZhciByZW0gPSBudW0gLSB0b3AgKiBVSU5UXzMyX01BWFxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKHRvcCwgb2Zmc2V0KVxuICBidWYud3JpdGVVSW50MzJCRShyZW0sIG9mZnNldCArIDQpXG4gIHJldHVybiBidWZcbn1cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICB2YXIgdG9wID0gYnVmLnJlYWRVSW50MzJCRShvZmZzZXQpXG4gIHZhciByZW0gPSBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpXG5cbiAgcmV0dXJuIHRvcCAqIFVJTlRfMzJfTUFYICsgcmVtXG59XG5cbmV4cG9ydHMuZW5jb2RlLmJ5dGVzID0gOFxuZXhwb3J0cy5kZWNvZGUuYnl0ZXMgPSA4XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlbW92ZVxuXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaSkge1xuICBpZiAoaSA+PSBhcnIubGVuZ3RoIHx8IGkgPCAwKSByZXR1cm5cbiAgdmFyIGxhc3QgPSBhcnIucG9wKClcbiAgaWYgKGkgPCBhcnIubGVuZ3RoKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXVxuICAgIGFycltpXSA9IGxhc3RcbiAgICByZXR1cm4gdG1wXG4gIH1cbiAgcmV0dXJuIGxhc3Rcbn1cbiIsImV4cG9ydHMuYWRkID0gYWRkXG5leHBvcnRzLmhhcyA9IGhhc1xuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmVcbmV4cG9ydHMuc3dhcCA9IHN3YXBcblxuZnVuY3Rpb24gYWRkIChsaXN0LCBpdGVtKSB7XG4gIGlmIChoYXMobGlzdCwgaXRlbSkpIHJldHVybiBpdGVtXG4gIGl0ZW0uX2luZGV4ID0gbGlzdC5sZW5ndGhcbiAgbGlzdC5wdXNoKGl0ZW0pXG4gIHJldHVybiBpdGVtXG59XG5cbmZ1bmN0aW9uIGhhcyAobGlzdCwgaXRlbSkge1xuICByZXR1cm4gaXRlbS5faW5kZXggPCBsaXN0Lmxlbmd0aCAmJiBsaXN0W2l0ZW0uX2luZGV4XSA9PT0gaXRlbVxufVxuXG5mdW5jdGlvbiByZW1vdmUgKGxpc3QsIGl0ZW0pIHtcbiAgaWYgKCFoYXMobGlzdCwgaXRlbSkpIHJldHVybiBudWxsXG5cbiAgdmFyIGxhc3QgPSBsaXN0LnBvcCgpXG4gIGlmIChsYXN0ICE9PSBpdGVtKSB7XG4gICAgbGlzdFtpdGVtLl9pbmRleF0gPSBsYXN0XG4gICAgbGFzdC5faW5kZXggPSBpdGVtLl9pbmRleFxuICB9XG5cbiAgcmV0dXJuIGl0ZW1cbn1cblxuZnVuY3Rpb24gc3dhcCAobGlzdCwgYSwgYikge1xuICBpZiAoIWhhcyhsaXN0LCBhKSB8fCAhaGFzKGxpc3QsIGIpKSByZXR1cm5cbiAgdmFyIHRtcCA9IGEuX2luZGV4XG4gIGEuX2luZGV4ID0gYi5faW5kZXhcbiAgbGlzdFthLl9pbmRleF0gPSBhXG4gIGIuX2luZGV4ID0gdG1wXG4gIGxpc3RbYi5faW5kZXhdID0gYlxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZWFkXG5cbnZhciBNU0IgPSAweDgwXG4gICwgUkVTVCA9IDB4N0ZcblxuZnVuY3Rpb24gcmVhZChidWYsIG9mZnNldCkge1xuICB2YXIgcmVzICAgID0gMFxuICAgICwgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgICAsIHNoaWZ0ICA9IDBcbiAgICAsIGNvdW50ZXIgPSBvZmZzZXRcbiAgICAsIGJcbiAgICAsIGwgPSBidWYubGVuZ3RoXG5cbiAgZG8ge1xuICAgIGlmIChjb3VudGVyID49IGwpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGRlY29kZSB2YXJpbnQnKVxuICAgIH1cbiAgICBiID0gYnVmW2NvdW50ZXIrK11cbiAgICByZXMgKz0gc2hpZnQgPCAyOFxuICAgICAgPyAoYiAmIFJFU1QpIDw8IHNoaWZ0XG4gICAgICA6IChiICYgUkVTVCkgKiBNYXRoLnBvdygyLCBzaGlmdClcbiAgICBzaGlmdCArPSA3XG4gIH0gd2hpbGUgKGIgPj0gTVNCKVxuXG4gIHJlYWQuYnl0ZXMgPSBjb3VudGVyIC0gb2Zmc2V0XG5cbiAgcmV0dXJuIHJlc1xufVxuIiwidmFyIHhzYWxzYTIwID0gcmVxdWlyZSgnLi94c2Fsc2EyMCcpKClcblxudmFyIFNJR01BID0gbmV3IFVpbnQ4QXJyYXkoWzEwMSwgMTIwLCAxMTIsIDk3LCAxMTAsIDEwMCwgMzIsIDUxLCA1MCwgNDUsIDk4LCAxMjEsIDExNiwgMTAxLCAzMiwgMTA3XSlcbnZhciBoZWFkID0gMTQ0XG52YXIgdG9wID0gaGVhZFxudmFyIGZyZWUgPSBbXVxuXG5tb2R1bGUuZXhwb3J0cyA9IFhTYWxzYTIwXG5cblhTYWxzYTIwLk5PTkNFQllURVMgPSAyNFxuWFNhbHNhMjAuS0VZQllURVMgPSAzMlxuXG5mdW5jdGlvbiBYU2Fsc2EyMCAobm9uY2UsIGtleSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgWFNhbHNhMjApKSByZXR1cm4gbmV3IFhTYWxzYTIwKG5vbmNlLCBrZXkpXG4gIGlmICghbm9uY2UgfHwgbm9uY2UubGVuZ3RoIDwgMjQpIHRocm93IG5ldyBFcnJvcignbm9uY2UgbXVzdCBiZSBhdCBsZWFzdCAyNCBieXRlcycpXG4gIGlmICgha2V5IHx8IGtleS5sZW5ndGggPCAzMikgdGhyb3cgbmV3IEVycm9yKCdrZXkgbXVzdCBiZSBhdCBsZWFzdCAzMiBieXRlcycpXG4gIHRoaXMuX3hvciA9IHhzYWxzYTIwICYmIHhzYWxzYTIwLmV4cG9ydHMgPyBuZXcgV0FTTShub25jZSwga2V5KSA6IG5ldyBGYWxsYmFjayhub25jZSwga2V5KVxufVxuXG5YU2Fsc2EyMC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQpIHtcbiAgaWYgKCFpbnB1dCkgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBtdXN0IGJlIFVpbnQ4QXJyYXkgb3IgQnVmZmVyJylcbiAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aClcbiAgaWYgKGlucHV0Lmxlbmd0aCkgdGhpcy5feG9yLnVwZGF0ZShpbnB1dCwgb3V0cHV0KVxuICByZXR1cm4gb3V0cHV0XG59XG5cblhTYWxzYTIwLnByb3RvdHlwZS5maW5hbCA9XG5YU2Fsc2EyMC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3hvci5maW5hbGl6ZSgpXG4gIHRoaXMuX3hvciA9IG51bGxcbn1cblxuZnVuY3Rpb24gV0FTTSAobm9uY2UsIGtleSkge1xuICBpZiAoIWZyZWUubGVuZ3RoKSB7XG4gICAgZnJlZS5wdXNoKGhlYWQpXG4gICAgaGVhZCArPSA2NFxuICB9XG5cbiAgdGhpcy5fcG9pbnRlciA9IGZyZWUucG9wKClcbiAgdGhpcy5fbm9uY2UgPSB0aGlzLl9wb2ludGVyICsgOFxuICB0aGlzLl9rZXkgPSB0aGlzLl9ub25jZSArIDI0XG4gIHRoaXMuX292ZXJmbG93ID0gMFxuXG4gIHhzYWxzYTIwLm1lbW9yeS5maWxsKDAsIHRoaXMuX3BvaW50ZXIsIHRoaXMuX3BvaW50ZXIgKyA4KVxuICB4c2Fsc2EyMC5tZW1vcnkuc2V0KG5vbmNlLCB0aGlzLl9ub25jZSlcbiAgeHNhbHNhMjAubWVtb3J5LnNldChrZXksIHRoaXMuX2tleSlcbn1cblxuV0FTTS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQpIHtcbiAgdmFyIGxlbiA9IHRoaXMuX292ZXJmbG93ICsgaW5wdXQubGVuZ3RoXG4gIHZhciBzdGFydCA9IGhlYWQgKyB0aGlzLl9vdmVyZmxvd1xuXG4gIHRvcCA9IGhlYWQgKyBsZW5cbiAgaWYgKHRvcCA+PSB4c2Fsc2EyMC5tZW1vcnkubGVuZ3RoKSB4c2Fsc2EyMC5yZWFsbG9jKHRvcClcblxuICB4c2Fsc2EyMC5tZW1vcnkuc2V0KGlucHV0LCBzdGFydClcbiAgeHNhbHNhMjAuZXhwb3J0cy54c2Fsc2EyMF94b3IodGhpcy5fcG9pbnRlciwgaGVhZCwgaGVhZCwgbGVuLCB0aGlzLl9ub25jZSwgdGhpcy5fa2V5KVxuICBvdXRwdXQuc2V0KHhzYWxzYTIwLm1lbW9yeS5zdWJhcnJheShzdGFydCwgaGVhZCArIGxlbikpXG5cbiAgdGhpcy5fb3ZlcmZsb3cgPSBsZW4gJiA2M1xufVxuXG5XQVNNLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgeHNhbHNhMjAubWVtb3J5LmZpbGwoMCwgdGhpcy5fcG9pbnRlciwgdGhpcy5fa2V5ICsgMzIpXG4gIGlmICh0b3AgPiBoZWFkKSB7XG4gICAgeHNhbHNhMjAubWVtb3J5LmZpbGwoMCwgaGVhZCwgdG9wKVxuICAgIHRvcCA9IDBcbiAgfVxuICBmcmVlLnB1c2godGhpcy5fcG9pbnRlcilcbn1cblxuZnVuY3Rpb24gRmFsbGJhY2sgKG5vbmNlLCBrZXkpIHtcbiAgdGhpcy5fcyA9IG5ldyBVaW50OEFycmF5KDMyKVxuICB0aGlzLl96ID0gbmV3IFVpbnQ4QXJyYXkoMTYpXG4gIHRoaXMuX292ZXJmbG93ID0gMFxuICBjb3JlX2hzYWxzYTIwKHRoaXMuX3MsIG5vbmNlLCBrZXksIFNJR01BKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgdGhpcy5feltpXSA9IG5vbmNlW2kgKyAxNl1cbn1cblxuRmFsbGJhY2sucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0KSB7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpXG4gIHZhciB1ID0gMFxuICB2YXIgaSA9IHRoaXMuX292ZXJmbG93XG4gIHZhciBiID0gaW5wdXQubGVuZ3RoICsgdGhpcy5fb3ZlcmZsb3dcbiAgdmFyIHogPSB0aGlzLl96XG4gIHZhciBtcG9zID0gLXRoaXMuX292ZXJmbG93XG4gIHZhciBjcG9zID0gLXRoaXMuX292ZXJmbG93XG5cbiAgd2hpbGUgKGIgPj0gNjQpIHtcbiAgICBjb3JlX3NhbHNhMjAoeCwgeiwgdGhpcy5fcywgU0lHTUEpXG4gICAgZm9yICg7IGkgPCA2NDsgaSsrKSBvdXRwdXRbY3BvcyArIGldID0gaW5wdXRbbXBvcyArIGldIF4geFtpXVxuICAgIHUgPSAxXG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHUgKz0gKHpbaV0gJiAweGZmKSB8IDBcbiAgICAgIHpbaV0gPSB1ICYgMHhmZlxuICAgICAgdSA+Pj49IDhcbiAgICB9XG4gICAgYiAtPSA2NFxuICAgIGNwb3MgKz0gNjRcbiAgICBtcG9zICs9IDY0XG4gICAgaSA9IDBcbiAgfVxuICBpZiAoYiA+IDApIHtcbiAgICBjb3JlX3NhbHNhMjAoeCwgeiwgdGhpcy5fcywgU0lHTUEpXG4gICAgZm9yICg7IGkgPCBiOyBpKyspIG91dHB1dFtjcG9zICsgaV0gPSBpbnB1dFttcG9zICsgaV0gXiB4W2ldXG4gIH1cblxuICB0aGlzLl9vdmVyZmxvdyA9IGIgJiA2M1xufVxuXG5GYWxsYmFjay5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3MuZmlsbCgwKVxuICB0aGlzLl96LmZpbGwoMClcbn1cblxuLy8gYmVsb3cgbWV0aG9kcyBhcmUgcG9ydGVkIGZyb20gdHdlZXQgbmFjbFxuXG5mdW5jdGlvbiBjb3JlX3NhbHNhMjAobywgcCwgaywgYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZikgPDwgOCB8IChjWyAyXSAmIDB4ZmYpIDw8IDE2IHwgKGNbIDNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKSA8PCA4IHwgKGtbIDJdICYgMHhmZikgPDwgMTYgfCAoa1sgM10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpIDw8IDggfCAoa1sgNl0gJiAweGZmKSA8PCAxNiB8IChrWyA3XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZikgPDwgOCB8IChrWzEwXSAmIDB4ZmYpIDw8IDE2IHwgKGtbMTFdICYgMHhmZikgPDwgMjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKSA8PCA4IHwgKGtbMTRdICYgMHhmZikgPDwgMTYgfCAoa1sxNV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpIDw8IDggfCAoY1sgNl0gJiAweGZmKSA8PCAxNiB8IChjWyA3XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZikgPDwgOCB8IChwWyAyXSAmIDB4ZmYpIDw8IDE2IHwgKHBbIDNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKSA8PCA4IHwgKHBbIDZdICYgMHhmZikgPDwgMTYgfCAocFsgN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpIDw8IDggfCAocFsxMF0gJiAweGZmKSA8PCAxNiB8IChwWzExXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZikgPDwgOCB8IChwWzE0XSAmIDB4ZmYpIDw8IDE2IHwgKHBbMTVdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKSA8PCA4IHwgKGNbMTBdICYgMHhmZikgPDwgMTYgfCAoY1sxMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpIDw8IDggfCAoa1sxOF0gJiAweGZmKSA8PCAxNiB8IChrWzE5XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZikgPDwgOCB8IChrWzIyXSAmIDB4ZmYpIDw8IDE2IHwgKGtbMjNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKSA8PCA4IHwgKGtbMjZdICYgMHhmZikgPDwgMTYgfCAoa1syN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpIDw8IDggfCAoa1szMF0gJiAweGZmKSA8PCAxNiB8IChrWzMxXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZikgPDwgOCB8IChjWzE0XSAmIDB4ZmYpIDw8IDE2IHwgKGNbMTVdICYgMHhmZikgPDwgMjRcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSArPSAyKSB7XG4gICAgdSA9IHgwICsgeDEyIHwgMFxuICAgIHg0IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHg0ICsgeDAgfCAwXG4gICAgeDggXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDggKyB4NCB8IDBcbiAgICB4MTIgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxMiArIHg4IHwgMFxuICAgIHgwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHg1ICsgeDEgfCAwXG4gICAgeDkgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDkgKyB4NSB8IDBcbiAgICB4MTMgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDEzICsgeDkgfCAwXG4gICAgeDEgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxICsgeDEzIHwgMFxuICAgIHg1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxMCArIHg2IHwgMFxuICAgIHgxNCBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MTQgKyB4MTAgfCAwXG4gICAgeDIgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDIgKyB4MTQgfCAwXG4gICAgeDYgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHg2ICsgeDIgfCAwXG4gICAgeDEwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxNSArIHgxMSB8IDBcbiAgICB4MyBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MyArIHgxNSB8IDBcbiAgICB4NyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4NyArIHgzIHwgMFxuICAgIHgxMSBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDExICsgeDcgfCAwXG4gICAgeDE1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgwICsgeDMgfCAwXG4gICAgeDEgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDEgKyB4MCB8IDBcbiAgICB4MiBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4MiArIHgxIHwgMFxuICAgIHgzIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MyArIHgyIHwgMFxuICAgIHgwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHg1ICsgeDQgfCAwXG4gICAgeDYgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDYgKyB4NSB8IDBcbiAgICB4NyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4NyArIHg2IHwgMFxuICAgIHg0IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4NCArIHg3IHwgMFxuICAgIHg1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxMCArIHg5IHwgMFxuICAgIHgxMSBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MTEgKyB4MTAgfCAwXG4gICAgeDggXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDggKyB4MTEgfCAwXG4gICAgeDkgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHg5ICsgeDggfCAwXG4gICAgeDEwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxNSArIHgxNCB8IDBcbiAgICB4MTIgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDEyICsgeDE1IHwgMFxuICAgIHgxMyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwXG4gICAgeDE0IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MTQgKyB4MTMgfCAwXG4gICAgeDE1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuICB9XG4gICB4MCA9ICB4MCArICBqMCB8IDBcbiAgIHgxID0gIHgxICsgIGoxIHwgMFxuICAgeDIgPSAgeDIgKyAgajIgfCAwXG4gICB4MyA9ICB4MyArICBqMyB8IDBcbiAgIHg0ID0gIHg0ICsgIGo0IHwgMFxuICAgeDUgPSAgeDUgKyAgajUgfCAwXG4gICB4NiA9ICB4NiArICBqNiB8IDBcbiAgIHg3ID0gIHg3ICsgIGo3IHwgMFxuICAgeDggPSAgeDggKyAgajggfCAwXG4gICB4OSA9ICB4OSArICBqOSB8IDBcbiAgeDEwID0geDEwICsgajEwIHwgMFxuICB4MTEgPSB4MTEgKyBqMTEgfCAwXG4gIHgxMiA9IHgxMiArIGoxMiB8IDBcbiAgeDEzID0geDEzICsgajEzIHwgMFxuICB4MTQgPSB4MTQgKyBqMTQgfCAwXG4gIHgxNSA9IHgxNSArIGoxNSB8IDBcblxuICBvWyAwXSA9IHgwID4+PiAgMCAmIDB4ZmZcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmXG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZlxuICBvWyAzXSA9IHgwID4+PiAyNCAmIDB4ZmZcblxuICBvWyA0XSA9IHgxID4+PiAgMCAmIDB4ZmZcbiAgb1sgNV0gPSB4MSA+Pj4gIDggJiAweGZmXG4gIG9bIDZdID0geDEgPj4+IDE2ICYgMHhmZlxuICBvWyA3XSA9IHgxID4+PiAyNCAmIDB4ZmZcblxuICBvWyA4XSA9IHgyID4+PiAgMCAmIDB4ZmZcbiAgb1sgOV0gPSB4MiA+Pj4gIDggJiAweGZmXG4gIG9bMTBdID0geDIgPj4+IDE2ICYgMHhmZlxuICBvWzExXSA9IHgyID4+PiAyNCAmIDB4ZmZcblxuICBvWzEyXSA9IHgzID4+PiAgMCAmIDB4ZmZcbiAgb1sxM10gPSB4MyA+Pj4gIDggJiAweGZmXG4gIG9bMTRdID0geDMgPj4+IDE2ICYgMHhmZlxuICBvWzE1XSA9IHgzID4+PiAyNCAmIDB4ZmZcblxuICBvWzE2XSA9IHg0ID4+PiAgMCAmIDB4ZmZcbiAgb1sxN10gPSB4NCA+Pj4gIDggJiAweGZmXG4gIG9bMThdID0geDQgPj4+IDE2ICYgMHhmZlxuICBvWzE5XSA9IHg0ID4+PiAyNCAmIDB4ZmZcblxuICBvWzIwXSA9IHg1ID4+PiAgMCAmIDB4ZmZcbiAgb1syMV0gPSB4NSA+Pj4gIDggJiAweGZmXG4gIG9bMjJdID0geDUgPj4+IDE2ICYgMHhmZlxuICBvWzIzXSA9IHg1ID4+PiAyNCAmIDB4ZmZcblxuICBvWzI0XSA9IHg2ID4+PiAgMCAmIDB4ZmZcbiAgb1syNV0gPSB4NiA+Pj4gIDggJiAweGZmXG4gIG9bMjZdID0geDYgPj4+IDE2ICYgMHhmZlxuICBvWzI3XSA9IHg2ID4+PiAyNCAmIDB4ZmZcblxuICBvWzI4XSA9IHg3ID4+PiAgMCAmIDB4ZmZcbiAgb1syOV0gPSB4NyA+Pj4gIDggJiAweGZmXG4gIG9bMzBdID0geDcgPj4+IDE2ICYgMHhmZlxuICBvWzMxXSA9IHg3ID4+PiAyNCAmIDB4ZmZcblxuICBvWzMyXSA9IHg4ID4+PiAgMCAmIDB4ZmZcbiAgb1szM10gPSB4OCA+Pj4gIDggJiAweGZmXG4gIG9bMzRdID0geDggPj4+IDE2ICYgMHhmZlxuICBvWzM1XSA9IHg4ID4+PiAyNCAmIDB4ZmZcblxuICBvWzM2XSA9IHg5ID4+PiAgMCAmIDB4ZmZcbiAgb1szN10gPSB4OSA+Pj4gIDggJiAweGZmXG4gIG9bMzhdID0geDkgPj4+IDE2ICYgMHhmZlxuICBvWzM5XSA9IHg5ID4+PiAyNCAmIDB4ZmZcblxuICBvWzQwXSA9IHgxMCA+Pj4gIDAgJiAweGZmXG4gIG9bNDFdID0geDEwID4+PiAgOCAmIDB4ZmZcbiAgb1s0Ml0gPSB4MTAgPj4+IDE2ICYgMHhmZlxuICBvWzQzXSA9IHgxMCA+Pj4gMjQgJiAweGZmXG5cbiAgb1s0NF0gPSB4MTEgPj4+ICAwICYgMHhmZlxuICBvWzQ1XSA9IHgxMSA+Pj4gIDggJiAweGZmXG4gIG9bNDZdID0geDExID4+PiAxNiAmIDB4ZmZcbiAgb1s0N10gPSB4MTEgPj4+IDI0ICYgMHhmZlxuXG4gIG9bNDhdID0geDEyID4+PiAgMCAmIDB4ZmZcbiAgb1s0OV0gPSB4MTIgPj4+ICA4ICYgMHhmZlxuICBvWzUwXSA9IHgxMiA+Pj4gMTYgJiAweGZmXG4gIG9bNTFdID0geDEyID4+PiAyNCAmIDB4ZmZcblxuICBvWzUyXSA9IHgxMyA+Pj4gIDAgJiAweGZmXG4gIG9bNTNdID0geDEzID4+PiAgOCAmIDB4ZmZcbiAgb1s1NF0gPSB4MTMgPj4+IDE2ICYgMHhmZlxuICBvWzU1XSA9IHgxMyA+Pj4gMjQgJiAweGZmXG5cbiAgb1s1Nl0gPSB4MTQgPj4+ICAwICYgMHhmZlxuICBvWzU3XSA9IHgxNCA+Pj4gIDggJiAweGZmXG4gIG9bNThdID0geDE0ID4+PiAxNiAmIDB4ZmZcbiAgb1s1OV0gPSB4MTQgPj4+IDI0ICYgMHhmZlxuXG4gIG9bNjBdID0geDE1ID4+PiAgMCAmIDB4ZmZcbiAgb1s2MV0gPSB4MTUgPj4+ICA4ICYgMHhmZlxuICBvWzYyXSA9IHgxNSA+Pj4gMTYgJiAweGZmXG4gIG9bNjNdID0geDE1ID4+PiAyNCAmIDB4ZmZcbn1cblxuZnVuY3Rpb24gY29yZV9oc2Fsc2EyMChvLHAsayxjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKSA8PCA4IHwgKGNbIDJdICYgMHhmZikgPDwgMTYgfCAoY1sgM10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpIDw8IDggfCAoa1sgMl0gJiAweGZmKSA8PCAxNiB8IChrWyAzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZikgPDwgOCB8IChrWyA2XSAmIDB4ZmYpIDw8IDE2IHwgKGtbIDddICYgMHhmZikgPDwgMjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKSA8PCA4IHwgKGtbMTBdICYgMHhmZikgPDwgMTYgfCAoa1sxMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpIDw8IDggfCAoa1sxNF0gJiAweGZmKSA8PCAxNiB8IChrWzE1XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZikgPDwgOCB8IChjWyA2XSAmIDB4ZmYpIDw8IDE2IHwgKGNbIDddICYgMHhmZikgPDwgMjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKSA8PCA4IHwgKHBbIDJdICYgMHhmZikgPDwgMTYgfCAocFsgM10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpIDw8IDggfCAocFsgNl0gJiAweGZmKSA8PCAxNiB8IChwWyA3XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZikgPDwgOCB8IChwWzEwXSAmIDB4ZmYpIDw8IDE2IHwgKHBbMTFdICYgMHhmZikgPDwgMjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKSA8PCA4IHwgKHBbMTRdICYgMHhmZikgPDwgMTYgfCAocFsxNV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpIDw8IDggfCAoY1sxMF0gJiAweGZmKSA8PCAxNiB8IChjWzExXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZikgPDwgOCB8IChrWzE4XSAmIDB4ZmYpIDw8IDE2IHwgKGtbMTldICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKSA8PCA4IHwgKGtbMjJdICYgMHhmZikgPDwgMTYgfCAoa1syM10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpIDw8IDggfCAoa1syNl0gJiAweGZmKSA8PCAxNiB8IChrWzI3XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZikgPDwgOCB8IChrWzMwXSAmIDB4ZmYpIDw8IDE2IHwgKGtbMzFdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKSA8PCA4IHwgKGNbMTRdICYgMHhmZikgPDwgMTYgfCAoY1sxNV0gJiAweGZmKSA8PCAyNFxuXG4gIHZhciB4MCA9IGowLCB4MSA9IGoxLCB4MiA9IGoyLCB4MyA9IGozLCB4NCA9IGo0LCB4NSA9IGo1LCB4NiA9IGo2LCB4NyA9IGo3LFxuICAgICAgeDggPSBqOCwgeDkgPSBqOSwgeDEwID0gajEwLCB4MTEgPSBqMTEsIHgxMiA9IGoxMiwgeDEzID0gajEzLCB4MTQgPSBqMTQsXG4gICAgICB4MTUgPSBqMTUsIHVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwXG4gICAgeDQgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDQgKyB4MCB8IDBcbiAgICB4OCBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4OCArIHg0IHwgMFxuICAgIHgxMiBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDEyICsgeDggfCAwXG4gICAgeDAgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDUgKyB4MSB8IDBcbiAgICB4OSBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4OSArIHg1IHwgMFxuICAgIHgxMyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4MTMgKyB4OSB8IDBcbiAgICB4MSBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDEgKyB4MTMgfCAwXG4gICAgeDUgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDEwICsgeDYgfCAwXG4gICAgeDE0IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgxNCArIHgxMCB8IDBcbiAgICB4MiBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4MiArIHgxNCB8IDBcbiAgICB4NiBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDYgKyB4MiB8IDBcbiAgICB4MTAgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMFxuICAgIHgzIF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgzICsgeDE1IHwgMFxuICAgIHg3IF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHg3ICsgeDMgfCAwXG4gICAgeDExIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MTEgKyB4NyB8IDBcbiAgICB4MTUgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDAgKyB4MyB8IDBcbiAgICB4MSBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MSArIHgwIHwgMFxuICAgIHgyIF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHgyICsgeDEgfCAwXG4gICAgeDMgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgzICsgeDIgfCAwXG4gICAgeDAgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDUgKyB4NCB8IDBcbiAgICB4NiBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4NiArIHg1IHwgMFxuICAgIHg3IF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHg3ICsgeDYgfCAwXG4gICAgeDQgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHg0ICsgeDcgfCAwXG4gICAgeDUgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDEwICsgeDkgfCAwXG4gICAgeDExIF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgxMSArIHgxMCB8IDBcbiAgICB4OCBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4OCArIHgxMSB8IDBcbiAgICB4OSBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDkgKyB4OCB8IDBcbiAgICB4MTAgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMFxuICAgIHgxMiBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MTIgKyB4MTUgfCAwXG4gICAgeDEzIF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHgxMyArIHgxMiB8IDBcbiAgICB4MTQgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxNCArIHgxMyB8IDBcbiAgICB4MTUgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG4gIH1cblxuICBvWyAwXSA9IHgwID4+PiAgMCAmIDB4ZmZcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmXG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZlxuICBvWyAzXSA9IHgwID4+PiAyNCAmIDB4ZmZcblxuICBvWyA0XSA9IHg1ID4+PiAgMCAmIDB4ZmZcbiAgb1sgNV0gPSB4NSA+Pj4gIDggJiAweGZmXG4gIG9bIDZdID0geDUgPj4+IDE2ICYgMHhmZlxuICBvWyA3XSA9IHg1ID4+PiAyNCAmIDB4ZmZcblxuICBvWyA4XSA9IHgxMCA+Pj4gIDAgJiAweGZmXG4gIG9bIDldID0geDEwID4+PiAgOCAmIDB4ZmZcbiAgb1sxMF0gPSB4MTAgPj4+IDE2ICYgMHhmZlxuICBvWzExXSA9IHgxMCA+Pj4gMjQgJiAweGZmXG5cbiAgb1sxMl0gPSB4MTUgPj4+ICAwICYgMHhmZlxuICBvWzEzXSA9IHgxNSA+Pj4gIDggJiAweGZmXG4gIG9bMTRdID0geDE1ID4+PiAxNiAmIDB4ZmZcbiAgb1sxNV0gPSB4MTUgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMTZdID0geDYgPj4+ICAwICYgMHhmZlxuICBvWzE3XSA9IHg2ID4+PiAgOCAmIDB4ZmZcbiAgb1sxOF0gPSB4NiA+Pj4gMTYgJiAweGZmXG4gIG9bMTldID0geDYgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMjBdID0geDcgPj4+ICAwICYgMHhmZlxuICBvWzIxXSA9IHg3ID4+PiAgOCAmIDB4ZmZcbiAgb1syMl0gPSB4NyA+Pj4gMTYgJiAweGZmXG4gIG9bMjNdID0geDcgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMjRdID0geDggPj4+ICAwICYgMHhmZlxuICBvWzI1XSA9IHg4ID4+PiAgOCAmIDB4ZmZcbiAgb1syNl0gPSB4OCA+Pj4gMTYgJiAweGZmXG4gIG9bMjddID0geDggPj4+IDI0ICYgMHhmZlxuXG4gIG9bMjhdID0geDkgPj4+ICAwICYgMHhmZlxuICBvWzI5XSA9IHg5ID4+PiAgOCAmIDB4ZmZcbiAgb1szMF0gPSB4OSA+Pj4gMTYgJiAweGZmXG4gIG9bMzFdID0geDkgPj4+IDI0ICYgMHhmZlxufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRXZWJBc3NlbWJseVxuXG5sb2FkV2ViQXNzZW1ibHkuc3VwcG9ydGVkID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSAndW5kZWZpbmVkJ1xuXG5mdW5jdGlvbiBsb2FkV2ViQXNzZW1ibHkgKG9wdHMpIHtcbiAgaWYgKCFsb2FkV2ViQXNzZW1ibHkuc3VwcG9ydGVkKSByZXR1cm4gbnVsbFxuXG4gIHZhciBpbXAgPSBvcHRzICYmIG9wdHMuaW1wb3J0c1xuICB2YXIgd2FzbSA9IHRvVWludDhBcnJheSgnQUdGemJRRUFBQUFCR2dOZ0JuOS9mMzkvZndCZ0JuOS9mMzkrZndGK1lBTi9mMzhBQXdjR0FBRUJBZ0lDQlFVQkFRcm9Cd2NvQXdadFpXMXZjbmtDQUF4NGMyRnNjMkV5TUY5NGIzSUFBQXhqYjNKbFgzTmhiSE5oTWpBQUJBcnFFUVlZQUNBQUlBRWdBaUFESUFRZ0FDa0RBQ0FGRUFFM0F3QUxQUUJCOEFBZ0F5QUZFQU1nQUNBQklBSWdBMEVRYWlBRVFmQUFFQUpCOEFCQ0FEY0RBRUg0QUVJQU53TUFRWUFCUWdBM0F3QkJpQUZDQURjREFBdUhCUUVCZnlBQ1FRQkdCRUJDQUE4TFFkQUFJQVVwQXdBM0F3QkIyQUFnQlVFSWFpa0RBRGNEQUVIZ0FDQUZRUkJxS1FNQU53TUFRZWdBSUFWQkdHb3BBd0EzQXdCQkFDQURLUU1BTndNQVFRZ2dCRGNEQUFKQUEwQWdBa0hBQUVrTkFVRVFRUUJCMEFBUUJTQUFJQUVwQXdCQkVDa0RBSVUzQXdBZ0FFRUlhaUFCUVFocUtRTUFRUmdwQXdDRk53TUFJQUJCRUdvZ0FVRVFhaWtEQUVFZ0tRTUFoVGNEQUNBQVFSaHFJQUZCR0dvcEF3QkJLQ2tEQUlVM0F3QWdBRUVnYWlBQlFTQnFLUU1BUVRBcEF3Q0ZOd01BSUFCQktHb2dBVUVvYWlrREFFRTRLUU1BaFRjREFDQUFRVEJxSUFGQk1Hb3BBd0JCd0FBcEF3Q0ZOd01BSUFCQk9Hb2dBVUU0YWlrREFFSElBQ2tEQUlVM0F3QkJDRUVJS1FNQVFnRjhOd01BSUFCQndBQnFJUUFnQVVIQUFHb2hBU0FDUWNBQWF5RUNEQUFMQzBFSUtRTUFJUVFnQWtFQVN3UkFRUkJCQUVIUUFCQUZBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUNRUWh1RGdjSEJnVUVBd0lCQUFzZ0FFRTRhaUFCUVRocUtRTUFRY2dBS1FNQWhUY0RBQXNnQUVFd2FpQUJRVEJxS1FNQVFjQUFLUU1BaFRjREFBc2dBRUVvYWlBQlFTaHFLUU1BUVRncEF3Q0ZOd01BQ3lBQVFTQnFJQUZCSUdvcEF3QkJNQ2tEQUlVM0F3QUxJQUJCR0dvZ0FVRVlhaWtEQUVFb0tRTUFoVGNEQUFzZ0FFRVFhaUFCUVJCcUtRTUFRU0FwQXdDRk53TUFDeUFBUVFocUlBRkJDR29wQXdCQkdDa0RBSVUzQXdBTElBQWdBU2tEQUVFUUtRTUFoVGNEQUF0QkVFSUFOd01BUVJoQ0FEY0RBRUVnUWdBM0F3QkJLRUlBTndNQVFUQkNBRGNEQUVFNFFnQTNBd0JCd0FCQ0FEY0RBRUhJQUVJQU53TUFRZEFBUWdBM0F3QkIyQUJDQURjREFFSGdBRUlBTndNQVFlZ0FRZ0EzQXdBZ0JBOExuUVVCRVg5QjVmREJpd1loQTBIdXlJR1pBeUVJUWJMYWlNc0hJUTFCOU1xQjJRWWhFaUFDS0FJQUlRUWdBa0VFYWlnQ0FDRUZJQUpCQ0dvb0FnQWhCaUFDUVF4cUtBSUFJUWNnQWtFUWFpZ0NBQ0VPSUFKQkZHb29BZ0FoRHlBQ1FSaHFLQUlBSVJBZ0FrRWNhaWdDQUNFUklBRW9BZ0FoQ1NBQlFRUnFLQUlBSVFvZ0FVRUlhaWdDQUNFTElBRkJER29vQWdBaERFRVVJUk1DUUFOQUlCTkJBRVlOQVNBSElBTWdEMnBCQjNkeklRY2dDeUFISUFOcVFRbDNjeUVMSUE4Z0N5QUhha0VOZDNNaER5QURJQThnQzJwQkVuZHpJUU1nRENBSUlBUnFRUWQzY3lFTUlCQWdEQ0FJYWtFSmQzTWhFQ0FFSUJBZ0RHcEJEWGR6SVFRZ0NDQUVJQkJxUVJKM2N5RUlJQkVnRFNBSmFrRUhkM01oRVNBRklCRWdEV3BCQ1hkeklRVWdDU0FGSUJGcVFRMTNjeUVKSUEwZ0NTQUZha0VTZDNNaERTQUdJQklnRG1wQkIzZHpJUVlnQ2lBR0lCSnFRUWwzY3lFS0lBNGdDaUFHYWtFTmQzTWhEaUFTSUE0Z0NtcEJFbmR6SVJJZ0JDQURJQVpxUVFkM2N5RUVJQVVnQkNBRGFrRUpkM01oQlNBR0lBVWdCR3BCRFhkeklRWWdBeUFHSUFWcVFSSjNjeUVESUFrZ0NDQUhha0VIZDNNaENTQUtJQWtnQ0dwQkNYZHpJUW9nQnlBS0lBbHFRUTEzY3lFSElBZ2dCeUFLYWtFU2QzTWhDQ0FPSUEwZ0RHcEJCM2R6SVE0Z0N5QU9JQTFxUVFsM2N5RUxJQXdnQ3lBT2FrRU5kM01oRENBTklBd2dDMnBCRW5keklRMGdEeUFTSUJGcVFRZDNjeUVQSUJBZ0R5QVNha0VKZDNNaEVDQVJJQkFnRDJwQkRYZHpJUkVnRWlBUklCQnFRUkozY3lFU0lCTkJBbXNoRXd3QUN3c2dBQ0FETmdJQUlBQkJCR29nQ0RZQ0FDQUFRUWhxSUEwMkFnQWdBRUVNYWlBU05nSUFJQUJCRUdvZ0NUWUNBQ0FBUVJScUlBbzJBZ0FnQUVFWWFpQUxOZ0lBSUFCQkhHb2dERFlDQUFzS0FDQUFJQUVnQWhBRkM5MEdBU0YvUWVYd3dZc0dJUU5CN3NpQm1RTWhDRUd5Mm9qTEJ5RU5RZlRLZ2RrR0lSSWdBaWdDQUNFRUlBSkJCR29vQWdBaEJTQUNRUWhxS0FJQUlRWWdBa0VNYWlnQ0FDRUhJQUpCRUdvb0FnQWhEaUFDUVJScUtBSUFJUThnQWtFWWFpZ0NBQ0VRSUFKQkhHb29BZ0FoRVNBQktBSUFJUWtnQVVFRWFpZ0NBQ0VLSUFGQkNHb29BZ0FoQ3lBQlFReHFLQUlBSVF3Z0F5RVRJQVFoRkNBRklSVWdCaUVXSUFjaEZ5QUlJUmdnQ1NFWklBb2hHaUFMSVJzZ0RDRWNJQTBoSFNBT0lSNGdEeUVmSUJBaElDQVJJU0VnRWlFaVFSUWhJd0pBQTBBZ0kwRUFSZzBCSUFjZ0F5QVBha0VIZDNNaEJ5QUxJQWNnQTJwQkNYZHpJUXNnRHlBTElBZHFRUTEzY3lFUElBTWdEeUFMYWtFU2QzTWhBeUFNSUFnZ0JHcEJCM2R6SVF3Z0VDQU1JQWhxUVFsM2N5RVFJQVFnRUNBTWFrRU5kM01oQkNBSUlBUWdFR3BCRW5keklRZ2dFU0FOSUFscVFRZDNjeUVSSUFVZ0VTQU5ha0VKZDNNaEJTQUpJQVVnRVdwQkRYZHpJUWtnRFNBSklBVnFRUkozY3lFTklBWWdFaUFPYWtFSGQzTWhCaUFLSUFZZ0VtcEJDWGR6SVFvZ0RpQUtJQVpxUVExM2N5RU9JQklnRGlBS2FrRVNkM01oRWlBRUlBTWdCbXBCQjNkeklRUWdCU0FFSUFOcVFRbDNjeUVGSUFZZ0JTQUVha0VOZDNNaEJpQURJQVlnQldwQkVuZHpJUU1nQ1NBSUlBZHFRUWQzY3lFSklBb2dDU0FJYWtFSmQzTWhDaUFISUFvZ0NXcEJEWGR6SVFjZ0NDQUhJQXBxUVJKM2N5RUlJQTRnRFNBTWFrRUhkM01oRGlBTElBNGdEV3BCQ1hkeklRc2dEQ0FMSUE1cVFRMTNjeUVNSUEwZ0RDQUxha0VTZDNNaERTQVBJQklnRVdwQkIzZHpJUThnRUNBUElCSnFRUWwzY3lFUUlCRWdFQ0FQYWtFTmQzTWhFU0FTSUJFZ0VHcEJFbmR6SVJJZ0kwRUNheUVqREFBTEN5QUFJQU1nRTJvMkFnQWdBRUVFYWlBRUlCUnFOZ0lBSUFCQkNHb2dCU0FWYWpZQ0FDQUFRUXhxSUFZZ0ZtbzJBZ0FnQUVFUWFpQUhJQmRxTmdJQUlBQkJGR29nQ0NBWWFqWUNBQ0FBUVJocUlBa2dHV28yQWdBZ0FFRWNhaUFLSUJwcU5nSUFJQUJCSUdvZ0N5QWJhallDQUNBQVFTUnFJQXdnSEdvMkFnQWdBRUVvYWlBTklCMXFOZ0lBSUFCQkxHb2dEaUFlYWpZQ0FDQUFRVEJxSUE4Z0gybzJBZ0FnQUVFMGFpQVFJQ0JxTmdJQUlBQkJPR29nRVNBaGFqWUNBQ0FBUVR4cUlCSWdJbW8yQWdBTCcpXG4gIHZhciByZWFkeSA9IG51bGxcblxuICB2YXIgbW9kID0ge1xuICAgIGJ1ZmZlcjogd2FzbSxcbiAgICBtZW1vcnk6IG51bGwsXG4gICAgZXhwb3J0czogbnVsbCxcbiAgICByZWFsbG9jOiByZWFsbG9jLFxuICAgIG9ubG9hZDogb25sb2FkXG4gIH1cblxuICBvbmxvYWQoZnVuY3Rpb24gKCkge30pXG5cbiAgcmV0dXJuIG1vZFxuXG4gIGZ1bmN0aW9uIHJlYWxsb2MgKHNpemUpIHtcbiAgICBtb2QuZXhwb3J0cy5tZW1vcnkuZ3JvdyhNYXRoLmNlaWwoTWF0aC5hYnMoc2l6ZSAtIG1vZC5tZW1vcnkubGVuZ3RoKSAvIDY1NTM2KSlcbiAgICBtb2QubWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkobW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubG9hZCAoY2IpIHtcbiAgICBpZiAobW9kLmV4cG9ydHMpIHJldHVybiBjYigpXG5cbiAgICBpZiAocmVhZHkpIHtcbiAgICAgIHJlYWR5LnRoZW4oY2IuYmluZChudWxsLCBudWxsKSkuY2F0Y2goY2IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hc3luYykgdGhyb3cgbmV3IEVycm9yKCdhc3luYycpXG4gICAgICBzZXR1cCh7aW5zdGFuY2U6IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKHdhc20pLCBpbXApfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlYWR5ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUod2FzbSwgaW1wKS50aGVuKHNldHVwKVxuICAgIH1cblxuICAgIG9ubG9hZChjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwICh3KSB7XG4gICAgbW9kLmV4cG9ydHMgPSB3Lmluc3RhbmNlLmV4cG9ydHNcbiAgICBtb2QubWVtb3J5ID0gbW9kLmV4cG9ydHMubWVtb3J5ICYmIG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIgJiYgbmV3IFVpbnQ4QXJyYXkobW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcilcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1VpbnQ4QXJyYXkgKHMpIHtcbiAgaWYgKHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXRvYihzKS5zcGxpdCgnJykubWFwKGNoYXJDb2RlQXQpKVxuICByZXR1cm4gbmV3IChyZXF1aXJlKCdidWYnICsgJ2ZlcicpLkJ1ZmZlcikocywgJ2Jhc2U2NCcpXG59XG5cbmZ1bmN0aW9uIGNoYXJDb2RlQXQgKGMpIHtcbiAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGh5cGVyY29yZSA9IHJlcXVpcmUoXCJoeXBlcmNvcmVcIilcbnZhciBSYW5kb21BY2Nlc3NJREJGaWxlID0gcmVxdWlyZShcIi4vcmFuZG9tLWFjY2Vzcy1pZGItZmlsZVwiKVxuXG5jb25zdCBtYWluID0gYXN5bmMgb3B0aW9ucyA9PiB7XG4gIGNvbnN0IHZvbHVtZSA9IGF3YWl0IFJhbmRvbUFjY2Vzc0lEQkZpbGUubW91bnQob3B0aW9ucylcbiAgdmFyIGZlZWQgPSBoeXBlcmNvcmUodm9sdW1lLCB7IHZhbHVlRW5jb2Rpbmc6IFwianNvblwiIH0pXG5cbiAgZmVlZC5hcHBlbmQoe1xuICAgIGhlbGxvOiBcIndvcmxkXCJcbiAgfSlcblxuICBmZWVkLmFwcGVuZCh7XG4gICAgaGVqOiBcInZlcmRlblwiXG4gIH0pXG5cbiAgZmVlZC5hcHBlbmQoe1xuICAgIGhvbGE6IFwibXVuZG9cIlxuICB9KVxuXG4gIGZlZWQuZmx1c2goZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIkFwcGVuZGVkIDMgbW9yZSBibG9ja3MsICVkIGluIHRvdGFsICglZCBieXRlcylcXG5cIixcbiAgICAgIGZlZWQubGVuZ3RoLFxuICAgICAgZmVlZC5ieXRlTGVuZ3RoXG4gICAgKVxuXG4gICAgZmVlZFxuICAgICAgLmNyZWF0ZVJlYWRTdHJlYW0oKVxuICAgICAgLm9uKFwiZGF0YVwiLCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKVxuICAgICAgLm9uKFwiZW5kXCIsIGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSwgXCJcXG4oZW5kKVwiKSlcbiAgfSlcbn1cblxubWFpbih7IGRlYnVnOiBmYWxzZSB9KVxuIiwiLy8gQGZsb3dcblxuY29uc3QgUmFuZG9tQWNjZXNzID0gcmVxdWlyZShcInJhbmRvbS1hY2Nlc3Mtc3RvcmFnZVwiKVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoXCJCdWZmZXJcIilcblxuY29uc3QgcHJvbWlzZSA9IHJlcXVlc3QgPT5cbiAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdClcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcilcbiAgfSlcblxuY2xhc3MgUmFuZG9tQWNjZXNzSURCRmlsZVZvbHVtZSB7XG4gIGNvbnN0cnVjdG9yKGRiLCBuYW1lLCB2ZXJzaW9uLCBzdG9yZU5hbWUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmRiID0gZGJcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvblxuICAgIHRoaXMuc3RvcmVOYW1lID0gc3RvcmVOYW1lXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB9XG4gIHN0b3JlKCkge1xuICAgIGNvbnN0IHsgZGIsIHN0b3JlTmFtZSB9ID0gdGhpc1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sIFwicmVhZHdyaXRlXCIpXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSlcbiAgfVxuICBhc3luYyBkZWxldGUodXJsKSB7XG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2UodGhpcy5zdG9yZSgpLmRlbGV0ZSh1cmwpKVxuICB9XG4gIGFzeW5jIHNhdmUodXJsLCBmaWxlKSB7XG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2UodGhpcy5zdG9yZSgpLnB1dChmaWxlLCB1cmwpKVxuICB9XG4gIGFzeW5jIG9wZW4odXJsLCBtb2RlKSB7XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IHByb21pc2UodGhpcy5zdG9yZSgpLmdldCh1cmwpKVxuICAgIGlmIChmaWxlKSB7XG4gICAgICByZXR1cm4gZmlsZVxuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJyZWFkd3JpdGVcIikge1xuICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2UodGhpcy5kYi5jcmVhdGVNdXRhYmxlRmlsZSh1cmwsIFwiYmluYXJ5L3JhbmRvbVwiKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEZpbGUgJHt1cmx9IGRvZXMgbm90IGV4aXN0YClcbiAgICB9XG4gIH1cblxuICBtb3VudChmaWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5kb21BY2Nlc3NJREJGaWxlKHRoaXMsIGAvJHtmaWxlfWAsIG9wdGlvbnMpXG4gIH1cbn1cblxuY2xhc3MgUmFuZG9tQWNjZXNzSURCRmlsZSBleHRlbmRzIFJhbmRvbUFjY2VzcyB7XG4gIHN0YXRpYyBhc3luYyBtb3VudChvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXNlbGYuSURCTXV0YWJsZUZpbGUpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgSW1wbGVtZW50YXRpb24gZGVwZW5kcyBvbiBJREJNdXRhYmxlRmlsZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSURCTXV0YWJsZUZpbGVgXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgYFJhbmRvbUFjY2Vzc2BcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBvcHRpb25zLnZlcnNpb24gfHwgMS4wXG4gICAgICBjb25zdCBzdG9yZU5hbWUgPSBvcHRpb25zLnN0b3JlTmFtZSB8fCBgSURCTXV0YWJsZUZpbGVgXG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihuYW1lLCB2ZXJzaW9uKVxuICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRiID0gcmVxdWVzdC5yZXN1bHRcbiAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHN0b3JlTmFtZSkpIHtcbiAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShzdG9yZU5hbWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGRiID0gYXdhaXQgcHJvbWlzZShyZXF1ZXN0KVxuICAgICAgY29uc3Qgdm9sdW1lID0gbmV3IFJhbmRvbUFjY2Vzc0lEQkZpbGVWb2x1bWUoXG4gICAgICAgIGRiLFxuICAgICAgICBuYW1lLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBzdG9yZU5hbWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIClcbiAgICAgIHJldHVybiAocGF0aCwgb3B0aW9ucykgPT4gdm9sdW1lLm1vdW50KHBhdGgsIG9wdGlvbnMpXG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyBvcGVuKHNlbGYsIHsgbW9kZSB9KSB7XG4gICAgc2VsZi5kZWJ1ZyAmJiBjb25zb2xlLmxvZyhgPj4gb3BlbiAke3NlbGYudXJsfSAke21vZGV9YClcblxuICAgIGlmICghc2VsZi5maWxlIHx8IChzZWxmLm1vZGUgIT09IG1vZGUgJiYgbW9kZSA9PT0gXCJyZWFkd3JpdGVcIikpIHtcbiAgICAgIHNlbGYubW9kZSA9IG1vZGVcbiAgICAgIHNlbGYuZmlsZSA9IGF3YWl0IHNlbGYudm9sdW1lLm9wZW4oc2VsZi51cmwsIG1vZGUpXG4gICAgfVxuXG4gICAgc2VsZi5kZWJ1ZyAmJiBjb25zb2xlLmxvZyhgPDwgb3BlbiAke3NlbGYudXJsfSAke21vZGV9YClcbiAgICByZXR1cm4gc2VsZlxuICB9XG4gIHN0YXRpYyBhc3luYyByZWFkKHNlbGYsIHsgZGF0YSwgb2Zmc2V0LCBzaXplIH0pIHtcbiAgICBzZWxmLmRlYnVnICYmIGNvbnNvbGUubG9nKGA+PiByZWFkICR7c2VsZi51cmx9IDwke29mZnNldH0sICR7c2l6ZX0+YClcbiAgICBjb25zdCBidWZmZXIgPSBkYXRhIHx8IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmZmVyXG4gICAgfVxuXG4gICAgY29uc3QgZmlsZSA9IHNlbGYuYWN0aXZhdGUoKVxuICAgIGZpbGUubG9jYXRpb24gPSBvZmZzZXRcbiAgICBjb25zdCBjaHVuayA9IGF3YWl0IHByb21pc2UoZmlsZS5yZWFkQXNBcnJheUJ1ZmZlcihzaXplKSlcblxuICAgIEJ1ZmZlci5mcm9tKGNodW5rKS5jb3B5KGJ1ZmZlcilcbiAgICBzZWxmLmRlYnVnICYmXG4gICAgICBjb25zb2xlLmxvZyhgPDwgcmVhZCAke3NlbGYudXJsfSA8JHtvZmZzZXR9LCAke3NpemV9PmAsIGJ1ZmZlcilcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cbiAgc3RhdGljIGFzeW5jIHdyaXRlKHNlbGYsIHsgZGF0YSwgb2Zmc2V0LCBzaXplIH0pIHtcbiAgICBzZWxmLmRlYnVnICYmIGNvbnNvbGUubG9nKGA+PiB3cml0ZSAke3NlbGYudXJsfSA8JHtvZmZzZXR9LCAke3NpemV9PmAsIGRhdGEpXG4gICAgY29uc3QgeyBieXRlTGVuZ3RoLCBieXRlT2Zmc2V0IH0gPSBkYXRhXG4gICAgY29uc3QgY2h1bmsgPVxuICAgICAgYnl0ZUxlbmd0aCA9PT0gc2l6ZVxuICAgICAgICA/IGJ5dGVPZmZzZXQgPiAwXG4gICAgICAgICAgPyBkYXRhLmJ1ZmZlci5zbGljZShieXRlT2Zmc2V0KVxuICAgICAgICAgIDogZGF0YS5idWZmZXJcbiAgICAgICAgOiBieXRlTGVuZ3RoID4gc2l6ZVxuICAgICAgICAgID8gZGF0YS5idWZmZXIuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIHNpemUpXG4gICAgICAgICAgOiBieXRlT2Zmc2V0ID4gMFxuICAgICAgICAgICAgPyBkYXRhLmJ1ZmZlci5zbGljZShieXRlT2Zmc2V0KVxuICAgICAgICAgICAgOiBkYXRhLmJ1ZmZlclxuXG4gICAgY29uc3QgZmlsZSA9IHNlbGYuYWN0aXZhdGUoKVxuICAgIGZpbGUubG9jYXRpb24gPSBvZmZzZXRcbiAgICBjb25zdCB3cm90ZSA9IGF3YWl0IGZpbGUud3JpdGUoY2h1bmspXG5cbiAgICBzZWxmLmRlYnVnICYmXG4gICAgICBjb25zb2xlLmxvZyhgPDwgd3JpdGUgJHt3cm90ZX0gJHtzZWxmLnVybH0gPCR7b2Zmc2V0fSwgJHtzaXplfT5gKVxuXG4gICAgcmV0dXJuIHdyb3RlXG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlbGV0ZShzZWxmLCB7IG9mZnNldCwgc2l6ZSB9KSB7XG4gICAgdGhpcy5kZWJ1ZyAmJiBjb25zb2xlLmxvZyhgPj4gZGVsZXRlICR7c2VsZi51cmx9IDwke29mZnNldH0sICR7c2l6ZX0+YClcbiAgICBjb25zdCBmaWxlID0gc2VsZi5hY3RpdmF0ZSgpXG4gICAgYXdhaXQgcHJvbWlzZShmaWxlLnRydW5jYXRlKG9mZnNldCkpXG5cbiAgICB0aGlzLmRlYnVnICYmIGNvbnNvbGUubG9nKGA8PCBkZWxldGUgJHtzZWxmLnVybH0gPCR7b2Zmc2V0fSwgJHtzaXplfT5gKVxuICB9XG4gIHN0YXRpYyBhc3luYyBzdGF0KHNlbGYpIHtcbiAgICBzZWxmLmRlYnVnICYmIGNvbnNvbGUubG9nKGA+PiBzdGF0ICR7c2VsZi51cmx9YClcbiAgICBjb25zdCBmaWxlID0gc2VsZi5hY3RpdmF0ZSgpXG4gICAgY29uc3Qgc3RhdCA9IGF3YWl0IHByb21pc2UoZmlsZS5nZXRNZXRhZGF0YSgpKVxuICAgIHNlbGYuZGVidWcgJiYgY29uc29sZS5sb2coYDw8IHN0YXQge3NpemU6JHtzdGF0LnNpemV9fSAke3NlbGYudXJsfSBgKVxuXG4gICAgcmV0dXJuIHN0YXRcbiAgfVxuICBzdGF0aWMgYXN5bmMgY2xvc2Uoc2VsZikge1xuICAgIHNlbGYuZGVidWcgJiYgY29uc29sZS5sb2coYD4+IGNsb3NlICR7c2VsZi51cmx9YClcbiAgICBjb25zdCB7IGxvY2tlZEZpbGUgfSA9IHRoaXNcbiAgICBpZiAobG9ja2VkRmlsZS5hY3RpdmUpIHtcbiAgICAgIGF3YWl0IHByb21pc2UobG9ja2VkRmlsZS5mbHVzaCgpKVxuICAgIH1cbiAgICBhd2FpdCBzZWxmLnZvbHVtZS5zYXZlKHNlbGYudXJsLCBzZWxmLmZpbGUpXG4gICAgdGhpcy5sb2NrZWRGaWxlID0gbnVsbFxuICAgIHRoaXMuZmlsZSA9IG51bGxcbiAgICBzZWxmLmRlYnVnICYmIGNvbnNvbGUubG9nKGA8PCBjbG9zZSAke3NlbGYudXJsfWApXG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc3Ryb3koc2VsZikge1xuICAgIHNlbGYuZGVidWcgJiYgY29uc29sZS5sb2coYD4+IGRlc3Ryb3kgJHtzZWxmLnVybH1gKVxuICAgIGF3YWl0IHNlbGYudm9sdW1lLmRlbGV0ZShzZWxmLnVybClcbiAgICBzZWxmLmRlYnVnICYmIGNvbnNvbGUubG9nKGA8PCBkZXN0cm95ICR7c2VsZi51cmx9YClcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBhd2FrZShzZWxmKSB7XG4gICAgY29uc3QgeyB3b3JrUXVldWUgfSA9IHNlbGZcbiAgICBzZWxmLmlzSWRsZSA9IGZhbHNlXG4gICAgbGV0IGluZGV4ID0gMFxuICAgIHdoaWxlIChpbmRleCA8IHdvcmtRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB3b3JrUXVldWVbaW5kZXgrK11cbiAgICAgIGF3YWl0IHRoaXMud2FpdChzZWxmLCByZXF1ZXN0KVxuICAgIH1cbiAgICB3b3JrUXVldWUubGVuZ3RoID0gMFxuICAgIHNlbGYuaXNJZGxlID0gdHJ1ZVxuICAgIGlmIChzZWxmLmZpbGUpIHtcbiAgICAgIGF3YWl0IHNlbGYudm9sdW1lLnNhdmUoc2VsZi51cmwsIHNlbGYuZmlsZSlcbiAgICB9XG4gIH1cbiAgc3RhdGljIHNjaGVkdWxlKHNlbGYsIHJlcXVlc3QpIHtcbiAgICBzZWxmLndvcmtRdWV1ZS5wdXNoKHJlcXVlc3QpXG4gICAgaWYgKHNlbGYuaXNJZGxlKSB7XG4gICAgICB0aGlzLmF3YWtlKHNlbGYpXG4gICAgfVxuICB9XG4gIHN0YXRpYyBwZXJmb3JtKHNlbGYsIHJlcXVlc3QpIHtcbiAgICBzd2l0Y2ggKHJlcXVlc3QudHlwZSkge1xuICAgICAgY2FzZSBSZXF1ZXN0VHlwZS5vcGVuOiB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW4oc2VsZiwgcmVxdWVzdClcbiAgICAgIH1cbiAgICAgIGNhc2UgUmVxdWVzdFR5cGUucmVhZDoge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkKHNlbGYsIHJlcXVlc3QpXG4gICAgICB9XG4gICAgICBjYXNlIFJlcXVlc3RUeXBlLndyaXRlOiB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlKHNlbGYsIHJlcXVlc3QpXG4gICAgICB9XG4gICAgICBjYXNlIFJlcXVlc3RUeXBlLmRlbGV0ZToge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoc2VsZiwgcmVxdWVzdClcbiAgICAgIH1cbiAgICAgIGNhc2UgUmVxdWVzdFR5cGUuc3RhdDoge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0KHNlbGYsIHJlcXVlc3QpXG4gICAgICB9XG4gICAgICBjYXNlIFJlcXVlc3RUeXBlLmNsb3NlOiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKHNlbGYsIHJlcXVlc3QpXG4gICAgICB9XG4gICAgICBjYXNlIFJlcXVlc3RUeXBlLmRlc3Ryb3k6IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzdG9yeShzZWxmLCByZXF1ZXN0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgd2FpdChzZWxmLCByZXF1ZXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGVyZm9ybShzZWxmLCByZXF1ZXN0KVxuICAgICAgcmVxdWVzdC5jYWxsYmFjayhudWxsLCByZXN1bHQpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3IpXG4gICAgfVxuICB9XG4gIF9vcGVuKHJlcXVlc3QpIHtcbiAgICByZXF1ZXN0Lm1vZGUgPSBcInJlYWR3cml0ZVwiXG4gICAgUmFuZG9tQWNjZXNzSURCRmlsZS5zY2hlZHVsZSh0aGlzLCByZXF1ZXN0KVxuICB9XG4gIF9vcGVuUmVhZG9ubHkocmVxdWVzdCkge1xuICAgIHJlcXVlc3QubW9kZSA9IFwicmVhZG9ubHlcIlxuICAgIFJhbmRvbUFjY2Vzc0lEQkZpbGUuc2NoZWR1bGUodGhpcywgcmVxdWVzdClcbiAgfVxuICBfd3JpdGUocmVxdWVzdCkge1xuICAgIFJhbmRvbUFjY2Vzc0lEQkZpbGUuc2NoZWR1bGUodGhpcywgcmVxdWVzdClcbiAgfVxuICBfcmVhZChyZXF1ZXN0KSB7XG4gICAgUmFuZG9tQWNjZXNzSURCRmlsZS5zY2hlZHVsZSh0aGlzLCByZXF1ZXN0KVxuICB9XG4gIF9kZWwocmVxdWVzdCkge1xuICAgIFJhbmRvbUFjY2Vzc0lEQkZpbGUuc2NoZWR1bGUodGhpcywgcmVxdWVzdClcbiAgfVxuICBfc3RhdChyZXF1ZXN0KSB7XG4gICAgUmFuZG9tQWNjZXNzSURCRmlsZS53YWl0KHRoaXMsIHJlcXVlc3QpXG4gIH1cbiAgX2Nsb3NlKHJlcXVlc3QpIHtcbiAgICBSYW5kb21BY2Nlc3NJREJGaWxlLnNjaGVkdWxlKHRoaXMsIHJlcXVlc3QpXG4gIH1cbiAgX2Rlc3Ryb3kocmVxdWVzdCkge1xuICAgIFJhbmRvbUFjY2Vzc0lEQkZpbGUuc2NoZWR1bGUodGhpcywgcmVxdWVzdClcbiAgfVxuICBjb25zdHJ1Y3Rvcih2b2x1bWUsIHVybCwgb3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnZvbHVtZSA9IHZvbHVtZVxuICAgIHRoaXMudXJsID0gdXJsXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuZmlsZSA9IG51bGxcbiAgICB0aGlzLm1vZGUgPSBudWxsXG4gICAgdGhpcy5sb2NrZWRGaWxlID0gbnVsbFxuXG4gICAgdGhpcy53b3JrUXVldWUgPSBbXVxuICAgIHRoaXMuaXNJZGxlID0gdHJ1ZVxuICAgIHRoaXMuZGVidWcgPSAhIXZvbHVtZS5vcHRpb25zLmRlYnVnXG4gIH1cbiAgYWN0aXZhdGUoKSB7XG4gICAgY29uc3QgeyBsb2NrZWRGaWxlLCBmaWxlLCBtb2RlIH0gPSB0aGlzXG4gICAgaWYgKGxvY2tlZEZpbGUgJiYgbG9ja2VkRmlsZS5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBsb2NrZWRGaWxlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvY2tlZEZpbGUgPSBmaWxlLm9wZW4obW9kZSlcbiAgICAgIHRoaXMubG9ja2VkRmlsZSA9IGxvY2tlZEZpbGVcbiAgICAgIHJldHVybiBsb2NrZWRGaWxlXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFJlcXVlc3RUeXBlID0ge1xuICBvcGVuOiAwLFxuICByZWFkOiAxLFxuICB3cml0ZTogMixcbiAgZGVsZXRlOiAzLFxuICBzdGF0OiA0LFxuICBjbG9zZTogNSxcbiAgZGVzdHJveTogNlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbUFjY2Vzc0lEQkZpbGVcbiJdfQ==
