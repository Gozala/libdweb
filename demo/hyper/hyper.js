;(function() {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require
          if (!f && c) return c(i, !0)
          if (u) return u(i, !0)
          var a = new Error("Cannot find module '" + i + "'")
          throw ((a.code = "MODULE_NOT_FOUND"), a)
        }
        var p = (n[i] = { exports: {} })
        e[i][0].call(
          p.exports,
          function(r) {
            var n = e[i][1][r]
            return o(n || r)
          },
          p,
          p.exports,
          r,
          e,
          n,
          t
        )
      }
      return n[i].exports
    }
    for (
      var u = "function" == typeof require && require, i = 0;
      i < t.length;
      i++
    )
      o(t[i])
    return o
  }
  return r
})()(
  {
    1: [
      function(require, module, exports) {
        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
        /* eslint-disable no-proto */

        "use strict"

        var base64 = require("base64-js")
        var ieee754 = require("ieee754")

        exports.Buffer = Buffer
        exports.SlowBuffer = SlowBuffer
        exports.INSPECT_MAX_BYTES = 50

        var K_MAX_LENGTH = 0x7fffffff
        exports.kMaxLength = K_MAX_LENGTH

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Print warning and recommend using `buffer` v4.x which has an Object
         *               implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * We report that the browser does not support typed arrays if the are not subclassable
         * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
         * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
         * for __proto__ and has a buggy typed array implementation.
         */
        Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

        if (
          !Buffer.TYPED_ARRAY_SUPPORT &&
          typeof console !== "undefined" &&
          typeof console.error === "function"
        ) {
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by " +
              "`buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          )
        }

        function typedArraySupport() {
          // Can typed array instances can be augmented?
          try {
            var arr = new Uint8Array(1)
            arr.__proto__ = {
              __proto__: Uint8Array.prototype,
              foo: function() {
                return 42
              }
            }
            return arr.foo() === 42
          } catch (e) {
            return false
          }
        }

        Object.defineProperty(Buffer.prototype, "parent", {
          get: function() {
            if (!(this instanceof Buffer)) {
              return undefined
            }
            return this.buffer
          }
        })

        Object.defineProperty(Buffer.prototype, "offset", {
          get: function() {
            if (!(this instanceof Buffer)) {
              return undefined
            }
            return this.byteOffset
          }
        })

        function createBuffer(length) {
          if (length > K_MAX_LENGTH) {
            throw new RangeError("Invalid typed array length")
          }
          // Return an augmented `Uint8Array` instance
          var buf = new Uint8Array(length)
          buf.__proto__ = Buffer.prototype
          return buf
        }

        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */

        function Buffer(arg, encodingOrOffset, length) {
          // Common case.
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string") {
              throw new Error(
                "If encoding is specified then the first argument must be a string"
              )
            }
            return allocUnsafe(arg)
          }
          return from(arg, encodingOrOffset, length)
        }

        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        if (
          typeof Symbol !== "undefined" &&
          Symbol.species &&
          Buffer[Symbol.species] === Buffer
        ) {
          Object.defineProperty(Buffer, Symbol.species, {
            value: null,
            configurable: true,
            enumerable: false,
            writable: false
          })
        }

        Buffer.poolSize = 8192 // not used by this implementation

        function from(value, encodingOrOffset, length) {
          if (typeof value === "number") {
            throw new TypeError('"value" argument must not be a number')
          }

          if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
            return fromArrayBuffer(value, encodingOrOffset, length)
          }

          if (typeof value === "string") {
            return fromString(value, encodingOrOffset)
          }

          return fromObject(value)
        }

        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/
        Buffer.from = function(value, encodingOrOffset, length) {
          return from(value, encodingOrOffset, length)
        }

        // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
        // https://github.com/feross/buffer/pull/148
        Buffer.prototype.__proto__ = Uint8Array.prototype
        Buffer.__proto__ = Uint8Array

        function assertSize(size) {
          if (typeof size !== "number") {
            throw new TypeError('"size" argument must be of type number')
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative')
          }
        }

        function alloc(size, fill, encoding) {
          assertSize(size)
          if (size <= 0) {
            return createBuffer(size)
          }
          if (fill !== undefined) {
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpretted as a start offset.
            return typeof encoding === "string"
              ? createBuffer(size).fill(fill, encoding)
              : createBuffer(size).fill(fill)
          }
          return createBuffer(size)
        }

        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/
        Buffer.alloc = function(size, fill, encoding) {
          return alloc(size, fill, encoding)
        }

        function allocUnsafe(size) {
          assertSize(size)
          return createBuffer(size < 0 ? 0 : checked(size) | 0)
        }

        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */
        Buffer.allocUnsafe = function(size) {
          return allocUnsafe(size)
        }
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */
        Buffer.allocUnsafeSlow = function(size) {
          return allocUnsafe(size)
        }

        function fromString(string, encoding) {
          if (typeof encoding !== "string" || encoding === "") {
            encoding = "utf8"
          }

          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding)
          }

          var length = byteLength(string, encoding) | 0
          var buf = createBuffer(length)

          var actual = buf.write(string, encoding)

          if (actual !== length) {
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            buf = buf.slice(0, actual)
          }

          return buf
        }

        function fromArrayLike(array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0
          var buf = createBuffer(length)
          for (var i = 0; i < length; i += 1) {
            buf[i] = array[i] & 255
          }
          return buf
        }

        function fromArrayBuffer(array, byteOffset, length) {
          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError('"offset" is outside of buffer bounds')
          }

          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('"length" is outside of buffer bounds')
          }

          var buf
          if (byteOffset === undefined && length === undefined) {
            buf = new Uint8Array(array)
          } else if (length === undefined) {
            buf = new Uint8Array(array, byteOffset)
          } else {
            buf = new Uint8Array(array, byteOffset, length)
          }

          // Return an augmented `Uint8Array` instance
          buf.__proto__ = Buffer.prototype
          return buf
        }

        function fromObject(obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0
            var buf = createBuffer(len)

            if (buf.length === 0) {
              return buf
            }

            obj.copy(buf, 0, 0, len)
            return buf
          }

          if (obj) {
            if (ArrayBuffer.isView(obj) || "length" in obj) {
              if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                return createBuffer(0)
              }
              return fromArrayLike(obj)
            }

            if (obj.type === "Buffer" && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data)
            }
          }

          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object."
          )
        }

        function checked(length) {
          // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= K_MAX_LENGTH) {
            throw new RangeError(
              "Attempt to allocate Buffer larger than maximum " +
                "size: 0x" +
                K_MAX_LENGTH.toString(16) +
                " bytes"
            )
          }
          return length | 0
        }

        function SlowBuffer(length) {
          if (+length != length) {
            // eslint-disable-line eqeqeq
            length = 0
          }
          return Buffer.alloc(+length)
        }

        Buffer.isBuffer = function isBuffer(b) {
          return b != null && b._isBuffer === true
        }

        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError("Arguments must be Buffers")
          }

          if (a === b) return 0

          var x = a.length
          var y = b.length

          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i]
              y = b[i]
              break
            }
          }

          if (x < y) return -1
          if (y < x) return 1
          return 0
        }

        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true
            default:
              return false
          }
        }

        Buffer.concat = function concat(list, length) {
          if (!Array.isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers')
          }

          if (list.length === 0) {
            return Buffer.alloc(0)
          }

          var i
          if (length === undefined) {
            length = 0
            for (i = 0; i < list.length; ++i) {
              length += list[i].length
            }
          }

          var buffer = Buffer.allocUnsafe(length)
          var pos = 0
          for (i = 0; i < list.length; ++i) {
            var buf = list[i]
            if (ArrayBuffer.isView(buf)) {
              buf = Buffer.from(buf)
            }
            if (!Buffer.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers')
            }
            buf.copy(buffer, pos)
            pos += buf.length
          }
          return buffer
        }

        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length
          }
          if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
            return string.byteLength
          }
          if (typeof string !== "string") {
            string = "" + string
          }

          var len = string.length
          if (len === 0) return 0

          // Use a for loop to avoid recursion
          var loweredCase = false
          for (;;) {
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len
              case "utf8":
              case "utf-8":
              case undefined:
                return utf8ToBytes(string).length
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2
              case "hex":
                return len >>> 1
              case "base64":
                return base64ToBytes(string).length
              default:
                if (loweredCase) return utf8ToBytes(string).length // assume utf8
                encoding = ("" + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }
        Buffer.byteLength = byteLength

        function slowToString(encoding, start, end) {
          var loweredCase = false

          // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.

          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
          if (start === undefined || start < 0) {
            start = 0
          }
          // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.
          if (start > this.length) {
            return ""
          }

          if (end === undefined || end > this.length) {
            end = this.length
          }

          if (end <= 0) {
            return ""
          }

          // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
          end >>>= 0
          start >>>= 0

          if (end <= start) {
            return ""
          }

          if (!encoding) encoding = "utf8"

          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end)

              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end)

              case "ascii":
                return asciiSlice(this, start, end)

              case "latin1":
              case "binary":
                return latin1Slice(this, start, end)

              case "base64":
                return base64Slice(this, start, end)

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end)

              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding)
                encoding = (encoding + "").toLowerCase()
                loweredCase = true
            }
          }
        }

        // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
        // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
        // reliably in a browserify context because there could be multiple different
        // copies of the 'buffer' package in use. This method works even for Buffer
        // instances that were created from another copy of the `buffer` package.
        // See: https://github.com/feross/buffer/issues/154
        Buffer.prototype._isBuffer = true

        function swap(b, n, m) {
          var i = b[n]
          b[n] = b[m]
          b[m] = i
        }

        Buffer.prototype.swap16 = function swap16() {
          var len = this.length
          if (len % 2 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 16-bits")
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1)
          }
          return this
        }

        Buffer.prototype.swap32 = function swap32() {
          var len = this.length
          if (len % 4 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 32-bits")
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3)
            swap(this, i + 1, i + 2)
          }
          return this
        }

        Buffer.prototype.swap64 = function swap64() {
          var len = this.length
          if (len % 8 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 64-bits")
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7)
            swap(this, i + 1, i + 6)
            swap(this, i + 2, i + 5)
            swap(this, i + 3, i + 4)
          }
          return this
        }

        Buffer.prototype.toString = function toString() {
          var length = this.length
          if (length === 0) return ""
          if (arguments.length === 0) return utf8Slice(this, 0, length)
          return slowToString.apply(this, arguments)
        }

        Buffer.prototype.toLocaleString = Buffer.prototype.toString

        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b))
            throw new TypeError("Argument must be a Buffer")
          if (this === b) return true
          return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.inspect = function inspect() {
          var str = ""
          var max = exports.INSPECT_MAX_BYTES
          if (this.length > 0) {
            str = this.toString("hex", 0, max)
              .match(/.{2}/g)
              .join(" ")
            if (this.length > max) str += " ... "
          }
          return "<Buffer " + str + ">"
        }

        Buffer.prototype.compare = function compare(
          target,
          start,
          end,
          thisStart,
          thisEnd
        ) {
          if (!Buffer.isBuffer(target)) {
            throw new TypeError("Argument must be a Buffer")
          }

          if (start === undefined) {
            start = 0
          }
          if (end === undefined) {
            end = target ? target.length : 0
          }
          if (thisStart === undefined) {
            thisStart = 0
          }
          if (thisEnd === undefined) {
            thisEnd = this.length
          }

          if (
            start < 0 ||
            end > target.length ||
            thisStart < 0 ||
            thisEnd > this.length
          ) {
            throw new RangeError("out of range index")
          }

          if (thisStart >= thisEnd && start >= end) {
            return 0
          }
          if (thisStart >= thisEnd) {
            return -1
          }
          if (start >= end) {
            return 1
          }

          start >>>= 0
          end >>>= 0
          thisStart >>>= 0
          thisEnd >>>= 0

          if (this === target) return 0

          var x = thisEnd - thisStart
          var y = end - start
          var len = Math.min(x, y)

          var thisCopy = this.slice(thisStart, thisEnd)
          var targetCopy = target.slice(start, end)

          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i]
              y = targetCopy[i]
              break
            }
          }

          if (x < y) return -1
          if (y < x) return 1
          return 0
        }

        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1

          // Normalize byteOffset
          if (typeof byteOffset === "string") {
            encoding = byteOffset
            byteOffset = 0
          } else if (byteOffset > 0x7fffffff) {
            byteOffset = 0x7fffffff
          } else if (byteOffset < -0x80000000) {
            byteOffset = -0x80000000
          }
          byteOffset = +byteOffset // Coerce to Number.
          if (numberIsNaN(byteOffset)) {
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : buffer.length - 1
          }

          // Normalize byteOffset: negative offsets start from the end of the buffer
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset
          if (byteOffset >= buffer.length) {
            if (dir) return -1
            else byteOffset = buffer.length - 1
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0
            else return -1
          }

          // Normalize val
          if (typeof val === "string") {
            val = Buffer.from(val, encoding)
          }

          // Finally, search either indexOf (if dir is true) or lastIndexOf
          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) {
              return -1
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
          } else if (typeof val === "number") {
            val = val & 0xff // Search for a byte value [0-255]
            if (typeof Uint8Array.prototype.indexOf === "function") {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(
                  buffer,
                  val,
                  byteOffset
                )
              } else {
                return Uint8Array.prototype.lastIndexOf.call(
                  buffer,
                  val,
                  byteOffset
                )
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
          }

          throw new TypeError("val must be string, number or Buffer")
        }

        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1
          var arrLength = arr.length
          var valLength = val.length

          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase()
            if (
              encoding === "ucs2" ||
              encoding === "ucs-2" ||
              encoding === "utf16le" ||
              encoding === "utf-16le"
            ) {
              if (arr.length < 2 || val.length < 2) {
                return -1
              }
              indexSize = 2
              arrLength /= 2
              valLength /= 2
              byteOffset /= 2
            }
          }

          function read(buf, i) {
            if (indexSize === 1) {
              return buf[i]
            } else {
              return buf.readUInt16BE(i * indexSize)
            }
          }

          var i
          if (dir) {
            var foundIndex = -1
            for (i = byteOffset; i < arrLength; i++) {
              if (
                read(arr, i) ===
                read(val, foundIndex === -1 ? 0 : i - foundIndex)
              ) {
                if (foundIndex === -1) foundIndex = i
                if (i - foundIndex + 1 === valLength)
                  return foundIndex * indexSize
              } else {
                if (foundIndex !== -1) i -= i - foundIndex
                foundIndex = -1
              }
            }
          } else {
            if (byteOffset + valLength > arrLength)
              byteOffset = arrLength - valLength
            for (i = byteOffset; i >= 0; i--) {
              var found = true
              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false
                  break
                }
              }
              if (found) return i
            }
          }

          return -1
        }

        Buffer.prototype.includes = function includes(
          val,
          byteOffset,
          encoding
        ) {
          return this.indexOf(val, byteOffset, encoding) !== -1
        }

        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
        }

        Buffer.prototype.lastIndexOf = function lastIndexOf(
          val,
          byteOffset,
          encoding
        ) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
        }

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0
          var remaining = buf.length - offset
          if (!length) {
            length = remaining
          } else {
            length = Number(length)
            if (length > remaining) {
              length = remaining
            }
          }

          var strLen = string.length

          if (length > strLen / 2) {
            length = strLen / 2
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16)
            if (numberIsNaN(parsed)) return i
            buf[offset + i] = parsed
          }
          return i
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(
            utf8ToBytes(string, buf.length - offset),
            buf,
            offset,
            length
          )
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length)
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(
            utf16leToBytes(string, buf.length - offset),
            buf,
            offset,
            length
          )
        }

        Buffer.prototype.write = function write(
          string,
          offset,
          length,
          encoding
        ) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = "utf8"
            length = this.length
            offset = 0
            // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === "string") {
            encoding = offset
            length = this.length
            offset = 0
            // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset >>> 0
            if (isFinite(length)) {
              length = length >>> 0
              if (encoding === undefined) encoding = "utf8"
            } else {
              encoding = length
              length = undefined
            }
          } else {
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            )
          }

          var remaining = this.length - offset
          if (length === undefined || length > remaining) length = remaining

          if (
            (string.length > 0 && (length < 0 || offset < 0)) ||
            offset > this.length
          ) {
            throw new RangeError("Attempt to write outside buffer bounds")
          }

          if (!encoding) encoding = "utf8"

          var loweredCase = false
          for (;;) {
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length)

              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length)

              case "ascii":
                return asciiWrite(this, string, offset, length)

              case "latin1":
              case "binary":
                return latin1Write(this, string, offset, length)

              case "base64":
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length)

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length)

              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding)
                encoding = ("" + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }

        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          }
        }

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf)
          } else {
            return base64.fromByteArray(buf.slice(start, end))
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end)
          var res = []

          var i = start
          while (i < end) {
            var firstByte = buf[i]
            var codePoint = null
            var bytesPerSequence =
              firstByte > 0xef
                ? 4
                : firstByte > 0xdf
                  ? 3
                  : firstByte > 0xbf
                    ? 2
                    : 1

            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint

              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte
                  }
                  break
                case 2:
                  secondByte = buf[i + 1]
                  if ((secondByte & 0xc0) === 0x80) {
                    tempCodePoint =
                      ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f)
                    if (tempCodePoint > 0x7f) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 3:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  if (
                    (secondByte & 0xc0) === 0x80 &&
                    (thirdByte & 0xc0) === 0x80
                  ) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0xc) |
                      ((secondByte & 0x3f) << 0x6) |
                      (thirdByte & 0x3f)
                    if (
                      tempCodePoint > 0x7ff &&
                      (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                    ) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 4:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  fourthByte = buf[i + 3]
                  if (
                    (secondByte & 0xc0) === 0x80 &&
                    (thirdByte & 0xc0) === 0x80 &&
                    (fourthByte & 0xc0) === 0x80
                  ) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0x12) |
                      ((secondByte & 0x3f) << 0xc) |
                      ((thirdByte & 0x3f) << 0x6) |
                      (fourthByte & 0x3f)
                    if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint
                    }
                  }
              }
            }

            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xfffd
              bytesPerSequence = 1
            } else if (codePoint > 0xffff) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000
              res.push(((codePoint >>> 10) & 0x3ff) | 0xd800)
              codePoint = 0xdc00 | (codePoint & 0x3ff)
            }

            res.push(codePoint)
            i += bytesPerSequence
          }

          return decodeCodePointsArray(res)
        }

        // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
          }

          // Decode in chunks to avoid "call stack size exceeded".
          var res = ""
          var i = 0
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
            )
          }
          return res
        }

        function asciiSlice(buf, start, end) {
          var ret = ""
          end = Math.min(buf.length, end)

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 0x7f)
          }
          return ret
        }

        function latin1Slice(buf, start, end) {
          var ret = ""
          end = Math.min(buf.length, end)

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i])
          }
          return ret
        }

        function hexSlice(buf, start, end) {
          var len = buf.length

          if (!start || start < 0) start = 0
          if (!end || end < 0 || end > len) end = len

          var out = ""
          for (var i = start; i < end; ++i) {
            out += toHex(buf[i])
          }
          return out
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end)
          var res = ""
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
          }
          return res
        }

        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length
          start = ~~start
          end = end === undefined ? len : ~~end

          if (start < 0) {
            start += len
            if (start < 0) start = 0
          } else if (start > len) {
            start = len
          }

          if (end < 0) {
            end += len
            if (end < 0) end = 0
          } else if (end > len) {
            end = len
          }

          if (end < start) end = start

          var newBuf = this.subarray(start, end)
          // Return an augmented `Uint8Array` instance
          newBuf.__proto__ = Buffer.prototype
          return newBuf
        }

        /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0)
            throw new RangeError("offset is not uint")
          if (offset + ext > length)
            throw new RangeError("Trying to access beyond buffer length")
        }

        Buffer.prototype.readUIntLE = function readUIntLE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }

          return val
        }

        Buffer.prototype.readUIntBE = function readUIntBE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length)
          }

          var val = this[offset + --byteLength]
          var mul = 1
          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul
          }

          return val
        }

        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 1, this.length)
          return this[offset]
        }

        Buffer.prototype.readUInt16LE = function readUInt16LE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          return this[offset] | (this[offset + 1] << 8)
        }

        Buffer.prototype.readUInt16BE = function readUInt16BE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          return (this[offset] << 8) | this[offset + 1]
        }

        Buffer.prototype.readUInt32LE = function readUInt32LE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            (this[offset] |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16)) +
            this[offset + 3] * 0x1000000
          )
        }

        Buffer.prototype.readUInt32BE = function readUInt32BE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            this[offset] * 0x1000000 +
            ((this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3])
          )
        }

        Buffer.prototype.readIntLE = function readIntLE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }
          mul *= 0x80

          if (val >= mul) val -= Math.pow(2, 8 * byteLength)

          return val
        }

        Buffer.prototype.readIntBE = function readIntBE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var i = byteLength
          var mul = 1
          var val = this[offset + --i]
          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul
          }
          mul *= 0x80

          if (val >= mul) val -= Math.pow(2, 8 * byteLength)

          return val
        }

        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 1, this.length)
          if (!(this[offset] & 0x80)) return this[offset]
          return (0xff - this[offset] + 1) * -1
        }

        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset] | (this[offset + 1] << 8)
          return val & 0x8000 ? val | 0xffff0000 : val
        }

        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset + 1] | (this[offset] << 8)
          return val & 0x8000 ? val | 0xffff0000 : val
        }

        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            this[offset] |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16) |
            (this[offset + 3] << 24)
          )
        }

        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            (this[offset] << 24) |
            (this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            this[offset + 3]
          )
        }

        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, true, 23, 4)
        }

        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, false, 23, 4)
        }

        Buffer.prototype.readDoubleLE = function readDoubleLE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, true, 52, 8)
        }

        Buffer.prototype.readDoubleBE = function readDoubleBE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf))
            throw new TypeError('"buffer" argument must be a Buffer instance')
          if (value > max || value < min)
            throw new RangeError('"value" argument is out of bounds')
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range")
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1
            checkInt(this, value, offset, byteLength, maxBytes, 0)
          }

          var mul = 1
          var i = 0
          this[offset] = value & 0xff
          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeUIntBE = function writeUIntBE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1
            checkInt(this, value, offset, byteLength, maxBytes, 0)
          }

          var i = byteLength - 1
          var mul = 1
          this[offset + i] = value & 0xff
          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeUInt8 = function writeUInt8(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
          this[offset] = value & 0xff
          return offset + 1
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          this[offset] = value & 0xff
          this[offset + 1] = value >>> 8
          return offset + 2
        }

        Buffer.prototype.writeUInt16BE = function writeUInt16BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          this[offset] = value >>> 8
          this[offset + 1] = value & 0xff
          return offset + 2
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          this[offset + 3] = value >>> 24
          this[offset + 2] = value >>> 16
          this[offset + 1] = value >>> 8
          this[offset] = value & 0xff
          return offset + 4
        }

        Buffer.prototype.writeUInt32BE = function writeUInt32BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          this[offset] = value >>> 24
          this[offset + 1] = value >>> 16
          this[offset + 2] = value >>> 8
          this[offset + 3] = value & 0xff
          return offset + 4
        }

        Buffer.prototype.writeIntLE = function writeIntLE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1)

            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }

          var i = 0
          var mul = 1
          var sub = 0
          this[offset] = value & 0xff
          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1
            }
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeIntBE = function writeIntBE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1)

            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }

          var i = byteLength - 1
          var mul = 1
          var sub = 0
          this[offset + i] = value & 0xff
          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1
            }
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeInt8 = function writeInt8(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
          if (value < 0) value = 0xff + value + 1
          this[offset] = value & 0xff
          return offset + 1
        }

        Buffer.prototype.writeInt16LE = function writeInt16LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          this[offset] = value & 0xff
          this[offset + 1] = value >>> 8
          return offset + 2
        }

        Buffer.prototype.writeInt16BE = function writeInt16BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          this[offset] = value >>> 8
          this[offset + 1] = value & 0xff
          return offset + 2
        }

        Buffer.prototype.writeInt32LE = function writeInt32LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          this[offset] = value & 0xff
          this[offset + 1] = value >>> 8
          this[offset + 2] = value >>> 16
          this[offset + 3] = value >>> 24
          return offset + 4
        }

        Buffer.prototype.writeInt32BE = function writeInt32BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          if (value < 0) value = 0xffffffff + value + 1
          this[offset] = value >>> 24
          this[offset + 1] = value >>> 16
          this[offset + 2] = value >>> 8
          this[offset + 3] = value & 0xff
          return offset + 4
        }

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range")
          if (offset < 0) throw new RangeError("Index out of range")
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            checkIEEE754(
              buf,
              value,
              offset,
              4,
              3.4028234663852886e38,
              -3.4028234663852886e38
            )
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4)
          return offset + 4
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE(
          value,
          offset,
          noAssert
        ) {
          return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function writeFloatBE(
          value,
          offset,
          noAssert
        ) {
          return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            checkIEEE754(
              buf,
              value,
              offset,
              8,
              1.7976931348623157e308,
              -1.7976931348623157e308
            )
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8)
          return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE(
          value,
          offset,
          noAssert
        ) {
          return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function writeDoubleBE(
          value,
          offset,
          noAssert
        ) {
          return writeDouble(this, value, offset, false, noAssert)
        }

        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!Buffer.isBuffer(target))
            throw new TypeError("argument should be a Buffer")
          if (!start) start = 0
          if (!end && end !== 0) end = this.length
          if (targetStart >= target.length) targetStart = target.length
          if (!targetStart) targetStart = 0
          if (end > 0 && end < start) end = start

          // Copy 0 bytes; we're done
          if (end === start) return 0
          if (target.length === 0 || this.length === 0) return 0

          // Fatal error conditions
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds")
          }
          if (start < 0 || start >= this.length)
            throw new RangeError("Index out of range")
          if (end < 0) throw new RangeError("sourceEnd out of bounds")

          // Are we oob?
          if (end > this.length) end = this.length
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start
          }

          var len = end - start

          if (
            this === target &&
            typeof Uint8Array.prototype.copyWithin === "function"
          ) {
            // Use built-in when available, missing from IE11
            this.copyWithin(targetStart, start, end)
          } else if (
            this === target &&
            start < targetStart &&
            targetStart < end
          ) {
            // descending copy from end
            for (var i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start]
            }
          } else {
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, end),
              targetStart
            )
          }

          return len
        }

        // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start
              start = 0
              end = this.length
            } else if (typeof end === "string") {
              encoding = end
              end = this.length
            }
            if (encoding !== undefined && typeof encoding !== "string") {
              throw new TypeError("encoding must be a string")
            }
            if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding)
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0)
              if (
                (encoding === "utf8" && code < 128) ||
                encoding === "latin1"
              ) {
                // Fast path: If `val` fits into a single byte, use that numeric value.
                val = code
              }
            }
          } else if (typeof val === "number") {
            val = val & 255
          }

          // Invalid ranges are not set to a default, so can range check early.
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError("Out of range index")
          }

          if (end <= start) {
            return this
          }

          start = start >>> 0
          end = end === undefined ? this.length : end >>> 0

          if (!val) val = 0

          var i
          if (typeof val === "number") {
            for (i = start; i < end; ++i) {
              this[i] = val
            }
          } else {
            var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding)
            var len = bytes.length
            if (len === 0) {
              throw new TypeError(
                'The value "' + val + '" is invalid for argument "value"'
              )
            }
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len]
            }
          }

          return this
        }

        // HELPER FUNCTIONS
        // ================

        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

        function base64clean(str) {
          // Node takes equal signs as end of the Base64 encoding
          str = str.split("=")[0]
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = str.trim().replace(INVALID_BASE64_RE, "")
          // Node converts strings with length < 2 to ''
          if (str.length < 2) return ""
          // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
          while (str.length % 4 !== 0) {
            str = str + "="
          }
          return str
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16)
          return n.toString(16)
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity
          var codePoint
          var length = string.length
          var leadSurrogate = null
          var bytes = []

          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i)

            // is surrogate component
            if (codePoint > 0xd7ff && codePoint < 0xe000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xdbff) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                  continue
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                  continue
                }

                // valid lead
                leadSurrogate = codePoint

                continue
              }

              // 2 leads in a row
              if (codePoint < 0xdc00) {
                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                leadSurrogate = codePoint
                continue
              }

              // valid surrogate pair
              codePoint =
                (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                0x10000
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
            }

            leadSurrogate = null

            // encode utf8
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break
              bytes.push(codePoint)
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break
              bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80)
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break
              bytes.push(
                (codePoint >> 0xc) | 0xe0,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80
              )
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break
              bytes.push(
                (codePoint >> 0x12) | 0xf0,
                ((codePoint >> 0xc) & 0x3f) | 0x80,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80
              )
            } else {
              throw new Error("Invalid code point")
            }
          }

          return bytes
        }

        function asciiToBytes(str) {
          var byteArray = []
          for (var i = 0; i < str.length; ++i) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xff)
          }
          return byteArray
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo
          var byteArray = []
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break

            c = str.charCodeAt(i)
            hi = c >> 8
            lo = c % 256
            byteArray.push(lo)
            byteArray.push(hi)
          }

          return byteArray
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str))
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break
            dst[i + offset] = src[i]
          }
          return i
        }

        // ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
        // but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
        function isArrayBuffer(obj) {
          return (
            obj instanceof ArrayBuffer ||
            (obj != null &&
              obj.constructor != null &&
              obj.constructor.name === "ArrayBuffer" &&
              typeof obj.byteLength === "number")
          )
        }

        function numberIsNaN(obj) {
          return obj !== obj // eslint-disable-line no-self-compare
        }
      },
      { "base64-js": 5, ieee754: 36 }
    ],
    2: [
      function(require, module, exports) {
        // crc16 impl, optimized for numeric inputs

        var TABLE = [
          0x0000,
          0x1021,
          0x2042,
          0x3063,
          0x4084,
          0x50a5,
          0x60c6,
          0x70e7,
          0x8108,
          0x9129,
          0xa14a,
          0xb16b,
          0xc18c,
          0xd1ad,
          0xe1ce,
          0xf1ef,
          0x1231,
          0x0210,
          0x3273,
          0x2252,
          0x52b5,
          0x4294,
          0x72f7,
          0x62d6,
          0x9339,
          0x8318,
          0xb37b,
          0xa35a,
          0xd3bd,
          0xc39c,
          0xf3ff,
          0xe3de,
          0x2462,
          0x3443,
          0x0420,
          0x1401,
          0x64e6,
          0x74c7,
          0x44a4,
          0x5485,
          0xa56a,
          0xb54b,
          0x8528,
          0x9509,
          0xe5ee,
          0xf5cf,
          0xc5ac,
          0xd58d,
          0x3653,
          0x2672,
          0x1611,
          0x0630,
          0x76d7,
          0x66f6,
          0x5695,
          0x46b4,
          0xb75b,
          0xa77a,
          0x9719,
          0x8738,
          0xf7df,
          0xe7fe,
          0xd79d,
          0xc7bc,
          0x48c4,
          0x58e5,
          0x6886,
          0x78a7,
          0x0840,
          0x1861,
          0x2802,
          0x3823,
          0xc9cc,
          0xd9ed,
          0xe98e,
          0xf9af,
          0x8948,
          0x9969,
          0xa90a,
          0xb92b,
          0x5af5,
          0x4ad4,
          0x7ab7,
          0x6a96,
          0x1a71,
          0x0a50,
          0x3a33,
          0x2a12,
          0xdbfd,
          0xcbdc,
          0xfbbf,
          0xeb9e,
          0x9b79,
          0x8b58,
          0xbb3b,
          0xab1a,
          0x6ca6,
          0x7c87,
          0x4ce4,
          0x5cc5,
          0x2c22,
          0x3c03,
          0x0c60,
          0x1c41,
          0xedae,
          0xfd8f,
          0xcdec,
          0xddcd,
          0xad2a,
          0xbd0b,
          0x8d68,
          0x9d49,
          0x7e97,
          0x6eb6,
          0x5ed5,
          0x4ef4,
          0x3e13,
          0x2e32,
          0x1e51,
          0x0e70,
          0xff9f,
          0xefbe,
          0xdfdd,
          0xcffc,
          0xbf1b,
          0xaf3a,
          0x9f59,
          0x8f78,
          0x9188,
          0x81a9,
          0xb1ca,
          0xa1eb,
          0xd10c,
          0xc12d,
          0xf14e,
          0xe16f,
          0x1080,
          0x00a1,
          0x30c2,
          0x20e3,
          0x5004,
          0x4025,
          0x7046,
          0x6067,
          0x83b9,
          0x9398,
          0xa3fb,
          0xb3da,
          0xc33d,
          0xd31c,
          0xe37f,
          0xf35e,
          0x02b1,
          0x1290,
          0x22f3,
          0x32d2,
          0x4235,
          0x5214,
          0x6277,
          0x7256,
          0xb5ea,
          0xa5cb,
          0x95a8,
          0x8589,
          0xf56e,
          0xe54f,
          0xd52c,
          0xc50d,
          0x34e2,
          0x24c3,
          0x14a0,
          0x0481,
          0x7466,
          0x6447,
          0x5424,
          0x4405,
          0xa7db,
          0xb7fa,
          0x8799,
          0x97b8,
          0xe75f,
          0xf77e,
          0xc71d,
          0xd73c,
          0x26d3,
          0x36f2,
          0x0691,
          0x16b0,
          0x6657,
          0x7676,
          0x4615,
          0x5634,
          0xd94c,
          0xc96d,
          0xf90e,
          0xe92f,
          0x99c8,
          0x89e9,
          0xb98a,
          0xa9ab,
          0x5844,
          0x4865,
          0x7806,
          0x6827,
          0x18c0,
          0x08e1,
          0x3882,
          0x28a3,
          0xcb7d,
          0xdb5c,
          0xeb3f,
          0xfb1e,
          0x8bf9,
          0x9bd8,
          0xabbb,
          0xbb9a,
          0x4a75,
          0x5a54,
          0x6a37,
          0x7a16,
          0x0af1,
          0x1ad0,
          0x2ab3,
          0x3a92,
          0xfd2e,
          0xed0f,
          0xdd6c,
          0xcd4d,
          0xbdaa,
          0xad8b,
          0x9de8,
          0x8dc9,
          0x7c26,
          0x6c07,
          0x5c64,
          0x4c45,
          0x3ca2,
          0x2c83,
          0x1ce0,
          0x0cc1,
          0xef1f,
          0xff3e,
          0xcf5d,
          0xdf7c,
          0xaf9b,
          0xbfba,
          0x8fd9,
          0x9ff8,
          0x6e17,
          0x7e36,
          0x4e55,
          0x5e74,
          0x2e93,
          0x3eb2,
          0x0ed1,
          0x1ef0
        ]

        module.exports = crc16

        function crc16(n) {
          var crc = 0
          var r = 0

          for (var i = 0; i < 8; i++) {
            r = n & 0xff
            n = (n - r) / 256
            crc = ((crc << 8) ^ TABLE[((crc >> 8) ^ r) & 0xff]) & 0xffff
          }

          return crc
        }
      },
      {}
    ],
    3: [
      function(require, module, exports) {
        var hash = require("./crc16")

        module.exports = LRU

        function LRU(max, opts) {
          if (!(this instanceof LRU)) return new LRU(max, opts)
          if (!opts) opts = {}

          // how many collisions before evicting (factor of two for fast modulo)
          this.collisions = factorOfTwo(opts.collisions || opts.bucketSize || 4)
          // buckets should be a factor of two for fast modulo as well
          this.buckets = factorOf(max, this.collisions) / this.collisions

          // we use 16bit hashing to bucket index must be <0xffff
          while (this.buckets > 65536) {
            this.buckets >>= 1
            this.collisions <<= 1
          }

          this.size = this.buckets * this.collisions
          this.wrap = !opts.indexedValues
          this.cache = new Array(this.size)
          this.hash =
            this.buckets === 65536 ? hash : maskedHash(this.buckets - 1)
          this.evict = opts.evict || null
        }

        LRU.prototype.set = function(index, val) {
          var pageStart = this.collisions * this.hash(index)
          var pageEnd = pageStart + this.collisions
          var ptr = pageStart
          var page = null

          while (ptr < pageEnd) {
            page = this.cache[ptr]

            if (!page) {
              // no exiting version, but we have space to store it
              page = this.cache[ptr] = this.wrap ? new Node(index, val) : val
              move(this.cache, pageStart, ptr, page)
              return
            }

            if (page.index === index) {
              // update existing version and move to head of bucket
              if (this.wrap) page.value = val
              else this.cache[ptr] = val
              move(this.cache, pageStart, ptr, page)
              return
            }

            ptr++
          }

          // bucket is full, update oldest (last element in bucket)
          if (this.wrap) {
            if (this.evict) this.evict(page.index, page.value)
            page.index = index
            page.value = val
          } else {
            if (this.evict) this.evict(page.index, page)
            this.cache[ptr - 1] = val
          }
          move(this.cache, pageStart, ptr - 1, page)
        }

        LRU.prototype.get = function(index) {
          var pageStart = this.collisions * this.hash(index)
          var pageEnd = pageStart + this.collisions
          var ptr = pageStart

          while (ptr < pageEnd) {
            var page = this.cache[ptr++]

            if (!page) return null
            if (page.index !== index) continue

            // we found it! move to head of bucket and return value
            move(this.cache, pageStart, ptr - 1, page)

            return this.wrap ? page.value : page
          }

          return null
        }

        function move(list, index, itemIndex, item) {
          while (itemIndex > index) list[itemIndex] = list[--itemIndex]
          list[index] = item
        }

        function Node(index, value) {
          this.index = index
          this.value = value
        }

        function factorOf(n, factor) {
          n = factorOfTwo(n)
          while (n & (factor - 1)) n <<= 1
          return n
        }

        function factorOfTwo(n) {
          if (n && !(n & (n - 1))) return n
          var p = 1
          while (p < n) p <<= 1
          return p
        }

        function maskedHash(mask) {
          return function(n) {
            return hash(n) & mask
          }
        }
      },
      { "./crc16": 2 }
    ],
    4: [
      function(require, module, exports) {
        module.exports = batcher

        function batcher(run) {
          var running = false
          var pendingBatch = null
          var pendingCallbacks = null
          var callbacks = null

          return append

          function done(err) {
            if (callbacks) callAll(callbacks, err)

            running = false
            callbacks = pendingCallbacks
            var nextBatch = pendingBatch

            pendingBatch = null
            pendingCallbacks = null

            if (!nextBatch || !nextBatch.length) {
              if (!callbacks || !callbacks.length) {
                callbacks = null
                return
              }
              if (!nextBatch) nextBatch = []
            }

            running = true
            run(nextBatch, done)
          }

          function append(val, cb) {
            if (running) {
              if (!pendingBatch) {
                pendingBatch = []
                pendingCallbacks = []
              }
              pushAll(pendingBatch, val)
              if (cb) pendingCallbacks.push(cb)
            } else {
              if (cb) callbacks = [cb]
              running = true
              run(Array.isArray(val) ? val : [val], done)
            }
          }
        }

        function pushAll(list, val) {
          if (Array.isArray(val)) pushArray(list, val)
          else list.push(val)
        }

        function pushArray(list, val) {
          for (var i = 0; i < val.length; i++) list.push(val[i])
        }

        function callAll(list, err) {
          for (var i = 0; i < list.length; i++) list[i](err)
        }
      },
      {}
    ],
    5: [
      function(require, module, exports) {
        "use strict"

        exports.byteLength = byteLength
        exports.toByteArray = toByteArray
        exports.fromByteArray = fromByteArray

        var lookup = []
        var revLookup = []
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array

        var code =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i]
          revLookup[code.charCodeAt(i)] = i
        }

        // Support decoding URL-safe base64 strings, as Node.js does.
        // See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup["-".charCodeAt(0)] = 62
        revLookup["_".charCodeAt(0)] = 63

        function getLens(b64) {
          var len = b64.length

          if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4")
          }

          // Trim off extra bytes after placeholder bytes are found
          // See: https://github.com/beatgammit/base64-js/issues/42
          var validLen = b64.indexOf("=")
          if (validLen === -1) validLen = len

          var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4)

          return [validLen, placeHoldersLen]
        }

        // base64 is 4/3 + up to two characters of the original data
        function byteLength(b64) {
          var lens = getLens(b64)
          var validLen = lens[0]
          var placeHoldersLen = lens[1]
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
        }

        function _byteLength(b64, validLen, placeHoldersLen) {
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
        }

        function toByteArray(b64) {
          var tmp
          var lens = getLens(b64)
          var validLen = lens[0]
          var placeHoldersLen = lens[1]

          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

          var curByte = 0

          // if there are placeholders, only get up to the last complete 4 chars
          var len = placeHoldersLen > 0 ? validLen - 4 : validLen

          for (var i = 0; i < len; i += 4) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 18) |
              (revLookup[b64.charCodeAt(i + 1)] << 12) |
              (revLookup[b64.charCodeAt(i + 2)] << 6) |
              revLookup[b64.charCodeAt(i + 3)]
            arr[curByte++] = (tmp >> 16) & 0xff
            arr[curByte++] = (tmp >> 8) & 0xff
            arr[curByte++] = tmp & 0xff
          }

          if (placeHoldersLen === 2) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 2) |
              (revLookup[b64.charCodeAt(i + 1)] >> 4)
            arr[curByte++] = tmp & 0xff
          }

          if (placeHoldersLen === 1) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 10) |
              (revLookup[b64.charCodeAt(i + 1)] << 4) |
              (revLookup[b64.charCodeAt(i + 2)] >> 2)
            arr[curByte++] = (tmp >> 8) & 0xff
            arr[curByte++] = tmp & 0xff
          }

          return arr
        }

        function tripletToBase64(num) {
          return (
            lookup[(num >> 18) & 0x3f] +
            lookup[(num >> 12) & 0x3f] +
            lookup[(num >> 6) & 0x3f] +
            lookup[num & 0x3f]
          )
        }

        function encodeChunk(uint8, start, end) {
          var tmp
          var output = []
          for (var i = start; i < end; i += 3) {
            tmp =
              ((uint8[i] << 16) & 0xff0000) +
              ((uint8[i + 1] << 8) & 0xff00) +
              (uint8[i + 2] & 0xff)
            output.push(tripletToBase64(tmp))
          }
          return output.join("")
        }

        function fromByteArray(uint8) {
          var tmp
          var len = uint8.length
          var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
          var parts = []
          var maxChunkLength = 16383 // must be multiple of 3

          // go through the array every three bytes, we'll deal with trailing stuff later
          for (
            var i = 0, len2 = len - extraBytes;
            i < len2;
            i += maxChunkLength
          ) {
            parts.push(
              encodeChunk(
                uint8,
                i,
                i + maxChunkLength > len2 ? len2 : i + maxChunkLength
              )
            )
          }

          // pad the end with zeros, but make sure to not forget the extra bytes
          if (extraBytes === 1) {
            tmp = uint8[len - 1]
            parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==")
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1]
            parts.push(
              lookup[tmp >> 10] +
                lookup[(tmp >> 4) & 0x3f] +
                lookup[(tmp << 2) & 0x3f] +
                "="
            )
          }

          return parts.join("")
        }
      },
      {}
    ],
    6: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var varint = require("varint")

          exports.encode = encode
          exports.encode.bytes = 0
          exports.encodingLength = encodingLength

          exports.decode = decode
          exports.decode.bytes = 0
          exports.decodingLength = decodingLength

          function State(input, output, offset) {
            this.inputOffset = 0
            this.inputLength = input.length
            this.input = input
            this.outputOffset = offset
            this.output = output
          }

          function encode(bitfield, buffer, offset) {
            if (!offset) offset = 0
            if (!buffer) buffer = new Buffer(encodingLength(bitfield))
            var state = new State(bitfield, buffer, offset)
            rle(state)
            encode.bytes = state.outputOffset - offset
            return buffer
          }

          function encodingLength(bitfield) {
            var state = new State(bitfield, null, 0)
            rle(state)
            return state.outputOffset
          }

          function decode(buffer, offset) {
            if (!offset) offset = 0

            var bitfield = new Buffer(decodingLength(buffer, offset))
            var ptr = 0

            while (offset < buffer.length) {
              var next = varint.decode(buffer, offset)
              var repeat = next & 1
              var len = repeat ? (next - (next & 3)) / 4 : next / 2

              offset += varint.decode.bytes

              if (repeat) {
                bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len)
              } else {
                buffer.copy(bitfield, ptr, offset, offset + len)
                offset += len
              }

              ptr += len
            }

            decode.bytes = buffer.length - offset

            return bitfield
          }

          function decodingLength(buffer, offset) {
            if (!offset) offset = 0

            var len = 0

            while (offset < buffer.length) {
              var next = varint.decode(buffer, offset)
              offset += varint.decode.bytes

              var repeat = next & 1
              var slice = repeat ? (next - (next & 3)) / 4 : next / 2

              len += slice
              if (!repeat) offset += slice
            }

            if (offset > buffer.length) throw new Error("Invalid RLE bitfield")

            return len
          }

          function rle(state) {
            var len = 0
            var bits = 0
            var input = state.input

            while (state.inputLength > 0 && !input[state.inputLength - 1])
              state.inputLength--

            for (var i = 0; i < state.inputLength; i++) {
              if (input[i] === bits) {
                len++
                continue
              }

              if (len) encodeUpdate(state, i, len, bits)

              if (input[i] === 0 || input[i] === 255) {
                bits = input[i]
                len = 1
              } else {
                len = 0
              }
            }

            if (len) encodeUpdate(state, state.inputLength, len, bits)
            encodeFinal(state)
          }

          function encodeHead(state, end) {
            var headLength = end - state.inputOffset
            varint.encode(2 * headLength, state.output, state.outputOffset)
            state.outputOffset += varint.encode.bytes
            state.input.copy(
              state.output,
              state.outputOffset,
              state.inputOffset,
              end
            )
            state.outputOffset += headLength
          }

          function encodeFinal(state) {
            var headLength = state.inputLength - state.inputOffset
            if (!headLength) return

            if (!state.output) {
              state.outputOffset +=
                headLength + varint.encodingLength(2 * headLength)
            } else {
              encodeHead(state, state.inputLength)
            }

            state.inputOffset = state.inputLength
          }

          function encodeUpdate(state, i, len, bit) {
            var headLength = i - len - state.inputOffset
            var headCost = headLength
              ? varint.encodingLength(2 * headLength) + headLength
              : 0
            var enc = 4 * len + (bit ? 2 : 0) + 1 // len << 2 | bit << 1 | 1
            var encCost = headCost + varint.encodingLength(enc)
            var baseCost =
              varint.encodingLength(2 * (i - state.inputOffset)) +
              i -
              state.inputOffset

            if (encCost >= baseCost) return

            if (!state.output) {
              state.outputOffset += encCost
              state.inputOffset = i
              return
            }

            if (headLength) encodeHead(state, i - len)

            varint.encode(enc, state.output, state.outputOffset)
            state.outputOffset += varint.encode.bytes
            state.inputOffset = i
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, varint: 9 }
    ],
    7: [
      function(require, module, exports) {
        module.exports = read

        var MSB = 0x80,
          REST = 0x7f

        function read(buf, offset) {
          var res = 0,
            offset = offset || 0,
            shift = 0,
            counter = offset,
            b,
            l = buf.length

          do {
            if (counter >= l) {
              read.bytes = 0
              read.bytesRead = 0 // DEPRECATED
              return undefined
            }
            b = buf[counter++]
            res +=
              shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift)
            shift += 7
          } while (b >= MSB)

          read.bytes = counter - offset

          return res
        }
      },
      {}
    ],
    8: [
      function(require, module, exports) {
        module.exports = encode

        var MSB = 0x80,
          REST = 0x7f,
          MSBALL = ~REST,
          INT = Math.pow(2, 31)

        function encode(num, out, offset) {
          out = out || []
          offset = offset || 0
          var oldOffset = offset

          while (num >= INT) {
            out[offset++] = (num & 0xff) | MSB
            num /= 128
          }
          while (num & MSBALL) {
            out[offset++] = (num & 0xff) | MSB
            num >>>= 7
          }
          out[offset] = num | 0

          encode.bytes = offset - oldOffset + 1

          return out
        }
      },
      {}
    ],
    9: [
      function(require, module, exports) {
        module.exports = {
          encode: require("./encode.js"),
          decode: require("./decode.js"),
          encodingLength: require("./length.js")
        }
      },
      { "./decode.js": 7, "./encode.js": 8, "./length.js": 10 }
    ],
    10: [
      function(require, module, exports) {
        var N1 = Math.pow(2, 7)
        var N2 = Math.pow(2, 14)
        var N3 = Math.pow(2, 21)
        var N4 = Math.pow(2, 28)
        var N5 = Math.pow(2, 35)
        var N6 = Math.pow(2, 42)
        var N7 = Math.pow(2, 49)
        var N8 = Math.pow(2, 56)
        var N9 = Math.pow(2, 63)

        module.exports = function(value) {
          return value < N1
            ? 1
            : value < N2
              ? 2
              : value < N3
                ? 3
                : value < N4
                  ? 4
                  : value < N5
                    ? 5
                    : value < N6
                      ? 6
                      : value < N7
                        ? 7
                        : value < N8
                          ? 8
                          : value < N9
                            ? 9
                            : 10
        }
      },
      {}
    ],
    11: [
      function(require, module, exports) {
        module.exports = loadWebAssembly

        loadWebAssembly.supported = typeof WebAssembly !== "undefined"

        function loadWebAssembly(opts) {
          if (!loadWebAssembly.supported) return null

          var imp = opts && opts.imports
          var wasm = toUint8Array(
            "AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL"
          )
          var ready = null

          var mod = {
            buffer: wasm,
            memory: null,
            exports: null,
            realloc: realloc,
            onload: onload
          }

          onload(function() {})

          return mod

          function realloc(size) {
            mod.exports.memory.grow(
              Math.ceil(Math.abs(size - mod.memory.length) / 65536)
            )
            mod.memory = new Uint8Array(mod.exports.memory.buffer)
          }

          function onload(cb) {
            if (mod.exports) return cb()

            if (ready) {
              ready.then(cb.bind(null, null)).catch(cb)
              return
            }

            try {
              if (opts && opts.async) throw new Error("async")
              setup({
                instance: new WebAssembly.Instance(
                  new WebAssembly.Module(wasm),
                  imp
                )
              })
            } catch (err) {
              ready = WebAssembly.instantiate(wasm, imp).then(setup)
            }

            onload(cb)
          }

          function setup(w) {
            mod.exports = w.instance.exports
            mod.memory =
              mod.exports.memory &&
              mod.exports.memory.buffer &&
              new Uint8Array(mod.exports.memory.buffer)
          }
        }

        function toUint8Array(s) {
          if (typeof atob === "function")
            return new Uint8Array(
              atob(s)
                .split("")
                .map(charCodeAt)
            )
          return new (require("buf" + "fer")).Buffer(s, "base64")
        }

        function charCodeAt(c) {
          return c.charCodeAt(0)
        }
      },
      {}
    ],
    12: [
      function(require, module, exports) {
        var assert = require("nanoassert")
        var wasm = require("./blake2b")()

        var head = 64
        var freeList = []

        module.exports = Blake2b
        var BYTES_MIN = (module.exports.BYTES_MIN = 16)
        var BYTES_MAX = (module.exports.BYTES_MAX = 64)
        var BYTES = (module.exports.BYTES = 32)
        var KEYBYTES_MIN = (module.exports.KEYBYTES_MIN = 16)
        var KEYBYTES_MAX = (module.exports.KEYBYTES_MAX = 64)
        var KEYBYTES = (module.exports.KEYBYTES = 32)
        var SALTBYTES = (module.exports.SALTBYTES = 16)
        var PERSONALBYTES = (module.exports.PERSONALBYTES = 16)

        function Blake2b(digestLength, key, salt, personal, noAssert) {
          if (!(this instanceof Blake2b))
            return new Blake2b(digestLength, key, salt, personal, noAssert)
          if (!(wasm && wasm.exports))
            throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)")
          if (!digestLength) digestLength = 32

          if (noAssert !== true) {
            assert(
              digestLength >= BYTES_MIN,
              "digestLength must be at least " +
                BYTES_MIN +
                ", was given " +
                digestLength
            )
            assert(
              digestLength <= BYTES_MAX,
              "digestLength must be at most " +
                BYTES_MAX +
                ", was given " +
                digestLength
            )
            if (key != null)
              assert(
                key.length >= KEYBYTES_MIN,
                "key must be at least " +
                  KEYBYTES_MIN +
                  ", was given " +
                  key.length
              )
            if (key != null)
              assert(
                key.length <= KEYBYTES_MAX,
                "key must be at least " +
                  KEYBYTES_MAX +
                  ", was given " +
                  key.length
              )
            if (salt != null)
              assert(
                salt.length === SALTBYTES,
                "salt must be exactly " +
                  SALTBYTES +
                  ", was given " +
                  salt.length
              )
            if (personal != null)
              assert(
                personal.length === PERSONALBYTES,
                "personal must be exactly " +
                  PERSONALBYTES +
                  ", was given " +
                  personal.length
              )
          }

          if (!freeList.length) {
            freeList.push(head)
            head += 216
          }

          this.digestLength = digestLength
          this.finalized = false
          this.pointer = freeList.pop()

          wasm.memory.fill(0, 0, 64)
          wasm.memory[0] = this.digestLength
          wasm.memory[1] = key ? key.length : 0
          wasm.memory[2] = 1 // fanout
          wasm.memory[3] = 1 // depth

          if (salt) wasm.memory.set(salt, 32)
          if (personal) wasm.memory.set(personal, 48)

          if (this.pointer + 216 > wasm.memory.length)
            wasm.realloc(this.pointer + 216) // we need 216 bytes for the state
          wasm.exports.blake2b_init(this.pointer, this.digestLength)

          if (key) {
            this.update(key)
            wasm.memory.fill(0, head, head + key.length) // whiteout key
            wasm.memory[this.pointer + 200] = 128
          }
        }

        Blake2b.prototype.update = function(input) {
          assert(this.finalized === false, "Hash instance finalized")
          assert(input, "input must be TypedArray or Buffer")

          if (head + input.length > wasm.memory.length)
            wasm.realloc(head + input.length)
          wasm.memory.set(input, head)
          wasm.exports.blake2b_update(this.pointer, head, head + input.length)
          return this
        }

        Blake2b.prototype.digest = function(enc) {
          assert(this.finalized === false, "Hash instance finalized")
          this.finalized = true

          freeList.push(this.pointer)
          wasm.exports.blake2b_final(this.pointer)

          if (!enc || enc === "binary") {
            return wasm.memory.slice(
              this.pointer + 128,
              this.pointer + 128 + this.digestLength
            )
          }

          if (enc === "hex") {
            return hexSlice(wasm.memory, this.pointer + 128, this.digestLength)
          }

          assert(
            enc.length >= this.digestLength,
            "input must be TypedArray or Buffer"
          )
          for (var i = 0; i < this.digestLength; i++) {
            enc[i] = wasm.memory[this.pointer + 128 + i]
          }

          return enc
        }

        // libsodium compat
        Blake2b.prototype.final = Blake2b.prototype.digest

        Blake2b.WASM = wasm && wasm.buffer
        Blake2b.SUPPORTED = typeof WebAssembly !== "undefined"

        Blake2b.ready = function(cb) {
          if (!cb) cb = noop
          if (!wasm) return cb(new Error("WebAssembly not supported"))

          // backwards compat, can be removed in a new major
          var p = new Promise(function(reject, resolve) {
            wasm.onload(function(err) {
              if (err) resolve()
              else reject()
              cb(err)
            })
          })

          return p
        }

        Blake2b.prototype.ready = Blake2b.ready

        function noop() {}

        function hexSlice(buf, start, len) {
          var str = ""
          for (var i = 0; i < len; i++) str += toHex(buf[start + i])
          return str
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16)
          return n.toString(16)
        }
      },
      { "./blake2b": 11, nanoassert: 42 }
    ],
    13: [
      function(require, module, exports) {
        var assert = require("nanoassert")
        var b2wasm = require("blake2b-wasm")

        // 64-bit unsigned addition
        // Sets v[a,a+1] += v[b,b+1]
        // v should be a Uint32Array
        function ADD64AA(v, a, b) {
          var o0 = v[a] + v[b]
          var o1 = v[a + 1] + v[b + 1]
          if (o0 >= 0x100000000) {
            o1++
          }
          v[a] = o0
          v[a + 1] = o1
        }

        // 64-bit unsigned addition
        // Sets v[a,a+1] += b
        // b0 is the low 32 bits of b, b1 represents the high 32 bits
        function ADD64AC(v, a, b0, b1) {
          var o0 = v[a] + b0
          if (b0 < 0) {
            o0 += 0x100000000
          }
          var o1 = v[a + 1] + b1
          if (o0 >= 0x100000000) {
            o1++
          }
          v[a] = o0
          v[a + 1] = o1
        }

        // Little-endian byte access
        function B2B_GET32(arr, i) {
          return (
            arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)
          )
        }

        // G Mixing function
        // The ROTRs are inlined for speed
        function B2B_G(a, b, c, d, ix, iy) {
          var x0 = m[ix]
          var x1 = m[ix + 1]
          var y0 = m[iy]
          var y1 = m[iy + 1]

          ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
          ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

          // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
          var xor0 = v[d] ^ v[a]
          var xor1 = v[d + 1] ^ v[a + 1]
          v[d] = xor1
          v[d + 1] = xor0

          ADD64AA(v, c, d)

          // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
          xor0 = v[b] ^ v[c]
          xor1 = v[b + 1] ^ v[c + 1]
          v[b] = (xor0 >>> 24) ^ (xor1 << 8)
          v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

          ADD64AA(v, a, b)
          ADD64AC(v, a, y0, y1)

          // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
          xor0 = v[d] ^ v[a]
          xor1 = v[d + 1] ^ v[a + 1]
          v[d] = (xor0 >>> 16) ^ (xor1 << 16)
          v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

          ADD64AA(v, c, d)

          // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
          xor0 = v[b] ^ v[c]
          xor1 = v[b + 1] ^ v[c + 1]
          v[b] = (xor1 >>> 31) ^ (xor0 << 1)
          v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
        }

        // Initialization Vector
        var BLAKE2B_IV32 = new Uint32Array([
          0xf3bcc908,
          0x6a09e667,
          0x84caa73b,
          0xbb67ae85,
          0xfe94f82b,
          0x3c6ef372,
          0x5f1d36f1,
          0xa54ff53a,
          0xade682d1,
          0x510e527f,
          0x2b3e6c1f,
          0x9b05688c,
          0xfb41bd6b,
          0x1f83d9ab,
          0x137e2179,
          0x5be0cd19
        ])

        var SIGMA8 = [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          14,
          10,
          4,
          8,
          9,
          15,
          13,
          6,
          1,
          12,
          0,
          2,
          11,
          7,
          5,
          3,
          11,
          8,
          12,
          0,
          5,
          2,
          15,
          13,
          10,
          14,
          3,
          6,
          7,
          1,
          9,
          4,
          7,
          9,
          3,
          1,
          13,
          12,
          11,
          14,
          2,
          6,
          5,
          10,
          4,
          0,
          15,
          8,
          9,
          0,
          5,
          7,
          2,
          4,
          10,
          15,
          14,
          1,
          11,
          12,
          6,
          8,
          3,
          13,
          2,
          12,
          6,
          10,
          0,
          11,
          8,
          3,
          4,
          13,
          7,
          5,
          15,
          14,
          1,
          9,
          12,
          5,
          1,
          15,
          14,
          13,
          4,
          10,
          0,
          7,
          6,
          3,
          9,
          2,
          8,
          11,
          13,
          11,
          7,
          14,
          12,
          1,
          3,
          9,
          5,
          0,
          15,
          4,
          8,
          6,
          2,
          10,
          6,
          15,
          14,
          9,
          11,
          3,
          0,
          8,
          12,
          2,
          13,
          7,
          1,
          4,
          10,
          5,
          10,
          2,
          8,
          4,
          7,
          6,
          1,
          5,
          15,
          11,
          9,
          14,
          3,
          12,
          13,
          0,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          14,
          10,
          4,
          8,
          9,
          15,
          13,
          6,
          1,
          12,
          0,
          2,
          11,
          7,
          5,
          3
        ]

        // These are offsets into a uint64 buffer.
        // Multiply them all by 2 to make them offsets into a uint32 buffer,
        // because this is Javascript and we don't have uint64s
        var SIGMA82 = new Uint8Array(
          SIGMA8.map(function(x) {
            return x * 2
          })
        )

        // Compression function. 'last' flag indicates last block.
        // Note we're representing 16 uint64s as 32 uint32s
        var v = new Uint32Array(32)
        var m = new Uint32Array(32)
        function blake2bCompress(ctx, last) {
          var i = 0

          // init work variables
          for (i = 0; i < 16; i++) {
            v[i] = ctx.h[i]
            v[i + 16] = BLAKE2B_IV32[i]
          }

          // low 64 bits of offset
          v[24] = v[24] ^ ctx.t
          v[25] = v[25] ^ (ctx.t / 0x100000000)
          // high 64 bits not supported, offset may not be higher than 2**53-1

          // last block flag set ?
          if (last) {
            v[28] = ~v[28]
            v[29] = ~v[29]
          }

          // get little-endian words
          for (i = 0; i < 32; i++) {
            m[i] = B2B_GET32(ctx.b, 4 * i)
          }

          // twelve rounds of mixing
          for (i = 0; i < 12; i++) {
            B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
            B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
            B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
            B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
            B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
            B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
            B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
            B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
          }

          for (i = 0; i < 16; i++) {
            ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
          }
        }

        // reusable parameter_block
        var parameter_block = new Uint8Array([
          0,
          0,
          0,
          0, //  0: outlen, keylen, fanout, depth
          0,
          0,
          0,
          0, //  4: leaf length, sequential mode
          0,
          0,
          0,
          0, //  8: node offset
          0,
          0,
          0,
          0, // 12: node offset
          0,
          0,
          0,
          0, // 16: node depth, inner length, rfu
          0,
          0,
          0,
          0, // 20: rfu
          0,
          0,
          0,
          0, // 24: rfu
          0,
          0,
          0,
          0, // 28: rfu
          0,
          0,
          0,
          0, // 32: salt
          0,
          0,
          0,
          0, // 36: salt
          0,
          0,
          0,
          0, // 40: salt
          0,
          0,
          0,
          0, // 44: salt
          0,
          0,
          0,
          0, // 48: personal
          0,
          0,
          0,
          0, // 52: personal
          0,
          0,
          0,
          0, // 56: personal
          0,
          0,
          0,
          0 // 60: personal
        ])

        // Creates a BLAKE2b hashing context
        // Requires an output length between 1 and 64 bytes
        // Takes an optional Uint8Array key
        function Blake2b(outlen, key, salt, personal) {
          // zero out parameter_block before usage
          parameter_block.fill(0)
          // state, 'param block'

          this.b = new Uint8Array(128)
          this.h = new Uint32Array(16)
          this.t = 0 // input count
          this.c = 0 // pointer within buffer
          this.outlen = outlen // output length in bytes

          parameter_block[0] = outlen
          if (key) parameter_block[1] = key.length
          parameter_block[2] = 1 // fanout
          parameter_block[3] = 1 // depth

          if (salt) parameter_block.set(salt, 32)
          if (personal) parameter_block.set(personal, 48)

          // initialize hash state
          for (var i = 0; i < 16; i++) {
            this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4)
          }

          // key the hash, if applicable
          if (key) {
            blake2bUpdate(this, key)
            // at the end
            this.c = 128
          }
        }

        Blake2b.prototype.update = function(input) {
          assert(input != null, "input must be Uint8Array or Buffer")
          blake2bUpdate(this, input)
          return this
        }

        Blake2b.prototype.digest = function(out) {
          var buf =
            !out || out === "binary" || out === "hex"
              ? new Uint8Array(this.outlen)
              : out
          assert(
            buf.length >= this.outlen,
            "out must have at least outlen bytes of space"
          )
          blake2bFinal(this, buf)
          if (out === "hex") return hexSlice(buf)
          return buf
        }

        Blake2b.prototype.final = Blake2b.prototype.digest

        Blake2b.ready = function(cb) {
          b2wasm.ready(function() {
            cb() // ignore the error
          })
        }

        // Updates a BLAKE2b streaming hash
        // Requires hash context and Uint8Array (byte array)
        function blake2bUpdate(ctx, input) {
          for (var i = 0; i < input.length; i++) {
            if (ctx.c === 128) {
              // buffer full ?
              ctx.t += ctx.c // add counters
              blake2bCompress(ctx, false) // compress (not last)
              ctx.c = 0 // counter to zero
            }
            ctx.b[ctx.c++] = input[i]
          }
        }

        // Completes a BLAKE2b streaming hash
        // Returns a Uint8Array containing the message digest
        function blake2bFinal(ctx, out) {
          ctx.t += ctx.c // mark last block offset

          while (ctx.c < 128) {
            // fill up with zeros
            ctx.b[ctx.c++] = 0
          }
          blake2bCompress(ctx, true) // final block flag = 1

          for (var i = 0; i < ctx.outlen; i++) {
            out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
          }
          return out
        }

        function hexSlice(buf) {
          var str = ""
          for (var i = 0; i < buf.length; i++) str += toHex(buf[i])
          return str
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16)
          return n.toString(16)
        }

        var Proto = Blake2b

        module.exports = function createHash(
          outlen,
          key,
          salt,
          personal,
          noAssert
        ) {
          if (noAssert !== true) {
            assert(
              outlen >= BYTES_MIN,
              "outlen must be at least " + BYTES_MIN + ", was given " + outlen
            )
            assert(
              outlen <= BYTES_MAX,
              "outlen must be at most " + BYTES_MAX + ", was given " + outlen
            )
            if (key != null)
              assert(
                key.length >= KEYBYTES_MIN,
                "key must be at least " +
                  KEYBYTES_MIN +
                  ", was given " +
                  key.length
              )
            if (key != null)
              assert(
                key.length <= KEYBYTES_MAX,
                "key must be at least " +
                  KEYBYTES_MAX +
                  ", was given " +
                  key.length
              )
            if (salt != null)
              assert(
                salt.length === SALTBYTES,
                "salt must be exactly " +
                  SALTBYTES +
                  ", was given " +
                  salt.length
              )
            if (personal != null)
              assert(
                personal.length === PERSONALBYTES,
                "personal must be exactly " +
                  PERSONALBYTES +
                  ", was given " +
                  personal.length
              )
          }

          return new Proto(outlen, key, salt, personal)
        }

        module.exports.ready = function(cb) {
          b2wasm.ready(function() {
            // ignore errors
            cb()
          })
        }

        module.exports.WASM_SUPPORTED = b2wasm.SUPPORTED
        module.exports.WASM_LOADED = false

        var BYTES_MIN = (module.exports.BYTES_MIN = 16)
        var BYTES_MAX = (module.exports.BYTES_MAX = 64)
        var BYTES = (module.exports.BYTES = 32)
        var KEYBYTES_MIN = (module.exports.KEYBYTES_MIN = 16)
        var KEYBYTES_MAX = (module.exports.KEYBYTES_MAX = 64)
        var KEYBYTES = (module.exports.KEYBYTES = 32)
        var SALTBYTES = (module.exports.SALTBYTES = 16)
        var PERSONALBYTES = (module.exports.PERSONALBYTES = 16)

        b2wasm.ready(function(err) {
          if (!err) {
            module.exports.WASM_LOADED = true
            Proto = b2wasm
          }
        })
      },
      { "blake2b-wasm": 12, nanoassert: 42 }
    ],
    14: [function(require, module, exports) {}, {}],
    15: [
      function(require, module, exports) {
        ;(function(Buffer) {
          function allocUnsafe(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be a number')
            }

            if (size < 0) {
              throw new RangeError('"size" argument must not be negative')
            }

            if (Buffer.allocUnsafe) {
              return Buffer.allocUnsafe(size)
            } else {
              return new Buffer(size)
            }
          }

          module.exports = allocUnsafe
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    16: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var bufferFill = require("buffer-fill")
          var allocUnsafe = require("buffer-alloc-unsafe")

          module.exports = function alloc(size, fill, encoding) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be a number')
            }

            if (size < 0) {
              throw new RangeError('"size" argument must not be negative')
            }

            if (Buffer.alloc) {
              return Buffer.alloc(size, fill, encoding)
            }

            var buffer = allocUnsafe(size)

            if (size === 0) {
              return buffer
            }

            if (fill === undefined) {
              return bufferFill(buffer, 0)
            }

            if (typeof encoding !== "string") {
              encoding = undefined
            }

            return bufferFill(buffer, fill, encoding)
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "buffer-alloc-unsafe": 15, "buffer-fill": 18 }
    ],
    17: [
      function(require, module, exports) {
        ;(function(Buffer) {
          "use strict"
          module.exports = function(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError("Arguments must be Buffers")
            }

            if (a === b) {
              return true
            }

            if (typeof a.equals === "function") {
              return a.equals(b)
            }

            if (a.length !== b.length) {
              return false
            }

            for (var i = 0; i < a.length; i++) {
              if (a[i] !== b[i]) {
                return false
              }
            }

            return true
          }
        }.call(this, { isBuffer: require("../is-buffer/index.js") }))
      },
      { "../is-buffer/index.js": 38 }
    ],
    18: [
      function(require, module, exports) {
        ;(function(Buffer) {
          /* Node.js 6.4.0 and up has full support */
          var hasFullSupport = (function() {
            try {
              if (!Buffer.isEncoding("latin1")) {
                return false
              }

              var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4)

              buf.fill("ab", "ucs2")

              return buf.toString("hex") === "61006200"
            } catch (_) {
              return false
            }
          })()

          function isSingleByte(val) {
            return val.length === 1 && val.charCodeAt(0) < 256
          }

          function fillWithNumber(buffer, val, start, end) {
            if (start < 0 || end > buffer.length) {
              throw new RangeError("Out of range index")
            }

            start = start >>> 0
            end = end === undefined ? buffer.length : end >>> 0

            if (end > start) {
              buffer.fill(val, start, end)
            }

            return buffer
          }

          function fillWithBuffer(buffer, val, start, end) {
            if (start < 0 || end > buffer.length) {
              throw new RangeError("Out of range index")
            }

            if (end <= start) {
              return buffer
            }

            start = start >>> 0
            end = end === undefined ? buffer.length : end >>> 0

            var pos = start
            var len = val.length
            while (pos <= end - len) {
              val.copy(buffer, pos)
              pos += len
            }

            if (pos !== end) {
              val.copy(buffer, pos, 0, end - pos)
            }

            return buffer
          }

          function fill(buffer, val, start, end, encoding) {
            if (hasFullSupport) {
              return buffer.fill(val, start, end, encoding)
            }

            if (typeof val === "number") {
              return fillWithNumber(buffer, val, start, end)
            }

            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start
                start = 0
                end = buffer.length
              } else if (typeof end === "string") {
                encoding = end
                end = buffer.length
              }

              if (encoding !== undefined && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string")
              }

              if (encoding === "latin1") {
                encoding = "binary"
              }

              if (
                typeof encoding === "string" &&
                !Buffer.isEncoding(encoding)
              ) {
                throw new TypeError("Unknown encoding: " + encoding)
              }

              if (val === "") {
                return fillWithNumber(buffer, 0, start, end)
              }

              if (isSingleByte(val)) {
                return fillWithNumber(buffer, val.charCodeAt(0), start, end)
              }

              val = new Buffer(val, encoding)
            }

            if (Buffer.isBuffer(val)) {
              return fillWithBuffer(buffer, val, start, end)
            }

            // Other values (e.g. undefined, boolean, object) results in zero-fill
            return fillWithNumber(buffer, 0, start, end)
          }

          module.exports = fill
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    19: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var toString = Object.prototype.toString

          var isModern =
            typeof Buffer.alloc === "function" &&
            typeof Buffer.allocUnsafe === "function" &&
            typeof Buffer.from === "function"

          function isArrayBuffer(input) {
            return toString.call(input).slice(8, -1) === "ArrayBuffer"
          }

          function fromArrayBuffer(obj, byteOffset, length) {
            byteOffset >>>= 0

            var maxLength = obj.byteLength - byteOffset

            if (maxLength < 0) {
              throw new RangeError("'offset' is out of bounds")
            }

            if (length === undefined) {
              length = maxLength
            } else {
              length >>>= 0

              if (length > maxLength) {
                throw new RangeError("'length' is out of bounds")
              }
            }

            return isModern
              ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
              : new Buffer(
                  new Uint8Array(obj.slice(byteOffset, byteOffset + length))
                )
          }

          function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8"
            }

            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding')
            }

            return isModern
              ? Buffer.from(string, encoding)
              : new Buffer(string, encoding)
          }

          function bufferFrom(value, encodingOrOffset, length) {
            if (typeof value === "number") {
              throw new TypeError('"value" argument must not be a number')
            }

            if (isArrayBuffer(value)) {
              return fromArrayBuffer(value, encodingOrOffset, length)
            }

            if (typeof value === "string") {
              return fromString(value, encodingOrOffset)
            }

            return isModern ? Buffer.from(value) : new Buffer(value)
          }

          module.exports = bufferFrom
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    20: [
      function(require, module, exports) {
        arguments[4][1][0].apply(exports, arguments)
      },
      { "base64-js": 5, dup: 1, ieee754: 36 }
    ],
    21: [
      function(require, module, exports) {
        var stream = require("readable-stream")
        var inherits = require("inherits")
        var bufferFrom = require("buffer-from")

        var SIGNAL_FLUSH = bufferFrom([0])

        var Bulk = function(opts, worker, flush) {
          if (!(this instanceof Bulk)) return new Bulk(opts, worker, flush)

          if (typeof opts === "function") {
            flush = worker
            worker = opts
            opts = {}
          }

          stream.Writable.call(this, opts)
          this._worker = worker
          this._flush = flush
          this.destroyed = false
        }

        inherits(Bulk, stream.Writable)

        Bulk.obj = function(opts, worker, flush) {
          if (typeof opts === "function") return Bulk.obj(null, opts, worker)
          if (!opts) opts = {}
          opts.objectMode = true
          return new Bulk(opts, worker, flush)
        }

        Bulk.prototype.end = function(data, enc, cb) {
          if (!this._flush)
            return stream.Writable.prototype.end.apply(this, arguments)
          if (typeof data === "function") return this.end(null, null, data)
          if (typeof enc === "function") return this.end(data, null, enc)
          if (data) this.write(data)
          if (!this._writableState.ending) this.write(SIGNAL_FLUSH)
          return stream.Writable.prototype.end.call(this, cb)
        }

        Bulk.prototype.destroy = function(err) {
          if (this.destroyed) return
          this.destroyed = true
          if (err) this.emit("error")
          this.emit("close")
        }

        Bulk.prototype._write = function(data, enc, cb) {
          if (data === SIGNAL_FLUSH) this._flush(cb)
          else this._worker([data], cb)
        }

        Bulk.prototype._writev = function(batch, cb) {
          var len = batch.length
          if (batch[batch.length - 1].chunk === SIGNAL_FLUSH) {
            cb = this._flusher(cb)
            if (!--len) return cb()
          }
          var arr = new Array(len)
          for (var i = 0; i < len; i++) arr[i] = batch[i].chunk
          this._worker(arr, cb)
        }

        Bulk.prototype._flusher = function(cb) {
          var self = this
          return function(err) {
            if (err) return cb(err)
            self._flush(cb)
          }
        }

        module.exports = Bulk
      },
      { "buffer-from": 19, inherits: 37, "readable-stream": 58 }
    ],
    22: [
      function(require, module, exports) {
        ;(function(Buffer) {
          module.exports = codecs

          var fromBuffer =
            Buffer.from && Buffer.from !== Uint8Array.from
              ? Buffer.from
              : Buffer

          codecs.ascii = createString("ascii")
          codecs.utf8 = createString("utf-8")
          codecs.hex = createString("hex")
          codecs.base64 = createString("base64")
          codecs.ucs2 = createString("ucs2")
          codecs.utf16le = createString("utf16le")
          codecs.ndjson = createJSON(true)
          codecs.json = createJSON(false)
          codecs.binary = {
            encode: function encodeBinary(obj) {
              return typeof obj === "string" ? fromBuffer(obj, "utf-8") : obj
            },
            decode: function decodeBinary(buf) {
              return buf
            }
          }

          function codecs(fmt) {
            if (typeof fmt === "object" && fmt && fmt.encode && fmt.decode)
              return fmt

            switch (fmt) {
              case "ndjson":
                return codecs.ndjson
              case "json":
                return codecs.json
              case "ascii":
                return codecs.ascii
              case "utf-8":
              case "utf8":
                return codecs.utf8
              case "hex":
                return codecs.hex
              case "base64":
                return codecs.base64
              case "ucs-2":
              case "ucs2":
                return codecs.ucs2
              case "utf16-le":
              case "utf16le":
                return codecs.utf16le
            }

            return codecs.binary
          }

          function createJSON(newline) {
            return {
              encode: newline ? encodeNDJSON : encodeJSON,
              decode: function decodeJSON(buf) {
                return JSON.parse(buf.toString())
              }
            }

            function encodeJSON(val) {
              return new Buffer(JSON.stringify(val))
            }

            function encodeNDJSON(val) {
              return new Buffer(JSON.stringify(val) + "\n")
            }
          }

          function createString(type) {
            return {
              encode: function encodeString(val) {
                if (typeof val !== "string") val = val.toString()
                return fromBuffer(val, type)
              },
              decode: function decodeString(buf) {
                return buf.toString(type)
              }
            }
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    23: [
      function(require, module, exports) {
        ;(function(Buffer) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.

          function isArray(arg) {
            if (Array.isArray) {
              return Array.isArray(arg)
            }
            return objectToString(arg) === "[object Array]"
          }
          exports.isArray = isArray

          function isBoolean(arg) {
            return typeof arg === "boolean"
          }
          exports.isBoolean = isBoolean

          function isNull(arg) {
            return arg === null
          }
          exports.isNull = isNull

          function isNullOrUndefined(arg) {
            return arg == null
          }
          exports.isNullOrUndefined = isNullOrUndefined

          function isNumber(arg) {
            return typeof arg === "number"
          }
          exports.isNumber = isNumber

          function isString(arg) {
            return typeof arg === "string"
          }
          exports.isString = isString

          function isSymbol(arg) {
            return typeof arg === "symbol"
          }
          exports.isSymbol = isSymbol

          function isUndefined(arg) {
            return arg === void 0
          }
          exports.isUndefined = isUndefined

          function isRegExp(re) {
            return objectToString(re) === "[object RegExp]"
          }
          exports.isRegExp = isRegExp

          function isObject(arg) {
            return typeof arg === "object" && arg !== null
          }
          exports.isObject = isObject

          function isDate(d) {
            return objectToString(d) === "[object Date]"
          }
          exports.isDate = isDate

          function isError(e) {
            return objectToString(e) === "[object Error]" || e instanceof Error
          }
          exports.isError = isError

          function isFunction(arg) {
            return typeof arg === "function"
          }
          exports.isFunction = isFunction

          function isPrimitive(arg) {
            return (
              arg === null ||
              typeof arg === "boolean" ||
              typeof arg === "number" ||
              typeof arg === "string" ||
              typeof arg === "symbol" || // ES6 symbol
              typeof arg === "undefined"
            )
          }
          exports.isPrimitive = isPrimitive

          exports.isBuffer = Buffer.isBuffer

          function objectToString(o) {
            return Object.prototype.toString.call(o)
          }
        }.call(this, { isBuffer: require("../../is-buffer/index.js") }))
      },
      { "../../is-buffer/index.js": 38 }
    ],
    24: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var objectCreate = Object.create || objectCreatePolyfill
        var objectKeys = Object.keys || objectKeysPolyfill
        var bind = Function.prototype.bind || functionBindPolyfill

        function EventEmitter() {
          if (
            !this._events ||
            !Object.prototype.hasOwnProperty.call(this, "_events")
          ) {
            this._events = objectCreate(null)
            this._eventsCount = 0
          }

          this._maxListeners = this._maxListeners || undefined
        }
        module.exports = EventEmitter

        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter

        EventEmitter.prototype._events = undefined
        EventEmitter.prototype._maxListeners = undefined

        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        var defaultMaxListeners = 10

        var hasDefineProperty
        try {
          var o = {}
          if (Object.defineProperty) Object.defineProperty(o, "x", { value: 0 })
          hasDefineProperty = o.x === 0
        } catch (err) {
          hasDefineProperty = false
        }
        if (hasDefineProperty) {
          Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: true,
            get: function() {
              return defaultMaxListeners
            },
            set: function(arg) {
              // check whether the input is a positive number (whose value is zero or
              // greater and not a NaN).
              if (typeof arg !== "number" || arg < 0 || arg !== arg)
                throw new TypeError(
                  '"defaultMaxListeners" must be a positive number'
                )
              defaultMaxListeners = arg
            }
          })
        } else {
          EventEmitter.defaultMaxListeners = defaultMaxListeners
        }

        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== "number" || n < 0 || isNaN(n))
            throw new TypeError('"n" argument must be a positive number')
          this._maxListeners = n
          return this
        }

        function $getMaxListeners(that) {
          if (that._maxListeners === undefined)
            return EventEmitter.defaultMaxListeners
          return that._maxListeners
        }

        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return $getMaxListeners(this)
        }

        // These standalone emit* functions are used to optimize calling of event
        // handlers for fast cases because emit() itself often has a variable number of
        // arguments and can be deoptimized because of that. These functions always have
        // the same number of arguments and thus do not get deoptimized, so the code
        // inside them can execute faster.
        function emitNone(handler, isFn, self) {
          if (isFn) handler.call(self)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].call(self)
          }
        }
        function emitOne(handler, isFn, self, arg1) {
          if (isFn) handler.call(self, arg1)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1)
          }
        }
        function emitTwo(handler, isFn, self, arg1, arg2) {
          if (isFn) handler.call(self, arg1, arg2)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2)
          }
        }
        function emitThree(handler, isFn, self, arg1, arg2, arg3) {
          if (isFn) handler.call(self, arg1, arg2, arg3)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i)
              listeners[i].call(self, arg1, arg2, arg3)
          }
        }

        function emitMany(handler, isFn, self, args) {
          if (isFn) handler.apply(self, args)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].apply(self, args)
          }
        }

        EventEmitter.prototype.emit = function emit(type) {
          var er, handler, len, args, i, events
          var doError = type === "error"

          events = this._events
          if (events) doError = doError && events.error == null
          else if (!doError) return false

          // If there is no 'error' event listener then throw.
          if (doError) {
            if (arguments.length > 1) er = arguments[1]
            if (er instanceof Error) {
              throw er // Unhandled 'error' event
            } else {
              // At least give some kind of context to the user
              var err = new Error('Unhandled "error" event. (' + er + ")")
              err.context = er
              throw err
            }
            return false
          }

          handler = events[type]

          if (!handler) return false

          var isFn = typeof handler === "function"
          len = arguments.length
          switch (len) {
            // fast cases
            case 1:
              emitNone(handler, isFn, this)
              break
            case 2:
              emitOne(handler, isFn, this, arguments[1])
              break
            case 3:
              emitTwo(handler, isFn, this, arguments[1], arguments[2])
              break
            case 4:
              emitThree(
                handler,
                isFn,
                this,
                arguments[1],
                arguments[2],
                arguments[3]
              )
              break
            // slower
            default:
              args = new Array(len - 1)
              for (i = 1; i < len; i++) args[i - 1] = arguments[i]
              emitMany(handler, isFn, this, args)
          }

          return true
        }

        function _addListener(target, type, listener, prepend) {
          var m
          var events
          var existing

          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')

          events = target._events
          if (!events) {
            events = target._events = objectCreate(null)
            target._eventsCount = 0
          } else {
            // To avoid recursion in the case that type === "newListener"! Before
            // adding it to the listeners, first emit "newListener".
            if (events.newListener) {
              target.emit(
                "newListener",
                type,
                listener.listener ? listener.listener : listener
              )

              // Re-assign `events` because a newListener handler could have caused the
              // this._events to be assigned to a new object
              events = target._events
            }
            existing = events[type]
          }

          if (!existing) {
            // Optimize the case of one listener. Don't need the extra array object.
            existing = events[type] = listener
            ++target._eventsCount
          } else {
            if (typeof existing === "function") {
              // Adding the second element, need to change to array.
              existing = events[type] = prepend
                ? [listener, existing]
                : [existing, listener]
            } else {
              // If we've already got an array, just append.
              if (prepend) {
                existing.unshift(listener)
              } else {
                existing.push(listener)
              }
            }

            // Check for listener leak
            if (!existing.warned) {
              m = $getMaxListeners(target)
              if (m && m > 0 && existing.length > m) {
                existing.warned = true
                var w = new Error(
                  "Possible EventEmitter memory leak detected. " +
                    existing.length +
                    ' "' +
                    String(type) +
                    '" listeners ' +
                    "added. Use emitter.setMaxListeners() to " +
                    "increase limit."
                )
                w.name = "MaxListenersExceededWarning"
                w.emitter = target
                w.type = type
                w.count = existing.length
                if (typeof console === "object" && console.warn) {
                  console.warn("%s: %s", w.name, w.message)
                }
              }
            }
          }

          return target
        }

        EventEmitter.prototype.addListener = function addListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, false)
        }

        EventEmitter.prototype.on = EventEmitter.prototype.addListener

        EventEmitter.prototype.prependListener = function prependListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, true)
        }

        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn)
            this.fired = true
            switch (arguments.length) {
              case 0:
                return this.listener.call(this.target)
              case 1:
                return this.listener.call(this.target, arguments[0])
              case 2:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1]
                )
              case 3:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1],
                  arguments[2]
                )
              default:
                var args = new Array(arguments.length)
                for (var i = 0; i < args.length; ++i) args[i] = arguments[i]
                this.listener.apply(this.target, args)
            }
          }
        }

        function _onceWrap(target, type, listener) {
          var state = {
            fired: false,
            wrapFn: undefined,
            target: target,
            type: type,
            listener: listener
          }
          var wrapped = bind.call(onceWrapper, state)
          wrapped.listener = listener
          state.wrapFn = wrapped
          return wrapped
        }

        EventEmitter.prototype.once = function once(type, listener) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')
          this.on(type, _onceWrap(this, type, listener))
          return this
        }

        EventEmitter.prototype.prependOnceListener = function prependOnceListener(
          type,
          listener
        ) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')
          this.prependListener(type, _onceWrap(this, type, listener))
          return this
        }

        // Emits a 'removeListener' event if and only if the listener was removed.
        EventEmitter.prototype.removeListener = function removeListener(
          type,
          listener
        ) {
          var list, events, position, i, originalListener

          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')

          events = this._events
          if (!events) return this

          list = events[type]
          if (!list) return this

          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0) this._events = objectCreate(null)
            else {
              delete events[type]
              if (events.removeListener)
                this.emit("removeListener", type, list.listener || listener)
            }
          } else if (typeof list !== "function") {
            position = -1

            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener
                position = i
                break
              }
            }

            if (position < 0) return this

            if (position === 0) list.shift()
            else spliceOne(list, position)

            if (list.length === 1) events[type] = list[0]

            if (events.removeListener)
              this.emit("removeListener", type, originalListener || listener)
          }

          return this
        }

        EventEmitter.prototype.removeAllListeners = function removeAllListeners(
          type
        ) {
          var listeners, events, i

          events = this._events
          if (!events) return this

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = objectCreate(null)
              this._eventsCount = 0
            } else if (events[type]) {
              if (--this._eventsCount === 0) this._events = objectCreate(null)
              else delete events[type]
            }
            return this
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = objectKeys(events)
            var key
            for (i = 0; i < keys.length; ++i) {
              key = keys[i]
              if (key === "removeListener") continue
              this.removeAllListeners(key)
            }
            this.removeAllListeners("removeListener")
            this._events = objectCreate(null)
            this._eventsCount = 0
            return this
          }

          listeners = events[type]

          if (typeof listeners === "function") {
            this.removeListener(type, listeners)
          } else if (listeners) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i])
            }
          }

          return this
        }

        function _listeners(target, type, unwrap) {
          var events = target._events

          if (!events) return []

          var evlistener = events[type]
          if (!evlistener) return []

          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener]

          return unwrap
            ? unwrapListeners(evlistener)
            : arrayClone(evlistener, evlistener.length)
        }

        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true)
        }

        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false)
        }

        EventEmitter.listenerCount = function(emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type)
          } else {
            return listenerCount.call(emitter, type)
          }
        }

        EventEmitter.prototype.listenerCount = listenerCount
        function listenerCount(type) {
          var events = this._events

          if (events) {
            var evlistener = events[type]

            if (typeof evlistener === "function") {
              return 1
            } else if (evlistener) {
              return evlistener.length
            }
          }

          return 0
        }

        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : []
        }

        // About 1.5x faster than the two-arg version of Array#splice().
        function spliceOne(list, index) {
          for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
            list[i] = list[k]
          list.pop()
        }

        function arrayClone(arr, n) {
          var copy = new Array(n)
          for (var i = 0; i < n; ++i) copy[i] = arr[i]
          return copy
        }

        function unwrapListeners(arr) {
          var ret = new Array(arr.length)
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i]
          }
          return ret
        }

        function objectCreatePolyfill(proto) {
          var F = function() {}
          F.prototype = proto
          return new F()
        }
        function objectKeysPolyfill(obj) {
          var keys = []
          for (var k in obj)
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
              keys.push(k)
            }
          return k
        }
        function functionBindPolyfill(context) {
          var fn = this
          return function() {
            return fn.apply(context, arguments)
          }
        }
      },
      {}
    ],
    25: [
      function(require, module, exports) {
        exports.fullRoots = function(index, result) {
          if (index & 1)
            throw new Error("You can only look up roots for depth(0) blocks")
          if (!result) result = []

          index /= 2

          var offset = 0
          var factor = 1

          while (true) {
            if (!index) return result
            while (factor * 2 <= index) factor *= 2
            result.push(offset + factor - 1)
            offset = offset + 2 * factor
            index -= factor
            factor = 1
          }
        }

        exports.depth = function(index) {
          var depth = 0

          index += 1
          while (!(index & 1)) {
            depth++
            index = rightShift(index)
          }

          return depth
        }

        exports.sibling = function(index, depth) {
          if (!depth) depth = exports.depth(index)
          var offset = exports.offset(index, depth)

          return exports.index(depth, offset & 1 ? offset - 1 : offset + 1)
        }

        exports.parent = function(index, depth) {
          if (!depth) depth = exports.depth(index)
          var offset = exports.offset(index, depth)

          return exports.index(depth + 1, rightShift(offset))
        }

        exports.leftChild = function(index, depth) {
          if (!(index & 1)) return -1
          if (!depth) depth = exports.depth(index)
          return exports.index(depth - 1, exports.offset(index, depth) * 2)
        }

        exports.rightChild = function(index, depth) {
          if (!(index & 1)) return -1
          if (!depth) depth = exports.depth(index)
          return exports.index(depth - 1, 1 + exports.offset(index, depth) * 2)
        }

        exports.children = function(index, depth) {
          if (!(index & 1)) return null

          if (!depth) depth = exports.depth(index)
          var offset = exports.offset(index, depth) * 2

          return [
            exports.index(depth - 1, offset),
            exports.index(depth - 1, offset + 1)
          ]
        }

        exports.leftSpan = function(index, depth) {
          if (!(index & 1)) return index
          if (!depth) depth = exports.depth(index)
          return exports.offset(index, depth) * twoPow(depth + 1)
        }

        exports.rightSpan = function(index, depth) {
          if (!(index & 1)) return index
          if (!depth) depth = exports.depth(index)
          return (exports.offset(index, depth) + 1) * twoPow(depth + 1) - 2
        }

        exports.count = function(index, depth) {
          if (!(index & 1)) return 1
          if (!depth) depth = exports.depth(index)
          return twoPow(depth + 1) - 1
        }

        exports.spans = function(index, depth) {
          if (!(index & 1)) return [index, index]
          if (!depth) depth = exports.depth(index)

          var offset = exports.offset(index, depth)
          var width = twoPow(depth + 1)

          return [offset * width, (offset + 1) * width - 2]
        }

        exports.index = function(depth, offset) {
          return (1 + 2 * offset) * twoPow(depth) - 1
        }

        exports.offset = function(index, depth) {
          if (!(index & 1)) return index / 2
          if (!depth) depth = exports.depth(index)

          return ((index + 1) / twoPow(depth) - 1) / 2
        }

        exports.iterator = function(index) {
          var ite = new Iterator()
          ite.seek(index || 0)
          return ite
        }

        function twoPow(n) {
          return n < 31 ? 1 << n : (1 << 30) * (1 << (n - 30))
        }

        function rightShift(n) {
          return (n - (n & 1)) / 2
        }

        function Iterator(index) {
          this.index = 0
          this.offset = 0
          this.factor = 0
        }

        Iterator.prototype.seek = function(index) {
          this.index = index
          if (this.index & 1) {
            this.offset = exports.offset(index)
            this.factor = twoPow(exports.depth(index) + 1)
          } else {
            this.offset = index / 2
            this.factor = 2
          }
        }

        Iterator.prototype.isLeft = function() {
          return !(this.offset & 1)
        }

        Iterator.prototype.isRight = function() {
          return !this.isLeft()
        }

        Iterator.prototype.prev = function() {
          if (!this.offset) return this.index
          this.offset--
          this.index -= this.factor
          return this.index
        }

        Iterator.prototype.next = function() {
          this.offset++
          this.index += this.factor
          return this.index
        }

        Iterator.prototype.sibling = function() {
          return this.isLeft() ? this.next() : this.prev()
        }

        Iterator.prototype.parent = function() {
          if (this.offset & 1) {
            this.index -= this.factor / 2
            this.offset = (this.offset - 1) / 2
          } else {
            this.index += this.factor / 2
            this.offset /= 2
          }
          this.factor *= 2
          return this.index
        }

        Iterator.prototype.leftSpan = function() {
          this.index = this.index - this.factor / 2 + 1
          this.offset = this.index / 2
          this.factor = 2
          return this.index
        }

        Iterator.prototype.rightSpan = function() {
          this.index = this.index + this.factor / 2 - 1
          this.offset = this.index / 2
          this.factor = 2
          return this.index
        }

        Iterator.prototype.leftChild = function() {
          if (this.factor === 2) return this.index
          this.factor /= 2
          this.index -= this.factor / 2
          this.offset *= 2
          return this.index
        }

        Iterator.prototype.rightChild = function() {
          if (this.factor === 2) return this.index
          this.factor /= 2
          this.index += this.factor / 2
          this.offset = 2 * this.offset + 1
          return this.index
        }
      },
      {}
    ],
    26: [
      function(require, module, exports) {
        ;(function(process) {
          var Readable = require("readable-stream").Readable
          var inherits = require("inherits")

          module.exports = from2

          from2.ctor = ctor
          from2.obj = obj

          var Proto = ctor()

          function toFunction(list) {
            list = list.slice()
            return function(_, cb) {
              var err = null
              var item = list.length ? list.shift() : null
              if (item instanceof Error) {
                err = item
                item = null
              }

              cb(err, item)
            }
          }

          function from2(opts, read) {
            if (typeof opts !== "object" || Array.isArray(opts)) {
              read = opts
              opts = {}
            }

            var rs = new Proto(opts)
            rs._from = Array.isArray(read) ? toFunction(read) : read || noop
            return rs
          }

          function ctor(opts, read) {
            if (typeof opts === "function") {
              read = opts
              opts = {}
            }

            opts = defaults(opts)

            inherits(Class, Readable)
            function Class(override) {
              if (!(this instanceof Class)) return new Class(override)
              this._reading = false
              this._callback = check
              this.destroyed = false
              Readable.call(this, override || opts)

              var self = this
              var hwm = this._readableState.highWaterMark

              function check(err, data) {
                if (self.destroyed) return
                if (err) return self.destroy(err)
                if (data === null) return self.push(null)
                self._reading = false
                if (self.push(data)) self._read(hwm)
              }
            }

            Class.prototype._from = read || noop
            Class.prototype._read = function(size) {
              if (this._reading || this.destroyed) return
              this._reading = true
              this._from(size, this._callback)
            }

            Class.prototype.destroy = function(err) {
              if (this.destroyed) return
              this.destroyed = true

              var self = this
              process.nextTick(function() {
                if (err) self.emit("error", err)
                self.emit("close")
              })
            }

            return Class
          }

          function obj(opts, read) {
            if (typeof opts === "function" || Array.isArray(opts)) {
              read = opts
              opts = {}
            }

            opts = defaults(opts)
            opts.objectMode = true
            opts.highWaterMark = 16

            return from2(opts, read)
          }

          function noop() {}

          function defaults(opts) {
            opts = opts || {}
            return opts
          }
        }.call(this, require("_process")))
      },
      { _process: 44, inherits: 37, "readable-stream": 58 }
    ],
    27: [
      function(require, module, exports) {
        ;(function(process) {
          var events = require("events")
          var inherits = require("inherits")
          var varint = require("varint")
          var messages = require("./messages")
          var bufferAlloc = require("buffer-alloc-unsafe")

          module.exports = Feed

          function Feed(stream) {
            if (!(this instanceof Feed)) return new Feed(stream)
            events.EventEmitter.call(this)

            this.key = null
            this.discoveryKey = null
            this.stream = stream
            this.peer = null // support a peer object to avoid event emitter + closures overhead

            this.id = -1
            this.remoteId = -1
            this.header = 0
            this.headerLength = 0
            this.closed = false

            this._buffer = []
          }

          inherits(Feed, events.EventEmitter)

          Feed.prototype.handshake = function(message) {
            return this._send(1, messages.Handshake, message)
          }

          Feed.prototype.info = function(message) {
            return this._send(2, messages.Info, message)
          }

          Feed.prototype.have = function(message) {
            return this._send(3, messages.Have, message)
          }

          Feed.prototype.unhave = function(message) {
            return this._send(4, messages.Unhave, message)
          }

          Feed.prototype.want = function(message) {
            return this._send(5, messages.Want, message)
          }

          Feed.prototype.unwant = function(message) {
            return this._send(6, messages.Unwant, message)
          }

          Feed.prototype.request = function(message) {
            return this._send(7, messages.Request, message)
          }

          Feed.prototype.cancel = function(message) {
            return this._send(8, messages.Cancel, message)
          }

          Feed.prototype.data = function(message) {
            return this._send(9, messages.Data, message)
          }

          Feed.prototype.extension = function(type, message) {
            var id = this.stream.extensions.indexOf(type)
            if (id === -1) return false

            var header = this.header | 15
            var len =
              this.headerLength + varint.encodingLength(id) + message.length
            var box = bufferAlloc(varint.encodingLength(len) + len)
            var offset = 0

            varint.encode(len, box, offset)
            offset += varint.encode.bytes

            varint.encode(header, box, offset)
            offset += varint.encode.bytes

            varint.encode(id, box, offset)
            offset += varint.encode.bytes

            message.copy(box, offset)
            return this.stream._push(box)
          }

          Feed.prototype.remoteSupports = function(name) {
            return this.stream.remoteSupports(name)
          }

          Feed.prototype.destroy = function(err) {
            this.stream.destroy(err)
          }

          Feed.prototype.close = function() {
            var i = this.stream.feeds.indexOf(this)

            if (i > -1) {
              this.stream.feeds[i] = this.stream.feeds[
                this.stream.feeds.length - 1
              ]
              this.stream.feeds.pop()
              this.stream._localFeeds[this.id] = null
              this.id = -1

              if (this.stream.destroyed) return
              if (this.stream.expectedFeeds <= 0 || --this.stream.expectedFeeds)
                return

              this.stream._prefinalize()
            }
          }

          Feed.prototype._onclose = function() {
            if (this.closed) return
            this.closed = true

            if (!this.stream.destroyed) {
              this.close()
              if (this.remoteId > -1)
                this.stream._remoteFeeds[this.remoteId] = null
              var hex = this.discoveryKey.toString("hex")
              if (this.stream._feeds[hex] === this)
                delete this.stream._feeds[hex]
            }

            if (this.peer) this.peer.onclose()
            else this.emit("close")
          }

          Feed.prototype._resume = function() {
            var self = this
            process.nextTick(resume)

            function resume() {
              while (self._buffer.length) {
                var next = self._buffer.shift()
                self._emit(next.type, next.message)
              }
              self._buffer = null
            }
          }

          Feed.prototype._onextension = function(data, start, end) {
            if (end <= start) return

            var id = varint.decode(data, start)
            var r = this.stream.remoteExtensions
            var localId = !r || id >= r.length ? -1 : r[id]

            if (localId === -1) return

            var message = data.slice(start + varint.decode.bytes, end)
            var name = this.stream.extensions[localId]

            if (this.peer && this.peer.onextension)
              this.peer.onextension(name, message)
            else this.emit("extension", name, message)
          }

          Feed.prototype._onmessage = function(type, data, start, end) {
            var message = decodeMessage(type, data, start, end)
            if (!message || this.closed) return

            if (type === 1) return this.stream._onhandshake(message)

            if (!this._buffer) {
              this._emit(type, message)
              return
            }

            if (this._buffer.length > 16) {
              this.destroy(
                new Error("Remote sent too many messages on an unopened feed")
              )
              return
            }

            this._buffer.push({ type: type, message: message })
          }

          Feed.prototype._emit = function(type, message) {
            if (this.peer) {
              switch (type) {
                case 2:
                  return this.peer.oninfo(message)
                case 3:
                  return this.peer.onhave(message)
                case 4:
                  return this.peer.onunhave(message)
                case 5:
                  return this.peer.onwant(message)
                case 6:
                  return this.peer.onunwant(message)
                case 7:
                  return this.peer.onrequest(message)
                case 8:
                  return this.peer.oncancel(message)
                case 9:
                  return this.peer.ondata(message)
              }
            } else {
              switch (type) {
                case 2:
                  return this.emit("info", message)
                case 3:
                  return this.emit("have", message)
                case 4:
                  return this.emit("unhave", message)
                case 5:
                  return this.emit("want", message)
                case 6:
                  return this.emit("unwant", message)
                case 7:
                  return this.emit("request", message)
                case 8:
                  return this.emit("cancel", message)
                case 9:
                  return this.emit("data", message)
              }
            }
          }

          Feed.prototype._send = function(type, enc, message) {
            var header = this.header | type
            var len = this.headerLength + enc.encodingLength(message)
            var box = bufferAlloc(varint.encodingLength(len) + len)
            var offset = 0

            varint.encode(len, box, offset)
            offset += varint.encode.bytes

            varint.encode(header, box, offset)
            offset += varint.encode.bytes

            enc.encode(message, box, offset)

            return this.stream._push(box)
          }

          function decodeMessage(type, data, start, end) {
            switch (type) {
              case 1:
                return decode(messages.Handshake, data, start, end)
              case 2:
                return decode(messages.Info, data, start, end)
              case 3:
                return decode(messages.Have, data, start, end)
              case 4:
                return decode(messages.Unhave, data, start, end)
              case 5:
                return decode(messages.Want, data, start, end)
              case 6:
                return decode(messages.Unwant, data, start, end)
              case 7:
                return decode(messages.Request, data, start, end)
              case 8:
                return decode(messages.Cancel, data, start, end)
              case 9:
                return decode(messages.Data, data, start, end)
            }
          }

          function decode(enc, data, start, end) {
            try {
              return enc.decode(data, start, end)
            } catch (err) {
              return null
            }
          }
        }.call(this, require("_process")))
      },
      {
        "./messages": 29,
        _process: 44,
        "buffer-alloc-unsafe": 15,
        events: 24,
        inherits: 37,
        varint: 82
      }
    ],
    28: [
      function(require, module, exports) {
        ;(function(process) {
          var stream = require("readable-stream")
          var inherits = require("inherits")
          var varint = require("varint")
          var sodium = require("sodium-universal")
          var indexOf = require("sorted-indexof")
          var feed = require("./feed")
          var messages = require("./messages")
          var bufferAlloc = require("buffer-alloc-unsafe")
          var bufferFrom = require("buffer-from")

          module.exports = Protocol

          function Protocol(opts) {
            if (!(this instanceof Protocol)) return new Protocol(opts)
            if (!opts) opts = {}

            stream.Duplex.call(this)
            var self = this

            this.id = opts.id || randomBytes(32)
            this.live = !!opts.live
            this.ack = !!opts.ack
            this.userData = opts.userData || null
            this.remoteId = null
            this.remoteLive = false
            this.remoteUserData = null

            this.destroyed = false
            this.encrypted = opts.encrypt !== false
            this.key = null
            this.discoveryKey = null
            this.remoteDiscoveryKey = null
            this.feeds = []
            this.expectedFeeds = opts.expectedFeeds || 0
            this.extensions = opts.extensions || []
            this.remoteExtensions = null

            this._localFeeds = []
            this._remoteFeeds = []
            this._feeds = {}

            this._nonce = null
            this._remoteNonce = null
            this._xor = null
            this._remoteXor = null
            this._needsKey = false
            this._length = bufferAlloc(varint.encodingLength(8388608))
            this._missing = 0
            this._buf = null
            this._pointer = 0
            this._data = null
            this._start = 0
            this._cb = null
            this._interval = null
            this._keepAlive = 0
            this._remoteKeepAlive = 0
            this._maybeFinalize = maybeFinalize

            if (opts.timeout !== 0 && opts.timeout !== false)
              this.setTimeout(opts.timeout || 5000, this._ontimeout)
            this.on("finish", this.finalize)

            function maybeFinalize(err) {
              if (err) return self.destroy(err)
              if (!self.expectedFeeds) self.finalize()
            }
          }

          inherits(Protocol, stream.Duplex)

          Protocol.prototype._prefinalize = function() {
            if (!this.emit("prefinalize", this._maybeFinalize)) this.finalize()
          }

          Protocol.prototype.setTimeout = function(ms, ontimeout) {
            if (this.destroyed) return
            if (ontimeout) this.once("timeout", ontimeout)

            var self = this

            this._keepAlive = 0
            this._remoteKeepAlive = 0

            clearInterval(this._interval)
            if (!ms) return

            this._interval = setInterval(kick, (ms / 4) | 0)
            if (this._interval.unref) this._interval.unref()

            function kick() {
              self._kick()
            }
          }

          Protocol.prototype.feed = function(key, opts) {
            if (this.destroyed) return null
            if (!opts) opts = {}

            var dk = opts.discoveryKey || discoveryKey(key)
            var ch = this._feed(dk)

            if (ch.id > -1) {
              if (opts.peer) ch.peer = opts.peer
              return ch
            }

            if (this._localFeeds.length >= 128) {
              this._tooManyFeeds()
              return null
            }

            ch.id = this._localFeeds.push(ch) - 1
            ch.header = ch.id << 4
            ch.headerLength = varint.encodingLength(ch.header)
            ch.key = key
            ch.discoveryKey = dk
            if (opts.peer) ch.peer = opts.peer

            this.feeds.push(ch)

            var first = !this.key
            var feed = {
              discoveryKey: dk,
              nonce: null
            }

            if (first) {
              this.key = key
              this.discoveryKey = dk

              if (!this._sameKey()) return null

              if (this.encrypted) {
                feed.nonce = this._nonce = randomBytes(24)
                this._xor = sodium.crypto_stream_xor_instance(
                  this._nonce,
                  this.key
                )
                if (this._remoteNonce) {
                  this._remoteXor = sodium.crypto_stream_xor_instance(
                    this._remoteNonce,
                    this.key
                  )
                }
              }

              if (this._needsKey) {
                this._needsKey = false
                this._resume()
              }
            }

            var box = encodeFeed(feed, ch.id)
            if (!feed.nonce && this.encrypted) this._xor.update(box, box)
            this._keepAlive = 0
            this.push(box)

            if (this.destroyed) return null

            if (first) {
              ch.handshake({
                id: this.id,
                live: this.live,
                userData: this.userData,
                extensions: this.extensions,
                ack: this.ack
              })
            }

            if (ch._buffer.length) ch._resume()
            else ch._buffer = null

            return ch
          }

          Protocol.prototype._resume = function() {
            var self = this
            process.nextTick(resume)

            function resume() {
              if (!self._data) return

              var data = self._data
              var start = self._start
              var cb = self._cb

              self._data = null
              self._start = 0
              self._cb = null
              self._parse(data, start, cb)
            }
          }

          Protocol.prototype._kick = function() {
            if (this._remoteKeepAlive > 4) {
              clearInterval(this._interval)
              this.emit("timeout")
              return
            }

            for (var i = 0; i < this.feeds.length; i++) {
              var ch = this.feeds[i]
              if (ch.peer) ch.peer.ontick()
              else ch.emit("tick")
            }

            this._remoteKeepAlive++

            if (this._keepAlive > 2) {
              this.ping()
              this._keepAlive = 0
            } else {
              this._keepAlive++
            }
          }

          Protocol.prototype.ping = function() {
            if (!this.key) return true
            var ping = bufferFrom([0])
            if (this._xor) this._xor.update(ping, ping)
            return this.push(ping)
          }

          Protocol.prototype.destroy = function(err) {
            if (this.destroyed) return
            this.destroyed = true
            if (err) this.emit("error", err)
            this._close()
            this.emit("close")
          }

          Protocol.prototype.finalize = function() {
            if (this.destroyed) return
            this.destroyed = true
            this._close()
            this.push(null)
          }

          Protocol.prototype._close = function() {
            clearInterval(this._interval)

            var feeds = this.feeds
            this.feeds = []
            for (var i = 0; i < feeds.length; i++) feeds[i]._onclose()

            if (this._xor) {
              this._xor.final()
              this._xor = null
            }
          }

          Protocol.prototype._read = function() {
            // do nothing, user back-pressures
          }

          Protocol.prototype._push = function(data) {
            if (this.destroyed) return
            this._keepAlive = 0
            if (this._xor) this._xor.update(data, data)
            return this.push(data)
          }

          Protocol.prototype._write = function(data, enc, cb) {
            this._remoteKeepAlive = 0
            this._parse(data, 0, cb)
          }

          Protocol.prototype._feed = function(dk) {
            var hex = dk.toString("hex")
            var ch = this._feeds[hex]
            if (ch) return ch
            ch = this._feeds[hex] = feed(this)
            return ch
          }

          Protocol.prototype.remoteSupports = function(name) {
            var i = this.extensions.indexOf(name)
            return (
              i > -1 &&
              !!this.remoteExtensions &&
              this.remoteExtensions.indexOf(i) > -1
            )
          }

          Protocol.prototype._onhandshake = function(handshake) {
            if (this.remoteId) return

            this.remoteId = handshake.id || randomBytes(32)
            this.remoteLive = handshake.live
            this.remoteUserData = handshake.userData
            this.remoteExtensions = indexOf(
              this.extensions,
              handshake.extensions
            )
            this.remoteAck = handshake.ack

            this.emit("handshake")
          }

          Protocol.prototype._onopen = function(id, data, start, end) {
            var feed = decodeFeed(data, start, end)

            if (!feed) return this._badFeed()

            if (!this.remoteDiscoveryKey) {
              this.remoteDiscoveryKey = feed.discoveryKey
              if (!this._sameKey()) return

              if (this.encrypted && !this._remoteNonce) {
                if (!feed.nonce) {
                  this.destroy(new Error("Remote did not include a nonce"))
                  return
                }
                this._remoteNonce = feed.nonce
              }

              if (this.encrypted && this.key && !this._remoteXor) {
                this._remoteXor = sodium.crypto_stream_xor_instance(
                  this._remoteNonce,
                  this.key
                )
              }
            }

            this._remoteFeeds[id] = this._feed(feed.discoveryKey)
            feed.remoteId = id

            this.emit("feed", feed.discoveryKey)
          }

          Protocol.prototype._onmessage = function(data, start, end) {
            if (end - start < 2) return

            var header = decodeHeader(data, start)
            if (header === -1)
              return this.destroy(new Error("Remote sent invalid header"))

            start += varint.decode.bytes

            var id = header >> 4
            var type = header & 15

            if (id >= 128) return this._tooManyFeeds()
            while (this._remoteFeeds.length < id) this._remoteFeeds.push(null)

            var ch = this._remoteFeeds[id]

            if (type === 0) {
              if (ch) ch._onclose()
              return this._onopen(id, data, start, end)
            }

            if (!ch) return this._badFeed()
            if (type === 15) return ch._onextension(data, start, end)
            ch._onmessage(type, data, start, end)
          }

          Protocol.prototype._parse = function(data, start, cb) {
            var decrypted = !!this._remoteXor

            if (start) {
              data = data.slice(start)
              start = 0
            }

            if (this._remoteXor) this._remoteXor.update(data, data)

            while (start < data.length && !this.destroyed) {
              if (this._missing) start = this._parseMessage(data, start)
              else start = this._parseLength(data, start)

              if (this._needsKey) {
                this._data = data
                this._start = start
                this._cb = cb
                return
              }

              if (!decrypted && this._remoteXor) {
                return this._parse(data, start, cb)
              }
            }

            cb()
          }

          Protocol.prototype._parseMessage = function(data, start) {
            var end = start + this._missing

            if (end <= data.length) {
              var ret = end

              if (this._buf) {
                data.copy(this._buf, this._pointer, start)
                data = this._buf
                start = 0
                end = data.length
                this._buf = null
              }

              this._missing = 0
              this._pointer = 0
              if (this.encrypted && !this.key) this._needsKey = true
              this._onmessage(data, start, end)

              return ret
            }

            if (!this._buf) {
              this._buf = bufferAlloc(this._missing)
              this._pointer = 0
            }

            var rem = data.length - start

            data.copy(this._buf, this._pointer, start)
            this._pointer += rem
            this._missing -= rem

            return data.length
          }

          Protocol.prototype._parseLength = function(data, start) {
            while (!this._missing && start < data.length) {
              var byte = (this._length[this._pointer++] = data[start++])

              if (!(byte & 0x80)) {
                this._missing = varint.decode(this._length)
                this._pointer = 0
                if (this._missing > 8388608) return this._tooBig(data.length)
                return start
              }

              if (this._pointer >= this._length.length)
                return this._tooBig(data.length)
            }

            return start
          }

          Protocol.prototype._sameKey = function() {
            if (!this.discoveryKey || !this.remoteDiscoveryKey) return true
            if (
              this.remoteDiscoveryKey.toString("hex") ===
              this.discoveryKey.toString("hex")
            )
              return true
            this.destroy(new Error("First shared hypercore must be the same"))
            return false
          }

          Protocol.prototype._tooManyFeeds = function() {
            this.destroy(
              new Error(
                "Only 128 feeds currently supported. Open a Github issue if you need more"
              )
            )
          }

          Protocol.prototype._tooBig = function(len) {
            this.destroy(
              new Error("Remote message is larger than 8MB (max allowed)")
            )
            return len
          }

          Protocol.prototype._badFeed = function() {
            this.destroy(new Error("Remote sent invalid feed message"))
          }

          Protocol.prototype._ontimeout = function() {
            this.destroy(new Error("Remote timed out"))
          }

          function decodeHeader(data, start) {
            try {
              return varint.decode(data, start)
            } catch (err) {
              return -1
            }
          }

          function decodeFeed(data, start, end) {
            var feed = null

            try {
              feed = messages.Feed.decode(data, start, end)
            } catch (err) {
              return null
            }

            if (feed.discoveryKey.length !== 32) return null
            if (feed.nonce && feed.nonce.length !== 24) return null

            return feed
          }

          function encodeFeed(feed, id) {
            var header = id << 4
            var len =
              varint.encodingLength(header) + messages.Feed.encodingLength(feed)
            var box = bufferAlloc(varint.encodingLength(len) + len)
            var offset = 0

            varint.encode(len, box, offset)
            offset += varint.encode.bytes

            varint.encode(header, box, offset)
            offset += varint.encode.bytes

            messages.Feed.encode(feed, box, offset)
            return box
          }

          function discoveryKey(key) {
            var buf = bufferAlloc(32)
            sodium.crypto_generichash(buf, bufferFrom("hypercore"), key)
            return buf
          }

          function randomBytes(n) {
            var buf = bufferAlloc(n)
            sodium.randombytes_buf(buf)
            return buf
          }
        }.call(this, require("_process")))
      },
      {
        "./feed": 27,
        "./messages": 29,
        _process: 44,
        "buffer-alloc-unsafe": 15,
        "buffer-from": 19,
        inherits: 37,
        "readable-stream": 58,
        "sodium-universal": 70,
        "sorted-indexof": 71,
        varint: 82
      }
    ],
    29: [
      function(require, module, exports) {
        ;(function(Buffer) {
          // This file is auto generated by the protocol-buffers cli tool

          /* eslint-disable quotes */
          /* eslint-disable indent */
          /* eslint-disable no-redeclare */

          // Remember to `npm install --save protocol-buffers-encodings`
          var encodings = require("protocol-buffers-encodings")
          var varint = encodings.varint
          var skip = encodings.skip

          var Feed = (exports.Feed = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Handshake = (exports.Handshake = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Info = (exports.Info = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Have = (exports.Have = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Unhave = (exports.Unhave = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Want = (exports.Want = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Unwant = (exports.Unwant = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Request = (exports.Request = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Cancel = (exports.Cancel = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Data = (exports.Data = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          defineFeed()
          defineHandshake()
          defineInfo()
          defineHave()
          defineUnhave()
          defineWant()
          defineUnwant()
          defineRequest()
          defineCancel()
          defineData()

          function defineFeed() {
            var enc = [encodings.bytes]

            Feed.encodingLength = encodingLength
            Feed.encode = encode
            Feed.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.discoveryKey))
                throw new Error("discoveryKey is required")
              var len = enc[0].encodingLength(obj.discoveryKey)
              length += 1 + len
              if (defined(obj.nonce)) {
                var len = enc[0].encodingLength(obj.nonce)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.discoveryKey))
                throw new Error("discoveryKey is required")
              buf[offset++] = 10
              enc[0].encode(obj.discoveryKey, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.nonce)) {
                buf[offset++] = 18
                enc[0].encode(obj.nonce, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                discoveryKey: null,
                nonce: null
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.discoveryKey = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.nonce = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineHandshake() {
            var enc = [encodings.bytes, encodings.bool, encodings.string]

            Handshake.encodingLength = encodingLength
            Handshake.encode = encode
            Handshake.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (defined(obj.id)) {
                var len = enc[0].encodingLength(obj.id)
                length += 1 + len
              }
              if (defined(obj.live)) {
                var len = enc[1].encodingLength(obj.live)
                length += 1 + len
              }
              if (defined(obj.userData)) {
                var len = enc[0].encodingLength(obj.userData)
                length += 1 + len
              }
              if (defined(obj.extensions)) {
                for (var i = 0; i < obj.extensions.length; i++) {
                  if (!defined(obj.extensions[i])) continue
                  var len = enc[2].encodingLength(obj.extensions[i])
                  length += 1 + len
                }
              }
              if (defined(obj.ack)) {
                var len = enc[1].encodingLength(obj.ack)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (defined(obj.id)) {
                buf[offset++] = 10
                enc[0].encode(obj.id, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.live)) {
                buf[offset++] = 16
                enc[1].encode(obj.live, buf, offset)
                offset += enc[1].encode.bytes
              }
              if (defined(obj.userData)) {
                buf[offset++] = 26
                enc[0].encode(obj.userData, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.extensions)) {
                for (var i = 0; i < obj.extensions.length; i++) {
                  if (!defined(obj.extensions[i])) continue
                  buf[offset++] = 34
                  enc[2].encode(obj.extensions[i], buf, offset)
                  offset += enc[2].encode.bytes
                }
              }
              if (defined(obj.ack)) {
                buf[offset++] = 40
                enc[1].encode(obj.ack, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                id: null,
                live: false,
                userData: null,
                extensions: [],
                ack: false
              }
              while (true) {
                if (end <= offset) {
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.id = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 2:
                    obj.live = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  case 3:
                    obj.userData = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 4:
                    obj.extensions.push(enc[2].decode(buf, offset))
                    offset += enc[2].decode.bytes
                    break
                  case 5:
                    obj.ack = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineInfo() {
            var enc = [encodings.bool]

            Info.encodingLength = encodingLength
            Info.encode = encode
            Info.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (defined(obj.uploading)) {
                var len = enc[0].encodingLength(obj.uploading)
                length += 1 + len
              }
              if (defined(obj.downloading)) {
                var len = enc[0].encodingLength(obj.downloading)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (defined(obj.uploading)) {
                buf[offset++] = 8
                enc[0].encode(obj.uploading, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.downloading)) {
                buf[offset++] = 16
                enc[0].encode(obj.downloading, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                uploading: false,
                downloading: false
              }
              while (true) {
                if (end <= offset) {
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.uploading = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 2:
                    obj.downloading = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineHave() {
            var enc = [encodings.varint, encodings.bytes]

            Have.encodingLength = encodingLength
            Have.encode = encode
            Have.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              if (defined(obj.bitfield)) {
                var len = enc[1].encodingLength(obj.bitfield)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.bitfield)) {
                buf[offset++] = 26
                enc[1].encode(obj.bitfield, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 1,
                bitfield: null
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 3:
                    obj.bitfield = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineUnhave() {
            var enc = [encodings.varint]

            Unhave.encodingLength = encodingLength
            Unhave.encode = encode
            Unhave.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 1
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineWant() {
            var enc = [encodings.varint]

            Want.encodingLength = encodingLength
            Want.encode = encode
            Want.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 0
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineUnwant() {
            var enc = [encodings.varint]

            Unwant.encodingLength = encodingLength
            Unwant.encode = encode
            Unwant.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 0
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineRequest() {
            var enc = [encodings.varint, encodings.bool]

            Request.encodingLength = encodingLength
            Request.encode = encode
            Request.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.index)) throw new Error("index is required")
              var len = enc[0].encodingLength(obj.index)
              length += 1 + len
              if (defined(obj.bytes)) {
                var len = enc[0].encodingLength(obj.bytes)
                length += 1 + len
              }
              if (defined(obj.hash)) {
                var len = enc[1].encodingLength(obj.hash)
                length += 1 + len
              }
              if (defined(obj.nodes)) {
                var len = enc[0].encodingLength(obj.nodes)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.index)) throw new Error("index is required")
              buf[offset++] = 8
              enc[0].encode(obj.index, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.bytes)) {
                buf[offset++] = 16
                enc[0].encode(obj.bytes, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.hash)) {
                buf[offset++] = 24
                enc[1].encode(obj.hash, buf, offset)
                offset += enc[1].encode.bytes
              }
              if (defined(obj.nodes)) {
                buf[offset++] = 32
                enc[0].encode(obj.nodes, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                index: 0,
                bytes: 0,
                hash: false,
                nodes: 0
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.bytes = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 3:
                    obj.hash = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  case 4:
                    obj.nodes = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineCancel() {
            var enc = [encodings.varint, encodings.bool]

            Cancel.encodingLength = encodingLength
            Cancel.encode = encode
            Cancel.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.index)) throw new Error("index is required")
              var len = enc[0].encodingLength(obj.index)
              length += 1 + len
              if (defined(obj.bytes)) {
                var len = enc[0].encodingLength(obj.bytes)
                length += 1 + len
              }
              if (defined(obj.hash)) {
                var len = enc[1].encodingLength(obj.hash)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.index)) throw new Error("index is required")
              buf[offset++] = 8
              enc[0].encode(obj.index, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.bytes)) {
                buf[offset++] = 16
                enc[0].encode(obj.bytes, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.hash)) {
                buf[offset++] = 24
                enc[1].encode(obj.hash, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                index: 0,
                bytes: 0,
                hash: false
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.bytes = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 3:
                    obj.hash = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineData() {
            var Node = (Data.Node = {
              buffer: true,
              encodingLength: null,
              encode: null,
              decode: null
            })

            defineNode()

            function defineNode() {
              var enc = [encodings.varint, encodings.bytes]

              Node.encodingLength = encodingLength
              Node.encode = encode
              Node.decode = decode

              function encodingLength(obj) {
                var length = 0
                if (!defined(obj.index)) throw new Error("index is required")
                var len = enc[0].encodingLength(obj.index)
                length += 1 + len
                if (!defined(obj.hash)) throw new Error("hash is required")
                var len = enc[1].encodingLength(obj.hash)
                length += 1 + len
                if (!defined(obj.size)) throw new Error("size is required")
                var len = enc[0].encodingLength(obj.size)
                length += 1 + len
                return length
              }

              function encode(obj, buf, offset) {
                if (!offset) offset = 0
                if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
                var oldOffset = offset
                if (!defined(obj.index)) throw new Error("index is required")
                buf[offset++] = 8
                enc[0].encode(obj.index, buf, offset)
                offset += enc[0].encode.bytes
                if (!defined(obj.hash)) throw new Error("hash is required")
                buf[offset++] = 18
                enc[1].encode(obj.hash, buf, offset)
                offset += enc[1].encode.bytes
                if (!defined(obj.size)) throw new Error("size is required")
                buf[offset++] = 24
                enc[0].encode(obj.size, buf, offset)
                offset += enc[0].encode.bytes
                encode.bytes = offset - oldOffset
                return buf
              }

              function decode(buf, offset, end) {
                if (!offset) offset = 0
                if (!end) end = buf.length
                if (!(end <= buf.length && offset <= buf.length))
                  throw new Error("Decoded message is not valid")
                var oldOffset = offset
                var obj = {
                  index: 0,
                  hash: null,
                  size: 0
                }
                var found0 = false
                var found1 = false
                var found2 = false
                while (true) {
                  if (end <= offset) {
                    if (!found0 || !found1 || !found2)
                      throw new Error("Decoded message is not valid")
                    decode.bytes = offset - oldOffset
                    return obj
                  }
                  var prefix = varint.decode(buf, offset)
                  offset += varint.decode.bytes
                  var tag = prefix >> 3
                  switch (tag) {
                    case 1:
                      obj.index = enc[0].decode(buf, offset)
                      offset += enc[0].decode.bytes
                      found0 = true
                      break
                    case 2:
                      obj.hash = enc[1].decode(buf, offset)
                      offset += enc[1].decode.bytes
                      found1 = true
                      break
                    case 3:
                      obj.size = enc[0].decode(buf, offset)
                      offset += enc[0].decode.bytes
                      found2 = true
                      break
                    default:
                      offset = skip(prefix & 7, buf, offset)
                  }
                }
              }
            }

            var enc = [encodings.varint, encodings.bytes, Node]

            Data.encodingLength = encodingLength
            Data.encode = encode
            Data.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.index)) throw new Error("index is required")
              var len = enc[0].encodingLength(obj.index)
              length += 1 + len
              if (defined(obj.value)) {
                var len = enc[1].encodingLength(obj.value)
                length += 1 + len
              }
              if (defined(obj.nodes)) {
                for (var i = 0; i < obj.nodes.length; i++) {
                  if (!defined(obj.nodes[i])) continue
                  var len = enc[2].encodingLength(obj.nodes[i])
                  length += varint.encodingLength(len)
                  length += 1 + len
                }
              }
              if (defined(obj.signature)) {
                var len = enc[1].encodingLength(obj.signature)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.index)) throw new Error("index is required")
              buf[offset++] = 8
              enc[0].encode(obj.index, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.value)) {
                buf[offset++] = 18
                enc[1].encode(obj.value, buf, offset)
                offset += enc[1].encode.bytes
              }
              if (defined(obj.nodes)) {
                for (var i = 0; i < obj.nodes.length; i++) {
                  if (!defined(obj.nodes[i])) continue
                  buf[offset++] = 26
                  varint.encode(
                    enc[2].encodingLength(obj.nodes[i]),
                    buf,
                    offset
                  )
                  offset += varint.encode.bytes
                  enc[2].encode(obj.nodes[i], buf, offset)
                  offset += enc[2].encode.bytes
                }
              }
              if (defined(obj.signature)) {
                buf[offset++] = 34
                enc[1].encode(obj.signature, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                index: 0,
                value: null,
                nodes: [],
                signature: null
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.value = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  case 3:
                    var len = varint.decode(buf, offset)
                    offset += varint.decode.bytes
                    obj.nodes.push(enc[2].decode(buf, offset, offset + len))
                    offset += enc[2].decode.bytes
                    break
                  case 4:
                    obj.signature = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defined(val) {
            return (
              val !== null &&
              val !== undefined &&
              (typeof val !== "number" || !isNaN(val))
            )
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "protocol-buffers-encodings": 45 }
    ],
    30: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var equals = require("buffer-equals")
          var low = require("last-one-wins")
          var remove = require("unordered-array-remove")
          var set = require("unordered-set")
          var merkle = require("merkle-tree-stream/generator")
          var flat = require("flat-tree")
          var bulk = require("bulk-write-stream")
          var from = require("from2")
          var codecs = require("codecs")
          var thunky = require("thunky")
          var batcher = require("atomic-batcher")
          var inherits = require("inherits")
          var events = require("events")
          var raf = require("random-access-file")
          var bitfield = require("./lib/bitfield")
          var sparseBitfield = require("sparse-bitfield")
          var treeIndex = require("./lib/tree-index")
          var storage = require("./lib/storage")
          var crypto = require("./lib/crypto")
          var nextTick = require("process-nextick-args")
          var bufferFrom = require("buffer-from")
          var bufferAlloc = require("buffer-alloc-unsafe")
          var replicate = null

          module.exports = Feed

          function Feed(createStorage, key, opts) {
            if (!(this instanceof Feed))
              return new Feed(createStorage, key, opts)
            events.EventEmitter.call(this)

            if (typeof createStorage === "string")
              createStorage = defaultStorage(createStorage)
            if (typeof createStorage !== "function")
              throw new Error("Storage should be a function or string")

            if (typeof key === "string") key = bufferFrom(key, "hex")

            if (!Buffer.isBuffer(key) && !opts) {
              opts = key
              key = null
            }

            if (!opts) opts = {}

            var self = this

            var secretKey = opts.secretKey || null
            if (typeof secretKey === "string")
              secretKey = bufferFrom(secretKey, "hex")

            this.id = opts.id || crypto.randomBytes(32)
            this.live = opts.live !== false
            this.sparse = !!opts.sparse
            this.length = 0
            this.byteLength = 0
            this.maxRequests = opts.maxRequests || 16
            this.key = key || null
            this.discoveryKey = this.key && crypto.discoveryKey(this.key)
            this.secretKey = secretKey
            this.bitfield = null
            this.tree = null
            this.writable = !!opts.writable
            this.readable = true
            this.opened = false
            this.closed = false
            this.allowPush = !!opts.allowPush
            this.peers = []

            // hooks
            this._onwrite = opts.onwrite || null

            this._ready = thunky(open) // TODO: if open fails, do not reopen next time
            this._indexing = !!opts.indexing
            this._createIfMissing = opts.createIfMissing !== false
            this._overwrite = !!opts.overwrite
            this._storeSecretKey = opts.storeSecretKey !== false
            this._merkle = null
            this._storage = storage(createStorage, opts.storageCacheSize)
            this._batch = batcher(this._onwrite ? workHook : work)

            this._waiting = []
            this._selections = []
            this._reserved = sparseBitfield()
            this._synced = null

            this._codec = toCodec(opts.valueEncoding)
            this._sync = low(sync)
            if (!this.sparse) this.download({ start: 0, end: -1 })

            // open it right away. TODO: do not reopen (i.e, set a flag not to retry)
            this._ready(onerror)

            function onerror(err) {
              if (err) self.emit("error", err)
            }

            function workHook(values, cb) {
              self._appendHook(values, cb)
            }

            function work(values, cb) {
              self._append(values, cb)
            }

            function sync(_, cb) {
              self._syncBitfield(cb)
            }

            function open(cb) {
              self._open(cb)
            }
          }

          inherits(Feed, events.EventEmitter)

          Feed.discoveryKey = crypto.discoveryKey

          // TODO: instead of using a getter, update on remote-update/add/remove
          Object.defineProperty(Feed.prototype, "remoteLength", {
            enumerable: true,
            get: function() {
              var len = 0
              for (var i = 0; i < this.peers.length; i++) {
                var remoteLength = this.peers[i].remoteLength
                if (remoteLength > len) len = remoteLength
              }
              return len
            }
          })

          Feed.prototype.replicate = function(opts) {
            // Lazy load replication deps
            if (!replicate) replicate = require("./lib/replicate")

            if (
              (!this._selections.length || this._selections[0].end !== -1) &&
              !this.sparse &&
              !(opts && opts.live)
            ) {
              // hack!! proper fix is to refactor ./replicate to *not* clear our non-sparse selection
              this.download({ start: 0, end: -1 })
            }

            return replicate(this, opts || {})
          }

          Feed.prototype.ready = function(onready) {
            this._ready(function(err) {
              if (!err) onready()
            })
          }

          Feed.prototype.update = function(len, cb) {
            if (typeof len === "function") return this.update(-1, len)
            if (typeof len !== "number") len = -1
            if (!cb) cb = noop

            var self = this

            this.ready(function(err) {
              if (err) return cb(err)
              if (len === -1) len = self.length + 1
              if (self.length >= len) return cb(null)

              if (self.writable) cb = self._writeStateReloader(cb)

              self._waiting.push({
                hash: true,
                bytes: 0,
                index: len - 1,
                update: true,
                callback: cb
              })

              self._updatePeers()
            })
          }

          // will reload the writable state. used by .update on a writable peer
          Feed.prototype._writeStateReloader = function(cb) {
            var self = this
            return function(err) {
              if (err) return cb(err)

              self._roots(self.length, function(err, roots) {
                if (err) return cb(err)
                self._merkle = merkle(crypto, roots)
                cb(null)
              })
            }
          }

          Feed.prototype._open = function(cb) {
            var self = this
            var generatedKey = false

            // TODO: clean up the duplicate code below ...

            this._storage.openKey(function(_, key) {
              if (key && !self._overwrite && !self.key) self.key = key

              if (!self.key && self.live) {
                var keyPair = crypto.keyPair()
                self.secretKey = keyPair.secretKey
                self.key = keyPair.publicKey
                generatedKey = true
              }

              self.discoveryKey = self.key && crypto.discoveryKey(self.key)
              self._storage.open(
                { key: self.key, discoveryKey: self.discoveryKey },
                onopen
              )
            })

            function onopen(err, state) {
              if (err) return cb(err)

              // if no key but we have data do a bitfield reset since we cannot verify the data.
              if (!state.key && state.bitfield.length) {
                self._overwrite = true
              }

              if (self._overwrite) {
                state.bitfield.fill(0)
                state.key = state.secretKey = null
              }

              self.bitfield = bitfield(state.bitfield)
              self.tree = treeIndex(self.bitfield.tree)
              self.length = self.tree.blocks()

              if (state.key && self.key && !equals(state.key, self.key)) {
                return cb(new Error("Another hypercore is stored here"))
              }

              if (state.key) self.key = state.key
              if (state.secretKey) self.secretKey = state.secretKey

              // verify key and secretKey go together
              if (self.key && self.secretKey) {
                var challenge = bufferAlloc(0)
                if (
                  !crypto.verify(
                    challenge,
                    crypto.sign(challenge, self.secretKey),
                    self.key
                  )
                ) {
                  return cb(new Error("Key and secret do not match"))
                }
              }

              if (!self.length) return onsignature(null, null)
              self._storage.getSignature(self.length - 1, onsignature)

              function onsignature(_, sig) {
                if (self.length) self.live = !!sig

                if ((generatedKey || !self.key) && !self._createIfMissing) {
                  return cb(new Error("No hypercore is stored here"))
                }

                if (!self.key && self.live) {
                  var keyPair = crypto.keyPair()
                  self.secretKey = keyPair.secretKey
                  self.key = keyPair.publicKey
                }

                var writable = !!self.secretKey || self.key === null

                if (!writable && self.writable)
                  return cb(new Error("Feed is not writable"))
                self.writable = writable
                self.discoveryKey = self.key && crypto.discoveryKey(self.key)

                if (self._storeSecretKey && !self.secretKey) {
                  self._storeSecretKey = false
                }

                var shouldWriteKey =
                  generatedKey || !safeBufferEquals(self.key, state.key)
                var shouldWriteSecretKey =
                  self._storeSecretKey &&
                  (generatedKey ||
                    !safeBufferEquals(self.secretKey, state.secretKey))

                var missing =
                  1 +
                  (shouldWriteKey ? 1 : 0) +
                  (shouldWriteSecretKey ? 1 : 0) +
                  (self._overwrite ? 1 : 0)
                var error = null

                if (shouldWriteKey) self._storage.key.write(0, self.key, done)
                if (shouldWriteSecretKey)
                  self._storage.secretKey.write(0, self.secretKey, done)

                if (self._overwrite) {
                  // TODO: support storage.resize for this instead
                  self._storage.putBitfield(0, state.bitfield, done)
                }

                done(null)

                function done(err) {
                  if (err) error = err
                  if (--missing) return
                  if (error) return cb(error)
                  self._roots(self.length, onroots)
                }

                function onroots(err, roots) {
                  if (err) return cb(err)

                  self._merkle = merkle(crypto, roots)
                  self.byteLength = roots.reduce(addSize, 0)
                  self.opened = true
                  self.emit("ready")

                  cb(null)
                }
              }
            }
          }

          Feed.prototype.download = function(range, cb) {
            if (typeof range === "function") return this.download(null, range)
            if (typeof range === "number")
              range = { start: range, end: range + 1 }
            if (!range) range = {}

            // TODO: if no peers, check if range is already satisfied and nextTick(cb) if so
            // this._updatePeers does this for us when there is a peer though, so not critical

            var sel = {
              _index: this._selections.length,
              hash: !!range.hash,
              iterator: null,
              start: range.start || 0,
              end: range.end || -1,
              linear: !!range.linear,
              callback: cb || noop
            }

            this._selections.push(sel)
            this._updatePeers()

            return sel
          }

          Feed.prototype.undownload = function(range) {
            if (typeof range === "number")
              range = { start: range, end: range + 1 }
            if (!range) range = {}

            if (range.callback && range._index > -1) {
              set.remove(this._selections, range)
              nextTick(range.callback, new Error("Download was cancelled"))
              return
            }

            var start = range.start || 0
            var end = range.end || -1
            var hash = !!range.hash
            var linear = !!range.linear

            for (var i = 0; i < this._selections.length; i++) {
              var s = this._selections[i]

              if (
                s.start === start &&
                s.end === end &&
                s.hash === hash &&
                s.linear === linear
              ) {
                set.remove(this._selections, s)
                nextTick(s.callback, new Error("Download was cancelled"))
                return
              }
            }
          }

          Feed.prototype.digest = function(index) {
            return this.tree.digest(2 * index)
          }

          Feed.prototype.proof = function(index, opts, cb) {
            if (typeof opts === "function") return this.proof(index, null, opts)
            if (!this.opened) return this._readyAndProof(index, opts, cb)
            if (!opts) opts = {}

            var proof = this.tree.proof(2 * index, opts)
            if (!proof)
              return cb(new Error("No proof available for this index"))

            var needsSig = this.live && !!proof.verifiedBy
            var pending = proof.nodes.length + (needsSig ? 1 : 0)
            var error = null
            var signature = null
            var nodes = new Array(proof.nodes.length)

            if (!pending) return cb(null, { nodes: nodes, signature: null })

            for (var i = 0; i < proof.nodes.length; i++) {
              this._storage.getNode(proof.nodes[i], onnode)
            }
            if (needsSig) {
              this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature)
            }

            function onsignature(err, sig) {
              if (sig) signature = sig
              onnode(err, null)
            }

            function onnode(err, node) {
              if (err) error = err

              if (node) {
                nodes[proof.nodes.indexOf(node.index)] = node
              }

              if (--pending) return
              if (error) return cb(error)
              cb(null, { nodes: nodes, signature: signature })
            }
          }

          Feed.prototype._readyAndProof = function(index, opts, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.proof(index, opts, cb)
            })
          }

          Feed.prototype.put = function(index, data, proof, cb) {
            if (!this.opened) return this._readyAndPut(index, data, proof, cb)
            this._putBuffer(index, this._codec.encode(data), proof, null, cb)
          }

          Feed.prototype.cancel = function(start, end) {
            // TODO: use same argument scheme as download
            if (!end) end = start + 1

            // cancel these right away as .download does not wait for ready
            for (var i = this._selections.length - 1; i >= 0; i--) {
              var sel = this._selections[i]
              if (start <= sel.start && sel.end <= end) {
                this.undownload(sel)
              }
            }

            // defer the last part until after ready as .get does that as well
            if (this.opened) this._cancel(start, end)
            else this._readyAndCancel(start, end)
          }

          Feed.prototype._cancel = function(start, end) {
            var i = 0

            for (i = start; i < end; i++) {
              this._reserved.set(i, false) // TODO: send cancel message if set returns true
            }

            for (i = this._waiting.length - 1; i >= 0; i--) {
              var w = this._waiting[i]
              if (
                (start <= w.start && w.end <= end) ||
                (start <= w.index && w.index < end)
              ) {
                remove(this._waiting, i)
                if (w.callback)
                  nextTick(w.callback, new Error("Request cancelled"))
              }
            }
          }

          Feed.prototype.clear = function(start, end, opts, cb) {
            // TODO: use same argument scheme as download
            if (typeof end === "function")
              return this.clear(start, start + 1, null, end)
            if (typeof opts === "function")
              return this.clear(start, end, null, opts)
            if (!opts) opts = {}
            if (!end) end = start + 1
            if (!cb) cb = noop

            // TODO: this needs some work. fx we can only calc byte offset for blocks we know about
            // so internally we should make sure to only do that. We should use the merkle tree for this

            var self = this
            var byteOffset =
              start === 0
                ? 0
                : typeof opts.byteOffset === "number"
                  ? opts.byteOffset
                  : -1
            var byteLength =
              typeof opts.byteLength === "number" ? opts.byteLength : -1

            this._ready(function(err) {
              if (err) return cb(err)

              var modified = false

              // TODO: use a buffer.fill thing here to speed this up!

              for (var i = start; i < end; i++) {
                if (self.bitfield.set(i, false)) modified = true
              }

              if (!modified) return nextTick(cb)

              // TODO: write to a tmp/update file that we want to del this incase it crashes will del'ing

              self._unannounce({ start: start, length: end - start })
              if (opts.delete === false || self._indexing) return sync()
              if (byteOffset > -1) return onstartbytes(null, byteOffset)
              self._storage.dataOffset(start, [], onstartbytes)

              function sync() {
                self.emit("clear", start, end)
                self._sync(null, cb)
              }

              function onstartbytes(err, offset) {
                if (err) return cb(err)
                byteOffset = offset
                if (byteLength > -1)
                  return onendbytes(null, byteLength + byteOffset)
                if (end === self.length)
                  return onendbytes(null, self.byteLength)
                self._storage.dataOffset(end, [], onendbytes)
              }

              function onendbytes(err, end) {
                if (err) return cb(err)
                if (!self._storage.data.del) return sync() // Not all data storage impls del
                self._storage.data.del(byteOffset, end - byteOffset, sync)
              }
            })
          }

          Feed.prototype.signature = function(index, cb) {
            if (typeof index === "function")
              return this.signature(this.length - 1, index)

            if (index < 0 || index >= this.length)
              return cb(new Error("No signature available for this index"))

            this._storage.nextSignature(index, cb)
          }

          Feed.prototype.verify = function(index, signature, cb) {
            var self = this

            this.rootHashes(index, function(err, roots) {
              if (err) return cb(err)

              var checksum = crypto.tree(roots)

              if (!crypto.verify(checksum, signature, self.key)) {
                cb(new Error("Signature verification failed"))
              } else {
                cb(null, true)
              }
            })
          }

          Feed.prototype.rootHashes = function(index, cb) {
            this._getRootsToVerify(index * 2 + 2, {}, [], cb)
          }

          Feed.prototype.seek = function(bytes, opts, cb) {
            if (typeof opts === "function") return this.seek(bytes, null, opts)
            if (!opts) opts = {}
            if (!this.opened) return this._readyAndSeek(bytes, opts, cb)

            var self = this

            this._seek(bytes, function(err, index, offset) {
              if (!err && isBlock(index)) return done(index / 2, offset)
              if (opts.wait === false)
                return cb(err || new Error("Unable to seek to this offset"))

              var start = opts.start || 0
              var end = opts.end || -1

              if (!err) {
                var left = flat.leftSpan(index) / 2
                var right = flat.rightSpan(index) / 2 + 1

                if (left > start) start = left
                if (right < end || end === -1) end = right
              }

              if (end > -1 && end <= start)
                return cb(new Error("Unable to seek to this offset"))

              self._waiting.push({
                hash: opts.hash !== false,
                bytes: bytes,
                index: -1,
                start: start,
                end: end,
                callback: cb || noop
              })

              self._updatePeers()
            })

            function done(index, offset) {
              for (var i = 0; i < self.peers.length; i++) {
                self.peers[i].haveBytes(bytes)
              }
              cb(null, index, offset)
            }
          }

          Feed.prototype._seek = function(offset, cb) {
            if (offset === 0) return cb(null, 0, 0)

            var self = this
            var roots = flat.fullRoots(this.length * 2)
            var nearestRoot = 0

            loop(null, null)

            function onroot(top) {
              if (isBlock(top)) return cb(null, top, offset)

              var left = flat.leftChild(top)
              while (!self.tree.get(left)) {
                if (isBlock(left)) return cb(null, nearestRoot, offset)
                left = flat.leftChild(left)
              }

              self._storage.getNode(left, onleftchild)
            }

            function onleftchild(err, node) {
              if (err) return cb(err)

              if (node.size > offset) {
                nearestRoot = node.index
                onroot(node.index)
              } else {
                offset -= node.size
                onroot(flat.sibling(node.index))
              }
            }

            function loop(err, node) {
              if (err) return cb(err)

              if (node) {
                if (node.size > offset) {
                  nearestRoot = node.index
                  return onroot(node.index)
                }
                offset -= node.size
              }

              if (!roots.length) return cb(new Error("Out of bounds"))
              self._storage.getNode(roots.shift(), loop)
            }
          }

          Feed.prototype._readyAndSeek = function(bytes, opts, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.seek(bytes, opts, cb)
            })
          }

          Feed.prototype._getBuffer = function(index, cb) {
            this._storage.getData(index, cb)
          }

          Feed.prototype._putBuffer = function(index, data, proof, from, cb) {
            // TODO: this nodes in proof are not instances of our Node prototype
            // but just similar. Check if this has any v8 perf implications.

            // TODO: if the proof contains a valid signature BUT fails, emit a critical error
            // --> feed should be considered dead

            var self = this
            var trusted = -1
            var missing = []
            var next = 2 * index
            var i = data ? 0 : 1

            while (true) {
              if (this.tree.get(next)) {
                trusted = next
                break
              }

              var sib = flat.sibling(next)
              next = flat.parent(next)

              if (i < proof.nodes.length && proof.nodes[i].index === sib) {
                i++
                continue
              }

              if (!this.tree.get(sib)) break
              missing.push(sib)
            }

            if (trusted === -1 && this.tree.get(next)) trusted = next

            var error = null
            var trustedNode = null
            var missingNodes = new Array(missing.length)
            var pending = missing.length + (trusted > -1 ? 1 : 0)

            for (i = 0; i < missing.length; i++)
              this._storage.getNode(missing[i], onmissing)
            if (trusted > -1) this._storage.getNode(trusted, ontrusted)
            if (!missing.length && trusted === -1) onmissingloaded(null)

            function ontrusted(err, node) {
              if (err) error = err
              if (node) trustedNode = node
              if (!--pending) onmissingloaded(error)
            }

            function onmissing(err, node) {
              if (err) error = err
              if (node) missingNodes[missing.indexOf(node.index)] = node
              if (!--pending) onmissingloaded(error)
            }

            function onmissingloaded(err) {
              if (err) return cb(err)
              self._verifyAndWrite(
                index,
                data,
                proof,
                missingNodes,
                trustedNode,
                from,
                cb
              )
            }
          }

          Feed.prototype._readyAndPut = function(index, data, proof, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.put(index, data, proof, cb)
            })
          }

          Feed.prototype._write = function(index, data, nodes, sig, from, cb) {
            if (!this._onwrite)
              return this._writeAfterHook(index, data, nodes, sig, from, cb)
            this._onwrite(
              index,
              data,
              from,
              writeHookDone(this, index, data, nodes, sig, from, cb)
            )
          }

          function writeHookDone(self, index, data, nodes, sig, from, cb) {
            return function(err) {
              if (err) return cb(err)
              self._writeAfterHook(index, data, nodes, sig, from, cb)
            }
          }

          Feed.prototype._writeAfterHook = function(
            index,
            data,
            nodes,
            sig,
            from,
            cb
          ) {
            var self = this
            var pending = nodes.length + 1 + (sig ? 1 : 0)
            var error = null

            for (var i = 0; i < nodes.length; i++)
              this._storage.putNode(nodes[i].index, nodes[i], ondone)
            if (data) this._storage.putData(index, data, nodes, ondone)
            else ondone()
            if (sig)
              this._storage.putSignature(sig.index, sig.signature, ondone)

            function ondone(err) {
              if (err) error = err
              if (--pending) return
              if (error) return cb(error)
              self._writeDone(index, data, nodes, from, cb)
            }
          }

          Feed.prototype._writeDone = function(index, data, nodes, from, cb) {
            for (var i = 0; i < nodes.length; i++) this.tree.set(nodes[i].index)
            this.tree.set(2 * index)

            if (data) {
              if (this.bitfield.set(index, true))
                this.emit("download", index, data, from)
              if (this.peers.length) this._announce({ start: index }, from)

              if (!this.writable) {
                if (!this._synced)
                  this._synced = this.bitfield.iterator(0, this.length)
                if (this._synced.next() === -1) {
                  this._synced.range(0, this.length)
                  this._synced.seek(0)
                  if (this._synced.next() === -1) {
                    this.emit("sync")
                  }
                }
              }
            }

            this._sync(null, cb)
          }

          Feed.prototype._verifyAndWrite = function(
            index,
            data,
            proof,
            localNodes,
            trustedNode,
            from,
            cb
          ) {
            var visited = []
            var remoteNodes = proof.nodes
            var top = data
              ? new storage.Node(2 * index, crypto.data(data), data.length)
              : remoteNodes.shift()

            // check if we already have the hash for this node
            if (verifyNode(trustedNode, top)) {
              this._write(index, data, visited, null, from, cb)
              return
            }

            // keep hashing with siblings until we reach or trusted node
            while (true) {
              var node = null
              var next = flat.sibling(top.index)

              if (remoteNodes.length && remoteNodes[0].index === next) {
                node = remoteNodes.shift()
                visited.push(node)
              } else if (localNodes.length && localNodes[0].index === next) {
                node = localNodes.shift()
              } else {
                // we cannot create another parent, i.e. these nodes must be roots in the tree
                this._verifyRootsAndWrite(
                  index,
                  data,
                  top,
                  proof,
                  visited,
                  from,
                  cb
                )
                return
              }

              visited.push(top)
              top = new storage.Node(
                flat.parent(top.index),
                crypto.parent(top, node),
                top.size + node.size
              )

              // the tree checks out, write the data and the visited nodes
              if (verifyNode(trustedNode, top)) {
                this._write(index, data, visited, null, from, cb)
                return
              }
            }
          }

          Feed.prototype._verifyRootsAndWrite = function(
            index,
            data,
            top,
            proof,
            nodes,
            from,
            cb
          ) {
            var remoteNodes = proof.nodes
            var lastNode = remoteNodes.length
              ? remoteNodes[remoteNodes.length - 1].index
              : top.index
            var verifiedBy =
              Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2
            var self = this

            this._getRootsToVerify(verifiedBy, top, remoteNodes, function(
              err,
              roots,
              extraNodes
            ) {
              if (err) return cb(err)

              var checksum = crypto.tree(roots)
              var signature = null

              if (self.length && self.live && !proof.signature) {
                return cb(new Error("Remote did not include a signature"))
              }

              if (proof.signature) {
                // check signaturex
                if (!crypto.verify(checksum, proof.signature, self.key)) {
                  return cb(new Error("Remote signature could not be verified"))
                }

                signature = {
                  index: verifiedBy / 2 - 1,
                  signature: proof.signature
                }
              } else {
                // check tree root
                if (!equals(checksum, self.key)) {
                  return cb(new Error("Remote checksum failed"))
                }
              }

              self.live = !!signature

              var length = verifiedBy / 2
              if (length > self.length) {
                // TODO: only emit this after the info has been flushed to storage
                self.length = length
                self.byteLength = roots.reduce(addSize, 0)
                if (self._synced) self._synced.seek(0, self.length)
                self.emit("append")
              }

              self._write(
                index,
                data,
                nodes.concat(extraNodes),
                signature,
                from,
                cb
              )
            })
          }

          Feed.prototype._getRootsToVerify = function(
            verifiedBy,
            top,
            remoteNodes,
            cb
          ) {
            var indexes = flat.fullRoots(verifiedBy)
            var roots = new Array(indexes.length)
            var nodes = []
            var error = null
            var pending = roots.length

            for (var i = 0; i < indexes.length; i++) {
              if (indexes[i] === top.index) {
                nodes.push(top)
                onnode(null, top)
              } else if (
                remoteNodes.length &&
                indexes[i] === remoteNodes[0].index
              ) {
                nodes.push(remoteNodes[0])
                onnode(null, remoteNodes.shift())
              } else if (this.tree.get(indexes[i])) {
                this._storage.getNode(indexes[i], onnode)
              } else {
                onnode(new Error("Missing tree roots needed for verify"))
              }
            }

            function onnode(err, node) {
              if (err) error = err
              if (node) roots[indexes.indexOf(node.index)] = node
              if (!--pending) done(error)
            }

            function done(err) {
              if (err) return cb(err)

              cb(null, roots, nodes)
            }
          }

          Feed.prototype._announce = function(message, from) {
            for (var i = 0; i < this.peers.length; i++) {
              var peer = this.peers[i]
              if (peer !== from) peer.have(message)
            }
          }

          Feed.prototype._unannounce = function(message) {
            for (var i = 0; i < this.peers.length; i++)
              this.peers[i].unhave(message)
          }

          Feed.prototype.downloaded = function(start, end) {
            return this.bitfield.total(start, end)
          }

          Feed.prototype.has = function(start, end) {
            if (end === undefined) return this.bitfield.get(start)
            var total = end - start
            return total === this.bitfield.total(start, end)
          }

          Feed.prototype.head = function(opts, cb) {
            if (typeof opts === "function") return this.head({}, opts)
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              if (self.length === 0) cb(new Error("feed is empty"))
              else self.get(self.length - 1, cb)
            })
          }

          Feed.prototype.get = function(index, opts, cb) {
            if (typeof opts === "function") return this.get(index, null, opts)
            if (!this.opened) return this._readyAndGet(index, opts, cb)

            if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout)

            if (!this.bitfield.get(index)) {
              if (opts && opts.wait === false)
                return cb(new Error("Block not downloaded"))

              this._waiting.push({
                bytes: 0,
                hash: false,
                index: index,
                options: opts,
                callback: cb
              })
              this._updatePeers()
              return
            }

            if (opts && opts.valueEncoding)
              cb = wrapCodec(toCodec(opts.valueEncoding), cb)
            else if (this._codec !== codecs.binary)
              cb = wrapCodec(this._codec, cb)

            this._getBuffer(index, cb)
          }

          Feed.prototype._readyAndGet = function(index, opts, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.get(index, opts, cb)
            })
          }

          Feed.prototype._updatePeers = function() {
            for (var i = 0; i < this.peers.length; i++) this.peers[i].update()
          }

          Feed.prototype.createWriteStream = function() {
            var self = this
            return bulk.obj(write)

            function write(batch, cb) {
              self._batch(batch, cb)
            }
          }

          Feed.prototype.createReadStream = function(opts) {
            if (!opts) opts = {}

            var self = this
            var start = opts.start || 0
            var end = typeof opts.end === "number" ? opts.end : -1
            var live = !!opts.live
            var snapshot = opts.snapshot !== false
            var first = true
            var range = this.download({ start: start, end: end, linear: true })

            return from
              .obj(read)
              .on("end", cleanup)
              .on("close", cleanup)

            function read(size, cb) {
              if (!self.opened) return open(size, cb)

              if (first) {
                if (end === -1) {
                  if (live) end = Infinity
                  else if (snapshot) end = self.length
                }
                if (opts.tail) start = self.length
                first = false
              }

              if (start === end || (end === -1 && start === self.length))
                return cb(null, null)
              self.get(start++, opts, cb)
            }

            function cleanup() {
              if (!range) return
              self.undownload(range)
              range = null
            }

            function open(size, cb) {
              self._ready(function(err) {
                if (err) return cb(err)
                read(size, cb)
              })
            }
          }

          // TODO: when calling finalize on a live feed write an END_OF_FEED block (length === 0?)
          Feed.prototype.finalize = function(cb) {
            if (!this.key) {
              this.key = crypto.tree(this._merkle.roots)
              this.discoveryKey = crypto.discoveryKey(this.key)
            }
            this._storage.key.write(0, this.key, cb)
          }

          Feed.prototype.append = function(batch, cb) {
            this._batch(Array.isArray(batch) ? batch : [batch], cb || noop)
          }

          Feed.prototype.flush = function(cb) {
            this._batch([], cb)
          }

          Feed.prototype.close = function(cb) {
            var self = this

            this._ready(function() {
              self.writable = false
              self.readable = false
              self._storage.close(function(err) {
                if (!self.closed && !err) {
                  self.closed = true
                  self.emit("close")
                }
                if (cb) cb(err)
              })
            })
          }

          Feed.prototype._appendHook = function(batch, cb) {
            var self = this
            var missing = batch.length
            var error = null

            if (!missing) return this._append(batch, cb)
            for (var i = 0; i < batch.length; i++) {
              this._onwrite(i + this.length, batch[i], null, done)
            }

            function done(err) {
              if (err) error = err
              if (--missing) return
              if (error) return cb(error)
              self._append(batch, cb)
            }
          }

          Feed.prototype._append = function(batch, cb) {
            if (!this.opened) return this._readyAndAppend(batch, cb)
            if (!this.writable)
              return cb(
                new Error("This feed is not writable. Did you create it?")
              )

            var self = this
            var pending =
              this.live && batch.length ? 1 + batch.length : batch.length
            var offset = 0
            var error = null

            if (!pending) return cb()

            for (var i = 0; i < batch.length; i++) {
              var data = this._codec.encode(batch[i])
              var nodes = this._merkle.next(data)

              if (this._indexing) done(null)
              else
                this._storage.data.write(this.byteLength + offset, data, done)

              if (this.live && i === batch.length - 1) {
                var sig = crypto.sign(
                  crypto.tree(this._merkle.roots),
                  this.secretKey
                )
                this._storage.putSignature(this.length + i, sig, done)
              }

              pending += nodes.length
              offset += data.length

              for (var j = 0; j < nodes.length; j++) {
                var node = nodes[j]
                this._storage.putNode(node.index, node, done)
              }
            }

            function done(err) {
              if (err) error = err
              if (--pending) return
              if (error) return cb(error)

              var start = self.length

              // TODO: only emit append and update length / byteLength after the info has been flushed to storage
              self.byteLength += offset
              for (var i = 0; i < batch.length; i++) {
                self.bitfield.set(self.length, true)
                self.tree.set(2 * self.length++)
              }
              self.emit("append")

              var message =
                self.length - start > 1
                  ? { start: start, length: self.length - start }
                  : { start: start }
              if (self.peers.length) self._announce(message)

              self._sync(null, cb)
            }
          }

          Feed.prototype._readyAndAppend = function(batch, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self._append(batch, cb)
            })
          }

          Feed.prototype._readyAndCancel = function(start, end) {
            var self = this
            this.ready(function() {
              self._cancel(start, end)
            })
          }

          Feed.prototype._pollWaiting = function() {
            var len = this._waiting.length
            for (var i = 0; i < len; i++) {
              var next = this._waiting[i]
              if (!next.bytes && !this.bitfield.get(next.index)) continue

              remove(this._waiting, i--)
              len--

              if (next.bytes) this.seek(next.bytes, next, next.callback)
              else if (next.update) this.update(next.index + 1, next.callback)
              else this.get(next.index, next.options, next.callback)
            }
          }

          Feed.prototype._syncBitfield = function(cb) {
            var missing = this.bitfield.pages.updates.length
            var next = null
            var error = null

            // All data / nodes have been written now. We still need to update the bitfields though

            // TODO 1: if the program fails during this write the bitfield might not have been fully written
            // HOWEVER, we can easily recover from this by traversing the tree and checking if the nodes exists
            // on disk. So if a get fails, it should try and recover once.

            // TODO 2: if .writable append bitfield updates into a single buffer for extra perf
            // Added benefit is that if the program exits while flushing the bitfield the feed will only get
            // truncated and not have missing chunks which is what you expect.

            if (!missing) {
              this._pollWaiting()
              return cb(null)
            }

            while ((next = this.bitfield.pages.lastUpdate()) !== null) {
              this._storage.putBitfield(next.offset, next.buffer, ondone)
            }

            this._pollWaiting()

            function ondone(err) {
              if (err) error = err
              if (--missing) return
              cb(error)
            }
          }

          Feed.prototype._roots = function(index, cb) {
            var roots = flat.fullRoots(2 * index)
            var result = new Array(roots.length)
            var pending = roots.length
            var error = null

            if (!pending) return cb(null, result)

            for (var i = 0; i < roots.length; i++) {
              this._storage.getNode(roots[i], onnode)
            }

            function onnode(err, node) {
              if (err) error = err
              if (node) result[roots.indexOf(node.index)] = node
              if (--pending) return
              if (error) return cb(error)
              cb(null, result)
            }
          }

          function noop() {}

          function verifyNode(trusted, node) {
            return (
              trusted &&
              trusted.index === node.index &&
              equals(trusted.hash, node.hash)
            )
          }

          function addSize(size, node) {
            return size + node.size
          }

          function isBlock(index) {
            return (index & 1) === 0
          }

          function defaultStorage(dir) {
            return function(name) {
              return raf(name, { directory: dir })
            }
          }

          function toCodec(enc) {
            // Switch to ndjson encoding if JSON is used. That way data files parse like ndjson \o/
            return codecs(enc === "json" ? "ndjson" : enc)
          }

          function wrapCodec(enc, cb) {
            return function(err, buf) {
              if (err) return cb(err)
              try {
                buf = enc.decode(buf)
              } catch (err) {
                return cb(err)
              }
              cb(null, buf)
            }
          }

          function timeoutCallback(cb, timeout) {
            var failed = false
            var id = setTimeout(ontimeout, timeout)
            return done

            function ontimeout() {
              failed = true
              // TODO: make libs/errors for all this stuff
              var err = new Error("ETIMEDOUT")
              err.code = "ETIMEDOUT"
              cb(err)
            }

            function done(err, val) {
              if (failed) return
              clearTimeout(id)
              cb(err, val)
            }
          }

          // buffer-equals, but handle 'null' buffer parameters.
          function safeBufferEquals(a, b) {
            if (!a) return !b
            if (!b) return !a
            return equals(a, b)
          }
        }.call(this, { isBuffer: require("../is-buffer/index.js") }))
      },
      {
        "../is-buffer/index.js": 38,
        "./lib/bitfield": 31,
        "./lib/crypto": 32,
        "./lib/replicate": 33,
        "./lib/storage": 34,
        "./lib/tree-index": 35,
        "atomic-batcher": 4,
        "buffer-alloc-unsafe": 15,
        "buffer-equals": 17,
        "buffer-from": 19,
        "bulk-write-stream": 21,
        codecs: 22,
        events: 24,
        "flat-tree": 25,
        from2: 26,
        inherits: 37,
        "last-one-wins": 39,
        "merkle-tree-stream/generator": 41,
        "process-nextick-args": 43,
        "random-access-file": 46,
        "sparse-bitfield": 72,
        thunky: 74,
        "unordered-array-remove": 77,
        "unordered-set": 78
      }
    ],
    31: [
      function(require, module, exports) {
        var flat = require("flat-tree")
        var rle = require("bitfield-rle")
        var pager = require("memory-pager")
        var bitfield = require("sparse-bitfield")

        var INDEX_UPDATE_MASK = [63, 207, 243, 252]
        var INDEX_ITERATE_MASK = [0, 192, 240, 252]
        var DATA_ITERATE_MASK = [128, 192, 224, 240, 248, 252, 254, 255]
        var DATA_UPDATE_MASK = [127, 191, 223, 239, 247, 251, 253, 254]
        var MAP_PARENT_RIGHT = new Array(256)
        var MAP_PARENT_LEFT = new Array(256)
        var NEXT_DATA_0_BIT = new Array(256)
        var NEXT_INDEX_0_BIT = new Array(256)
        var TOTAL_1_BITS = new Array(256)

        for (var i = 0; i < 256; i++) {
          var a = (i & (15 << 4)) >> 4
          var b = i & 15
          var nibble = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]
          MAP_PARENT_RIGHT[i] =
            ((a === 15 ? 3 : a === 0 ? 0 : 1) << 2) |
            (b === 15 ? 3 : b === 0 ? 0 : 1)
          MAP_PARENT_LEFT[i] = MAP_PARENT_RIGHT[i] << 4
          NEXT_DATA_0_BIT[i] =
            i === 255 ? -1 : 8 - Math.ceil(Math.log(256 - i) / Math.log(2))
          NEXT_INDEX_0_BIT[i] =
            i === 255 ? -1 : Math.floor(NEXT_DATA_0_BIT[i] / 2)
          TOTAL_1_BITS[i] = nibble[i >> 4] + nibble[i & 0x0f]
        }

        module.exports = Bitfield

        function Bitfield(buffer) {
          if (!(this instanceof Bitfield)) return new Bitfield(buffer)

          this.pages = pager(3328)

          if (buffer) {
            for (var i = 0; i < buffer.length; i += 3328) {
              this.pages.set(i / 3328, buffer.slice(i, i + 3328))
            }
          }

          this.data = bitfield({
            pageSize: 1024,
            pageOffset: 0,
            pages: this.pages,
            trackUpdates: true
          })

          this.tree = bitfield({
            pageSize: 2048,
            pageOffset: 1024,
            pages: this.pages,
            trackUpdates: true
          })

          this.index = bitfield({
            pageSize: 256,
            pageOffset: 1024 + 2048,
            pages: this.pages,
            trackUpdates: true
          })

          this.length = this.data.length
          this._iterator = flat.iterator(0)
        }

        Bitfield.prototype.set = function(i, value) {
          var o = i & 7
          i = (i - o) / 8
          var v = value
            ? this.data.getByte(i) | (128 >> o)
            : this.data.getByte(i) & DATA_UPDATE_MASK[o]

          if (!this.data.setByte(i, v)) return false
          this.length = this.data.length
          this._setIndex(i, v)
          return true
        }

        Bitfield.prototype.get = function(i) {
          return this.data.get(i)
        }

        Bitfield.prototype.total = function(start, end) {
          if (!start || start < 0) start = 0
          if (!end) end = this.data.length
          if (end < start) return 0
          if (end > this.data.length) {
            this._expand(end)
          }
          var o = start & 7
          var e = end & 7
          var pos = (start - o) / 8
          var last = (end - e) / 8
          var leftMask = 255 - (o ? DATA_ITERATE_MASK[o - 1] : 0)
          var rightMask = e ? DATA_ITERATE_MASK[e - 1] : 0
          var byte = this.data.getByte(pos)
          if (pos === last) {
            return TOTAL_1_BITS[byte & leftMask & rightMask]
          }
          var total = TOTAL_1_BITS[byte & leftMask]
          for (var i = pos + 1; i < last; i++) {
            total += TOTAL_1_BITS[this.data.getByte(i)]
          }
          total += TOTAL_1_BITS[this.data.getByte(last) & rightMask]
          return total
        }

        // TODO: use the index to speed this up *a lot*
        Bitfield.prototype.compress = function() {
          return rle.encode(this.data.toBuffer())
        }

        Bitfield.prototype._setIndex = function(i, value) {
          //                    (a + b | c + d | e + f | g + h)
          // -> (a | b | c | d)                                (e | f | g | h)
          //

          var o = i & 3
          i = (i - o) / 4

          var bitfield = this.index
          var ite = this._iterator
          var start = 2 * i
          var byte =
            (bitfield.getByte(start) & INDEX_UPDATE_MASK[o]) |
            (getIndexValue(value) >> (2 * o))
          var len = bitfield.length
          var maxLength = this.pages.length * 256

          ite.seek(start)

          while (ite.index < maxLength && bitfield.setByte(ite.index, byte)) {
            if (ite.isLeft()) {
              byte =
                MAP_PARENT_LEFT[byte] |
                MAP_PARENT_RIGHT[bitfield.getByte(ite.sibling())]
            } else {
              byte =
                MAP_PARENT_RIGHT[byte] |
                MAP_PARENT_LEFT[bitfield.getByte(ite.sibling())]
            }
            ite.parent()
          }

          if (len !== bitfield.length) this._expand(len)

          return ite.index !== start
        }

        Bitfield.prototype._expand = function(len) {
          var roots = flat.fullRoots(2 * len)
          var bitfield = this.index
          var ite = this._iterator
          var byte = 0

          for (var i = 0; i < roots.length; i++) {
            ite.seek(roots[i])
            byte = bitfield.getByte(ite.index)

            do {
              if (ite.isLeft()) {
                byte =
                  MAP_PARENT_LEFT[byte] |
                  MAP_PARENT_RIGHT[bitfield.getByte(ite.sibling())]
              } else {
                byte =
                  MAP_PARENT_RIGHT[byte] |
                  MAP_PARENT_LEFT[bitfield.getByte(ite.sibling())]
              }
            } while (setByteNoAlloc(bitfield, ite.parent(), byte))
          }
        }

        function setByteNoAlloc(bitfield, i, b) {
          if (8 * i >= bitfield.length) return false
          return bitfield.setByte(i, b)
        }

        Bitfield.prototype.iterator = function(start, end) {
          var ite = new Iterator(this)

          ite.range(start || 0, end || this.length)
          ite.seek(0)

          return ite
        }

        function Iterator(bitfield) {
          this.start = 0
          this.end = 0

          this._indexEnd = 0
          this._pos = 0
          this._byte = 0
          this._bitfield = bitfield
        }

        Iterator.prototype.range = function(start, end) {
          this.start = start
          this.end = end
          this._indexEnd = 2 * Math.ceil(end / 32)

          if (this.end > this._bitfield.length) {
            this._bitfield._expand(this.end)
          }

          return this
        }

        Iterator.prototype.seek = function(offset) {
          offset += this.start
          if (offset < this.start) offset = this.start

          if (offset >= this.end) {
            this._pos = -1
            return this
          }

          var o = offset & 7

          this._pos = (offset - o) / 8
          this._byte =
            this._bitfield.data.getByte(this._pos) |
            (o ? DATA_ITERATE_MASK[o - 1] : 0)

          return this
        }

        Iterator.prototype.random = function() {
          var i = this.seek(
            Math.floor(Math.random() * (this.end - this.start))
          ).next()
          return i === -1 ? this.seek(0).next() : i
        }

        Iterator.prototype.next = function() {
          if (this._pos === -1) return -1

          var dataBitfield = this._bitfield.data
          var free = NEXT_DATA_0_BIT[this._byte]

          while (free === -1) {
            this._byte = dataBitfield.getByte(++this._pos)
            free = NEXT_DATA_0_BIT[this._byte]

            if (free === -1) {
              this._pos = this._skipAhead(this._pos)
              if (this._pos === -1) return -1

              this._byte = dataBitfield.getByte(this._pos)
              free = NEXT_DATA_0_BIT[this._byte]
            }
          }

          this._byte |= DATA_ITERATE_MASK[free]

          var n = 8 * this._pos + free
          return n < this.end ? n : -1
        }

        Iterator.prototype.peek = function() {
          if (this._pos === -1) return -1

          var free = NEXT_DATA_0_BIT[this._byte]
          var n = 8 * this._pos + free
          return n < this.end ? n : -1
        }

        Iterator.prototype._skipAhead = function(start) {
          var indexBitfield = this._bitfield.index
          var treeEnd = this._indexEnd
          var ite = this._bitfield._iterator
          var o = start & 3

          ite.seek(2 * ((start - o) / 4))

          var treeByte =
            indexBitfield.getByte(ite.index) | INDEX_ITERATE_MASK[o]

          while (NEXT_INDEX_0_BIT[treeByte] === -1) {
            if (ite.isLeft()) {
              ite.next()
            } else {
              ite.next()
              ite.parent()
            }

            if (rightSpan(ite) >= treeEnd) {
              while (rightSpan(ite) >= treeEnd && isParent(ite)) ite.leftChild()
              if (rightSpan(ite) >= treeEnd) return -1
            }

            treeByte = indexBitfield.getByte(ite.index)
          }

          while (ite.factor > 2) {
            if (NEXT_INDEX_0_BIT[treeByte] < 2) ite.leftChild()
            else ite.rightChild()

            treeByte = indexBitfield.getByte(ite.index)
          }

          var free = NEXT_INDEX_0_BIT[treeByte]
          if (free === -1) free = 4

          var next = ite.index * 2 + free

          return next <= start ? start + 1 : next
        }

        function rightSpan(ite) {
          return ite.index + ite.factor / 2 - 1
        }

        function isParent(ite) {
          return ite.index & 1
        }

        function getIndexValue(n) {
          switch (n) {
            case 255:
              return 192
            case 0:
              return 0
            default:
              return 64
          }
        }
      },
      {
        "bitfield-rle": 6,
        "flat-tree": 25,
        "memory-pager": 40,
        "sparse-bitfield": 72
      }
    ],
    32: [
      function(require, module, exports) {
        var sodium = require("sodium-universal")
        var uint64be = require("uint64be")
        var bufferFrom = require("buffer-from")
        var bufferAlloc = require("buffer-alloc-unsafe")

        // https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack
        var LEAF_TYPE = bufferFrom([0])
        var PARENT_TYPE = bufferFrom([1])
        var ROOT_TYPE = bufferFrom([2])
        var HYPERCORE = bufferFrom("hypercore")

        exports.keyPair = function(seed) {
          var publicKey = bufferAlloc(sodium.crypto_sign_PUBLICKEYBYTES)
          var secretKey = bufferAlloc(sodium.crypto_sign_SECRETKEYBYTES)

          if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)
          else sodium.crypto_sign_keypair(publicKey, secretKey)

          return {
            publicKey: publicKey,
            secretKey: secretKey
          }
        }

        exports.sign = function(message, secretKey) {
          var signature = bufferAlloc(sodium.crypto_sign_BYTES)
          sodium.crypto_sign_detached(signature, message, secretKey)
          return signature
        }

        exports.verify = function(message, signature, publicKey) {
          return sodium.crypto_sign_verify_detached(
            signature,
            message,
            publicKey
          )
        }

        exports.data = function(data) {
          return blake2b([LEAF_TYPE, encodeUInt64(data.length), data])
        }

        exports.leaf = function(leaf) {
          return exports.data(leaf.data)
        }

        exports.parent = function(a, b) {
          if (a.index > b.index) {
            var tmp = a
            a = b
            b = tmp
          }

          return blake2b([
            PARENT_TYPE,
            encodeUInt64(a.size + b.size),
            a.hash,
            b.hash
          ])
        }

        exports.tree = function(roots) {
          var buffers = new Array(3 * roots.length + 1)
          var j = 0

          buffers[j++] = ROOT_TYPE

          for (var i = 0; i < roots.length; i++) {
            var r = roots[i]
            buffers[j++] = r.hash
            buffers[j++] = encodeUInt64(r.index)
            buffers[j++] = encodeUInt64(r.size)
          }

          return blake2b(buffers)
        }

        exports.randomBytes = function(n) {
          var buf = bufferAlloc(n)
          sodium.randombytes_buf(buf)
          return buf
        }

        exports.discoveryKey = function(tree) {
          var digest = bufferAlloc(32)
          sodium.crypto_generichash(digest, HYPERCORE, tree)
          return digest
        }

        function encodeUInt64(n) {
          return uint64be.encode(n, bufferAlloc(8))
        }

        function blake2b(buffers) {
          var digest = bufferAlloc(32)
          sodium.crypto_generichash_batch(digest, buffers)
          return digest
        }
      },
      {
        "buffer-alloc-unsafe": 15,
        "buffer-from": 19,
        "sodium-universal": 70,
        uint64be: 76
      }
    ],
    33: [
      function(require, module, exports) {
        var protocol = require("hypercore-protocol")
        var bitfield = require("sparse-bitfield")
        var set = require("unordered-set")
        var rle = require("bitfield-rle")

        module.exports = replicate

        function replicate(feed, opts) {
          var stream = opts.stream

          if (!stream) {
            if (!opts.expectedFeeds) opts.expectedFeeds = 1
            if (!opts.id) opts.id = feed.id
            stream = protocol(opts)
          }

          feed.ready(function(err) {
            if (err) return stream.destroy(err)
            if (stream.destroyed) return

            var peer = new Peer(feed, opts)
            peer.feed = feed
            peer.stream = stream.feed(feed.key, { peer: peer })

            peer.remoteId = stream.remoteId
            stream.setMaxListeners(0)
            stream.on("handshake", function() {
              peer.remoteId = stream.remoteId
            })

            // stream might get destroyed on feed init in case of conf errors
            if (stream.destroyed) return

            peer.ready()
          })

          return stream
        }

        function Peer(feed, opts) {
          this.feed = feed
          this.stream = null // set by replicate just after creation
          this.remoteId = null
          this.remoteBitfield = null
          this.remoteLength = 0
          this.remoteWant = false
          this.live = !!opts.live
          this.sparse = feed.sparse

          this.remoteDownloading = true
          this.downloading =
            typeof opts.download === "boolean" ? opts.download : !feed.writable
          this.uploading = true

          this.maxRequests = opts.maxRequests || feed.maxRequests || 16
          this.inflightRequests = []

          this._index = -1
          this._lastBytes = 0
          this._first = true
          this._closed = false
          this._destroyed = false
          this._defaultDownloading = this.downloading
        }

        Peer.prototype.onwant = function() {
          // TODO: reply to the actual want context
          this.remoteWant = true
          var rle = this.feed.bitfield.compress()
          this.stream.have({ start: 0, bitfield: rle })
        }

        Peer.prototype.ondata = function(data) {
          var self = this

          // Ignore unrequested messages unless we allow push
          // TODO: would be better to check if the byte range was requested instead, but this works fine
          var allowPush = this.feed.allowPush || !data.value
          if (!allowPush && !this.feed._reserved.get(data.index)) {
            // If we do not have this block, send back unhave message for this index,
            // to let the remote know we rejected it.
            // TODO: we might want to have some "unwanted push" threshold to punish spammers
            if (!self.feed.bitfield.get(data.index))
              self.unhave({ start: data.index })
            self._clear(data.index, !data.value)
            return
          }

          this.feed._putBuffer(data.index, data.value, data, this, function(
            err
          ) {
            if (err) return self.destroy(err)
            self._clear(data.index, !data.value)
          })
        }

        Peer.prototype._clear = function(index, hash) {
          // TODO: optimize me (no splice and do not run through all ...)
          for (var i = 0; i < this.inflightRequests.length; i++) {
            if (this.inflightRequests[i].index === index) {
              this.inflightRequests.splice(i, 1)
              i--
            }
          }

          this.feed._reserved.set(index, false)
          // TODO: only update all if we have overlapping selections
          this.feed._updatePeers()
        }

        Peer.prototype.onrequest = function(request) {
          if (request.bytes) return this._onbytes(request)

          var self = this
          var opts = { digest: request.nodes, hash: request.hash }

          this.feed.proof(request.index, opts, onproof)

          function onproof(err, proof) {
            if (err) return self.destroy(err)
            if (request.hash) onvalue(null, null)
            else if (self.feed.bitfield.get(request.index))
              self.feed._getBuffer(request.index, onvalue)

            function onvalue(err, value) {
              if (err) return self.destroy(err)

              if (!self.remoteBitfield) self.remoteBitfield = bitfield()

              if (value) {
                if (!self.remoteBitfield.set(request.index, true)) return
                self.feed.emit("upload", request.index, value, self)
              } else {
                if (self.remoteBitfield.get(request.index)) return
              }

              if (request.index + 1 > self.remoteLength) {
                self.remoteLength = request.index + 1
                self._updateEnd()
              }

              self.stream.data({
                index: request.index,
                value: value,
                nodes: proof.nodes,
                signature: proof.signature
              })
            }
          }
        }

        Peer.prototype._onbytes = function(request) {
          var self = this

          this.feed.seek(request.bytes, { wait: false }, function(err, index) {
            if (err) {
              request.bytes = 0
              self.onrequest(request)
              return
            }

            // quick'n'dirty filter for parallel bytes requests
            // it does not matter that this doesn't catch ALL parallel requests - just a bandwidth optimization
            if (self._lastBytes === request.bytes) return
            self._lastBytes = request.bytes

            request.bytes = 0
            request.index = index
            request.nodes = 0

            self.onrequest(request)
          })
        }

        Peer.prototype.ontick = function() {
          if (!this.inflightRequests.length) return

          var first = this.inflightRequests[0]
          if (--first.tick) return

          if (
            first.hash
              ? this.feed.tree.get(2 * first.index)
              : this.feed.bitfield.get(first.index)
          ) {
            // prob a bytes response
            this.inflightRequests.shift()
            this.feed._reserved.set(first.index, false)
            return
          }

          this.destroy(new Error("Request timeout"))
        }

        Peer.prototype.onhave = function(have) {
          var updated = this._first
          if (this._first) this._first = false

          if (have.bitfield) {
            // TODO: handle start !== 0
            this.remoteBitfield = bitfield(rle.decode(have.bitfield))
            if (this.remoteBitfield.length > this.remoteLength) {
              this.remoteLength = this.remoteBitfield.length
              while (
                this.remoteLength &&
                !this.remoteBitfield.get(this.remoteLength - 1)
              )
                this.remoteLength--
              updated = true
            }
          } else {
            if (!this.remoteBitfield) this.remoteBitfield = bitfield()
            // TODO: if len > something simply copy a 0b1111... buffer to the bitfield

            var start = have.start
            var len = have.length || 1

            while (len--) this.remoteBitfield.set(start++, true)
            if (start > this.remoteLength) {
              this.remoteLength = start
              updated = true
            }
          }

          if (updated) {
            this.feed.emit("remote-update", this)
          }

          this._updateEnd()
          this.update()
        }

        Peer.prototype._updateEnd = function() {
          if (this.live || this.feed.sparse || !this.feed._selections.length)
            return

          var sel = this.feed._selections[0]
          var remoteLength = this.feed.length || -1

          for (var i = 0; i < this.feed.peers.length; i++) {
            if (this.feed.peers[i].remoteLength > remoteLength) {
              remoteLength = this.feed.peers[i].remoteLength
            }
          }

          sel.end = remoteLength
        }

        Peer.prototype.oninfo = function(info) {
          this.remoteDownloading = info.downloading
          if (info.downloading || this.live) return
          this.update()
          if (this.feed._selections.length && this.downloading) return
          this.end()
        }

        Peer.prototype.onunhave = function(unhave) {
          if (!this.remoteBitfield) return

          var start = unhave.start
          var len = unhave.length || 1

          while (len--) this.remoteBitfield.set(start++, false)
        }

        Peer.prototype.onunwant = Peer.prototype.oncancel = function() {
          // TODO: impl all of me
        }

        Peer.prototype.onclose = function() {
          this.destroy()
        }

        Peer.prototype.have = function(have) {
          // called by feed
          if (this.stream && this.remoteWant) this.stream.have(have)
        }

        Peer.prototype.unhave = function(unhave) {
          // called by feed
          if (this.stream && this.remoteWant) this.stream.unhave(unhave)
        }

        Peer.prototype.haveBytes = function(bytes) {
          // called by feed
          for (var i = 0; i < this.inflightRequests.length; i++) {
            if (this.inflightRequests[i].bytes === bytes) {
              this.feed._reserved.set(this.inflightRequests[i].index, false)
              this.inflightRequests.splice(i, 1)
              i--
            }
          }

          this.update()
        }

        Peer.prototype.update = function() {
          // do nothing
          while (this._update()) {}
        }

        Peer.prototype._update = function() {
          // should return true if mutated false if not
          if (!this.downloading || !this.remoteBitfield) return false

          var selections = this.feed._selections
          var waiting = this.feed._waiting
          var wlen = waiting.length
          var slen = selections.length
          var inflight = this.inflightRequests.length
          var offset = 0
          var i = 0

          // TODO: less duplicate code here
          // TODO: re-add priority levels

          while (inflight < this.maxRequests) {
            offset = Math.floor(Math.random() * waiting.length)

            for (i = 0; i < waiting.length; i++) {
              var w = waiting[offset++]
              if (offset === waiting.length) offset = 0

              this._downloadWaiting(w)
              if (waiting.length !== wlen) return true // mutated
              if (this.inflightRequests.length >= this.maxRequests) return false
            }
            if (inflight === this.inflightRequests.length) break
            inflight = this.inflightRequests.length
          }

          while (inflight < this.maxRequests) {
            offset = Math.floor(Math.random() * selections.length)

            for (i = 0; i < selections.length; i++) {
              var s = selections[offset++]
              if (offset === selections.length) offset = 0

              if (!s.iterator)
                s.iterator = this.feed.bitfield.iterator(s.start, s.end)
              this._downloadRange(s)
              if (selections.length !== slen) return true // mutated
              if (this.inflightRequests.length >= this.maxRequests) return false
            }

            if (inflight === this.inflightRequests.length) return false
            inflight = this.inflightRequests.length
          }

          return false
        }

        Peer.prototype.ready = function() {
          set.add(this.feed.peers, this)
          this.stream.want({ start: 0 }) // TODO: don't just subscribe to *EVERYTHING* hehe
          this.feed.emit("peer-add", this)
        }

        Peer.prototype.end = function() {
          if (!this.downloading && !this.remoteDownloading && !this.live) {
            if (!this._defaultDownloading) {
              this.stream.info({ downloading: false, uploading: false })
            }
            this._close()
            return
          }
          if (!this._closed) {
            this._closed = true
            this.downloading = false
            this.stream.info({ downloading: false, uploading: true })
          } else {
            if (!this.live) this._close()
          }
        }

        Peer.prototype._close = function() {
          if (this._index === -1) return
          if (!this._destroyed) {
            this.stream.close()
            this._destroyed = true
          }
          set.remove(this.feed.peers, this)
          this._index = -1
          for (var i = 0; i < this.inflightRequests.length; i++) {
            this.feed._reserved.set(this.inflightRequests[i].index, false)
          }
          this._updateEnd()
          this.remoteWant = false
          this.feed._updatePeers()
          this.feed.emit("peer-remove", this)
        }

        Peer.prototype.destroy = function(err) {
          if (this._index === -1 || this._destroyed) return
          this.stream.destroy(err)
          this._destroyed = true
          this._close()
        }

        Peer.prototype._downloadWaiting = function(wait) {
          if (!wait.bytes) {
            if (
              !this.remoteBitfield.get(wait.index) ||
              !this.feed._reserved.set(wait.index, true)
            )
              return
            this._request(wait.index, 0, false)
            return
          }

          this._downloadRange(wait)
        }

        Peer.prototype._downloadRange = function(range) {
          if (!range.iterator)
            range.iterator = this.feed.bitfield.iterator(range.start, range.end)

          var reserved = this.feed._reserved
          var ite = range.iterator
          var wantedEnd = Math.min(
            range.end === -1 ? this.remoteLength : range.end,
            this.remoteLength
          )

          if (ite.end !== wantedEnd) ite.range(range.start, wantedEnd)

          var i = range.linear ? ite.next() : ite.random()
          var reset = false
          var start = i

          if (i === -1) {
            if (
              !range.bytes &&
              ite.seek(0).next() === -1 &&
              (range.end > -1 && this.remoteLength >= range.end)
            ) {
              set.remove(this.feed._selections, range)
              range.callback(null)
              if (!this.live && !this.sparse && !this.feed._selections.length)
                this.end()
            }
            return
          }

          while (
            !this.remoteBitfield.get(i) ||
            (range.hash && this.feed.tree.get(2 * i)) ||
            !reserved.set(i, true)
          ) {
            i = ite.next()
            reset = true

            if (i > -1) {
              // check this index
              continue
            }

            if (!range.linear && start !== 0) {
              // retry from the beginning since we are iterating randomly and started !== 0
              i = ite.seek(0).next()
              start = 0
              continue
            }

            // we have checked all indexes.
            // if we are looking for hashes we should check if we have all now (first check only checks blocks)
            if (range.hash) {
              // quick'n'dirty check if have all hashes - can be optimized be checking only tree roots
              // but we don't really request long ranges of hashes so yolo
              for (var j = range.start; j < wantedEnd; j++) {
                if (!this.feed.tree.get(2 * j)) return
              }
              if (!range.bytes) {
                set.remove(this.feed._selections, range)
                range.callback(null)
              }
            }

            // exit the update loop - nothing to do
            return
          }

          if (reset) ite.seek(0)

          this._request(i, range.bytes || 0, range.hash)
        }

        Peer.prototype._request = function(index, bytes, hash) {
          var request = {
            tick: 6,
            bytes: bytes,
            index: index,
            hash: hash,
            nodes: this.feed.digest(index)
          }

          this.inflightRequests.push(request)
          this.stream.request(request)
        }
      },
      {
        "bitfield-rle": 6,
        "hypercore-protocol": 28,
        "sparse-bitfield": 72,
        "unordered-set": 78
      }
    ],
    34: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var uint64be = require("uint64be")
          var flat = require("flat-tree")
          var alru = require("array-lru")
          var bufferAlloc = require("buffer-alloc-unsafe")

          module.exports = Storage

          var noarr = []

          function Storage(create, cacheSize) {
            if (!(this instanceof Storage))
              return new Storage(create, cacheSize)
            cacheSize = typeof cacheSize === "undefined" ? 65536 : cacheSize

            this.cache =
              cacheSize > 0 ? alru(cacheSize, { indexedValues: true }) : null
            this.key = null
            this.secretKey = null
            this.tree = null
            this.data = null
            this.bitfield = null
            this.signatures = null
            this.create = create
          }

          Storage.prototype.putData = function(index, data, nodes, cb) {
            if (!cb) cb = noop
            var self = this
            if (!data.length) return cb(null)
            this.dataOffset(index, nodes, function(err, offset, size) {
              if (err) return cb(err)
              if (size !== data.length)
                return cb(new Error("Unexpected data size"))
              self.data.write(offset, data, cb)
            })
          }

          Storage.prototype.getData = function(index, cb) {
            var self = this
            this.dataOffset(index, noarr, function(err, offset, size) {
              if (err) return cb(err)
              self.data.read(offset, size, cb)
            })
          }

          Storage.prototype.nextSignature = function(index, cb) {
            var self = this

            this._getSignature(index, function(err, signature) {
              if (err) return cb(err)
              if (isBlank(signature)) return self.nextSignature(index + 1, cb)
              cb(null, { index: index, signature: signature })
            })
          }

          Storage.prototype.getSignature = function(index, cb) {
            this._getSignature(index, function(err, signature) {
              if (err) return cb(err)
              if (isBlank(signature)) return cb(new Error("No signature found"))
              cb(null, signature)
            })
          }

          Storage.prototype._getSignature = function(index, cb) {
            this.signatures.read(32 + 64 * index, 64, cb)
          }

          Storage.prototype.putSignature = function(index, signature, cb) {
            this.signatures.write(32 + 64 * index, signature, cb)
          }

          Storage.prototype.dataOffset = function(index, cachedNodes, cb) {
            var roots = flat.fullRoots(2 * index)
            var self = this
            var offset = 0
            var pending = roots.length
            var error = null
            var blk = 2 * index

            if (!pending) {
              pending = 1
              onnode(null, null)
              return
            }

            for (var i = 0; i < roots.length; i++) {
              var node = findNode(cachedNodes, roots[i])
              if (node) onnode(null, node)
              else this.getNode(roots[i], onnode)
            }

            function onlast(err, node) {
              if (err) return cb(err)
              cb(null, offset, node.size)
            }

            function onnode(err, node) {
              if (err) error = err
              if (node) offset += node.size
              if (--pending) return

              if (error) return cb(error)

              var last = findNode(cachedNodes, blk)
              if (last) onlast(null, last)
              else self.getNode(blk, onlast)
            }
          }

          Storage.prototype.getNode = function(index, cb) {
            if (this.cache) {
              var cached = this.cache.get(index)
              if (cached) return cb(null, cached)
            }

            var self = this

            this.tree.read(32 + 40 * index, 40, function(err, buf) {
              if (err) return cb(err)

              var hash = buf.slice(0, 32)
              var size = uint64be.decode(buf, 32)

              if (!size && isBlank(hash)) return cb(new Error("No node found"))

              var val = new Node(index, hash, size, null)
              if (self.cache) self.cache.set(index, val)
              cb(null, val)
            })
          }

          Storage.prototype.putNode = function(index, node, cb) {
            if (!cb) cb = noop

            // TODO: re-enable put cache. currently this causes a memleak
            // because node.hash is a slice of the big data buffer on replicate
            // if (this.cache) this.cache.set(index, node)

            var buf = bufferAlloc(40)

            node.hash.copy(buf, 0)
            uint64be.encode(node.size, buf, 32)
            this.tree.write(32 + 40 * index, buf, cb)
          }

          Storage.prototype.putBitfield = function(offset, data, cb) {
            this.bitfield.write(32 + offset, data, cb)
          }

          Storage.prototype.close = function(cb) {
            if (!cb) cb = noop
            var missing = 6
            var error = null

            close(this.bitfield, done)
            close(this.tree, done)
            close(this.data, done)
            close(this.key, done)
            close(this.secretKey, done)
            close(this.signatures, done)

            function done(err) {
              if (err) error = err
              if (--missing) return
              cb(error)
            }
          }

          Storage.prototype.openKey = function(opts, cb) {
            if (typeof opts === "function") return this.openKey({}, opts)
            if (!this.key) this.key = this.create("key", opts)
            this.key.read(0, 32, cb)
          }

          Storage.prototype.open = function(opts, cb) {
            if (typeof opts === "function") return this.open({}, opts)

            var self = this
            var error = null
            var missing = 5

            if (!this.key) this.key = this.create("key", opts)
            if (!this.secretKey)
              this.secretKey = this.create("secret_key", opts)
            if (!this.tree) this.tree = this.create("tree", opts)
            if (!this.data) this.data = this.create("data", opts)
            if (!this.bitfield) this.bitfield = this.create("bitfield", opts)
            if (!this.signatures)
              this.signatures = this.create("signatures", opts)

            var result = {
              bitfield: bufferAlloc(0),
              secretKey: null,
              key: null
            }

            this.bitfield.write(0, header(0, 3328, null), function(err) {
              if (err) return cb(err)
              readAll(self.bitfield, 32, 3328, function(err, data) {
                if (data) result.bitfield = data
                done(err)
              })
            })

            this.signatures.write(0, header(1, 64, "Ed25519"), done)
            this.tree.write(0, header(2, 40, "BLAKE2b"), done)

            // TODO: Improve the error handling here.
            // I.e. if secretKey length === 64 and it fails, error

            this.secretKey.read(0, 64, function(_, data) {
              if (data) result.secretKey = data
              done(null)
            })

            this.key.read(0, 32, function(_, data) {
              if (data) result.key = data
              done(null)
            })

            function done(err) {
              if (err) error = err
              if (--missing) return
              if (error) cb(error)
              else cb(null, result)
            }
          }

          Storage.Node = Node

          function noop() {}

          function header(type, size, name) {
            var buf = bufferAlloc(32)
            buf.fill(0)

            // magic number
            buf[0] = 5
            buf[1] = 2
            buf[2] = 87
            buf[3] = type

            // version
            buf[4] = 0

            // block size
            buf.writeUInt16BE(size, 5)

            if (name) {
              // algo name
              buf[7] = name.length
              buf.write(name, 8)
            }

            return buf
          }

          function Node(index, hash, size) {
            this.index = index
            this.hash = hash
            this.size = size
          }

          function findNode(nodes, index) {
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].index === index) return nodes[i]
            }
            return null
          }

          function isBlank(buf) {
            for (var i = 0; i < buf.length; i++) {
              if (buf[i]) return false
            }
            return true
          }

          function close(st, cb) {
            if (st.close) st.close(cb)
            else cb()
          }

          function statAndReadAll(st, offset, cb) {
            st.stat(function(err, stat) {
              if (err) return cb(null, bufferAlloc(0))
              st.read(offset, stat.size - offset, cb)
            })
          }

          function readAll(st, offset, pageSize, cb) {
            if (typeof st.length === "number" && st.length > -1)
              return st.read(offset, st.length - offset, cb)
            if (st.statable === true) return statAndReadAll(st, offset, cb)

            var bufs = []

            st.read(offset, pageSize, loop)

            function loop(err, buf) {
              if (err) return cb(null, Buffer.concat(bufs))
              bufs.push(buf)
              st.read(offset + bufs.length * pageSize, pageSize, loop)
            }
          }
        }.call(this, require("buffer").Buffer))
      },
      {
        "array-lru": 3,
        buffer: 20,
        "buffer-alloc-unsafe": 15,
        "flat-tree": 25,
        uint64be: 76
      }
    ],
    35: [
      function(require, module, exports) {
        var flat = require("flat-tree")
        var bitfield = require("sparse-bitfield")

        module.exports = TreeIndex

        function TreeIndex(bits) {
          if (!(this instanceof TreeIndex)) return new TreeIndex(bits)
          this.bitfield = bits || bitfield()
        }

        TreeIndex.prototype.proof = function(index, opts) {
          if (!opts) opts = {}

          var nodes = []
          var remoteTree = opts.tree || new TreeIndex()
          var digest = opts.digest || 0

          if (!this.get(index)) return null
          if (opts.hash) nodes.push(index) // always return hash - no matter what the digest says
          if (digest === 1) return { nodes: nodes, verifiedBy: 0 }

          var roots = null
          var sibling = index
          var next = index
          var hasRoot = digest & 1
          digest = rightShift(digest)

          while (digest) {
            if (digest === 1 && hasRoot) {
              if (this.get(next)) remoteTree.set(next)

              // having a root implies having prev roots as well
              // TODO: this can be optimized away be only sending "newer" roots,
              // when sending roots
              if (flat.sibling(next) < next) next = flat.sibling(next)
              roots = flat.fullRoots(flat.rightSpan(next) + 2)
              for (var i = 0; i < roots.length; i++) {
                if (this.get(roots[i])) remoteTree.set(roots[i])
              }
              break
            }

            sibling = flat.sibling(next)
            if (digest & 1) {
              if (this.get(sibling)) remoteTree.set(sibling)
            }
            next = flat.parent(next)
            digest = rightShift(digest)
          }

          next = index

          while (!remoteTree.get(next)) {
            sibling = flat.sibling(next)
            if (!this.get(sibling)) {
              // next is a local root
              var verifiedBy = this.verifiedBy(next)
              addFullRoots(verifiedBy, nodes, next, remoteTree)
              return { nodes: nodes, verifiedBy: verifiedBy }
            } else {
              if (!remoteTree.get(sibling)) nodes.push(sibling)
            }

            next = flat.parent(next)
          }

          return { nodes: nodes, verifiedBy: 0 }
        }

        TreeIndex.prototype.digest = function(index) {
          if (this.get(index)) return 1

          var digest = 0
          var next = flat.sibling(index)
          var max = Math.max(next + 2, this.bitfield.length) // TODO: make this less ... hacky

          var bit = 2
          var depth = flat.depth(index)
          var parent = flat.parent(next, depth++)

          while (flat.rightSpan(next) < max || flat.leftSpan(parent) > 0) {
            if (this.get(next)) {
              digest |= bit
            }
            if (this.get(parent)) {
              digest |= 2 * bit + 1
              if (digest + 1 === 4 * bit) return 1
              return digest
            }
            next = flat.sibling(parent)
            parent = flat.parent(next, depth++)
            bit *= 2
          }

          return digest
        }

        TreeIndex.prototype.blocks = function() {
          var top = 0
          var next = 0
          var max = this.bitfield.length

          while (flat.rightSpan(next) < max) {
            next = flat.parent(next)
            if (this.get(next)) top = next
          }

          return (this.get(top) ? this.verifiedBy(top) : 0) / 2
        }

        TreeIndex.prototype.roots = function() {
          return flat.fullRoots(2 * this.blocks())
        }

        TreeIndex.prototype.verifiedBy = function(index, nodes) {
          var hasIndex = this.get(index)
          if (!hasIndex) return 0

          // find root of current tree

          var depth = flat.depth(index)
          var top = index
          var parent = flat.parent(top, depth++)
          while (this.get(parent) && this.get(flat.sibling(top))) {
            top = parent
            parent = flat.parent(top, depth++)
          }

          // expand right down

          depth--
          while (depth) {
            top = flat.leftChild(
              flat.index(depth, flat.offset(top, depth) + 1),
              depth
            )
            depth--

            while (!this.get(top) && depth) top = flat.leftChild(top, depth--)
            if (nodes && this.get(top)) nodes.push(top)
          }

          return this.get(top) ? top + 2 : top
        }

        TreeIndex.prototype.get = function(index) {
          return this.bitfield.get(index)
        }

        TreeIndex.prototype.set = function(index) {
          if (!this.bitfield.set(index, true)) return false
          while (this.bitfield.get(flat.sibling(index))) {
            index = flat.parent(index)
            if (!this.bitfield.set(index, true)) break
          }
          return true
        }

        function rightShift(n) {
          return (n - (n & 1)) / 2
        }

        function addFullRoots(verifiedBy, nodes, root, remoteTree) {
          var roots = flat.fullRoots(verifiedBy)
          for (var i = 0; i < roots.length; i++) {
            if (roots[i] !== root && !remoteTree.get(roots[i]))
              nodes.push(roots[i])
          }
        }
      },
      { "flat-tree": 25, "sparse-bitfield": 72 }
    ],
    36: [
      function(require, module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m
          var eLen = nBytes * 8 - mLen - 1
          var eMax = (1 << eLen) - 1
          var eBias = eMax >> 1
          var nBits = -7
          var i = isLE ? nBytes - 1 : 0
          var d = isLE ? -1 : 1
          var s = buffer[offset + i]

          i += d

          e = s & ((1 << -nBits) - 1)
          s >>= -nBits
          nBits += eLen
          for (
            ;
            nBits > 0;
            e = e * 256 + buffer[offset + i], i += d, nBits -= 8
          ) {}

          m = e & ((1 << -nBits) - 1)
          e >>= -nBits
          nBits += mLen
          for (
            ;
            nBits > 0;
            m = m * 256 + buffer[offset + i], i += d, nBits -= 8
          ) {}

          if (e === 0) {
            e = 1 - eBias
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity
          } else {
            m = m + Math.pow(2, mLen)
            e = e - eBias
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }

        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c
          var eLen = nBytes * 8 - mLen - 1
          var eMax = (1 << eLen) - 1
          var eBias = eMax >> 1
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0
          var i = isLE ? 0 : nBytes - 1
          var d = isLE ? 1 : -1
          var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

          value = Math.abs(value)

          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0
            e = eMax
          } else {
            e = Math.floor(Math.log(value) / Math.LN2)
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--
              c *= 2
            }
            if (e + eBias >= 1) {
              value += rt / c
            } else {
              value += rt * Math.pow(2, 1 - eBias)
            }
            if (value * c >= 2) {
              e++
              c /= 2
            }

            if (e + eBias >= eMax) {
              m = 0
              e = eMax
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen)
              e = e + eBias
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
              e = 0
            }
          }

          for (
            ;
            mLen >= 8;
            buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
          ) {}

          e = (e << mLen) | m
          eLen += mLen
          for (
            ;
            eLen > 0;
            buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
          ) {}

          buffer[offset + i - d] |= s * 128
        }
      },
      {}
    ],
    37: [
      function(require, module, exports) {
        if (typeof Object.create === "function") {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            })
          }
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function() {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
          }
        }
      },
      {}
    ],
    38: [
      function(require, module, exports) {
        /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

        // The _isBuffer check is for Safari 5-7 support, because it's missing
        // Object.prototype.constructor. Remove this eventually
        module.exports = function(obj) {
          return (
            obj != null &&
            (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
          )
        }

        function isBuffer(obj) {
          return (
            !!obj.constructor &&
            typeof obj.constructor.isBuffer === "function" &&
            obj.constructor.isBuffer(obj)
          )
        }

        // For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
          return (
            typeof obj.readFloatLE === "function" &&
            typeof obj.slice === "function" &&
            isBuffer(obj.slice(0, 0))
          )
        }
      },
      {}
    ],
    39: [
      function(require, module, exports) {
        module.exports = function(work) {
          var pending = null
          var callback = null
          var callbacks = null
          var next = null

          return function(val, cb) {
            next = val
            update(cb || noop)
          }

          function update(cb) {
            if (callback) {
              if (!pending) pending = []
              pending.push(cb)
              return
            }

            var val = next
            next = null
            callback = cb
            work(val, done)
          }

          function done(err) {
            var cb = callback
            var cbs = callbacks
            callbacks = null
            callback = null

            if (pending) {
              callbacks = pending
              pending = null
              update(noop)
            }

            if (cbs) {
              for (var i = 0; i < cbs.length; i++) cbs[i](err)
            }
            cb(err)
          }
        }

        function noop(_) {}
      },
      {}
    ],
    40: [
      function(require, module, exports) {
        ;(function(Buffer) {
          module.exports = Pager

          function Pager(pageSize) {
            if (!(this instanceof Pager)) return new Pager(pageSize)

            this.length = 0
            this.updates = []
            this.pages = new Array(16)
            this.pageSize = pageSize || 1024
          }

          Pager.prototype.updated = function(page) {
            if (page.updated || !this.updates) return
            page.updated = true
            this.updates.push(page)
          }

          Pager.prototype.lastUpdate = function() {
            if (!this.updates || !this.updates.length) return null
            var page = this.updates.pop()
            page.updated = false
            return page
          }

          Pager.prototype.get = function(i, noAllocate) {
            if (i >= this.pages.length) {
              if (noAllocate) return
              this.pages = grow(this.pages, i, this.length)
            }

            var page = this.pages[i]

            if (!page && !noAllocate) {
              page = this.pages[i] = new Page(i, alloc(this.pageSize))
              if (i >= this.length) this.length = i + 1
            }

            return page
          }

          Pager.prototype.set = function(i, buf) {
            if (i >= this.pages.length)
              this.pages = grow(this.pages, i, this.length)
            if (i >= this.length) this.length = i + 1

            if (!buf) {
              this.pages[i] = undefined
              return
            }

            var page = this.pages[i]
            var b = truncate(buf, this.pageSize)

            if (page) page.buffer = b
            else this.pages[i] = new Page(i, b)
          }

          Pager.prototype.toBuffer = function() {
            var list = new Array(this.length)
            var empty = alloc(this.pageSize)

            for (var i = 0; i < list.length; i++) {
              list[i] = this.pages[i] ? this.pages[i].buffer : empty
            }

            return Buffer.concat(list)
          }

          function grow(list, index, len) {
            var nlen = list.length * 2
            while (nlen <= index) nlen *= 2

            var twice = new Array(nlen)
            for (var i = 0; i < len; i++) twice[i] = list[i]
            return twice
          }

          function truncate(buf, len) {
            if (buf.length === len) return buf
            if (buf.length > len) return buf.slice(0, len)
            var cpy = alloc(len)
            buf.copy(cpy)
            return cpy
          }

          function alloc(size) {
            if (Buffer.alloc) return Buffer.alloc(size)
            var buf = new Buffer(size)
            buf.fill(0)
            return buf
          }

          function Page(i, buf) {
            this.offset = i * buf.length
            this.buffer = buf
            this.updated = false
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    41: [
      function(require, module, exports) {
        ;(function(Buffer) {
          // a more low level interface to the merkle tree stream.
          // useful for certain applications the require non-streamy access to the algos.
          // versioned by the same semver as the stream interface.

          var flat = require("flat-tree")

          module.exports = MerkleGenerator

          function MerkleGenerator(opts, roots) {
            if (!(this instanceof MerkleGenerator))
              return new MerkleGenerator(opts, roots)
            if (!opts || !opts.leaf || !opts.parent)
              throw new Error("opts.leaf and opts.parent required")

            this.roots = roots || opts.roots || []
            this.blocks = this.roots.length
              ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2
              : 0

            for (var i = 0; i < this.roots.length; i++) {
              var r = this.roots[i]
              if (r && !r.parent) r.parent = flat.parent(r.index)
            }

            this._leaf = opts.leaf
            this._parent = opts.parent
          }

          MerkleGenerator.prototype.next = function(data, nodes) {
            if (!Buffer.isBuffer(data)) data = new Buffer(data)
            if (!nodes) nodes = []

            var index = 2 * this.blocks++

            var leaf = {
              index: index,
              parent: flat.parent(index),
              hash: null,
              size: data.length,
              data: data
            }

            leaf.hash = this._leaf(leaf, this.roots)
            this.roots.push(leaf)
            nodes.push(leaf)

            while (this.roots.length > 1) {
              var left = this.roots[this.roots.length - 2]
              var right = this.roots[this.roots.length - 1]

              if (left.parent !== right.parent) break

              this.roots.pop()
              this.roots[this.roots.length - 1] = leaf = {
                index: left.parent,
                parent: flat.parent(left.parent),
                hash: this._parent(left, right),
                size: left.size + right.size,
                data: null
              }
              nodes.push(leaf)
            }

            return nodes
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "flat-tree": 25 }
    ],
    42: [
      function(require, module, exports) {
        assert.notEqual = notEqual
        assert.notOk = notOk
        assert.equal = equal
        assert.ok = assert

        module.exports = assert

        function equal(a, b, m) {
          assert(a == b, m) // eslint-disable-line eqeqeq
        }

        function notEqual(a, b, m) {
          assert(a != b, m) // eslint-disable-line eqeqeq
        }

        function notOk(t, m) {
          assert(!t, m)
        }

        function assert(t, m) {
          if (!t) throw new Error(m || "AssertionError")
        }
      },
      {}
    ],
    43: [
      function(require, module, exports) {
        ;(function(process) {
          "use strict"

          if (
            !process.version ||
            process.version.indexOf("v0.") === 0 ||
            (process.version.indexOf("v1.") === 0 &&
              process.version.indexOf("v1.8.") !== 0)
          ) {
            module.exports = nextTick
          } else {
            module.exports = process.nextTick
          }

          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
              throw new TypeError('"callback" argument must be a function')
            }
            var len = arguments.length
            var args, i
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn)
              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1)
                })
              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2)
                })
              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3)
                })
              default:
                args = new Array(len - 1)
                i = 0
                while (i < args.length) {
                  args[i++] = arguments[i]
                }
                return process.nextTick(function afterTick() {
                  fn.apply(null, args)
                })
            }
          }
        }.call(this, require("_process")))
      },
      { _process: 44 }
    ],
    44: [
      function(require, module, exports) {
        // shim for using process in browser
        var process = (module.exports = {})

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout
        var cachedClearTimeout

        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined")
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined")
        }
        ;(function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout
            } else {
              cachedSetTimeout = defaultSetTimout
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout
            } else {
              cachedClearTimeout = defaultClearTimeout
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout
          }
        })()
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0)
          }
          // if setTimeout wasn't available but was latter defined
          if (
            (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
            setTimeout
          ) {
            cachedSetTimeout = setTimeout
            return setTimeout(fun, 0)
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0)
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0)
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0)
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker)
          }
          // if clearTimeout wasn't available but was latter defined
          if (
            (cachedClearTimeout === defaultClearTimeout ||
              !cachedClearTimeout) &&
            clearTimeout
          ) {
            cachedClearTimeout = clearTimeout
            return clearTimeout(marker)
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker)
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker)
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker)
            }
          }
        }
        var queue = []
        var draining = false
        var currentQueue
        var queueIndex = -1

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return
          }
          draining = false
          if (currentQueue.length) {
            queue = currentQueue.concat(queue)
          } else {
            queueIndex = -1
          }
          if (queue.length) {
            drainQueue()
          }
        }

        function drainQueue() {
          if (draining) {
            return
          }
          var timeout = runTimeout(cleanUpNextTick)
          draining = true

          var len = queue.length
          while (len) {
            currentQueue = queue
            queue = []
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run()
              }
            }
            queueIndex = -1
            len = queue.length
          }
          currentQueue = null
          draining = false
          runClearTimeout(timeout)
        }

        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1)
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i]
            }
          }
          queue.push(new Item(fun, args))
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue)
          }
        }

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun
          this.array = array
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array)
        }
        process.title = "browser"
        process.browser = true
        process.env = {}
        process.argv = []
        process.version = "" // empty string to avoid regexp issues
        process.versions = {}

        function noop() {}

        process.on = noop
        process.addListener = noop
        process.once = noop
        process.off = noop
        process.removeListener = noop
        process.removeAllListeners = noop
        process.emit = noop
        process.prependListener = noop
        process.prependOnceListener = noop

        process.listeners = function(name) {
          return []
        }

        process.binding = function(name) {
          throw new Error("process.binding is not supported")
        }

        process.cwd = function() {
          return "/"
        }
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported")
        }
        process.umask = function() {
          return 0
        }
      },
      {}
    ],
    45: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var varint = require("varint")
          var svarint = require("signed-varint")

          exports.make = encoder

          exports.name = function(enc) {
            var keys = Object.keys(exports)
            for (var i = 0; i < keys.length; i++) {
              if (exports[keys[i]] === enc) return keys[i]
            }
            return null
          }

          exports.skip = function(type, buffer, offset) {
            switch (type) {
              case 0:
                varint.decode(buffer, offset)
                return offset + varint.decode.bytes

              case 1:
                return offset + 8

              case 2:
                var len = varint.decode(buffer, offset)
                return offset + varint.decode.bytes + len

              case 3:
              case 4:
                throw new Error("Groups are not supported")

              case 5:
                return offset + 4
            }

            throw new Error("Unknown wire type: " + type)
          }

          exports.bytes = encoder(
            2,
            function encode(val, buffer, offset) {
              var oldOffset = offset
              var len = bufferLength(val)

              varint.encode(len, buffer, offset)
              offset += varint.encode.bytes

              if (Buffer.isBuffer(val)) val.copy(buffer, offset)
              else buffer.write(val, offset, len)
              offset += len

              encode.bytes = offset - oldOffset
              return buffer
            },
            function decode(buffer, offset) {
              var oldOffset = offset

              var len = varint.decode(buffer, offset)
              offset += varint.decode.bytes

              var val = buffer.slice(offset, offset + len)
              offset += val.length

              decode.bytes = offset - oldOffset
              return val
            },
            function encodingLength(val) {
              var len = bufferLength(val)
              return varint.encodingLength(len) + len
            }
          )

          exports.string = encoder(
            2,
            function encode(val, buffer, offset) {
              var oldOffset = offset
              var len = Buffer.byteLength(val)

              varint.encode(len, buffer, offset, "utf-8")
              offset += varint.encode.bytes

              buffer.write(val, offset, len)
              offset += len

              encode.bytes = offset - oldOffset
              return buffer
            },
            function decode(buffer, offset) {
              var oldOffset = offset

              var len = varint.decode(buffer, offset)
              offset += varint.decode.bytes

              var val = buffer.toString("utf-8", offset, offset + len)
              offset += len

              decode.bytes = offset - oldOffset
              return val
            },
            function encodingLength(val) {
              var len = Buffer.byteLength(val)
              return varint.encodingLength(len) + len
            }
          )

          exports.bool = encoder(
            0,
            function encode(val, buffer, offset) {
              buffer[offset] = val ? 1 : 0
              encode.bytes = 1
              return buffer
            },
            function decode(buffer, offset) {
              var bool = buffer[offset] > 0
              decode.bytes = 1
              return bool
            },
            function encodingLength() {
              return 1
            }
          )

          exports.int32 = encoder(
            0,
            function encode(val, buffer, offset) {
              varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)
              encode.bytes = varint.encode.bytes
              return buffer
            },
            function decode(buffer, offset) {
              var val = varint.decode(buffer, offset)
              decode.bytes = varint.decode.bytes
              return val > 2147483647 ? val - 4294967296 : val
            },
            function encodingLength(val) {
              return varint.encodingLength(val < 0 ? val + 4294967296 : val)
            }
          )

          exports.int64 = encoder(
            0,
            function encode(val, buffer, offset) {
              if (val < 0) {
                var last = offset + 9
                varint.encode(val * -1, buffer, offset)
                offset += varint.encode.bytes - 1
                buffer[offset] = buffer[offset] | 0x80
                while (offset < last - 1) {
                  offset++
                  buffer[offset] = 0xff
                }
                buffer[last] = 0x01
                encode.bytes = 10
              } else {
                varint.encode(val, buffer, offset)
                encode.bytes = varint.encode.bytes
              }
              return buffer
            },
            function decode(buffer, offset) {
              var val = varint.decode(buffer, offset)
              if (val >= Math.pow(2, 63)) {
                var limit = 9
                while (buffer[offset + limit - 1] === 0xff) limit--
                limit = limit || 9
                var subset = Buffer.allocUnsafe(limit)
                buffer.copy(subset, 0, offset, offset + limit)
                subset[limit - 1] = subset[limit - 1] & 0x7f
                val = -1 * varint.decode(subset, 0)
                decode.bytes = 10
              } else {
                decode.bytes = varint.decode.bytes
              }
              return val
            },
            function encodingLength(val) {
              return val < 0 ? 10 : varint.encodingLength(val)
            }
          )

          exports.sint32 = exports.sint64 = encoder(
            0,
            svarint.encode,
            svarint.decode,
            svarint.encodingLength
          )

          exports.uint32 = exports.uint64 = exports.enum = exports.varint = encoder(
            0,
            varint.encode,
            varint.decode,
            varint.encodingLength
          )

          // we cannot represent these in javascript so we just use buffers
          exports.fixed64 = exports.sfixed64 = encoder(
            1,
            function encode(val, buffer, offset) {
              val.copy(buffer, offset)
              encode.bytes = 8
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.slice(offset, offset + 8)
              decode.bytes = 8
              return val
            },
            function encodingLength() {
              return 8
            }
          )

          exports.double = encoder(
            1,
            function encode(val, buffer, offset) {
              buffer.writeDoubleLE(val, offset)
              encode.bytes = 8
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readDoubleLE(offset)
              decode.bytes = 8
              return val
            },
            function encodingLength() {
              return 8
            }
          )

          exports.fixed32 = encoder(
            5,
            function encode(val, buffer, offset) {
              buffer.writeUInt32LE(val, offset)
              encode.bytes = 4
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readUInt32LE(offset)
              decode.bytes = 4
              return val
            },
            function encodingLength() {
              return 4
            }
          )

          exports.sfixed32 = encoder(
            5,
            function encode(val, buffer, offset) {
              buffer.writeInt32LE(val, offset)
              encode.bytes = 4
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readInt32LE(offset)
              decode.bytes = 4
              return val
            },
            function encodingLength() {
              return 4
            }
          )

          exports.float = encoder(
            5,
            function encode(val, buffer, offset) {
              buffer.writeFloatLE(val, offset)
              encode.bytes = 4
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readFloatLE(offset)
              decode.bytes = 4
              return val
            },
            function encodingLength() {
              return 4
            }
          )

          function encoder(type, encode, decode, encodingLength) {
            encode.bytes = decode.bytes = 0

            return {
              type: type,
              encode: encode,
              decode: decode,
              encodingLength: encodingLength
            }
          }

          function bufferLength(val) {
            return Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val)
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "signed-varint": 60, varint: 82 }
    ],
    46: [
      function(require, module, exports) {
        module.exports = function() {
          throw new Error("random-access-file is not supported in the browser")
        }
      },
      {}
    ],
    47: [
      function(require, module, exports) {
        ;(function(process) {
          var events = require("events")
          var inherits = require("inherits")

          var NOT_READABLE = defaultImpl(new Error("Not readable"))
          var NOT_WRITABLE = defaultImpl(new Error("Not writable"))
          var NOT_DELETABLE = defaultImpl(new Error("Not deletable"))
          var NOT_STATABLE = defaultImpl(new Error("Not statable"))
          var NO_OPEN_READABLE = defaultImpl(new Error("No readonly open"))

          module.exports = RandomAccess

          function RandomAccess(opts) {
            if (!(this instanceof RandomAccess)) return new RandomAccess(opts)
            events.EventEmitter.call(this)

            this._queued = []
            this._pending = 0
            this._needsOpen = true

            this.opened = false
            this.closed = false
            this.destroyed = false

            if (opts) {
              if (opts.openReadonly) this._openReadonly = opts.openReadonly
              if (opts.open) this._open = opts.open
              if (opts.read) this._read = opts.read
              if (opts.write) this._write = opts.write
              if (opts.del) this._del = opts.del
              if (opts.stat) this._stat = opts.stat
              if (opts.close) this._close = opts.close
              if (opts.destroy) this._destroy = opts.destroy
            }

            this.preferReadonly = this._openReadonly !== NO_OPEN_READABLE
            this.readable = this._read !== NOT_READABLE
            this.writable = this._write !== NOT_WRITABLE
            this.deletable = this._del !== NOT_DELETABLE
            this.statable = this._stat !== NOT_STATABLE
          }

          inherits(RandomAccess, events.EventEmitter)

          RandomAccess.prototype.open = function(cb) {
            if (!cb) cb = noop
            if (this.opened && !this._needsOpen)
              return process.nextTick(cb, null)
            queueAndRun(this, new Request(this, 0, 0, 0, null, cb))
          }

          RandomAccess.prototype._open = defaultImpl(null)
          RandomAccess.prototype._openReadonly = NO_OPEN_READABLE

          RandomAccess.prototype.read = function(offset, size, cb) {
            this.run(new Request(this, 1, offset, size, null, cb))
          }

          RandomAccess.prototype._read = NOT_READABLE

          RandomAccess.prototype.write = function(offset, data, cb) {
            if (!cb) cb = noop
            openWritable(this)
            this.run(new Request(this, 2, offset, data.length, data, cb))
          }

          RandomAccess.prototype._write = NOT_WRITABLE

          RandomAccess.prototype.del = function(offset, size, cb) {
            if (!cb) cb = noop
            openWritable(this)
            this.run(new Request(this, 3, offset, size, null, cb))
          }

          RandomAccess.prototype._del = NOT_DELETABLE

          RandomAccess.prototype.stat = function(cb) {
            this.run(new Request(this, 4, 0, 0, null, cb))
          }

          RandomAccess.prototype._stat = NOT_STATABLE

          RandomAccess.prototype.close = function(cb) {
            if (!cb) cb = noop
            if (this.closed) return process.nextTick(cb, null)
            queueAndRun(this, new Request(this, 5, 0, 0, null, cb))
          }

          RandomAccess.prototype._close = defaultImpl(null)

          RandomAccess.prototype.destroy = function(cb) {
            if (!cb) cb = noop
            if (!this.closed) this.close(noop)
            queueAndRun(this, new Request(this, 6, 0, 0, null, cb))
          }

          RandomAccess.prototype._destroy = defaultImpl(null)

          RandomAccess.prototype.run = function(req) {
            if (this._needsOpen) this.open(noop)
            if (this._queued.length) this._queued.push(req)
            else req._run()
          }

          function noop() {}

          function Request(self, type, offset, size, data, cb) {
            this.type = type
            this.offset = offset
            this.data = data
            this.size = size
            this.storage = self

            this._sync = false
            this._callback = cb
          }

          Request.prototype._unqueue = function(err) {
            var ra = this.storage
            var queued = ra._queued

            if (!err) {
              switch (this.type) {
                case 0:
                  if (!ra.opened) {
                    ra.opened = true
                    ra.emit("open")
                  }
                  break

                case 5:
                  if (!ra.closed) {
                    ra.closed = true
                    ra.emit("close")
                  }
                  break

                case 6:
                  if (!ra.destroyed) {
                    ra.destroyed = true
                    ra.emit("destroy")
                  }
                  break
              }
            }

            if (queued.length && queued[0] === this) queued.shift()
            if (!--ra._pending && queued.length) queued[0]._run()
          }

          Request.prototype.callback = function(err, val) {
            if (this._sync) return nextTick(this, err, val)
            this._unqueue(err)
            this._callback(err, val)
          }

          Request.prototype._openAndNotClosed = function() {
            var ra = this.storage
            if (ra.opened && !ra.closed) return true
            if (!ra.opened) nextTick(this, new Error("Not opened"))
            else if (ra.closed) nextTick(this, new Error("Closed"))
            return false
          }

          Request.prototype._open = function() {
            var ra = this.storage

            if (ra.opened && !ra._needsOpen) return nextTick(this, null)
            if (ra.closed) return nextTick(this, new Error("Closed"))

            ra._needsOpen = false
            if (ra.preferReadonly) ra._openReadonly(this)
            else ra._open(this)
          }

          Request.prototype._run = function() {
            var ra = this.storage
            ra._pending++

            this._sync = true

            switch (this.type) {
              case 0:
                this._open()
                break

              case 1:
                if (this._openAndNotClosed()) ra._read(this)
                break

              case 2:
                if (this._openAndNotClosed()) ra._write(this)
                break

              case 3:
                if (this._openAndNotClosed()) ra._del(this)
                break

              case 4:
                if (this._openAndNotClosed()) ra._stat(this)
                break

              case 5:
                if (ra.closed || !ra.opened) nextTick(this, null)
                else ra._close(this)
                break

              case 6:
                if (ra.destroyed) nextTick(this, null)
                else ra._destroy(this)
                break
            }

            this._sync = false
          }

          function queueAndRun(self, req) {
            self._queued.push(req)
            if (!self._pending) req._run()
          }

          function openWritable(self) {
            if (self.preferReadonly) {
              self._needsOpen = true
              self.preferReadonly = false
            }
          }

          function defaultImpl(err) {
            return overridable

            function overridable(req) {
              nextTick(req, err)
            }
          }

          function nextTick(req, err, val) {
            process.nextTick(nextTickCallback, req, err, val)
          }

          function nextTickCallback(req, err, val) {
            req.callback(err, val)
          }
        }.call(this, require("_process")))
      },
      { _process: 44, events: 24, inherits: 37 }
    ],
    48: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a duplex stream is just a stream that is both readable and writable.
        // Since JS doesn't have multiple prototypal inheritance, this class
        // prototypally inherits from Readable, and then parasitically from
        // Writable.

        "use strict"

        /*<replacement>*/

        var pna = require("process-nextick-args")
        /*</replacement>*/

        /*<replacement>*/
        var objectKeys =
          Object.keys ||
          function(obj) {
            var keys = []
            for (var key in obj) {
              keys.push(key)
            }
            return keys
          }
        /*</replacement>*/

        module.exports = Duplex

        /*<replacement>*/
        var util = require("core-util-is")
        util.inherits = require("inherits")
        /*</replacement>*/

        var Readable = require("./_stream_readable")
        var Writable = require("./_stream_writable")

        util.inherits(Duplex, Readable)

        {
          // avoid scope creep, the keys array can then be collected
          var keys = objectKeys(Writable.prototype)
          for (var v = 0; v < keys.length; v++) {
            var method = keys[v]
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method]
          }
        }

        function Duplex(options) {
          if (!(this instanceof Duplex)) return new Duplex(options)

          Readable.call(this, options)
          Writable.call(this, options)

          if (options && options.readable === false) this.readable = false

          if (options && options.writable === false) this.writable = false

          this.allowHalfOpen = true
          if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false

          this.once("end", onend)
        }

        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function() {
            return this._writableState.highWaterMark
          }
        })

        // the no-half-open enforcer
        function onend() {
          // if we allow half-open state, or if the writable side ended,
          // then we're ok.
          if (this.allowHalfOpen || this._writableState.ended) return

          // no more data can be written.
          // But allow more writes to happen in this tick.
          pna.nextTick(onEndNT, this)
        }

        function onEndNT(self) {
          self.end()
        }

        Object.defineProperty(Duplex.prototype, "destroyed", {
          get: function() {
            if (
              this._readableState === undefined ||
              this._writableState === undefined
            ) {
              return false
            }
            return (
              this._readableState.destroyed && this._writableState.destroyed
            )
          },
          set: function(value) {
            // we ignore the value if the stream
            // has not been initialized yet
            if (
              this._readableState === undefined ||
              this._writableState === undefined
            ) {
              return
            }

            // backward compatibility, the user is explicitly
            // managing destroyed
            this._readableState.destroyed = value
            this._writableState.destroyed = value
          }
        })

        Duplex.prototype._destroy = function(err, cb) {
          this.push(null)
          this.end()

          pna.nextTick(cb, err)
        }
      },
      {
        "./_stream_readable": 50,
        "./_stream_writable": 52,
        "core-util-is": 23,
        inherits: 37,
        "process-nextick-args": 57
      }
    ],
    49: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a passthrough stream.
        // basically just the most minimal sort of Transform stream.
        // Every written chunk gets output as-is.

        "use strict"

        module.exports = PassThrough

        var Transform = require("./_stream_transform")

        /*<replacement>*/
        var util = require("core-util-is")
        util.inherits = require("inherits")
        /*</replacement>*/

        util.inherits(PassThrough, Transform)

        function PassThrough(options) {
          if (!(this instanceof PassThrough)) return new PassThrough(options)

          Transform.call(this, options)
        }

        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk)
        }
      },
      { "./_stream_transform": 51, "core-util-is": 23, inherits: 37 }
    ],
    50: [
      function(require, module, exports) {
        ;(function(process, global) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          "use strict"

          /*<replacement>*/

          var pna = require("process-nextick-args")
          /*</replacement>*/

          module.exports = Readable

          /*<replacement>*/
          var isArray = require("isarray")
          /*</replacement>*/

          /*<replacement>*/
          var Duplex
          /*</replacement>*/

          Readable.ReadableState = ReadableState

          /*<replacement>*/
          var EE = require("events").EventEmitter

          var EElistenerCount = function(emitter, type) {
            return emitter.listeners(type).length
          }
          /*</replacement>*/

          /*<replacement>*/
          var Stream = require("./internal/streams/stream")
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = require("safe-buffer").Buffer
          var OurUint8Array = global.Uint8Array || function() {}
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk)
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
          }

          /*</replacement>*/

          /*<replacement>*/
          var util = require("core-util-is")
          util.inherits = require("inherits")
          /*</replacement>*/

          /*<replacement>*/
          var debugUtil = require("util")
          var debug = void 0
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream")
          } else {
            debug = function() {}
          }
          /*</replacement>*/

          var BufferList = require("./internal/streams/BufferList")
          var destroyImpl = require("./internal/streams/destroy")
          var StringDecoder

          util.inherits(Readable, Stream)

          var kProxyEvents = ["error", "close", "destroy", "pause", "resume"]

          function prependListener(emitter, event, fn) {
            // Sadly this is not cacheable as some libraries bundle their own
            // event emitter implementation with them.
            if (typeof emitter.prependListener === "function")
              return emitter.prependListener(event, fn)

            // This is a hack to make sure that our error handler is attached before any
            // userland ones.  NEVER DO THIS. This is here only because this code needs
            // to continue to work with older versions of Node.js that do not include
            // the prependListener() method. The goal is to eventually remove this hack.
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn)
            else if (isArray(emitter._events[event]))
              emitter._events[event].unshift(fn)
            else emitter._events[event] = [fn, emitter._events[event]]
          }

          function ReadableState(options, stream) {
            Duplex = Duplex || require("./_stream_duplex")

            options = options || {}

            // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.
            var isDuplex = stream instanceof Duplex

            // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away
            this.objectMode = !!options.objectMode

            if (isDuplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode

            // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"
            var hwm = options.highWaterMark
            var readableHwm = options.readableHighWaterMark
            var defaultHwm = this.objectMode ? 16 : 16 * 1024

            if (hwm || hwm === 0) this.highWaterMark = hwm
            else if (isDuplex && (readableHwm || readableHwm === 0))
              this.highWaterMark = readableHwm
            else this.highWaterMark = defaultHwm

            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark)

            // A linked list is used to store data chunks instead of an array because the
            // linked list can remove elements from the beginning faster than
            // array.shift()
            this.buffer = new BufferList()
            this.length = 0
            this.pipes = null
            this.pipesCount = 0
            this.flowing = null
            this.ended = false
            this.endEmitted = false
            this.reading = false

            // a flag to be able to tell if the event 'readable'/'data' is emitted
            // immediately, or on a later tick.  We set this to true at first, because
            // any actions that shouldn't happen until "later" should generally also
            // not happen before the first read call.
            this.sync = true

            // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.
            this.needReadable = false
            this.emittedReadable = false
            this.readableListening = false
            this.resumeScheduled = false

            // has it been destroyed
            this.destroyed = false

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || "utf8"

            // the number of writers that are awaiting a drain event in .pipe()s
            this.awaitDrain = 0

            // if true, a maybeReadMore has been scheduled
            this.readingMore = false

            this.decoder = null
            this.encoding = null
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require("string_decoder/").StringDecoder
              this.decoder = new StringDecoder(options.encoding)
              this.encoding = options.encoding
            }
          }

          function Readable(options) {
            Duplex = Duplex || require("./_stream_duplex")

            if (!(this instanceof Readable)) return new Readable(options)

            this._readableState = new ReadableState(options, this)

            // legacy
            this.readable = true

            if (options) {
              if (typeof options.read === "function") this._read = options.read

              if (typeof options.destroy === "function")
                this._destroy = options.destroy
            }

            Stream.call(this)
          }

          Object.defineProperty(Readable.prototype, "destroyed", {
            get: function() {
              if (this._readableState === undefined) {
                return false
              }
              return this._readableState.destroyed
            },
            set: function(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._readableState) {
                return
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._readableState.destroyed = value
            }
          })

          Readable.prototype.destroy = destroyImpl.destroy
          Readable.prototype._undestroy = destroyImpl.undestroy
          Readable.prototype._destroy = function(err, cb) {
            this.push(null)
            cb(err)
          }

          // Manually shove something into the read() buffer.
          // This returns true if the highWaterMark has not been hit yet,
          // similar to how Writable.write() returns true if you should
          // write() some more.
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState
            var skipChunkCheck

            if (!state.objectMode) {
              if (typeof chunk === "string") {
                encoding = encoding || state.defaultEncoding
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding)
                  encoding = ""
                }
                skipChunkCheck = true
              }
            } else {
              skipChunkCheck = true
            }

            return readableAddChunk(
              this,
              chunk,
              encoding,
              false,
              skipChunkCheck
            )
          }

          // Unshift should *always* be something directly out of read()
          Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false)
          }

          function readableAddChunk(
            stream,
            chunk,
            encoding,
            addToFront,
            skipChunkCheck
          ) {
            var state = stream._readableState
            if (chunk === null) {
              state.reading = false
              onEofChunk(stream, state)
            } else {
              var er
              if (!skipChunkCheck) er = chunkInvalid(state, chunk)
              if (er) {
                stream.emit("error", er)
              } else if (state.objectMode || (chunk && chunk.length > 0)) {
                if (
                  typeof chunk !== "string" &&
                  !state.objectMode &&
                  Object.getPrototypeOf(chunk) !== Buffer.prototype
                ) {
                  chunk = _uint8ArrayToBuffer(chunk)
                }

                if (addToFront) {
                  if (state.endEmitted)
                    stream.emit(
                      "error",
                      new Error("stream.unshift() after end event")
                    )
                  else addChunk(stream, state, chunk, true)
                } else if (state.ended) {
                  stream.emit("error", new Error("stream.push() after EOF"))
                } else {
                  state.reading = false
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk)
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false)
                    else maybeReadMore(stream, state)
                  } else {
                    addChunk(stream, state, chunk, false)
                  }
                }
              } else if (!addToFront) {
                state.reading = false
              }
            }

            return needMoreData(state)
          }

          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit("data", chunk)
              stream.read(0)
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length
              if (addToFront) state.buffer.unshift(chunk)
              else state.buffer.push(chunk)

              if (state.needReadable) emitReadable(stream)
            }
            maybeReadMore(stream, state)
          }

          function chunkInvalid(state, chunk) {
            var er
            if (
              !_isUint8Array(chunk) &&
              typeof chunk !== "string" &&
              chunk !== undefined &&
              !state.objectMode
            ) {
              er = new TypeError("Invalid non-string/buffer chunk")
            }
            return er
          }

          // if it's past the high water mark, we can push in some more.
          // Also, if we have no data yet, we can stand some
          // more bytes.  This is to work around cases where hwm=0,
          // such as the repl.  Also, if the push() triggered a
          // readable event, and the user called read(largeNumber) such that
          // needReadable was set, then we ought to push more, so that another
          // 'readable' event will be triggered.
          function needMoreData(state) {
            return (
              !state.ended &&
              (state.needReadable ||
                state.length < state.highWaterMark ||
                state.length === 0)
            )
          }

          Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false
          }

          // backwards compatibility.
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require("string_decoder/").StringDecoder
            this._readableState.decoder = new StringDecoder(enc)
            this._readableState.encoding = enc
            return this
          }

          // Don't raise the hwm > 8MB
          var MAX_HWM = 0x800000
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM
            } else {
              // Get the next highest power of 2 to prevent increasing hwm excessively in
              // tiny amounts
              n--
              n |= n >>> 1
              n |= n >>> 2
              n |= n >>> 4
              n |= n >>> 8
              n |= n >>> 16
              n++
            }
            return n
          }

          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function howMuchToRead(n, state) {
            if (n <= 0 || (state.length === 0 && state.ended)) return 0
            if (state.objectMode) return 1
            if (n !== n) {
              // Only flow one buffer at a time
              if (state.flowing && state.length)
                return state.buffer.head.data.length
              else return state.length
            }
            // If we're asking for more than the current hwm, then raise the hwm.
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n)
            if (n <= state.length) return n
            // Don't have enough
            if (!state.ended) {
              state.needReadable = true
              return 0
            }
            return state.length
          }

          // you can override either this method, or the async _read(n) below.
          Readable.prototype.read = function(n) {
            debug("read", n)
            n = parseInt(n, 10)
            var state = this._readableState
            var nOrig = n

            if (n !== 0) state.emittedReadable = false

            // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.
            if (
              n === 0 &&
              state.needReadable &&
              (state.length >= state.highWaterMark || state.ended)
            ) {
              debug("read: emitReadable", state.length, state.ended)
              if (state.length === 0 && state.ended) endReadable(this)
              else emitReadable(this)
              return null
            }

            n = howMuchToRead(n, state)

            // if we've ended, and we're now clear, then finish it up.
            if (n === 0 && state.ended) {
              if (state.length === 0) endReadable(this)
              return null
            }

            // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.

            // if we need a readable event, then we need to do some reading.
            var doRead = state.needReadable
            debug("need readable", doRead)

            // if we currently have less than the highWaterMark, then also read some
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true
              debug("length less than watermark", doRead)
            }

            // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.
            if (state.ended || state.reading) {
              doRead = false
              debug("reading or ended", doRead)
            } else if (doRead) {
              debug("do read")
              state.reading = true
              state.sync = true
              // if the length is currently zero, then we *need* a readable event.
              if (state.length === 0) state.needReadable = true
              // call internal read method
              this._read(state.highWaterMark)
              state.sync = false
              // If _read pushed data synchronously, then `reading` will be false,
              // and we need to re-evaluate how much data we can return to the user.
              if (!state.reading) n = howMuchToRead(nOrig, state)
            }

            var ret
            if (n > 0) ret = fromList(n, state)
            else ret = null

            if (ret === null) {
              state.needReadable = true
              n = 0
            } else {
              state.length -= n
            }

            if (state.length === 0) {
              // If we have nothing in the buffer, then we want to know
              // as soon as we *do* get something into the buffer.
              if (!state.ended) state.needReadable = true

              // If we tried to read() past the EOF, then emit end on the next tick.
              if (nOrig !== n && state.ended) endReadable(this)
            }

            if (ret !== null) this.emit("data", ret)

            return ret
          }

          function onEofChunk(stream, state) {
            if (state.ended) return
            if (state.decoder) {
              var chunk = state.decoder.end()
              if (chunk && chunk.length) {
                state.buffer.push(chunk)
                state.length += state.objectMode ? 1 : chunk.length
              }
            }
            state.ended = true

            // emit 'readable' now to make sure it gets picked up.
            emitReadable(stream)
          }

          // Don't emit readable right away in sync mode, because this can trigger
          // another read() call => stack overflow.  This way, it might trigger
          // a nextTick recursion warning, but that's not so bad.
          function emitReadable(stream) {
            var state = stream._readableState
            state.needReadable = false
            if (!state.emittedReadable) {
              debug("emitReadable", state.flowing)
              state.emittedReadable = true
              if (state.sync) pna.nextTick(emitReadable_, stream)
              else emitReadable_(stream)
            }
          }

          function emitReadable_(stream) {
            debug("emit readable")
            stream.emit("readable")
            flow(stream)
          }

          // at this point, the user has presumably seen the 'readable' event,
          // and called read() to consume some data.  that may have triggered
          // in turn another _read(n) call, in which case reading = true if
          // it's in progress.
          // However, if we're not ended, or reading, and the length < hwm,
          // then go ahead and try to read some more preemptively.
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true
              pna.nextTick(maybeReadMore_, stream, state)
            }
          }

          function maybeReadMore_(stream, state) {
            var len = state.length
            while (
              !state.reading &&
              !state.flowing &&
              !state.ended &&
              state.length < state.highWaterMark
            ) {
              debug("maybeReadMore read 0")
              stream.read(0)
              if (len === state.length)
                // didn't get any data, stop spinning.
                break
              else len = state.length
            }
            state.readingMore = false
          }

          // abstract method.  to be overridden in specific implementation classes.
          // call cb(er, data) where data is <= n in length.
          // for virtual (non-string, non-buffer) streams, "length" is somewhat
          // arbitrary, and perhaps not very meaningful.
          Readable.prototype._read = function(n) {
            this.emit("error", new Error("_read() is not implemented"))
          }

          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this
            var state = this._readableState

            switch (state.pipesCount) {
              case 0:
                state.pipes = dest
                break
              case 1:
                state.pipes = [state.pipes, dest]
                break
              default:
                state.pipes.push(dest)
                break
            }
            state.pipesCount += 1
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts)

            var doEnd =
              (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr

            var endFn = doEnd ? onend : unpipe
            if (state.endEmitted) pna.nextTick(endFn)
            else src.once("end", endFn)

            dest.on("unpipe", onunpipe)
            function onunpipe(readable, unpipeInfo) {
              debug("onunpipe")
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true
                  cleanup()
                }
              }
            }

            function onend() {
              debug("onend")
              dest.end()
            }

            // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            var ondrain = pipeOnDrain(src)
            dest.on("drain", ondrain)

            var cleanedUp = false
            function cleanup() {
              debug("cleanup")
              // cleanup event handlers once the pipe is broken
              dest.removeListener("close", onclose)
              dest.removeListener("finish", onfinish)
              dest.removeListener("drain", ondrain)
              dest.removeListener("error", onerror)
              dest.removeListener("unpipe", onunpipe)
              src.removeListener("end", onend)
              src.removeListener("end", unpipe)
              src.removeListener("data", ondata)

              cleanedUp = true

              // if the reader is waiting for a drain event from this
              // specific writer, then it would cause it to never start
              // flowing again.
              // So, if this is awaiting a drain, then we just call it now.
              // If we don't know, then assume that we are waiting for one.
              if (
                state.awaitDrain &&
                (!dest._writableState || dest._writableState.needDrain)
              )
                ondrain()
            }

            // If the user pushes more data while we're writing to dest then we'll end up
            // in ondata again. However, we only want to increase awaitDrain once because
            // dest will only emit one 'drain' event for the multiple writes.
            // => Introduce a guard on increasing awaitDrain.
            var increasedAwaitDrain = false
            src.on("data", ondata)
            function ondata(chunk) {
              debug("ondata")
              increasedAwaitDrain = false
              var ret = dest.write(chunk)
              if (false === ret && !increasedAwaitDrain) {
                // If the user unpiped during `dest.write()`, it is possible
                // to get stuck in a permanently paused state if that write
                // also returned false.
                // => Check whether `dest` is still a piping destination.
                if (
                  ((state.pipesCount === 1 && state.pipes === dest) ||
                    (state.pipesCount > 1 &&
                      indexOf(state.pipes, dest) !== -1)) &&
                  !cleanedUp
                ) {
                  debug(
                    "false write response, pause",
                    src._readableState.awaitDrain
                  )
                  src._readableState.awaitDrain++
                  increasedAwaitDrain = true
                }
                src.pause()
              }
            }

            // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.
            function onerror(er) {
              debug("onerror", er)
              unpipe()
              dest.removeListener("error", onerror)
              if (EElistenerCount(dest, "error") === 0) dest.emit("error", er)
            }

            // Make sure our error handler is attached before userland ones.
            prependListener(dest, "error", onerror)

            // Both close and finish should trigger unpipe, but only once.
            function onclose() {
              dest.removeListener("finish", onfinish)
              unpipe()
            }
            dest.once("close", onclose)
            function onfinish() {
              debug("onfinish")
              dest.removeListener("close", onclose)
              unpipe()
            }
            dest.once("finish", onfinish)

            function unpipe() {
              debug("unpipe")
              src.unpipe(dest)
            }

            // tell the dest that it's being piped to
            dest.emit("pipe", src)

            // start the flow if it hasn't been started already.
            if (!state.flowing) {
              debug("pipe resume")
              src.resume()
            }

            return dest
          }

          function pipeOnDrain(src) {
            return function() {
              var state = src._readableState
              debug("pipeOnDrain", state.awaitDrain)
              if (state.awaitDrain) state.awaitDrain--
              if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                state.flowing = true
                flow(src)
              }
            }
          }

          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState
            var unpipeInfo = { hasUnpiped: false }

            // if we're not piping anywhere, then do nothing.
            if (state.pipesCount === 0) return this

            // just one destination.  most common case.
            if (state.pipesCount === 1) {
              // passed in one, but it's not the right one.
              if (dest && dest !== state.pipes) return this

              if (!dest) dest = state.pipes

              // got a match.
              state.pipes = null
              state.pipesCount = 0
              state.flowing = false
              if (dest) dest.emit("unpipe", this, unpipeInfo)
              return this
            }

            // slow case. multiple pipe destinations.

            if (!dest) {
              // remove all.
              var dests = state.pipes
              var len = state.pipesCount
              state.pipes = null
              state.pipesCount = 0
              state.flowing = false

              for (var i = 0; i < len; i++) {
                dests[i].emit("unpipe", this, unpipeInfo)
              }
              return this
            }

            // try to find the right one.
            var index = indexOf(state.pipes, dest)
            if (index === -1) return this

            state.pipes.splice(index, 1)
            state.pipesCount -= 1
            if (state.pipesCount === 1) state.pipes = state.pipes[0]

            dest.emit("unpipe", this, unpipeInfo)

            return this
          }

          // set up data events if they are asked for
          // Ensure readable listeners eventually get something
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn)

            if (ev === "data") {
              // Start flowing on next tick if stream isn't explicitly paused
              if (this._readableState.flowing !== false) this.resume()
            } else if (ev === "readable") {
              var state = this._readableState
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true
                state.emittedReadable = false
                if (!state.reading) {
                  pna.nextTick(nReadingNextTick, this)
                } else if (state.length) {
                  emitReadable(this)
                }
              }
            }

            return res
          }
          Readable.prototype.addListener = Readable.prototype.on

          function nReadingNextTick(self) {
            debug("readable nexttick read 0")
            self.read(0)
          }

          // pause() and resume() are remnants of the legacy readable stream API
          // If the user uses them, then switch into old mode.
          Readable.prototype.resume = function() {
            var state = this._readableState
            if (!state.flowing) {
              debug("resume")
              state.flowing = true
              resume(this, state)
            }
            return this
          }

          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true
              pna.nextTick(resume_, stream, state)
            }
          }

          function resume_(stream, state) {
            if (!state.reading) {
              debug("resume read 0")
              stream.read(0)
            }

            state.resumeScheduled = false
            state.awaitDrain = 0
            stream.emit("resume")
            flow(stream)
            if (state.flowing && !state.reading) stream.read(0)
          }

          Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing)
            if (false !== this._readableState.flowing) {
              debug("pause")
              this._readableState.flowing = false
              this.emit("pause")
            }
            return this
          }

          function flow(stream) {
            var state = stream._readableState
            debug("flow", state.flowing)
            while (state.flowing && stream.read() !== null) {}
          }

          // wrap an old-style stream as the async data source.
          // This is *not* part of the readable stream interface.
          // It is an ugly unfortunate mess of history.
          Readable.prototype.wrap = function(stream) {
            var _this = this

            var state = this._readableState
            var paused = false

            stream.on("end", function() {
              debug("wrapped end")
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end()
                if (chunk && chunk.length) _this.push(chunk)
              }

              _this.push(null)
            })

            stream.on("data", function(chunk) {
              debug("wrapped data")
              if (state.decoder) chunk = state.decoder.write(chunk)

              // don't skip over falsy values in objectMode
              if (state.objectMode && (chunk === null || chunk === undefined))
                return
              else if (!state.objectMode && (!chunk || !chunk.length)) return

              var ret = _this.push(chunk)
              if (!ret) {
                paused = true
                stream.pause()
              }
            })

            // proxy all the other methods.
            // important when wrapping filters and duplexes.
            for (var i in stream) {
              if (this[i] === undefined && typeof stream[i] === "function") {
                this[i] = (function(method) {
                  return function() {
                    return stream[method].apply(stream, arguments)
                  }
                })(i)
              }
            }

            // proxy certain important events.
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]))
            }

            // when we try to consume some more bytes, simply unpause the
            // underlying stream.
            this._read = function(n) {
              debug("wrapped _read", n)
              if (paused) {
                paused = false
                stream.resume()
              }
            }

            return this
          }

          Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function() {
              return this._readableState.highWaterMark
            }
          })

          // exposed for testing purposes only.
          Readable._fromList = fromList

          // Pluck off n bytes from an array of buffers.
          // Length is the combined lengths of all the buffers in the list.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromList(n, state) {
            // nothing buffered
            if (state.length === 0) return null

            var ret
            if (state.objectMode) ret = state.buffer.shift()
            else if (!n || n >= state.length) {
              // read it all, truncate the list
              if (state.decoder) ret = state.buffer.join("")
              else if (state.buffer.length === 1) ret = state.buffer.head.data
              else ret = state.buffer.concat(state.length)
              state.buffer.clear()
            } else {
              // read part of list
              ret = fromListPartial(n, state.buffer, state.decoder)
            }

            return ret
          }

          // Extracts only enough buffered data to satisfy the amount requested.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromListPartial(n, list, hasStrings) {
            var ret
            if (n < list.head.data.length) {
              // slice is the same for buffers and strings
              ret = list.head.data.slice(0, n)
              list.head.data = list.head.data.slice(n)
            } else if (n === list.head.data.length) {
              // first chunk is a perfect match
              ret = list.shift()
            } else {
              // result spans more than one buffer
              ret = hasStrings
                ? copyFromBufferString(n, list)
                : copyFromBuffer(n, list)
            }
            return ret
          }

          // Copies a specified amount of characters from the list of buffered data
          // chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBufferString(n, list) {
            var p = list.head
            var c = 1
            var ret = p.data
            n -= ret.length
            while ((p = p.next)) {
              var str = p.data
              var nb = n > str.length ? str.length : n
              if (nb === str.length) ret += str
              else ret += str.slice(0, n)
              n -= nb
              if (n === 0) {
                if (nb === str.length) {
                  ++c
                  if (p.next) list.head = p.next
                  else list.head = list.tail = null
                } else {
                  list.head = p
                  p.data = str.slice(nb)
                }
                break
              }
              ++c
            }
            list.length -= c
            return ret
          }

          // Copies a specified amount of bytes from the list of buffered data chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n)
            var p = list.head
            var c = 1
            p.data.copy(ret)
            n -= p.data.length
            while ((p = p.next)) {
              var buf = p.data
              var nb = n > buf.length ? buf.length : n
              buf.copy(ret, ret.length - n, 0, nb)
              n -= nb
              if (n === 0) {
                if (nb === buf.length) {
                  ++c
                  if (p.next) list.head = p.next
                  else list.head = list.tail = null
                } else {
                  list.head = p
                  p.data = buf.slice(nb)
                }
                break
              }
              ++c
            }
            list.length -= c
            return ret
          }

          function endReadable(stream) {
            var state = stream._readableState

            // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.
            if (state.length > 0)
              throw new Error('"endReadable()" called on non-empty stream')

            if (!state.endEmitted) {
              state.ended = true
              pna.nextTick(endReadableNT, state, stream)
            }
          }

          function endReadableNT(state, stream) {
            // Check that we didn't get one last unshift.
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true
              stream.readable = false
              stream.emit("end")
            }
          }

          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x) return i
            }
            return -1
          }
        }.call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {}
        ))
      },
      {
        "./_stream_duplex": 48,
        "./internal/streams/BufferList": 53,
        "./internal/streams/destroy": 54,
        "./internal/streams/stream": 55,
        _process: 44,
        "core-util-is": 23,
        events: 24,
        inherits: 37,
        isarray: 56,
        "process-nextick-args": 57,
        "safe-buffer": 59,
        "string_decoder/": 73,
        util: 14
      }
    ],
    51: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a transform stream is a readable/writable stream where you do
        // something with the data.  Sometimes it's called a "filter",
        // but that's not a great name for it, since that implies a thing where
        // some bits pass through, and others are simply ignored.  (That would
        // be a valid example of a transform, of course.)
        //
        // While the output is causally related to the input, it's not a
        // necessarily symmetric or synchronous transformation.  For example,
        // a zlib stream might take multiple plain-text writes(), and then
        // emit a single compressed chunk some time in the future.
        //
        // Here's how this works:
        //
        // The Transform stream has all the aspects of the readable and writable
        // stream classes.  When you write(chunk), that calls _write(chunk,cb)
        // internally, and returns false if there's a lot of pending writes
        // buffered up.  When you call read(), that calls _read(n) until
        // there's enough pending readable data buffered up.
        //
        // In a transform stream, the written data is placed in a buffer.  When
        // _read(n) is called, it transforms the queued up data, calling the
        // buffered _write cb's as it consumes chunks.  If consuming a single
        // written chunk would result in multiple output chunks, then the first
        // outputted bit calls the readcb, and subsequent chunks just go into
        // the read buffer, and will cause it to emit 'readable' if necessary.
        //
        // This way, back-pressure is actually determined by the reading side,
        // since _read has to be called to start processing a new chunk.  However,
        // a pathological inflate type of transform can cause excessive buffering
        // here.  For example, imagine a stream where every byte of input is
        // interpreted as an integer from 0-255, and then results in that many
        // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
        // 1kb of data being output.  In this case, you could write a very small
        // amount of input, and end up with a very large amount of output.  In
        // such a pathological inflating mechanism, there'd be no way to tell
        // the system to stop doing the transform.  A single 4MB write could
        // cause the system to run out of memory.
        //
        // However, even in such a pathological case, only a single written chunk
        // would be consumed, and then the rest would wait (un-transformed) until
        // the results of the previous transformed chunk were consumed.

        "use strict"

        module.exports = Transform

        var Duplex = require("./_stream_duplex")

        /*<replacement>*/
        var util = require("core-util-is")
        util.inherits = require("inherits")
        /*</replacement>*/

        util.inherits(Transform, Duplex)

        function afterTransform(er, data) {
          var ts = this._transformState
          ts.transforming = false

          var cb = ts.writecb

          if (!cb) {
            return this.emit(
              "error",
              new Error("write callback called multiple times")
            )
          }

          ts.writechunk = null
          ts.writecb = null

          if (data != null)
            // single equals check for both `null` and `undefined`
            this.push(data)

          cb(er)

          var rs = this._readableState
          rs.reading = false
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark)
          }
        }

        function Transform(options) {
          if (!(this instanceof Transform)) return new Transform(options)

          Duplex.call(this, options)

          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }

          // start out asking for a readable event once data is transformed.
          this._readableState.needReadable = true

          // we have implemented the _read method, and done the other things
          // that Readable wants before the first _read call, so unset the
          // sync guard flag.
          this._readableState.sync = false

          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform

            if (typeof options.flush === "function") this._flush = options.flush
          }

          // When the writable side finishes, then flush out anything remaining.
          this.on("prefinish", prefinish)
        }

        function prefinish() {
          var _this = this

          if (typeof this._flush === "function") {
            this._flush(function(er, data) {
              done(_this, er, data)
            })
          } else {
            done(this, null, null)
          }
        }

        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false
          return Duplex.prototype.push.call(this, chunk, encoding)
        }

        // This is the part where you do stuff!
        // override this function in implementation classes.
        // 'chunk' is an input chunk.
        //
        // Call `push(newChunk)` to pass along transformed output
        // to the readable side.  You may call 'push' zero or more times.
        //
        // Call `cb(err)` when you are done with this chunk.  If you pass
        // an error, then that'll put the hurt on the whole operation.  If you
        // never call cb(), then you'll never get another chunk.
        Transform.prototype._transform = function(chunk, encoding, cb) {
          throw new Error("_transform() is not implemented")
        }

        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState
          ts.writecb = cb
          ts.writechunk = chunk
          ts.writeencoding = encoding
          if (!ts.transforming) {
            var rs = this._readableState
            if (
              ts.needTransform ||
              rs.needReadable ||
              rs.length < rs.highWaterMark
            )
              this._read(rs.highWaterMark)
          }
        }

        // Doesn't matter what the args are here.
        // _transform does all the work.
        // That we got here means that the readable side wants more data.
        Transform.prototype._read = function(n) {
          var ts = this._transformState

          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)
          } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that we've asked for it.
            ts.needTransform = true
          }
        }

        Transform.prototype._destroy = function(err, cb) {
          var _this2 = this

          Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2)
            _this2.emit("close")
          })
        }

        function done(stream, er, data) {
          if (er) return stream.emit("error", er)

          if (data != null)
            // single equals check for both `null` and `undefined`
            stream.push(data)

          // if there's nothing in the write buffer, then that means
          // that nothing more will ever be provided
          if (stream._writableState.length)
            throw new Error("Calling transform done when ws.length != 0")

          if (stream._transformState.transforming)
            throw new Error("Calling transform done when still transforming")

          return stream.push(null)
        }
      },
      { "./_stream_duplex": 48, "core-util-is": 23, inherits: 37 }
    ],
    52: [
      function(require, module, exports) {
        ;(function(process, global, setImmediate) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // A bit simpler than readable streams.
          // Implement an async ._write(chunk, encoding, cb), and it'll handle all
          // the drain event emission and buffering.

          "use strict"

          /*<replacement>*/

          var pna = require("process-nextick-args")
          /*</replacement>*/

          module.exports = Writable

          /* <replacement> */
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk
            this.encoding = encoding
            this.callback = cb
            this.next = null
          }

          // It seems a linked list but it is not
          // there will be only 2 of these for each stream
          function CorkedRequest(state) {
            var _this = this

            this.next = null
            this.entry = null
            this.finish = function() {
              onCorkedFinish(_this, state)
            }
          }
          /* </replacement> */

          /*<replacement>*/
          var asyncWrite =
            !process.browser &&
            ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1
              ? setImmediate
              : pna.nextTick
          /*</replacement>*/

          /*<replacement>*/
          var Duplex
          /*</replacement>*/

          Writable.WritableState = WritableState

          /*<replacement>*/
          var util = require("core-util-is")
          util.inherits = require("inherits")
          /*</replacement>*/

          /*<replacement>*/
          var internalUtil = {
            deprecate: require("util-deprecate")
          }
          /*</replacement>*/

          /*<replacement>*/
          var Stream = require("./internal/streams/stream")
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = require("safe-buffer").Buffer
          var OurUint8Array = global.Uint8Array || function() {}
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk)
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
          }

          /*</replacement>*/

          var destroyImpl = require("./internal/streams/destroy")

          util.inherits(Writable, Stream)

          function nop() {}

          function WritableState(options, stream) {
            Duplex = Duplex || require("./_stream_duplex")

            options = options || {}

            // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.
            var isDuplex = stream instanceof Duplex

            // object stream flag to indicate whether or not this stream
            // contains buffers or objects.
            this.objectMode = !!options.objectMode

            if (isDuplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode

            // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()
            var hwm = options.highWaterMark
            var writableHwm = options.writableHighWaterMark
            var defaultHwm = this.objectMode ? 16 : 16 * 1024

            if (hwm || hwm === 0) this.highWaterMark = hwm
            else if (isDuplex && (writableHwm || writableHwm === 0))
              this.highWaterMark = writableHwm
            else this.highWaterMark = defaultHwm

            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark)

            // if _final has been called
            this.finalCalled = false

            // drain event flag.
            this.needDrain = false
            // at the start of calling end()
            this.ending = false
            // when end() has been called, and returned
            this.ended = false
            // when 'finish' is emitted
            this.finished = false

            // has it been destroyed
            this.destroyed = false

            // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.
            var noDecode = options.decodeStrings === false
            this.decodeStrings = !noDecode

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || "utf8"

            // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.
            this.length = 0

            // a flag to see when we're in the middle of a write.
            this.writing = false

            // when true all writes will be buffered until .uncork() call
            this.corked = 0

            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true

            // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.
            this.bufferProcessing = false

            // the callback that's passed to _write(chunk,cb)
            this.onwrite = function(er) {
              onwrite(stream, er)
            }

            // the callback that the user supplies to write(chunk,encoding,cb)
            this.writecb = null

            // the amount that is being written when _write is called.
            this.writelen = 0

            this.bufferedRequest = null
            this.lastBufferedRequest = null

            // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted
            this.pendingcb = 0

            // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams
            this.prefinished = false

            // True if the error was already emitted and should not be thrown again
            this.errorEmitted = false

            // count buffered requests
            this.bufferedRequestCount = 0

            // allocate the first CorkedRequest, there is always
            // one allocated and free to use, and we maintain at most two
            this.corkedRequestsFree = new CorkedRequest(this)
          }

          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest
            var out = []
            while (current) {
              out.push(current)
              current = current.next
            }
            return out
          }

          ;(function() {
            try {
              Object.defineProperty(WritableState.prototype, "buffer", {
                get: internalUtil.deprecate(
                  function() {
                    return this.getBuffer()
                  },
                  "_writableState.buffer is deprecated. Use _writableState.getBuffer " +
                    "instead.",
                  "DEP0003"
                )
              })
            } catch (_) {}
          })()

          // Test _writableState for inheritance to account for Duplex streams,
          // whose prototype chain only points to Readable.
          var realHasInstance
          if (
            typeof Symbol === "function" &&
            Symbol.hasInstance &&
            typeof Function.prototype[Symbol.hasInstance] === "function"
          ) {
            realHasInstance = Function.prototype[Symbol.hasInstance]
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function(object) {
                if (realHasInstance.call(this, object)) return true
                if (this !== Writable) return false

                return object && object._writableState instanceof WritableState
              }
            })
          } else {
            realHasInstance = function(object) {
              return object instanceof this
            }
          }

          function Writable(options) {
            Duplex = Duplex || require("./_stream_duplex")

            // Writable ctor is applied to Duplexes, too.
            // `realHasInstance` is necessary because using plain `instanceof`
            // would return false, as no `_writableState` property is attached.

            // Trying to use the custom `instanceof` for Writable here will also break the
            // Node.js LazyTransform implementation, which has a non-trivial getter for
            // `_writableState` that would lead to infinite recursion.
            if (
              !realHasInstance.call(Writable, this) &&
              !(this instanceof Duplex)
            ) {
              return new Writable(options)
            }

            this._writableState = new WritableState(options, this)

            // legacy.
            this.writable = true

            if (options) {
              if (typeof options.write === "function")
                this._write = options.write

              if (typeof options.writev === "function")
                this._writev = options.writev

              if (typeof options.destroy === "function")
                this._destroy = options.destroy

              if (typeof options.final === "function")
                this._final = options.final
            }

            Stream.call(this)
          }

          // Otherwise people can pipe Writable streams, which is just wrong.
          Writable.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"))
          }

          function writeAfterEnd(stream, cb) {
            var er = new Error("write after end")
            // TODO: defer error events consistently everywhere, not just the cb
            stream.emit("error", er)
            pna.nextTick(cb, er)
          }

          // Checks that a user-supplied chunk is valid, especially for the particular
          // mode the stream is in. Currently this means that `null` is never accepted
          // and undefined/non-string values are only allowed in object mode.
          function validChunk(stream, state, chunk, cb) {
            var valid = true
            var er = false

            if (chunk === null) {
              er = new TypeError("May not write null values to stream")
            } else if (
              typeof chunk !== "string" &&
              chunk !== undefined &&
              !state.objectMode
            ) {
              er = new TypeError("Invalid non-string/buffer chunk")
            }
            if (er) {
              stream.emit("error", er)
              pna.nextTick(cb, er)
              valid = false
            }
            return valid
          }

          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState
            var ret = false
            var isBuf = !state.objectMode && _isUint8Array(chunk)

            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk)
            }

            if (typeof encoding === "function") {
              cb = encoding
              encoding = null
            }

            if (isBuf) encoding = "buffer"
            else if (!encoding) encoding = state.defaultEncoding

            if (typeof cb !== "function") cb = nop

            if (state.ended) writeAfterEnd(this, cb)
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb)
            }

            return ret
          }

          Writable.prototype.cork = function() {
            var state = this._writableState

            state.corked++
          }

          Writable.prototype.uncork = function() {
            var state = this._writableState

            if (state.corked) {
              state.corked--

              if (
                !state.writing &&
                !state.corked &&
                !state.finished &&
                !state.bufferProcessing &&
                state.bufferedRequest
              )
                clearBuffer(this, state)
            }
          }

          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(
            encoding
          ) {
            // node::ParseEncoding() requires lower case.
            if (typeof encoding === "string") encoding = encoding.toLowerCase()
            if (
              !(
                [
                  "hex",
                  "utf8",
                  "utf-8",
                  "ascii",
                  "binary",
                  "base64",
                  "ucs2",
                  "ucs-2",
                  "utf16le",
                  "utf-16le",
                  "raw"
                ].indexOf((encoding + "").toLowerCase()) > -1
              )
            )
              throw new TypeError("Unknown encoding: " + encoding)
            this._writableState.defaultEncoding = encoding
            return this
          }

          function decodeChunk(state, chunk, encoding) {
            if (
              !state.objectMode &&
              state.decodeStrings !== false &&
              typeof chunk === "string"
            ) {
              chunk = Buffer.from(chunk, encoding)
            }
            return chunk
          }

          Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function() {
              return this._writableState.highWaterMark
            }
          })

          // if we're already writing something, then just put this
          // in the queue, and wait our turn.  Otherwise, call _write
          // If we return false, then we need a drain event, so set that flag.
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding)
              if (chunk !== newChunk) {
                isBuf = true
                encoding = "buffer"
                chunk = newChunk
              }
            }
            var len = state.objectMode ? 1 : chunk.length

            state.length += len

            var ret = state.length < state.highWaterMark
            // we must ensure that previous needDrain will not be reset to false.
            if (!ret) state.needDrain = true

            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest
              state.lastBufferedRequest = {
                chunk: chunk,
                encoding: encoding,
                isBuf: isBuf,
                callback: cb,
                next: null
              }
              if (last) {
                last.next = state.lastBufferedRequest
              } else {
                state.bufferedRequest = state.lastBufferedRequest
              }
              state.bufferedRequestCount += 1
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb)
            }

            return ret
          }

          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len
            state.writecb = cb
            state.writing = true
            state.sync = true
            if (writev) stream._writev(chunk, state.onwrite)
            else stream._write(chunk, encoding, state.onwrite)
            state.sync = false
          }

          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb

            if (sync) {
              // defer the callback if we are being called synchronously
              // to avoid piling up things on the stack
              pna.nextTick(cb, er)
              // this can emit finish, and it will always happen
              // after error
              pna.nextTick(finishMaybe, stream, state)
              stream._writableState.errorEmitted = true
              stream.emit("error", er)
            } else {
              // the caller expect this to happen before if
              // it is async
              cb(er)
              stream._writableState.errorEmitted = true
              stream.emit("error", er)
              // this can emit finish, but finish must
              // always follow error
              finishMaybe(stream, state)
            }
          }

          function onwriteStateUpdate(state) {
            state.writing = false
            state.writecb = null
            state.length -= state.writelen
            state.writelen = 0
          }

          function onwrite(stream, er) {
            var state = stream._writableState
            var sync = state.sync
            var cb = state.writecb

            onwriteStateUpdate(state)

            if (er) onwriteError(stream, state, sync, er, cb)
            else {
              // Check if we're actually ready to finish, but don't emit yet
              var finished = needFinish(state)

              if (
                !finished &&
                !state.corked &&
                !state.bufferProcessing &&
                state.bufferedRequest
              ) {
                clearBuffer(stream, state)
              }

              if (sync) {
                /*<replacement>*/
                asyncWrite(afterWrite, stream, state, finished, cb)
                /*</replacement>*/
              } else {
                afterWrite(stream, state, finished, cb)
              }
            }
          }

          function afterWrite(stream, state, finished, cb) {
            if (!finished) onwriteDrain(stream, state)
            state.pendingcb--
            cb()
            finishMaybe(stream, state)
          }

          // Must force callback to be called on nextTick, so that we don't
          // emit 'drain' before the write() consumer gets the 'false' return
          // value, and has a chance to attach a 'drain' listener.
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false
              stream.emit("drain")
            }
          }

          // if there's something in the buffer waiting, then process it
          function clearBuffer(stream, state) {
            state.bufferProcessing = true
            var entry = state.bufferedRequest

            if (stream._writev && entry && entry.next) {
              // Fast case, write everything using _writev()
              var l = state.bufferedRequestCount
              var buffer = new Array(l)
              var holder = state.corkedRequestsFree
              holder.entry = entry

              var count = 0
              var allBuffers = true
              while (entry) {
                buffer[count] = entry
                if (!entry.isBuf) allBuffers = false
                entry = entry.next
                count += 1
              }
              buffer.allBuffers = allBuffers

              doWrite(
                stream,
                state,
                true,
                state.length,
                buffer,
                "",
                holder.finish
              )

              // doWrite is almost always async, defer these to save a bit of time
              // as the hot path ends with doWrite
              state.pendingcb++
              state.lastBufferedRequest = null
              if (holder.next) {
                state.corkedRequestsFree = holder.next
                holder.next = null
              } else {
                state.corkedRequestsFree = new CorkedRequest(state)
              }
              state.bufferedRequestCount = 0
            } else {
              // Slow case, write chunks one-by-one
              while (entry) {
                var chunk = entry.chunk
                var encoding = entry.encoding
                var cb = entry.callback
                var len = state.objectMode ? 1 : chunk.length

                doWrite(stream, state, false, len, chunk, encoding, cb)
                entry = entry.next
                state.bufferedRequestCount--
                // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.
                if (state.writing) {
                  break
                }
              }

              if (entry === null) state.lastBufferedRequest = null
            }

            state.bufferedRequest = entry
            state.bufferProcessing = false
          }

          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error("_write() is not implemented"))
          }

          Writable.prototype._writev = null

          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState

            if (typeof chunk === "function") {
              cb = chunk
              chunk = null
              encoding = null
            } else if (typeof encoding === "function") {
              cb = encoding
              encoding = null
            }

            if (chunk !== null && chunk !== undefined)
              this.write(chunk, encoding)

            // .end() fully uncorks
            if (state.corked) {
              state.corked = 1
              this.uncork()
            }

            // ignore unnecessary end() calls.
            if (!state.ending && !state.finished) endWritable(this, state, cb)
          }

          function needFinish(state) {
            return (
              state.ending &&
              state.length === 0 &&
              state.bufferedRequest === null &&
              !state.finished &&
              !state.writing
            )
          }
          function callFinal(stream, state) {
            stream._final(function(err) {
              state.pendingcb--
              if (err) {
                stream.emit("error", err)
              }
              state.prefinished = true
              stream.emit("prefinish")
              finishMaybe(stream, state)
            })
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === "function") {
                state.pendingcb++
                state.finalCalled = true
                pna.nextTick(callFinal, stream, state)
              } else {
                state.prefinished = true
                stream.emit("prefinish")
              }
            }
          }

          function finishMaybe(stream, state) {
            var need = needFinish(state)
            if (need) {
              prefinish(stream, state)
              if (state.pendingcb === 0) {
                state.finished = true
                stream.emit("finish")
              }
            }
            return need
          }

          function endWritable(stream, state, cb) {
            state.ending = true
            finishMaybe(stream, state)
            if (cb) {
              if (state.finished) pna.nextTick(cb)
              else stream.once("finish", cb)
            }
            state.ended = true
            stream.writable = false
          }

          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry
            corkReq.entry = null
            while (entry) {
              var cb = entry.callback
              state.pendingcb--
              cb(err)
              entry = entry.next
            }
            if (state.corkedRequestsFree) {
              state.corkedRequestsFree.next = corkReq
            } else {
              state.corkedRequestsFree = corkReq
            }
          }

          Object.defineProperty(Writable.prototype, "destroyed", {
            get: function() {
              if (this._writableState === undefined) {
                return false
              }
              return this._writableState.destroyed
            },
            set: function(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._writableState) {
                return
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._writableState.destroyed = value
            }
          })

          Writable.prototype.destroy = destroyImpl.destroy
          Writable.prototype._undestroy = destroyImpl.undestroy
          Writable.prototype._destroy = function(err, cb) {
            this.end()
            cb(err)
          }
        }.call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
          require("timers").setImmediate
        ))
      },
      {
        "./_stream_duplex": 48,
        "./internal/streams/destroy": 54,
        "./internal/streams/stream": 55,
        _process: 44,
        "core-util-is": 23,
        inherits: 37,
        "process-nextick-args": 57,
        "safe-buffer": 59,
        timers: 75,
        "util-deprecate": 79
      }
    ],
    53: [
      function(require, module, exports) {
        "use strict"

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
          }
        }

        var Buffer = require("safe-buffer").Buffer
        var util = require("util")

        function copyBuffer(src, target, offset) {
          src.copy(target, offset)
        }

        module.exports = (function() {
          function BufferList() {
            _classCallCheck(this, BufferList)

            this.head = null
            this.tail = null
            this.length = 0
          }

          BufferList.prototype.push = function push(v) {
            var entry = { data: v, next: null }
            if (this.length > 0) this.tail.next = entry
            else this.head = entry
            this.tail = entry
            ++this.length
          }

          BufferList.prototype.unshift = function unshift(v) {
            var entry = { data: v, next: this.head }
            if (this.length === 0) this.tail = entry
            this.head = entry
            ++this.length
          }

          BufferList.prototype.shift = function shift() {
            if (this.length === 0) return
            var ret = this.head.data
            if (this.length === 1) this.head = this.tail = null
            else this.head = this.head.next
            --this.length
            return ret
          }

          BufferList.prototype.clear = function clear() {
            this.head = this.tail = null
            this.length = 0
          }

          BufferList.prototype.join = function join(s) {
            if (this.length === 0) return ""
            var p = this.head
            var ret = "" + p.data
            while ((p = p.next)) {
              ret += s + p.data
            }
            return ret
          }

          BufferList.prototype.concat = function concat(n) {
            if (this.length === 0) return Buffer.alloc(0)
            if (this.length === 1) return this.head.data
            var ret = Buffer.allocUnsafe(n >>> 0)
            var p = this.head
            var i = 0
            while (p) {
              copyBuffer(p.data, ret, i)
              i += p.data.length
              p = p.next
            }
            return ret
          }

          return BufferList
        })()

        if (util && util.inspect && util.inspect.custom) {
          module.exports.prototype[util.inspect.custom] = function() {
            var obj = util.inspect({ length: this.length })
            return this.constructor.name + " " + obj
          }
        }
      },
      { "safe-buffer": 59, util: 14 }
    ],
    54: [
      function(require, module, exports) {
        "use strict"

        /*<replacement>*/

        var pna = require("process-nextick-args")
        /*</replacement>*/

        // undocumented cb() API, needed for core, not for public API
        function destroy(err, cb) {
          var _this = this

          var readableDestroyed =
            this._readableState && this._readableState.destroyed
          var writableDestroyed =
            this._writableState && this._writableState.destroyed

          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err)
            } else if (
              err &&
              (!this._writableState || !this._writableState.errorEmitted)
            ) {
              pna.nextTick(emitErrorNT, this, err)
            }
            return this
          }

          // we set destroyed to true before firing error callbacks in order
          // to make it re-entrance safe in case destroy() is called within callbacks

          if (this._readableState) {
            this._readableState.destroyed = true
          }

          // if this is a duplex stream mark the writable part as destroyed as well
          if (this._writableState) {
            this._writableState.destroyed = true
          }

          this._destroy(err || null, function(err) {
            if (!cb && err) {
              pna.nextTick(emitErrorNT, _this, err)
              if (_this._writableState) {
                _this._writableState.errorEmitted = true
              }
            } else if (cb) {
              cb(err)
            }
          })

          return this
        }

        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false
            this._readableState.reading = false
            this._readableState.ended = false
            this._readableState.endEmitted = false
          }

          if (this._writableState) {
            this._writableState.destroyed = false
            this._writableState.ended = false
            this._writableState.ending = false
            this._writableState.finished = false
            this._writableState.errorEmitted = false
          }
        }

        function emitErrorNT(self, err) {
          self.emit("error", err)
        }

        module.exports = {
          destroy: destroy,
          undestroy: undestroy
        }
      },
      { "process-nextick-args": 57 }
    ],
    55: [
      function(require, module, exports) {
        module.exports = require("events").EventEmitter
      },
      { events: 24 }
    ],
    56: [
      function(require, module, exports) {
        var toString = {}.toString

        module.exports =
          Array.isArray ||
          function(arr) {
            return toString.call(arr) == "[object Array]"
          }
      },
      {}
    ],
    57: [
      function(require, module, exports) {
        ;(function(process) {
          "use strict"

          if (
            !process.version ||
            process.version.indexOf("v0.") === 0 ||
            (process.version.indexOf("v1.") === 0 &&
              process.version.indexOf("v1.8.") !== 0)
          ) {
            module.exports = { nextTick: nextTick }
          } else {
            module.exports = process
          }

          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
              throw new TypeError('"callback" argument must be a function')
            }
            var len = arguments.length
            var args, i
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn)
              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1)
                })
              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2)
                })
              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3)
                })
              default:
                args = new Array(len - 1)
                i = 0
                while (i < args.length) {
                  args[i++] = arguments[i]
                }
                return process.nextTick(function afterTick() {
                  fn.apply(null, args)
                })
            }
          }
        }.call(this, require("_process")))
      },
      { _process: 44 }
    ],
    58: [
      function(require, module, exports) {
        exports = module.exports = require("./lib/_stream_readable.js")
        exports.Stream = exports
        exports.Readable = exports
        exports.Writable = require("./lib/_stream_writable.js")
        exports.Duplex = require("./lib/_stream_duplex.js")
        exports.Transform = require("./lib/_stream_transform.js")
        exports.PassThrough = require("./lib/_stream_passthrough.js")
      },
      {
        "./lib/_stream_duplex.js": 48,
        "./lib/_stream_passthrough.js": 49,
        "./lib/_stream_readable.js": 50,
        "./lib/_stream_transform.js": 51,
        "./lib/_stream_writable.js": 52
      }
    ],
    59: [
      function(require, module, exports) {
        /* eslint-disable node/no-deprecated-api */
        var buffer = require("buffer")
        var Buffer = buffer.Buffer

        // alternative to using Object.keys for old browsers
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key]
          }
        }
        if (
          Buffer.from &&
          Buffer.alloc &&
          Buffer.allocUnsafe &&
          Buffer.allocUnsafeSlow
        ) {
          module.exports = buffer
        } else {
          // Copy properties from require('buffer')
          copyProps(buffer, exports)
          exports.Buffer = SafeBuffer
        }

        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length)
        }

        // Copy static methods from Buffer
        copyProps(Buffer, SafeBuffer)

        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number")
          }
          return Buffer(arg, encodingOrOffset, length)
        }

        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number")
          }
          var buf = Buffer(size)
          if (fill !== undefined) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding)
            } else {
              buf.fill(fill)
            }
          } else {
            buf.fill(0)
          }
          return buf
        }

        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number")
          }
          return Buffer(size)
        }

        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number")
          }
          return buffer.SlowBuffer(size)
        }
      },
      { buffer: 20 }
    ],
    60: [
      function(require, module, exports) {
        var varint = require("varint")
        exports.encode = function encode(v, b, o) {
          v = v >= 0 ? v * 2 : v * -2 - 1
          var r = varint.encode(v, b, o)
          encode.bytes = varint.encode.bytes
          return r
        }
        exports.decode = function decode(b, o) {
          var v = varint.decode(b, o)
          decode.bytes = varint.decode.bytes
          return v & 1 ? (v + 1) / -2 : v / 2
        }

        exports.encodingLength = function(v) {
          return varint.encodingLength(v >= 0 ? v * 2 : v * -2 - 1)
        }
      },
      { varint: 82 }
    ],
    61: [
      function(require, module, exports) {
        module.exports = fallback

        function _add(a, b) {
          var rl = a.l + b.l
          var a2 = {
            h: (a.h + b.h + ((rl / 2) >>> 31)) >>> 0,
            l: rl >>> 0
          }
          a.h = a2.h
          a.l = a2.l
        }

        function _xor(a, b) {
          a.h ^= b.h
          a.h >>>= 0
          a.l ^= b.l
          a.l >>>= 0
        }

        function _rotl(a, n) {
          var a2 = {
            h: (a.h << n) | (a.l >>> (32 - n)),
            l: (a.l << n) | (a.h >>> (32 - n))
          }
          a.h = a2.h
          a.l = a2.l
        }

        function _rotl32(a) {
          var al = a.l
          a.l = a.h
          a.h = al
        }

        function _compress(v0, v1, v2, v3) {
          _add(v0, v1)
          _add(v2, v3)
          _rotl(v1, 13)
          _rotl(v3, 16)
          _xor(v1, v0)
          _xor(v3, v2)
          _rotl32(v0)
          _add(v2, v1)
          _add(v0, v3)
          _rotl(v1, 17)
          _rotl(v3, 21)
          _xor(v1, v2)
          _xor(v3, v0)
          _rotl32(v2)
        }

        function _get_int(a, offset) {
          return (
            (a[offset + 3] << 24) |
            (a[offset + 2] << 16) |
            (a[offset + 1] << 8) |
            a[offset]
          )
        }

        function fallback(out, m, key) {
          // modified from https://github.com/jedisct1/siphash-js to use uint8arrays
          var k0 = { h: _get_int(key, 4), l: _get_int(key, 0) }
          var k1 = { h: _get_int(key, 12), l: _get_int(key, 8) }
          var v0 = { h: k0.h, l: k0.l }
          var v2 = k0
          var v1 = { h: k1.h, l: k1.l }
          var v3 = k1
          var mi
          var mp = 0
          var ml = m.length
          var ml7 = ml - 7
          var buf = new Uint8Array(new ArrayBuffer(8))

          _xor(v0, { h: 0x736f6d65, l: 0x70736575 })
          _xor(v1, { h: 0x646f7261, l: 0x6e646f6d })
          _xor(v2, { h: 0x6c796765, l: 0x6e657261 })
          _xor(v3, { h: 0x74656462, l: 0x79746573 })

          while (mp < ml7) {
            mi = { h: _get_int(m, mp + 4), l: _get_int(m, mp) }
            _xor(v3, mi)
            _compress(v0, v1, v2, v3)
            _compress(v0, v1, v2, v3)
            _xor(v0, mi)
            mp += 8
          }

          buf[7] = ml
          var ic = 0
          while (mp < ml) {
            buf[ic++] = m[mp++]
          }
          while (ic < 7) {
            buf[ic++] = 0
          }

          mi = {
            h: (buf[7] << 24) | (buf[6] << 16) | (buf[5] << 8) | buf[4],
            l: (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0]
          }

          _xor(v3, mi)
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)
          _xor(v0, mi)
          _xor(v2, { h: 0, l: 0xff })
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)

          var h = v0
          _xor(h, v1)
          _xor(h, v2)
          _xor(h, v3)

          out[0] = h.l & 0xff
          out[1] = (h.l >> 8) & 0xff
          out[2] = (h.l >> 16) & 0xff
          out[3] = (h.l >> 24) & 0xff
          out[4] = h.h & 0xff
          out[5] = (h.h >> 8) & 0xff
          out[6] = (h.h >> 16) & 0xff
          out[7] = (h.h >> 24) & 0xff
        }
      },
      {}
    ],
    62: [
      function(require, module, exports) {
        var wasm = require("./siphash24")
        var fallback = require("./fallback")
        var assert = require("nanoassert")

        module.exports = siphash24

        var BYTES = (siphash24.BYTES = 8)
        var KEYBYTES = (siphash24.KEYBYTES = 16)
        var mod = wasm()

        siphash24.WASM_SUPPORTED = typeof WebAssembly !== "undefined"
        siphash24.WASM_LOADED = false

        if (mod) {
          mod.onload(function(err) {
            siphash24.WASM_LOADED = !err
          })
        }

        function siphash24(data, key, out, noAssert) {
          if (!out) out = new Uint8Array(8)

          if (noAssert !== true) {
            assert(out.length >= BYTES, "output must be at least " + BYTES)
            assert(key.length >= KEYBYTES, "key must be at least " + KEYBYTES)
          }

          if (mod && mod.exports) {
            if (data.length + 24 > mod.memory.length)
              mod.realloc(data.length + 24)
            mod.memory.set(key, 8)
            mod.memory.set(data, 24)
            mod.exports.siphash(24, data.length)
            out.set(mod.memory.subarray(0, 8))
          } else {
            fallback(out, data, key)
          }

          return out
        }
      },
      { "./fallback": 61, "./siphash24": 63, nanoassert: 42 }
    ],
    63: [
      function(require, module, exports) {
        module.exports = loadWebAssembly

        loadWebAssembly.supported = typeof WebAssembly !== "undefined"

        function loadWebAssembly(opts) {
          if (!loadWebAssembly.supported) return null

          var imp = opts && opts.imports
          var wasm = toUint8Array(
            "AGFzbQEAAAABBgFgAn9/AAMCAQAFBQEBCpBOBxQCBm1lbW9yeQIAB3NpcGhhc2gAAArdCAHaCAIIfgJ/QvXKzYPXrNu38wAhAkLt3pHzlszct+QAIQNC4eSV89bs2bzsACEEQvPK0cunjNmy9AAhBUEIKQMAIQdBECkDACEIIAGtQjiGIQYgAUEHcSELIAAgAWogC2shCiAFIAiFIQUgBCAHhSEEIAMgCIUhAyACIAeFIQICQANAIAAgCkYNASAAKQMAIQkgBSAJhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAmFIQIgAEEIaiEADAALCwJAAkACQAJAAkACQAJAAkAgCw4HBwYFBAMCAQALIAYgADEABkIwhoQhBgsgBiAAMQAFQiiGhCEGCyAGIAAxAARCIIaEIQYLIAYgADEAA0IYhoQhBgsgBiAAMQACQhCGhCEGCyAGIAAxAAFCCIaEIQYLIAYgADEAAIQhBgsgBSAGhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAaFIQIgBEL/AYUhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEQQAgAiADIAQgBYWFhTcDAAs="
          )
          var ready = null

          var mod = {
            buffer: wasm,
            memory: null,
            exports: null,
            realloc: realloc,
            onload: onload
          }

          onload(function() {})

          return mod

          function realloc(size) {
            mod.exports.memory.grow(
              Math.max(0, Math.ceil(Math.abs(size - mod.memory.length) / 65536))
            )
            mod.memory = new Uint8Array(mod.exports.memory.buffer)
          }

          function onload(cb) {
            if (mod.exports) return cb()

            if (ready) {
              ready.then(cb.bind(null, null)).catch(cb)
              return
            }

            try {
              if (opts && opts.async) throw new Error("async")
              setup({
                instance: new WebAssembly.Instance(
                  new WebAssembly.Module(wasm),
                  imp
                )
              })
            } catch (err) {
              ready = WebAssembly.instantiate(wasm, imp).then(setup)
            }

            onload(cb)
          }

          function setup(w) {
            mod.exports = w.instance.exports
            mod.memory =
              mod.exports.memory &&
              mod.exports.memory.buffer &&
              new Uint8Array(mod.exports.memory.buffer)
          }
        }

        function toUint8Array(s) {
          if (typeof atob === "function")
            return new Uint8Array(
              atob(s)
                .split("")
                .map(charCodeAt)
            )
          return new (require("buf" + "fer")).Buffer(s, "base64")
        }

        function charCodeAt(c) {
          return c.charCodeAt(0)
        }
      },
      {}
    ],
    64: [
      function(require, module, exports) {
        var blake2b = require("blake2b")

        module.exports.crypto_generichash_PRIMITIVE = "blake2b"
        module.exports.crypto_generichash_BYTES_MIN = blake2b.BYTES_MIN
        module.exports.crypto_generichash_BYTES_MAX = blake2b.BYTES_MAX
        module.exports.crypto_generichash_BYTES = blake2b.BYTES
        module.exports.crypto_generichash_KEYBYTES_MIN = blake2b.KEYBYTES_MIN
        module.exports.crypto_generichash_KEYBYTES_MAX = blake2b.KEYBYTES_MAX
        module.exports.crypto_generichash_KEYBYTES = blake2b.KEYBYTES
        module.exports.crypto_generichash_WASM_SUPPORTED =
          blake2b.WASM_SUPPORTED
        module.exports.crypto_generichash_WASM_LOADED = false

        module.exports.crypto_generichash = function(output, input, key) {
          blake2b(output.length, key)
            .update(input)
            .final(output)
        }

        module.exports.crypto_generichash_ready = blake2b.ready

        module.exports.crypto_generichash_batch = function(
          output,
          inputArray,
          key
        ) {
          var ctx = blake2b(output.length, key)
          for (var i = 0; i < inputArray.length; i++) {
            ctx.update(inputArray[i])
          }
          ctx.final(output)
        }

        module.exports.crypto_generichash_instance = function(key, outlen) {
          if (outlen == null) outlen = module.exports.crypto_generichash_BYTES
          return blake2b(outlen, key)
        }

        blake2b.ready(function(err) {
          module.exports.crypto_generichash_WASM_LOADED = blake2b.WASM_LOADED
        })
      },
      { blake2b: 13 }
    ],
    65: [
      function(require, module, exports) {
        var assert = require("nanoassert")
        var randombytes_buf = require("./randombytes").randombytes_buf
        var blake2b = require("blake2b")

        module.exports.crypto_kdf_PRIMITIVE = "blake2b"
        module.exports.crypto_kdf_BYTES_MIN = 16
        module.exports.crypto_kdf_BYTES_MAX = 64
        module.exports.crypto_kdf_CONTEXTBYTES = 8
        module.exports.crypto_kdf_KEYBYTES = 32

        function STORE64_LE(dest, int) {
          var mul = 1
          var i = 0
          dest[0] = int & 0xff
          while (++i < 8 && (mul *= 0x100)) {
            dest[i] = (int / mul) & 0xff
          }
        }

        module.exports.crypto_kdf_derive_from_key = function crypto_kdf_derive_from_key(
          subkey,
          subkey_id,
          ctx,
          key
        ) {
          assert(
            subkey.length >= module.exports.crypto_kdf_BYTES_MIN,
            "subkey must be at least crypto_kdf_BYTES_MIN"
          )
          assert(
            subkey_id >= 0 && subkey_id <= 0x1fffffffffffff,
            "subkey_id must be safe integer"
          )
          assert(
            ctx.length >= module.exports.crypto_kdf_CONTEXTBYTES,
            "context must be at least crypto_kdf_CONTEXTBYTES"
          )

          var ctx_padded = new Uint8Array(blake2b.PERSONALBYTES)
          var salt = new Uint8Array(blake2b.SALTBYTES)

          ctx_padded.set(ctx, 0, module.exports.crypto_kdf_CONTEXTBYTES)
          STORE64_LE(salt, subkey_id)

          var outlen = Math.min(
            subkey.length,
            module.exports.crypto_kdf_BYTES_MAX
          )
          blake2b(
            outlen,
            key.subarray(0, module.exports.crypto_kdf_KEYBYTES),
            salt,
            ctx_padded,
            true
          ).final(subkey)
        }

        module.exports.crypto_kdf_keygen = function crypto_kdf_keygen(out) {
          assert(
            out.length >= module.exports.crypto_kdf_KEYBYTES,
            "out.length must be crypto_kdf_KEYBYTES"
          )
          randombytes_buf(out.subarray(0, module.exports.crypto_kdf_KEYBYTES))
        }
      },
      { "./randombytes": 69, blake2b: 13, nanoassert: 42 }
    ],
    66: [
      function(require, module, exports) {
        var siphash = require("siphash24")

        exports.crypto_shorthash_PRIMITIVE = "siphash24"
        exports.crypto_shorthash_BYTES = siphash.BYTES
        exports.crypto_shorthash_KEYBYTES = siphash.KEYBYTES
        exports.crypto_shorthash_WASM_SUPPORTED = siphash.WASM_SUPPORTED
        exports.crypto_shorthash_WASM_LOADED = siphash.WASM_LOADED
        exports.crypto_shorthash = shorthash

        function shorthash(out, data, key, noAssert) {
          siphash(data, key, out, noAssert)
        }
      },
      { siphash24: 62 }
    ],
    67: [
      function(require, module, exports) {
        var xsalsa20 = require("xsalsa20")

        exports.crypto_stream_KEYBYTES = 32
        exports.crypto_stream_NONCEBYTES = 24
        exports.crypto_stream_PRIMITIVE = "xsalsa20"

        exports.crypto_stream = function(out, nonce, key) {
          out.fill(0)
          exports.crypto_stream_xor(out, out, nonce, key)
        }

        exports.crypto_stream_xor = function(out, inp, nonce, key) {
          var xor = xsalsa20(nonce, key)
          xor.update(inp, out)
          xor.final()
        }

        exports.crypto_stream_xor_instance = function(nonce, key) {
          return new XOR(nonce, key)
        }

        function XOR(nonce, key) {
          this._instance = xsalsa20(nonce, key)
        }

        XOR.prototype.update = function(out, inp) {
          this._instance.update(inp, out)
        }

        XOR.prototype.final = function() {
          this._instance.finalize()
          this._instance = null
        }
      },
      { xsalsa20: 84 }
    ],
    68: [
      function(require, module, exports) {
        "use strict"

        // Based on https://github.com/dchest/tweetnacl-js/blob/6dcbcaf5f5cbfd313f2dcfe763db35c828c8ff5b/nacl-fast.js.

        var sodium = module.exports
        var cs = require("./crypto_stream")

        // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
        // Public domain.
        //
        // Implementation derived from TweetNaCl version 20140427.
        // See for details: http://tweetnacl.cr.yp.to/

        var gf = function(init) {
          var i,
            r = new Float64Array(16)
          if (init) for (i = 0; i < init.length; i++) r[i] = init[i]
          return r
        }

        // also forwarded at the bottom but randombytes is non-enumerable
        var randombytes = require("./randombytes").randombytes

        var _0 = new Uint8Array(16)
        var _9 = new Uint8Array(32)
        _9[0] = 9

        var gf0 = gf(),
          gf1 = gf([1]),
          _121665 = gf([0xdb41, 1]),
          D = gf([
            0x78a3,
            0x1359,
            0x4dca,
            0x75eb,
            0xd8ab,
            0x4141,
            0x0a4d,
            0x0070,
            0xe898,
            0x7779,
            0x4079,
            0x8cc7,
            0xfe73,
            0x2b6f,
            0x6cee,
            0x5203
          ]),
          D2 = gf([
            0xf159,
            0x26b2,
            0x9b94,
            0xebd6,
            0xb156,
            0x8283,
            0x149a,
            0x00e0,
            0xd130,
            0xeef3,
            0x80f2,
            0x198e,
            0xfce7,
            0x56df,
            0xd9dc,
            0x2406
          ]),
          X = gf([
            0xd51a,
            0x8f25,
            0x2d60,
            0xc956,
            0xa7b2,
            0x9525,
            0xc760,
            0x692c,
            0xdc5c,
            0xfdd6,
            0xe231,
            0xc0a4,
            0x53fe,
            0xcd6e,
            0x36d3,
            0x2169
          ]),
          Y = gf([
            0x6658,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666
          ]),
          I = gf([
            0xa0b0,
            0x4a0e,
            0x1b27,
            0xc4ee,
            0xe478,
            0xad2f,
            0x1806,
            0x2f43,
            0xd7a7,
            0x3dfb,
            0x0099,
            0x2b4d,
            0xdf0b,
            0x4fc1,
            0x2480,
            0x2b83
          ])

        function ts64(x, i, h, l) {
          x[i] = (h >> 24) & 0xff
          x[i + 1] = (h >> 16) & 0xff
          x[i + 2] = (h >> 8) & 0xff
          x[i + 3] = h & 0xff
          x[i + 4] = (l >> 24) & 0xff
          x[i + 5] = (l >> 16) & 0xff
          x[i + 6] = (l >> 8) & 0xff
          x[i + 7] = l & 0xff
        }

        function vn(x, xi, y, yi, n) {
          var i,
            d = 0
          for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i]
          return (1 & ((d - 1) >>> 8)) - 1
        }

        function crypto_verify_16(x, xi, y, yi) {
          return vn(x, xi, y, yi, 16)
        }

        function crypto_verify_32(x, xi, y, yi) {
          return vn(x, xi, y, yi, 32)
        }

        /*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

        var poly1305 = function(key) {
          this.buffer = new Uint8Array(16)
          this.r = new Uint16Array(10)
          this.h = new Uint16Array(10)
          this.pad = new Uint16Array(8)
          this.leftover = 0
          this.fin = 0

          var t0, t1, t2, t3, t4, t5, t6, t7

          t0 = (key[0] & 0xff) | ((key[1] & 0xff) << 8)
          this.r[0] = t0 & 0x1fff
          t1 = (key[2] & 0xff) | ((key[3] & 0xff) << 8)
          this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff
          t2 = (key[4] & 0xff) | ((key[5] & 0xff) << 8)
          this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03
          t3 = (key[6] & 0xff) | ((key[7] & 0xff) << 8)
          this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff
          t4 = (key[8] & 0xff) | ((key[9] & 0xff) << 8)
          this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff
          this.r[5] = (t4 >>> 1) & 0x1ffe
          t5 = (key[10] & 0xff) | ((key[11] & 0xff) << 8)
          this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff
          t6 = (key[12] & 0xff) | ((key[13] & 0xff) << 8)
          this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81
          t7 = (key[14] & 0xff) | ((key[15] & 0xff) << 8)
          this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff
          this.r[9] = (t7 >>> 5) & 0x007f

          this.pad[0] = (key[16] & 0xff) | ((key[17] & 0xff) << 8)
          this.pad[1] = (key[18] & 0xff) | ((key[19] & 0xff) << 8)
          this.pad[2] = (key[20] & 0xff) | ((key[21] & 0xff) << 8)
          this.pad[3] = (key[22] & 0xff) | ((key[23] & 0xff) << 8)
          this.pad[4] = (key[24] & 0xff) | ((key[25] & 0xff) << 8)
          this.pad[5] = (key[26] & 0xff) | ((key[27] & 0xff) << 8)
          this.pad[6] = (key[28] & 0xff) | ((key[29] & 0xff) << 8)
          this.pad[7] = (key[30] & 0xff) | ((key[31] & 0xff) << 8)
        }

        poly1305.prototype.blocks = function(m, mpos, bytes) {
          var hibit = this.fin ? 0 : 1 << 11
          var t0, t1, t2, t3, t4, t5, t6, t7, c
          var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9

          var h0 = this.h[0],
            h1 = this.h[1],
            h2 = this.h[2],
            h3 = this.h[3],
            h4 = this.h[4],
            h5 = this.h[5],
            h6 = this.h[6],
            h7 = this.h[7],
            h8 = this.h[8],
            h9 = this.h[9]

          var r0 = this.r[0],
            r1 = this.r[1],
            r2 = this.r[2],
            r3 = this.r[3],
            r4 = this.r[4],
            r5 = this.r[5],
            r6 = this.r[6],
            r7 = this.r[7],
            r8 = this.r[8],
            r9 = this.r[9]

          while (bytes >= 16) {
            t0 = (m[mpos + 0] & 0xff) | ((m[mpos + 1] & 0xff) << 8)
            h0 += t0 & 0x1fff
            t1 = (m[mpos + 2] & 0xff) | ((m[mpos + 3] & 0xff) << 8)
            h1 += ((t0 >>> 13) | (t1 << 3)) & 0x1fff
            t2 = (m[mpos + 4] & 0xff) | ((m[mpos + 5] & 0xff) << 8)
            h2 += ((t1 >>> 10) | (t2 << 6)) & 0x1fff
            t3 = (m[mpos + 6] & 0xff) | ((m[mpos + 7] & 0xff) << 8)
            h3 += ((t2 >>> 7) | (t3 << 9)) & 0x1fff
            t4 = (m[mpos + 8] & 0xff) | ((m[mpos + 9] & 0xff) << 8)
            h4 += ((t3 >>> 4) | (t4 << 12)) & 0x1fff
            h5 += (t4 >>> 1) & 0x1fff
            t5 = (m[mpos + 10] & 0xff) | ((m[mpos + 11] & 0xff) << 8)
            h6 += ((t4 >>> 14) | (t5 << 2)) & 0x1fff
            t6 = (m[mpos + 12] & 0xff) | ((m[mpos + 13] & 0xff) << 8)
            h7 += ((t5 >>> 11) | (t6 << 5)) & 0x1fff
            t7 = (m[mpos + 14] & 0xff) | ((m[mpos + 15] & 0xff) << 8)
            h8 += ((t6 >>> 8) | (t7 << 8)) & 0x1fff
            h9 += (t7 >>> 5) | hibit

            c = 0

            d0 = c
            d0 += h0 * r0
            d0 += h1 * (5 * r9)
            d0 += h2 * (5 * r8)
            d0 += h3 * (5 * r7)
            d0 += h4 * (5 * r6)
            c = d0 >>> 13
            d0 &= 0x1fff
            d0 += h5 * (5 * r5)
            d0 += h6 * (5 * r4)
            d0 += h7 * (5 * r3)
            d0 += h8 * (5 * r2)
            d0 += h9 * (5 * r1)
            c += d0 >>> 13
            d0 &= 0x1fff

            d1 = c
            d1 += h0 * r1
            d1 += h1 * r0
            d1 += h2 * (5 * r9)
            d1 += h3 * (5 * r8)
            d1 += h4 * (5 * r7)
            c = d1 >>> 13
            d1 &= 0x1fff
            d1 += h5 * (5 * r6)
            d1 += h6 * (5 * r5)
            d1 += h7 * (5 * r4)
            d1 += h8 * (5 * r3)
            d1 += h9 * (5 * r2)
            c += d1 >>> 13
            d1 &= 0x1fff

            d2 = c
            d2 += h0 * r2
            d2 += h1 * r1
            d2 += h2 * r0
            d2 += h3 * (5 * r9)
            d2 += h4 * (5 * r8)
            c = d2 >>> 13
            d2 &= 0x1fff
            d2 += h5 * (5 * r7)
            d2 += h6 * (5 * r6)
            d2 += h7 * (5 * r5)
            d2 += h8 * (5 * r4)
            d2 += h9 * (5 * r3)
            c += d2 >>> 13
            d2 &= 0x1fff

            d3 = c
            d3 += h0 * r3
            d3 += h1 * r2
            d3 += h2 * r1
            d3 += h3 * r0
            d3 += h4 * (5 * r9)
            c = d3 >>> 13
            d3 &= 0x1fff
            d3 += h5 * (5 * r8)
            d3 += h6 * (5 * r7)
            d3 += h7 * (5 * r6)
            d3 += h8 * (5 * r5)
            d3 += h9 * (5 * r4)
            c += d3 >>> 13
            d3 &= 0x1fff

            d4 = c
            d4 += h0 * r4
            d4 += h1 * r3
            d4 += h2 * r2
            d4 += h3 * r1
            d4 += h4 * r0
            c = d4 >>> 13
            d4 &= 0x1fff
            d4 += h5 * (5 * r9)
            d4 += h6 * (5 * r8)
            d4 += h7 * (5 * r7)
            d4 += h8 * (5 * r6)
            d4 += h9 * (5 * r5)
            c += d4 >>> 13
            d4 &= 0x1fff

            d5 = c
            d5 += h0 * r5
            d5 += h1 * r4
            d5 += h2 * r3
            d5 += h3 * r2
            d5 += h4 * r1
            c = d5 >>> 13
            d5 &= 0x1fff
            d5 += h5 * r0
            d5 += h6 * (5 * r9)
            d5 += h7 * (5 * r8)
            d5 += h8 * (5 * r7)
            d5 += h9 * (5 * r6)
            c += d5 >>> 13
            d5 &= 0x1fff

            d6 = c
            d6 += h0 * r6
            d6 += h1 * r5
            d6 += h2 * r4
            d6 += h3 * r3
            d6 += h4 * r2
            c = d6 >>> 13
            d6 &= 0x1fff
            d6 += h5 * r1
            d6 += h6 * r0
            d6 += h7 * (5 * r9)
            d6 += h8 * (5 * r8)
            d6 += h9 * (5 * r7)
            c += d6 >>> 13
            d6 &= 0x1fff

            d7 = c
            d7 += h0 * r7
            d7 += h1 * r6
            d7 += h2 * r5
            d7 += h3 * r4
            d7 += h4 * r3
            c = d7 >>> 13
            d7 &= 0x1fff
            d7 += h5 * r2
            d7 += h6 * r1
            d7 += h7 * r0
            d7 += h8 * (5 * r9)
            d7 += h9 * (5 * r8)
            c += d7 >>> 13
            d7 &= 0x1fff

            d8 = c
            d8 += h0 * r8
            d8 += h1 * r7
            d8 += h2 * r6
            d8 += h3 * r5
            d8 += h4 * r4
            c = d8 >>> 13
            d8 &= 0x1fff
            d8 += h5 * r3
            d8 += h6 * r2
            d8 += h7 * r1
            d8 += h8 * r0
            d8 += h9 * (5 * r9)
            c += d8 >>> 13
            d8 &= 0x1fff

            d9 = c
            d9 += h0 * r9
            d9 += h1 * r8
            d9 += h2 * r7
            d9 += h3 * r6
            d9 += h4 * r5
            c = d9 >>> 13
            d9 &= 0x1fff
            d9 += h5 * r4
            d9 += h6 * r3
            d9 += h7 * r2
            d9 += h8 * r1
            d9 += h9 * r0
            c += d9 >>> 13
            d9 &= 0x1fff

            c = ((c << 2) + c) | 0
            c = (c + d0) | 0
            d0 = c & 0x1fff
            c = c >>> 13
            d1 += c

            h0 = d0
            h1 = d1
            h2 = d2
            h3 = d3
            h4 = d4
            h5 = d5
            h6 = d6
            h7 = d7
            h8 = d8
            h9 = d9

            mpos += 16
            bytes -= 16
          }
          this.h[0] = h0
          this.h[1] = h1
          this.h[2] = h2
          this.h[3] = h3
          this.h[4] = h4
          this.h[5] = h5
          this.h[6] = h6
          this.h[7] = h7
          this.h[8] = h8
          this.h[9] = h9
        }

        poly1305.prototype.finish = function(mac, macpos) {
          var g = new Uint16Array(10)
          var c, mask, f, i

          if (this.leftover) {
            i = this.leftover
            this.buffer[i++] = 1
            for (; i < 16; i++) this.buffer[i] = 0
            this.fin = 1
            this.blocks(this.buffer, 0, 16)
          }

          c = this.h[1] >>> 13
          this.h[1] &= 0x1fff
          for (i = 2; i < 10; i++) {
            this.h[i] += c
            c = this.h[i] >>> 13
            this.h[i] &= 0x1fff
          }
          this.h[0] += c * 5
          c = this.h[0] >>> 13
          this.h[0] &= 0x1fff
          this.h[1] += c
          c = this.h[1] >>> 13
          this.h[1] &= 0x1fff
          this.h[2] += c

          g[0] = this.h[0] + 5
          c = g[0] >>> 13
          g[0] &= 0x1fff
          for (i = 1; i < 10; i++) {
            g[i] = this.h[i] + c
            c = g[i] >>> 13
            g[i] &= 0x1fff
          }
          g[9] -= 1 << 13

          mask = (c ^ 1) - 1
          for (i = 0; i < 10; i++) g[i] &= mask
          mask = ~mask
          for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i]

          this.h[0] = (this.h[0] | (this.h[1] << 13)) & 0xffff
          this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 0xffff
          this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 0xffff
          this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 0xffff
          this.h[4] =
            ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) & 0xffff
          this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 0xffff
          this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 0xffff
          this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 0xffff

          f = this.h[0] + this.pad[0]
          this.h[0] = f & 0xffff
          for (i = 1; i < 8; i++) {
            f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0
            this.h[i] = f & 0xffff
          }

          mac[macpos + 0] = (this.h[0] >>> 0) & 0xff
          mac[macpos + 1] = (this.h[0] >>> 8) & 0xff
          mac[macpos + 2] = (this.h[1] >>> 0) & 0xff
          mac[macpos + 3] = (this.h[1] >>> 8) & 0xff
          mac[macpos + 4] = (this.h[2] >>> 0) & 0xff
          mac[macpos + 5] = (this.h[2] >>> 8) & 0xff
          mac[macpos + 6] = (this.h[3] >>> 0) & 0xff
          mac[macpos + 7] = (this.h[3] >>> 8) & 0xff
          mac[macpos + 8] = (this.h[4] >>> 0) & 0xff
          mac[macpos + 9] = (this.h[4] >>> 8) & 0xff
          mac[macpos + 10] = (this.h[5] >>> 0) & 0xff
          mac[macpos + 11] = (this.h[5] >>> 8) & 0xff
          mac[macpos + 12] = (this.h[6] >>> 0) & 0xff
          mac[macpos + 13] = (this.h[6] >>> 8) & 0xff
          mac[macpos + 14] = (this.h[7] >>> 0) & 0xff
          mac[macpos + 15] = (this.h[7] >>> 8) & 0xff
        }

        poly1305.prototype.update = function(m, mpos, bytes) {
          var i, want

          if (this.leftover) {
            want = 16 - this.leftover
            if (want > bytes) want = bytes
            for (i = 0; i < want; i++)
              this.buffer[this.leftover + i] = m[mpos + i]
            bytes -= want
            mpos += want
            this.leftover += want
            if (this.leftover < 16) return
            this.blocks(this.buffer, 0, 16)
            this.leftover = 0
          }

          if (bytes >= 16) {
            want = bytes - (bytes % 16)
            this.blocks(m, mpos, want)
            mpos += want
            bytes -= want
          }

          if (bytes) {
            for (i = 0; i < bytes; i++)
              this.buffer[this.leftover + i] = m[mpos + i]
            this.leftover += bytes
          }
        }

        function crypto_stream_xor(c, cpos, m, mpos, clen, n, k) {
          cs.crypto_stream_xor(c, m, n, k)
        }

        function crypto_stream(c, cpos, clen, n, k) {
          cs.crypto_stream(c, n, k)
        }

        function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
          var s = new poly1305(k)
          s.update(m, mpos, n)
          s.finish(out, outpos)
          return 0
        }

        function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
          var x = new Uint8Array(16)
          crypto_onetimeauth(x, 0, m, mpos, n, k)
          return crypto_verify_16(h, hpos, x, 0)
        }

        function crypto_secretbox(c, m, d, n, k) {
          var i
          if (d < 32) return -1
          crypto_stream_xor(c, 0, m, 0, d, n, k)
          crypto_onetimeauth(c, 16, c, 32, d - 32, c)
          for (i = 0; i < 16; i++) c[i] = 0
          return 0
        }

        function crypto_secretbox_open(m, c, d, n, k) {
          var i
          var x = new Uint8Array(32)
          if (d < 32) return -1
          crypto_stream(x, 0, 32, n, k)
          if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
            return -1
          crypto_stream_xor(m, 0, c, 0, d, n, k)
          for (i = 0; i < 32; i++) m[i] = 0
          return 0
        }

        function set25519(r, a) {
          var i
          for (i = 0; i < 16; i++) r[i] = a[i] | 0
        }

        function car25519(o) {
          var i,
            v,
            c = 1
          for (i = 0; i < 16; i++) {
            v = o[i] + c + 65535
            c = Math.floor(v / 65536)
            o[i] = v - c * 65536
          }
          o[0] += c - 1 + 37 * (c - 1)
        }

        function sel25519(p, q, b) {
          var t,
            c = ~(b - 1)
          for (var i = 0; i < 16; i++) {
            t = c & (p[i] ^ q[i])
            p[i] ^= t
            q[i] ^= t
          }
        }

        function pack25519(o, n) {
          var i, j, b
          var m = gf(),
            t = gf()
          for (i = 0; i < 16; i++) t[i] = n[i]
          car25519(t)
          car25519(t)
          car25519(t)
          for (j = 0; j < 2; j++) {
            m[0] = t[0] - 0xffed
            for (i = 1; i < 15; i++) {
              m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1)
              m[i - 1] &= 0xffff
            }
            m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1)
            b = (m[15] >> 16) & 1
            m[14] &= 0xffff
            sel25519(t, m, 1 - b)
          }
          for (i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 0xff
            o[2 * i + 1] = t[i] >> 8
          }
        }

        function neq25519(a, b) {
          var c = new Uint8Array(32),
            d = new Uint8Array(32)
          pack25519(c, a)
          pack25519(d, b)
          return crypto_verify_32(c, 0, d, 0)
        }

        function par25519(a) {
          var d = new Uint8Array(32)
          pack25519(d, a)
          return d[0] & 1
        }

        function unpack25519(o, n) {
          var i
          for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8)
          o[15] &= 0x7fff
        }

        function A(o, a, b) {
          for (var i = 0; i < 16; i++) o[i] = a[i] + b[i]
        }

        function Z(o, a, b) {
          for (var i = 0; i < 16; i++) o[i] = a[i] - b[i]
        }

        function M(o, a, b) {
          var v,
            c,
            t0 = 0,
            t1 = 0,
            t2 = 0,
            t3 = 0,
            t4 = 0,
            t5 = 0,
            t6 = 0,
            t7 = 0,
            t8 = 0,
            t9 = 0,
            t10 = 0,
            t11 = 0,
            t12 = 0,
            t13 = 0,
            t14 = 0,
            t15 = 0,
            t16 = 0,
            t17 = 0,
            t18 = 0,
            t19 = 0,
            t20 = 0,
            t21 = 0,
            t22 = 0,
            t23 = 0,
            t24 = 0,
            t25 = 0,
            t26 = 0,
            t27 = 0,
            t28 = 0,
            t29 = 0,
            t30 = 0,
            b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3],
            b4 = b[4],
            b5 = b[5],
            b6 = b[6],
            b7 = b[7],
            b8 = b[8],
            b9 = b[9],
            b10 = b[10],
            b11 = b[11],
            b12 = b[12],
            b13 = b[13],
            b14 = b[14],
            b15 = b[15]

          v = a[0]
          t0 += v * b0
          t1 += v * b1
          t2 += v * b2
          t3 += v * b3
          t4 += v * b4
          t5 += v * b5
          t6 += v * b6
          t7 += v * b7
          t8 += v * b8
          t9 += v * b9
          t10 += v * b10
          t11 += v * b11
          t12 += v * b12
          t13 += v * b13
          t14 += v * b14
          t15 += v * b15
          v = a[1]
          t1 += v * b0
          t2 += v * b1
          t3 += v * b2
          t4 += v * b3
          t5 += v * b4
          t6 += v * b5
          t7 += v * b6
          t8 += v * b7
          t9 += v * b8
          t10 += v * b9
          t11 += v * b10
          t12 += v * b11
          t13 += v * b12
          t14 += v * b13
          t15 += v * b14
          t16 += v * b15
          v = a[2]
          t2 += v * b0
          t3 += v * b1
          t4 += v * b2
          t5 += v * b3
          t6 += v * b4
          t7 += v * b5
          t8 += v * b6
          t9 += v * b7
          t10 += v * b8
          t11 += v * b9
          t12 += v * b10
          t13 += v * b11
          t14 += v * b12
          t15 += v * b13
          t16 += v * b14
          t17 += v * b15
          v = a[3]
          t3 += v * b0
          t4 += v * b1
          t5 += v * b2
          t6 += v * b3
          t7 += v * b4
          t8 += v * b5
          t9 += v * b6
          t10 += v * b7
          t11 += v * b8
          t12 += v * b9
          t13 += v * b10
          t14 += v * b11
          t15 += v * b12
          t16 += v * b13
          t17 += v * b14
          t18 += v * b15
          v = a[4]
          t4 += v * b0
          t5 += v * b1
          t6 += v * b2
          t7 += v * b3
          t8 += v * b4
          t9 += v * b5
          t10 += v * b6
          t11 += v * b7
          t12 += v * b8
          t13 += v * b9
          t14 += v * b10
          t15 += v * b11
          t16 += v * b12
          t17 += v * b13
          t18 += v * b14
          t19 += v * b15
          v = a[5]
          t5 += v * b0
          t6 += v * b1
          t7 += v * b2
          t8 += v * b3
          t9 += v * b4
          t10 += v * b5
          t11 += v * b6
          t12 += v * b7
          t13 += v * b8
          t14 += v * b9
          t15 += v * b10
          t16 += v * b11
          t17 += v * b12
          t18 += v * b13
          t19 += v * b14
          t20 += v * b15
          v = a[6]
          t6 += v * b0
          t7 += v * b1
          t8 += v * b2
          t9 += v * b3
          t10 += v * b4
          t11 += v * b5
          t12 += v * b6
          t13 += v * b7
          t14 += v * b8
          t15 += v * b9
          t16 += v * b10
          t17 += v * b11
          t18 += v * b12
          t19 += v * b13
          t20 += v * b14
          t21 += v * b15
          v = a[7]
          t7 += v * b0
          t8 += v * b1
          t9 += v * b2
          t10 += v * b3
          t11 += v * b4
          t12 += v * b5
          t13 += v * b6
          t14 += v * b7
          t15 += v * b8
          t16 += v * b9
          t17 += v * b10
          t18 += v * b11
          t19 += v * b12
          t20 += v * b13
          t21 += v * b14
          t22 += v * b15
          v = a[8]
          t8 += v * b0
          t9 += v * b1
          t10 += v * b2
          t11 += v * b3
          t12 += v * b4
          t13 += v * b5
          t14 += v * b6
          t15 += v * b7
          t16 += v * b8
          t17 += v * b9
          t18 += v * b10
          t19 += v * b11
          t20 += v * b12
          t21 += v * b13
          t22 += v * b14
          t23 += v * b15
          v = a[9]
          t9 += v * b0
          t10 += v * b1
          t11 += v * b2
          t12 += v * b3
          t13 += v * b4
          t14 += v * b5
          t15 += v * b6
          t16 += v * b7
          t17 += v * b8
          t18 += v * b9
          t19 += v * b10
          t20 += v * b11
          t21 += v * b12
          t22 += v * b13
          t23 += v * b14
          t24 += v * b15
          v = a[10]
          t10 += v * b0
          t11 += v * b1
          t12 += v * b2
          t13 += v * b3
          t14 += v * b4
          t15 += v * b5
          t16 += v * b6
          t17 += v * b7
          t18 += v * b8
          t19 += v * b9
          t20 += v * b10
          t21 += v * b11
          t22 += v * b12
          t23 += v * b13
          t24 += v * b14
          t25 += v * b15
          v = a[11]
          t11 += v * b0
          t12 += v * b1
          t13 += v * b2
          t14 += v * b3
          t15 += v * b4
          t16 += v * b5
          t17 += v * b6
          t18 += v * b7
          t19 += v * b8
          t20 += v * b9
          t21 += v * b10
          t22 += v * b11
          t23 += v * b12
          t24 += v * b13
          t25 += v * b14
          t26 += v * b15
          v = a[12]
          t12 += v * b0
          t13 += v * b1
          t14 += v * b2
          t15 += v * b3
          t16 += v * b4
          t17 += v * b5
          t18 += v * b6
          t19 += v * b7
          t20 += v * b8
          t21 += v * b9
          t22 += v * b10
          t23 += v * b11
          t24 += v * b12
          t25 += v * b13
          t26 += v * b14
          t27 += v * b15
          v = a[13]
          t13 += v * b0
          t14 += v * b1
          t15 += v * b2
          t16 += v * b3
          t17 += v * b4
          t18 += v * b5
          t19 += v * b6
          t20 += v * b7
          t21 += v * b8
          t22 += v * b9
          t23 += v * b10
          t24 += v * b11
          t25 += v * b12
          t26 += v * b13
          t27 += v * b14
          t28 += v * b15
          v = a[14]
          t14 += v * b0
          t15 += v * b1
          t16 += v * b2
          t17 += v * b3
          t18 += v * b4
          t19 += v * b5
          t20 += v * b6
          t21 += v * b7
          t22 += v * b8
          t23 += v * b9
          t24 += v * b10
          t25 += v * b11
          t26 += v * b12
          t27 += v * b13
          t28 += v * b14
          t29 += v * b15
          v = a[15]
          t15 += v * b0
          t16 += v * b1
          t17 += v * b2
          t18 += v * b3
          t19 += v * b4
          t20 += v * b5
          t21 += v * b6
          t22 += v * b7
          t23 += v * b8
          t24 += v * b9
          t25 += v * b10
          t26 += v * b11
          t27 += v * b12
          t28 += v * b13
          t29 += v * b14
          t30 += v * b15

          t0 += 38 * t16
          t1 += 38 * t17
          t2 += 38 * t18
          t3 += 38 * t19
          t4 += 38 * t20
          t5 += 38 * t21
          t6 += 38 * t22
          t7 += 38 * t23
          t8 += 38 * t24
          t9 += 38 * t25
          t10 += 38 * t26
          t11 += 38 * t27
          t12 += 38 * t28
          t13 += 38 * t29
          t14 += 38 * t30
          // t15 left as is

          // first car
          c = 1
          v = t0 + c + 65535
          c = Math.floor(v / 65536)
          t0 = v - c * 65536
          v = t1 + c + 65535
          c = Math.floor(v / 65536)
          t1 = v - c * 65536
          v = t2 + c + 65535
          c = Math.floor(v / 65536)
          t2 = v - c * 65536
          v = t3 + c + 65535
          c = Math.floor(v / 65536)
          t3 = v - c * 65536
          v = t4 + c + 65535
          c = Math.floor(v / 65536)
          t4 = v - c * 65536
          v = t5 + c + 65535
          c = Math.floor(v / 65536)
          t5 = v - c * 65536
          v = t6 + c + 65535
          c = Math.floor(v / 65536)
          t6 = v - c * 65536
          v = t7 + c + 65535
          c = Math.floor(v / 65536)
          t7 = v - c * 65536
          v = t8 + c + 65535
          c = Math.floor(v / 65536)
          t8 = v - c * 65536
          v = t9 + c + 65535
          c = Math.floor(v / 65536)
          t9 = v - c * 65536
          v = t10 + c + 65535
          c = Math.floor(v / 65536)
          t10 = v - c * 65536
          v = t11 + c + 65535
          c = Math.floor(v / 65536)
          t11 = v - c * 65536
          v = t12 + c + 65535
          c = Math.floor(v / 65536)
          t12 = v - c * 65536
          v = t13 + c + 65535
          c = Math.floor(v / 65536)
          t13 = v - c * 65536
          v = t14 + c + 65535
          c = Math.floor(v / 65536)
          t14 = v - c * 65536
          v = t15 + c + 65535
          c = Math.floor(v / 65536)
          t15 = v - c * 65536
          t0 += c - 1 + 37 * (c - 1)

          // second car
          c = 1
          v = t0 + c + 65535
          c = Math.floor(v / 65536)
          t0 = v - c * 65536
          v = t1 + c + 65535
          c = Math.floor(v / 65536)
          t1 = v - c * 65536
          v = t2 + c + 65535
          c = Math.floor(v / 65536)
          t2 = v - c * 65536
          v = t3 + c + 65535
          c = Math.floor(v / 65536)
          t3 = v - c * 65536
          v = t4 + c + 65535
          c = Math.floor(v / 65536)
          t4 = v - c * 65536
          v = t5 + c + 65535
          c = Math.floor(v / 65536)
          t5 = v - c * 65536
          v = t6 + c + 65535
          c = Math.floor(v / 65536)
          t6 = v - c * 65536
          v = t7 + c + 65535
          c = Math.floor(v / 65536)
          t7 = v - c * 65536
          v = t8 + c + 65535
          c = Math.floor(v / 65536)
          t8 = v - c * 65536
          v = t9 + c + 65535
          c = Math.floor(v / 65536)
          t9 = v - c * 65536
          v = t10 + c + 65535
          c = Math.floor(v / 65536)
          t10 = v - c * 65536
          v = t11 + c + 65535
          c = Math.floor(v / 65536)
          t11 = v - c * 65536
          v = t12 + c + 65535
          c = Math.floor(v / 65536)
          t12 = v - c * 65536
          v = t13 + c + 65535
          c = Math.floor(v / 65536)
          t13 = v - c * 65536
          v = t14 + c + 65535
          c = Math.floor(v / 65536)
          t14 = v - c * 65536
          v = t15 + c + 65535
          c = Math.floor(v / 65536)
          t15 = v - c * 65536
          t0 += c - 1 + 37 * (c - 1)

          o[0] = t0
          o[1] = t1
          o[2] = t2
          o[3] = t3
          o[4] = t4
          o[5] = t5
          o[6] = t6
          o[7] = t7
          o[8] = t8
          o[9] = t9
          o[10] = t10
          o[11] = t11
          o[12] = t12
          o[13] = t13
          o[14] = t14
          o[15] = t15
        }

        function S(o, a) {
          M(o, a, a)
        }

        function inv25519(o, i) {
          var c = gf()
          var a
          for (a = 0; a < 16; a++) c[a] = i[a]
          for (a = 253; a >= 0; a--) {
            S(c, c)
            if (a !== 2 && a !== 4) M(c, c, i)
          }
          for (a = 0; a < 16; a++) o[a] = c[a]
        }

        function pow2523(o, i) {
          var c = gf()
          var a
          for (a = 0; a < 16; a++) c[a] = i[a]
          for (a = 250; a >= 0; a--) {
            S(c, c)
            if (a !== 1) M(c, c, i)
          }
          for (a = 0; a < 16; a++) o[a] = c[a]
        }

        function crypto_scalarmult(q, n, p) {
          check(q, crypto_scalarmult_BYTES)
          check(n, crypto_scalarmult_SCALARBYTES)
          check(p, crypto_scalarmult_BYTES)
          var z = new Uint8Array(32)
          var x = new Float64Array(80),
            r,
            i
          var a = gf(),
            b = gf(),
            c = gf(),
            d = gf(),
            e = gf(),
            f = gf()
          for (i = 0; i < 31; i++) z[i] = n[i]
          z[31] = (n[31] & 127) | 64
          z[0] &= 248
          unpack25519(x, p)
          for (i = 0; i < 16; i++) {
            b[i] = x[i]
            d[i] = a[i] = c[i] = 0
          }
          a[0] = d[0] = 1
          for (i = 254; i >= 0; --i) {
            r = (z[i >>> 3] >>> (i & 7)) & 1
            sel25519(a, b, r)
            sel25519(c, d, r)
            A(e, a, c)
            Z(a, a, c)
            A(c, b, d)
            Z(b, b, d)
            S(d, e)
            S(f, a)
            M(a, c, a)
            M(c, b, e)
            A(e, a, c)
            Z(a, a, c)
            S(b, a)
            Z(c, d, f)
            M(a, c, _121665)
            A(a, a, d)
            M(c, c, a)
            M(a, d, f)
            M(d, b, x)
            S(b, e)
            sel25519(a, b, r)
            sel25519(c, d, r)
          }
          for (i = 0; i < 16; i++) {
            x[i + 16] = a[i]
            x[i + 32] = c[i]
            x[i + 48] = b[i]
            x[i + 64] = d[i]
          }
          var x32 = x.subarray(32)
          var x16 = x.subarray(16)
          inv25519(x32, x32)
          M(x16, x16, x32)
          pack25519(q, x16)
          return 0
        }

        function crypto_scalarmult_base(q, n) {
          return crypto_scalarmult(q, n, _9)
        }

        var K = [
          0x428a2f98,
          0xd728ae22,
          0x71374491,
          0x23ef65cd,
          0xb5c0fbcf,
          0xec4d3b2f,
          0xe9b5dba5,
          0x8189dbbc,
          0x3956c25b,
          0xf348b538,
          0x59f111f1,
          0xb605d019,
          0x923f82a4,
          0xaf194f9b,
          0xab1c5ed5,
          0xda6d8118,
          0xd807aa98,
          0xa3030242,
          0x12835b01,
          0x45706fbe,
          0x243185be,
          0x4ee4b28c,
          0x550c7dc3,
          0xd5ffb4e2,
          0x72be5d74,
          0xf27b896f,
          0x80deb1fe,
          0x3b1696b1,
          0x9bdc06a7,
          0x25c71235,
          0xc19bf174,
          0xcf692694,
          0xe49b69c1,
          0x9ef14ad2,
          0xefbe4786,
          0x384f25e3,
          0x0fc19dc6,
          0x8b8cd5b5,
          0x240ca1cc,
          0x77ac9c65,
          0x2de92c6f,
          0x592b0275,
          0x4a7484aa,
          0x6ea6e483,
          0x5cb0a9dc,
          0xbd41fbd4,
          0x76f988da,
          0x831153b5,
          0x983e5152,
          0xee66dfab,
          0xa831c66d,
          0x2db43210,
          0xb00327c8,
          0x98fb213f,
          0xbf597fc7,
          0xbeef0ee4,
          0xc6e00bf3,
          0x3da88fc2,
          0xd5a79147,
          0x930aa725,
          0x06ca6351,
          0xe003826f,
          0x14292967,
          0x0a0e6e70,
          0x27b70a85,
          0x46d22ffc,
          0x2e1b2138,
          0x5c26c926,
          0x4d2c6dfc,
          0x5ac42aed,
          0x53380d13,
          0x9d95b3df,
          0x650a7354,
          0x8baf63de,
          0x766a0abb,
          0x3c77b2a8,
          0x81c2c92e,
          0x47edaee6,
          0x92722c85,
          0x1482353b,
          0xa2bfe8a1,
          0x4cf10364,
          0xa81a664b,
          0xbc423001,
          0xc24b8b70,
          0xd0f89791,
          0xc76c51a3,
          0x0654be30,
          0xd192e819,
          0xd6ef5218,
          0xd6990624,
          0x5565a910,
          0xf40e3585,
          0x5771202a,
          0x106aa070,
          0x32bbd1b8,
          0x19a4c116,
          0xb8d2d0c8,
          0x1e376c08,
          0x5141ab53,
          0x2748774c,
          0xdf8eeb99,
          0x34b0bcb5,
          0xe19b48a8,
          0x391c0cb3,
          0xc5c95a63,
          0x4ed8aa4a,
          0xe3418acb,
          0x5b9cca4f,
          0x7763e373,
          0x682e6ff3,
          0xd6b2b8a3,
          0x748f82ee,
          0x5defb2fc,
          0x78a5636f,
          0x43172f60,
          0x84c87814,
          0xa1f0ab72,
          0x8cc70208,
          0x1a6439ec,
          0x90befffa,
          0x23631e28,
          0xa4506ceb,
          0xde82bde9,
          0xbef9a3f7,
          0xb2c67915,
          0xc67178f2,
          0xe372532b,
          0xca273ece,
          0xea26619c,
          0xd186b8c7,
          0x21c0c207,
          0xeada7dd6,
          0xcde0eb1e,
          0xf57d4f7f,
          0xee6ed178,
          0x06f067aa,
          0x72176fba,
          0x0a637dc5,
          0xa2c898a6,
          0x113f9804,
          0xbef90dae,
          0x1b710b35,
          0x131c471b,
          0x28db77f5,
          0x23047d84,
          0x32caab7b,
          0x40c72493,
          0x3c9ebe0a,
          0x15c9bebc,
          0x431d67c4,
          0x9c100d4c,
          0x4cc5d4be,
          0xcb3e42b6,
          0x597f299c,
          0xfc657e2a,
          0x5fcb6fab,
          0x3ad6faec,
          0x6c44198c,
          0x4a475817
        ]

        function crypto_hashblocks_hl(hh, hl, m, n) {
          var wh = new Int32Array(16),
            wl = new Int32Array(16),
            bh0,
            bh1,
            bh2,
            bh3,
            bh4,
            bh5,
            bh6,
            bh7,
            bl0,
            bl1,
            bl2,
            bl3,
            bl4,
            bl5,
            bl6,
            bl7,
            th,
            tl,
            i,
            j,
            h,
            l,
            a,
            b,
            c,
            d

          var ah0 = hh[0],
            ah1 = hh[1],
            ah2 = hh[2],
            ah3 = hh[3],
            ah4 = hh[4],
            ah5 = hh[5],
            ah6 = hh[6],
            ah7 = hh[7],
            al0 = hl[0],
            al1 = hl[1],
            al2 = hl[2],
            al3 = hl[3],
            al4 = hl[4],
            al5 = hl[5],
            al6 = hl[6],
            al7 = hl[7]

          var pos = 0
          while (n >= 128) {
            for (i = 0; i < 16; i++) {
              j = 8 * i + pos
              wh[i] =
                (m[j + 0] << 24) | (m[j + 1] << 16) | (m[j + 2] << 8) | m[j + 3]
              wl[i] =
                (m[j + 4] << 24) | (m[j + 5] << 16) | (m[j + 6] << 8) | m[j + 7]
            }
            for (i = 0; i < 80; i++) {
              bh0 = ah0
              bh1 = ah1
              bh2 = ah2
              bh3 = ah3
              bh4 = ah4
              bh5 = ah5
              bh6 = ah6
              bh7 = ah7

              bl0 = al0
              bl1 = al1
              bl2 = al2
              bl3 = al3
              bl4 = al4
              bl5 = al5
              bl6 = al6
              bl7 = al7

              // add
              h = ah7
              l = al7

              a = l & 0xffff
              b = l >>> 16
              c = h & 0xffff
              d = h >>> 16

              // Sigma1
              h =
                ((ah4 >>> 14) | (al4 << (32 - 14))) ^
                ((ah4 >>> 18) | (al4 << (32 - 18))) ^
                ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))))
              l =
                ((al4 >>> 14) | (ah4 << (32 - 14))) ^
                ((al4 >>> 18) | (ah4 << (32 - 18))) ^
                ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))))

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // Ch
              h = (ah4 & ah5) ^ (~ah4 & ah6)
              l = (al4 & al5) ^ (~al4 & al6)

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // K
              h = K[i * 2]
              l = K[i * 2 + 1]

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // w
              h = wh[i % 16]
              l = wl[i % 16]

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              b += a >>> 16
              c += b >>> 16
              d += c >>> 16

              th = (c & 0xffff) | (d << 16)
              tl = (a & 0xffff) | (b << 16)

              // add
              h = th
              l = tl

              a = l & 0xffff
              b = l >>> 16
              c = h & 0xffff
              d = h >>> 16

              // Sigma0
              h =
                ((ah0 >>> 28) | (al0 << (32 - 28))) ^
                ((al0 >>> (34 - 32)) | (ah0 << (32 - (34 - 32)))) ^
                ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))))
              l =
                ((al0 >>> 28) | (ah0 << (32 - 28))) ^
                ((ah0 >>> (34 - 32)) | (al0 << (32 - (34 - 32)))) ^
                ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))))

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // Maj
              h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2)
              l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2)

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              b += a >>> 16
              c += b >>> 16
              d += c >>> 16

              bh7 = (c & 0xffff) | (d << 16)
              bl7 = (a & 0xffff) | (b << 16)

              // add
              h = bh3
              l = bl3

              a = l & 0xffff
              b = l >>> 16
              c = h & 0xffff
              d = h >>> 16

              h = th
              l = tl

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              b += a >>> 16
              c += b >>> 16
              d += c >>> 16

              bh3 = (c & 0xffff) | (d << 16)
              bl3 = (a & 0xffff) | (b << 16)

              ah1 = bh0
              ah2 = bh1
              ah3 = bh2
              ah4 = bh3
              ah5 = bh4
              ah6 = bh5
              ah7 = bh6
              ah0 = bh7

              al1 = bl0
              al2 = bl1
              al3 = bl2
              al4 = bl3
              al5 = bl4
              al6 = bl5
              al7 = bl6
              al0 = bl7

              if (i % 16 === 15) {
                for (j = 0; j < 16; j++) {
                  // add
                  h = wh[j]
                  l = wl[j]

                  a = l & 0xffff
                  b = l >>> 16
                  c = h & 0xffff
                  d = h >>> 16

                  h = wh[(j + 9) % 16]
                  l = wl[(j + 9) % 16]

                  a += l & 0xffff
                  b += l >>> 16
                  c += h & 0xffff
                  d += h >>> 16

                  // sigma0
                  th = wh[(j + 1) % 16]
                  tl = wl[(j + 1) % 16]
                  h =
                    ((th >>> 1) | (tl << (32 - 1))) ^
                    ((th >>> 8) | (tl << (32 - 8))) ^
                    (th >>> 7)
                  l =
                    ((tl >>> 1) | (th << (32 - 1))) ^
                    ((tl >>> 8) | (th << (32 - 8))) ^
                    ((tl >>> 7) | (th << (32 - 7)))

                  a += l & 0xffff
                  b += l >>> 16
                  c += h & 0xffff
                  d += h >>> 16

                  // sigma1
                  th = wh[(j + 14) % 16]
                  tl = wl[(j + 14) % 16]
                  h =
                    ((th >>> 19) | (tl << (32 - 19))) ^
                    ((tl >>> (61 - 32)) | (th << (32 - (61 - 32)))) ^
                    (th >>> 6)
                  l =
                    ((tl >>> 19) | (th << (32 - 19))) ^
                    ((th >>> (61 - 32)) | (tl << (32 - (61 - 32)))) ^
                    ((tl >>> 6) | (th << (32 - 6)))

                  a += l & 0xffff
                  b += l >>> 16
                  c += h & 0xffff
                  d += h >>> 16

                  b += a >>> 16
                  c += b >>> 16
                  d += c >>> 16

                  wh[j] = (c & 0xffff) | (d << 16)
                  wl[j] = (a & 0xffff) | (b << 16)
                }
              }
            }

            // add
            h = ah0
            l = al0

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[0]
            l = hl[0]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[0] = ah0 = (c & 0xffff) | (d << 16)
            hl[0] = al0 = (a & 0xffff) | (b << 16)

            h = ah1
            l = al1

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[1]
            l = hl[1]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[1] = ah1 = (c & 0xffff) | (d << 16)
            hl[1] = al1 = (a & 0xffff) | (b << 16)

            h = ah2
            l = al2

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[2]
            l = hl[2]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[2] = ah2 = (c & 0xffff) | (d << 16)
            hl[2] = al2 = (a & 0xffff) | (b << 16)

            h = ah3
            l = al3

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[3]
            l = hl[3]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[3] = ah3 = (c & 0xffff) | (d << 16)
            hl[3] = al3 = (a & 0xffff) | (b << 16)

            h = ah4
            l = al4

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[4]
            l = hl[4]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[4] = ah4 = (c & 0xffff) | (d << 16)
            hl[4] = al4 = (a & 0xffff) | (b << 16)

            h = ah5
            l = al5

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[5]
            l = hl[5]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[5] = ah5 = (c & 0xffff) | (d << 16)
            hl[5] = al5 = (a & 0xffff) | (b << 16)

            h = ah6
            l = al6

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[6]
            l = hl[6]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[6] = ah6 = (c & 0xffff) | (d << 16)
            hl[6] = al6 = (a & 0xffff) | (b << 16)

            h = ah7
            l = al7

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[7]
            l = hl[7]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[7] = ah7 = (c & 0xffff) | (d << 16)
            hl[7] = al7 = (a & 0xffff) | (b << 16)

            pos += 128
            n -= 128
          }

          return n
        }

        function crypto_hash(out, m, n) {
          var hh = new Int32Array(8),
            hl = new Int32Array(8),
            x = new Uint8Array(256),
            i,
            b = n

          hh[0] = 0x6a09e667
          hh[1] = 0xbb67ae85
          hh[2] = 0x3c6ef372
          hh[3] = 0xa54ff53a
          hh[4] = 0x510e527f
          hh[5] = 0x9b05688c
          hh[6] = 0x1f83d9ab
          hh[7] = 0x5be0cd19

          hl[0] = 0xf3bcc908
          hl[1] = 0x84caa73b
          hl[2] = 0xfe94f82b
          hl[3] = 0x5f1d36f1
          hl[4] = 0xade682d1
          hl[5] = 0x2b3e6c1f
          hl[6] = 0xfb41bd6b
          hl[7] = 0x137e2179

          crypto_hashblocks_hl(hh, hl, m, n)
          n %= 128

          for (i = 0; i < n; i++) x[i] = m[b - n + i]
          x[n] = 128

          n = 256 - 128 * (n < 112 ? 1 : 0)
          x[n - 9] = 0
          ts64(x, n - 8, (b / 0x20000000) | 0, b << 3)
          crypto_hashblocks_hl(hh, hl, x, n)

          for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i])

          return 0
        }

        function add(p, q) {
          var a = gf(),
            b = gf(),
            c = gf(),
            d = gf(),
            e = gf(),
            f = gf(),
            g = gf(),
            h = gf(),
            t = gf()

          Z(a, p[1], p[0])
          Z(t, q[1], q[0])
          M(a, a, t)
          A(b, p[0], p[1])
          A(t, q[0], q[1])
          M(b, b, t)
          M(c, p[3], q[3])
          M(c, c, D2)
          M(d, p[2], q[2])
          A(d, d, d)
          Z(e, b, a)
          Z(f, d, c)
          A(g, d, c)
          A(h, b, a)

          M(p[0], e, f)
          M(p[1], h, g)
          M(p[2], g, f)
          M(p[3], e, h)
        }

        function cswap(p, q, b) {
          var i
          for (i = 0; i < 4; i++) {
            sel25519(p[i], q[i], b)
          }
        }

        function pack(r, p) {
          var tx = gf(),
            ty = gf(),
            zi = gf()
          inv25519(zi, p[2])
          M(tx, p[0], zi)
          M(ty, p[1], zi)
          pack25519(r, ty)
          r[31] ^= par25519(tx) << 7
        }

        function scalarmult(p, q, s) {
          var b, i
          set25519(p[0], gf0)
          set25519(p[1], gf1)
          set25519(p[2], gf1)
          set25519(p[3], gf0)
          for (i = 255; i >= 0; --i) {
            b = (s[(i / 8) | 0] >> (i & 7)) & 1
            cswap(p, q, b)
            add(q, p)
            add(p, p)
            cswap(p, q, b)
          }
        }

        function scalarbase(p, s) {
          var q = [gf(), gf(), gf(), gf()]
          set25519(q[0], X)
          set25519(q[1], Y)
          set25519(q[2], gf1)
          M(q[3], X, Y)
          scalarmult(p, q, s)
        }

        function crypto_sign_keypair(pk, sk, seeded) {
          check(pk, sodium.crypto_sign_PUBLICKEYBYTES)
          check(sk, sodium.crypto_sign_SECRETKEYBYTES)

          var d = new Uint8Array(64)
          var p = [gf(), gf(), gf(), gf()]
          var i

          if (!seeded) randombytes(sk, 32)
          crypto_hash(d, sk, 32)
          d[0] &= 248
          d[31] &= 127
          d[31] |= 64

          scalarbase(p, d)
          pack(pk, p)

          for (i = 0; i < 32; i++) sk[i + 32] = pk[i]
          return 0
        }

        function crypto_sign_seed_keypair(pk, sk, seed) {
          check(seed, sodium.crypto_sign_SEEDBYTES)
          seed.copy(sk)
          crypto_sign_keypair(pk, sk, true)
        }

        var L = new Float64Array([
          0xed,
          0xd3,
          0xf5,
          0x5c,
          0x1a,
          0x63,
          0x12,
          0x58,
          0xd6,
          0x9c,
          0xf7,
          0xa2,
          0xde,
          0xf9,
          0xde,
          0x14,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0x10
        ])

        function modL(r, x) {
          var carry, i, j, k
          for (i = 63; i >= 32; --i) {
            carry = 0
            for (j = i - 32, k = i - 12; j < k; ++j) {
              x[j] += carry - 16 * x[i] * L[j - (i - 32)]
              carry = (x[j] + 128) >> 8
              x[j] -= carry * 256
            }
            x[j] += carry
            x[i] = 0
          }
          carry = 0
          for (j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j]
            carry = x[j] >> 8
            x[j] &= 255
          }
          for (j = 0; j < 32; j++) x[j] -= carry * L[j]
          for (i = 0; i < 32; i++) {
            x[i + 1] += x[i] >> 8
            r[i] = x[i] & 255
          }
        }

        function reduce(r) {
          var x = new Float64Array(64),
            i
          for (i = 0; i < 64; i++) x[i] = r[i]
          for (i = 0; i < 64; i++) r[i] = 0
          modL(r, x)
        }

        // Note: difference from C - smlen returned, not passed as argument.
        function crypto_sign(sm, m, sk) {
          check(sm, crypto_sign_BYTES + m.length)
          check(m, 0)
          check(sk, crypto_sign_SECRETKEYBYTES)
          var n = m.length

          var d = new Uint8Array(64),
            h = new Uint8Array(64),
            r = new Uint8Array(64)
          var i,
            j,
            x = new Float64Array(64)
          var p = [gf(), gf(), gf(), gf()]

          crypto_hash(d, sk, 32)
          d[0] &= 248
          d[31] &= 127
          d[31] |= 64

          var smlen = n + 64
          for (i = 0; i < n; i++) sm[64 + i] = m[i]
          for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i]

          crypto_hash(r, sm.subarray(32), n + 32)
          reduce(r)
          scalarbase(p, r)
          pack(sm, p)

          for (i = 32; i < 64; i++) sm[i] = sk[i]
          crypto_hash(h, sm, n + 64)
          reduce(h)

          for (i = 0; i < 64; i++) x[i] = 0
          for (i = 0; i < 32; i++) x[i] = r[i]
          for (i = 0; i < 32; i++) {
            for (j = 0; j < 32; j++) {
              x[i + j] += h[i] * d[j]
            }
          }

          modL(sm.subarray(32), x)
        }

        function crypto_sign_detached(sig, m, sk) {
          var sm = new Uint8Array(m.length + crypto_sign_BYTES)
          crypto_sign(sm, m, sk)
          for (var i = 0; i < crypto_sign_BYTES; i++) sig[i] = sm[i]
        }

        function unpackneg(r, p) {
          var t = gf(),
            chk = gf(),
            num = gf(),
            den = gf(),
            den2 = gf(),
            den4 = gf(),
            den6 = gf()

          set25519(r[2], gf1)
          unpack25519(r[1], p)
          S(num, r[1])
          M(den, num, D)
          Z(num, num, r[2])
          A(den, r[2], den)

          S(den2, den)
          S(den4, den2)
          M(den6, den4, den2)
          M(t, den6, num)
          M(t, t, den)

          pow2523(t, t)
          M(t, t, num)
          M(t, t, den)
          M(t, t, den)
          M(r[0], t, den)

          S(chk, r[0])
          M(chk, chk, den)
          if (neq25519(chk, num)) M(r[0], r[0], I)

          S(chk, r[0])
          M(chk, chk, den)
          if (neq25519(chk, num)) return -1

          if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0])

          M(r[3], r[0], r[1])
          return 0
        }

        function crypto_sign_open(msg, sm, pk) {
          check(msg, sm.length - crypto_sign_BYTES)
          check(sm, crypto_sign_BYTES)
          check(pk, crypto_sign_PUBLICKEYBYTES)
          var n = sm.length
          var m = new Uint8Array(sm.length)

          var i, mlen
          var t = new Uint8Array(32),
            h = new Uint8Array(64)
          var p = [gf(), gf(), gf(), gf()],
            q = [gf(), gf(), gf(), gf()]

          mlen = -1
          if (n < 64) return false

          if (unpackneg(q, pk)) return false

          for (i = 0; i < n; i++) m[i] = sm[i]
          for (i = 0; i < 32; i++) m[i + 32] = pk[i]
          crypto_hash(h, m, n)
          reduce(h)
          scalarmult(p, q, h)

          scalarbase(q, sm.subarray(32))
          add(p, q)
          pack(t, p)

          n -= 64
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i = 0; i < n; i++) m[i] = 0
            return false
          }

          for (i = 0; i < n; i++) msg[i] = sm[i + 64]
          mlen = n
          return true
        }

        function crypto_sign_verify_detached(sig, m, pk) {
          check(sig, crypto_sign_BYTES)
          var sm = new Uint8Array(m.length + crypto_sign_BYTES)
          var i = 0
          for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i]
          for (i = 0; i < m.length; i++) sm[i + crypto_sign_BYTES] = m[i]
          return crypto_sign_open(m, sm, pk)
        }

        function crypto_secretbox_detached(o, mac, msg, n, k) {
          check(mac, sodium.crypto_secretbox_MACBYTES)
          var tmp = new Uint8Array(msg.length + mac.length)
          crypto_secretbox_easy(tmp, msg, n, k)
          o.set(tmp.subarray(0, msg.length))
          mac.set(tmp.subarray(msg.length))
        }

        function crypto_secretbox_open_detached(msg, o, mac, n, k) {
          check(mac, sodium.crypto_secretbox_MACBYTES)
          var tmp = new Uint8Array(o.length + mac.length)
          tmp.set(o)
          tmp.set(mac, msg.length)
          return crypto_secretbox_open_easy(msg, tmp, n, k)
        }

        function crypto_secretbox_easy(o, msg, n, k) {
          check(msg, 0)
          check(o, msg.length + sodium.crypto_secretbox_MACBYTES)
          check(n, crypto_secretbox_NONCEBYTES)
          check(k, crypto_secretbox_KEYBYTES)

          var i
          var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length)
          var c = new Uint8Array(m.length)
          for (i = 0; i < msg.length; i++)
            m[i + crypto_secretbox_ZEROBYTES] = msg[i]
          crypto_secretbox(c, m, m.length, n, k)
          for (i = crypto_secretbox_BOXZEROBYTES; i < c.length; i++)
            o[i - crypto_secretbox_BOXZEROBYTES] = c[i]
        }

        function crypto_secretbox_open_easy(msg, box, n, k) {
          check(box, sodium.crypto_secretbox_MACBYTES)
          check(msg, box.length - sodium.crypto_secretbox_MACBYTES)
          check(n, crypto_secretbox_NONCEBYTES)
          check(k, crypto_secretbox_KEYBYTES)

          var i
          var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length)
          var m = new Uint8Array(c.length)
          for (i = 0; i < box.length; i++)
            c[i + crypto_secretbox_BOXZEROBYTES] = box[i]
          if (c.length < 32) return false
          if (crypto_secretbox_open(m, c, c.length, n, k) !== 0) return false

          for (i = crypto_secretbox_ZEROBYTES; i < m.length; i++)
            msg[i - crypto_secretbox_ZEROBYTES] = m[i]
          return true
        }

        var crypto_secretbox_KEYBYTES = 32,
          crypto_secretbox_NONCEBYTES = 24,
          crypto_secretbox_ZEROBYTES = 32,
          crypto_secretbox_BOXZEROBYTES = 16,
          crypto_scalarmult_BYTES = 32,
          crypto_scalarmult_SCALARBYTES = 32,
          crypto_box_PUBLICKEYBYTES = 32,
          crypto_box_SECRETKEYBYTES = 32,
          crypto_box_BEFORENMBYTES = 32,
          crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
          crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
          crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
          crypto_sign_BYTES = 64,
          crypto_sign_PUBLICKEYBYTES = 32,
          crypto_sign_SECRETKEYBYTES = 64,
          crypto_sign_SEEDBYTES = 32,
          crypto_hash_BYTES = 64

        sodium.memzero = function(len, offset) {
          for (var i = offset; i < len; i++) arr[i] = 0
        }

        sodium.crypto_sign_BYTES = crypto_sign_BYTES
        sodium.crypto_sign_PUBLICKEYBYTES = crypto_sign_PUBLICKEYBYTES
        sodium.crypto_sign_SECRETKEYBYTES = crypto_sign_SECRETKEYBYTES
        sodium.crypto_sign_SEEDBYTES = crypto_sign_SEEDBYTES
        sodium.crypto_sign_keypair = crypto_sign_keypair
        sodium.crypto_sign_seed_keypair = crypto_sign_seed_keypair
        sodium.crypto_sign = crypto_sign
        sodium.crypto_sign_open = crypto_sign_open
        sodium.crypto_sign_detached = crypto_sign_detached
        sodium.crypto_sign_verify_detached = crypto_sign_verify_detached

        forward(require("./crypto_generichash"))
        forward(require("./crypto_kdf"))
        forward(require("./crypto_shorthash"))
        forward(require("./randombytes"))
        forward(require("./crypto_stream"))

        sodium.crypto_scalarmult_BYTES = crypto_scalarmult_BYTES
        sodium.crypto_scalarmult_SCALARBYTES = crypto_scalarmult_SCALARBYTES
        sodium.crypto_scalarmult_base = crypto_scalarmult_base
        sodium.crypto_scalarmult = crypto_scalarmult

        ;(sodium.crypto_secretbox_KEYBYTES = crypto_secretbox_KEYBYTES),
          (sodium.crypto_secretbox_NONCEBYTES = crypto_secretbox_NONCEBYTES),
          (sodium.crypto_secretbox_MACBYTES = 16)
        sodium.crypto_secretbox_easy = crypto_secretbox_easy
        sodium.crypto_secretbox_open_easy = crypto_secretbox_open_easy
        sodium.crypto_secretbox_detached = crypto_secretbox_detached
        sodium.crypto_secretbox_open_detached = crypto_secretbox_open_detached

        function cleanup(arr) {
          for (var i = 0; i < arr.length; i++) arr[i] = 0
        }

        function check(buf, len) {
          if (!buf || (len && buf.length < len))
            throw new Error(
              "Argument must be a buffer" + (len ? " of length " + len : "")
            )
        }

        function forward(submodule) {
          Object.keys(submodule).forEach(function(prop) {
            module.exports[prop] = submodule[prop]
          })
        }
      },
      {
        "./crypto_generichash": 64,
        "./crypto_kdf": 65,
        "./crypto_shorthash": 66,
        "./crypto_stream": 67,
        "./randombytes": 69
      }
    ],
    69: [
      function(require, module, exports) {
        ;(function(global) {
          var assert = require("nanoassert")
          var randombytes = (function() {
            var QUOTA = 65536 // limit for QuotaExceededException
            var crypto =
              typeof global !== "undefined"
                ? (crypto = global.crypto || global.msCrypto)
                : null

            function browserBytes(out, n) {
              for (var i = 0; i < n; i += QUOTA) {
                crypto.getRandomValues(
                  out.subarray(i, i + Math.min(n - i, QUOTA))
                )
              }
            }

            function nodeBytes(out, n) {
              out.set(crypto.randomBytes(n))
            }

            function noImpl() {
              throw new Error("No secure random number generator available")
            }

            if (crypto && crypto.getRandomValues) {
              return browserBytes
            } else if (typeof require !== "undefined") {
              // Node.js.
              crypto = require("crypto")
              if (crypto && crypto.randomBytes) {
                return nodeBytes
              }
            }

            return noImpl
          })()

          Object.defineProperty(module.exports, "randombytes", {
            value: randombytes
          })

          module.exports.randombytes_buf = function(out) {
            assert(out, "out must be given")
            randombytes(out, out.length)
          }
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {}
        ))
      },
      { crypto: 14, nanoassert: 42 }
    ],
    70: [
      function(require, module, exports) {
        module.exports = require("sodium-javascript")
      },
      { "sodium-javascript": 68 }
    ],
    71: [
      function(require, module, exports) {
        module.exports = indexOf

        function indexOf(left, right) {
          var result = new Array(right.length)
          var i = 0
          var j = 0

          while (i < left.length && j < right.length) {
            var a = left[i]
            var b = right[j]

            if (a === b) {
              result[j++] = i
              continue
            }

            if (a < b) {
              i++
              continue
            }

            result[j++] = -1
            continue
          }

          for (; j < right.length; j++) result[j] = -1

          return result
        }
      },
      {}
    ],
    72: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var pager = require("memory-pager")

          module.exports = Bitfield

          function Bitfield(opts) {
            if (!(this instanceof Bitfield)) return new Bitfield(opts)
            if (!opts) opts = {}
            if (Buffer.isBuffer(opts)) opts = { buffer: opts }

            this.pageOffset = opts.pageOffset || 0
            this.pageSize = opts.pageSize || 1024
            this.pages = opts.pages || pager(this.pageSize)

            this.byteLength = this.pages.length * this.pageSize
            this.length = 8 * this.byteLength

            if (!powerOfTwo(this.pageSize))
              throw new Error("The page size should be a power of two")

            this._trackUpdates = !!opts.trackUpdates
            this._pageMask = this.pageSize - 1

            if (opts.buffer) {
              for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
                this.pages.set(
                  i / this.pageSize,
                  opts.buffer.slice(i, i + this.pageSize)
                )
              }
              this.byteLength = opts.buffer.length
              this.length = 8 * this.byteLength
            }
          }

          Bitfield.prototype.get = function(i) {
            var o = i & 7
            var j = (i - o) / 8

            return !!(this.getByte(j) & (128 >> o))
          }

          Bitfield.prototype.getByte = function(i) {
            var o = i & this._pageMask
            var j = (i - o) / this.pageSize
            var page = this.pages.get(j, true)

            return page ? page.buffer[o + this.pageOffset] : 0
          }

          Bitfield.prototype.set = function(i, v) {
            var o = i & 7
            var j = (i - o) / 8
            var b = this.getByte(j)

            return this.setByte(j, v ? b | (128 >> o) : b & (255 ^ (128 >> o)))
          }

          Bitfield.prototype.toBuffer = function() {
            var all = alloc(this.pages.length * this.pageSize)

            for (var i = 0; i < this.pages.length; i++) {
              var next = this.pages.get(i, true)
              var allOffset = i * this.pageSize
              if (next)
                next.buffer.copy(
                  all,
                  allOffset,
                  this.pageOffset,
                  this.pageOffset + this.pageSize
                )
            }

            return all
          }

          Bitfield.prototype.setByte = function(i, b) {
            var o = i & this._pageMask
            var j = (i - o) / this.pageSize
            var page = this.pages.get(j, false)

            o += this.pageOffset

            if (page.buffer[o] === b) return false
            page.buffer[o] = b

            if (i >= this.byteLength) {
              this.byteLength = i + 1
              this.length = this.byteLength * 8
            }

            if (this._trackUpdates) this.pages.updated(page)

            return true
          }

          function alloc(n) {
            if (Buffer.alloc) return Buffer.alloc(n)
            var b = new Buffer(n)
            b.fill(0)
            return b
          }

          function powerOfTwo(x) {
            return !(x & (x - 1))
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "memory-pager": 40 }
    ],
    73: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict"

        /*<replacement>*/

        var Buffer = require("safe-buffer").Buffer
        /*</replacement>*/

        var isEncoding =
          Buffer.isEncoding ||
          function(encoding) {
            encoding = "" + encoding
            switch (encoding && encoding.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return true
              default:
                return false
            }
          }

        function _normalizeEncoding(enc) {
          if (!enc) return "utf8"
          var retried
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8"
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le"
              case "latin1":
              case "binary":
                return "latin1"
              case "base64":
              case "ascii":
              case "hex":
                return enc
              default:
                if (retried) return // undefined
                enc = ("" + enc).toLowerCase()
                retried = true
            }
          }
        }

        // Do not cache `Buffer.isEncoding` when checking encoding names as some
        // modules monkey-patch it to support additional encodings
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc)
          if (
            typeof nenc !== "string" &&
            (Buffer.isEncoding === isEncoding || !isEncoding(enc))
          )
            throw new Error("Unknown encoding: " + enc)
          return nenc || enc
        }

        // StringDecoder provides an interface for efficiently splitting a series of
        // buffers into a series of JS strings without breaking apart multi-byte
        // characters.
        exports.StringDecoder = StringDecoder
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding)
          var nb
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text
              this.end = utf16End
              nb = 4
              break
            case "utf8":
              this.fillLast = utf8FillLast
              nb = 4
              break
            case "base64":
              this.text = base64Text
              this.end = base64End
              nb = 3
              break
            default:
              this.write = simpleWrite
              this.end = simpleEnd
              return
          }
          this.lastNeed = 0
          this.lastTotal = 0
          this.lastChar = Buffer.allocUnsafe(nb)
        }

        StringDecoder.prototype.write = function(buf) {
          if (buf.length === 0) return ""
          var r
          var i
          if (this.lastNeed) {
            r = this.fillLast(buf)
            if (r === undefined) return ""
            i = this.lastNeed
            this.lastNeed = 0
          } else {
            i = 0
          }
          if (i < buf.length)
            return r ? r + this.text(buf, i) : this.text(buf, i)
          return r || ""
        }

        StringDecoder.prototype.end = utf8End

        // Returns only complete characters in a Buffer
        StringDecoder.prototype.text = utf8Text

        // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
        StringDecoder.prototype.fillLast = function(buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(
              this.lastChar,
              this.lastTotal - this.lastNeed,
              0,
              this.lastNeed
            )
            return this.lastChar.toString(this.encoding, 0, this.lastTotal)
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length)
          this.lastNeed -= buf.length
        }

        // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
        // continuation byte. If an invalid byte is detected, -2 is returned.
        function utf8CheckByte(byte) {
          if (byte <= 0x7f) return 0
          else if (byte >> 5 === 0x06) return 2
          else if (byte >> 4 === 0x0e) return 3
          else if (byte >> 3 === 0x1e) return 4
          return byte >> 6 === 0x02 ? -1 : -2
        }

        // Checks at most 3 bytes at the end of a Buffer in order to detect an
        // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
        // needed to complete the UTF-8 character (if applicable) are returned.
        function utf8CheckIncomplete(self, buf, i) {
          var j = buf.length - 1
          if (j < i) return 0
          var nb = utf8CheckByte(buf[j])
          if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 1
            return nb
          }
          if (--j < i || nb === -2) return 0
          nb = utf8CheckByte(buf[j])
          if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 2
            return nb
          }
          if (--j < i || nb === -2) return 0
          nb = utf8CheckByte(buf[j])
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2) nb = 0
              else self.lastNeed = nb - 3
            }
            return nb
          }
          return 0
        }

        // Validates as many continuation bytes for a multi-byte UTF-8 character as
        // needed or are available. If we see a non-continuation byte where we expect
        // one, we "replace" the validated continuation bytes we've seen so far with
        // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
        // behavior. The continuation byte check is included three times in the case
        // where all of the continuation bytes for a character exist in the same buffer.
        // It is also done this way as a slight performance increase instead of using a
        // loop.
        function utf8CheckExtraBytes(self, buf, p) {
          if ((buf[0] & 0xc0) !== 0x80) {
            self.lastNeed = 0
            return "\ufffd"
          }
          if (self.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 0xc0) !== 0x80) {
              self.lastNeed = 1
              return "\ufffd"
            }
            if (self.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 0xc0) !== 0x80) {
                self.lastNeed = 2
                return "\ufffd"
              }
            }
          }
        }

        // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed
          var r = utf8CheckExtraBytes(this, buf, p)
          if (r !== undefined) return r
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed)
            return this.lastChar.toString(this.encoding, 0, this.lastTotal)
          }
          buf.copy(this.lastChar, p, 0, buf.length)
          this.lastNeed -= buf.length
        }

        // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
        // partial character, the character's bytes are buffered until the required
        // number of bytes are available.
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i)
          if (!this.lastNeed) return buf.toString("utf8", i)
          this.lastTotal = total
          var end = buf.length - (total - this.lastNeed)
          buf.copy(this.lastChar, 0, end)
          return buf.toString("utf8", i, end)
        }

        // For UTF-8, a replacement character is added when ending on a partial
        // character.
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : ""
          if (this.lastNeed) return r + "\ufffd"
          return r
        }

        // UTF-16LE typically needs two bytes per character, but even if we have an even
        // number of bytes available, we need to check if we end on a leading/high
        // surrogate. In that case, we need to wait for the next two bytes in order to
        // decode the last character properly.
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i)
            if (r) {
              var c = r.charCodeAt(r.length - 1)
              if (c >= 0xd800 && c <= 0xdbff) {
                this.lastNeed = 2
                this.lastTotal = 4
                this.lastChar[0] = buf[buf.length - 2]
                this.lastChar[1] = buf[buf.length - 1]
                return r.slice(0, -1)
              }
            }
            return r
          }
          this.lastNeed = 1
          this.lastTotal = 2
          this.lastChar[0] = buf[buf.length - 1]
          return buf.toString("utf16le", i, buf.length - 1)
        }

        // For UTF-16LE we do not explicitly append special replacement characters if we
        // end on a partial character, we simply let v8 handle that.
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : ""
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed
            return r + this.lastChar.toString("utf16le", 0, end)
          }
          return r
        }

        function base64Text(buf, i) {
          var n = (buf.length - i) % 3
          if (n === 0) return buf.toString("base64", i)
          this.lastNeed = 3 - n
          this.lastTotal = 3
          if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1]
          } else {
            this.lastChar[0] = buf[buf.length - 2]
            this.lastChar[1] = buf[buf.length - 1]
          }
          return buf.toString("base64", i, buf.length - n)
        }

        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : ""
          if (this.lastNeed)
            return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed)
          return r
        }

        // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
        function simpleWrite(buf) {
          return buf.toString(this.encoding)
        }

        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : ""
        }
      },
      { "safe-buffer": 59 }
    ],
    74: [
      function(require, module, exports) {
        ;(function(process) {
          "use strict"

          var nextTick = nextTickArgs
          process.nextTick(upgrade, 42) // pass 42 and see if upgrade is called with it

          module.exports = thunky

          function thunky(fn) {
            var state = run
            return thunk

            function thunk(callback) {
              state(callback || noop)
            }

            function run(callback) {
              var stack = [callback]
              state = wait
              fn(done)

              function wait(callback) {
                stack.push(callback)
              }

              function done(err) {
                var args = arguments
                state = isError(err) ? run : finished
                while (stack.length) finished(stack.shift())

                function finished(callback) {
                  nextTick(apply, callback, args)
                }
              }
            }
          }

          function isError(err) {
            // inlined from util so this works in the browser
            return Object.prototype.toString.call(err) === "[object Error]"
          }

          function noop() {}

          function apply(callback, args) {
            callback.apply(null, args)
          }

          function upgrade(val) {
            if (val === 42) nextTick = process.nextTick
          }

          function nextTickArgs(fn, a, b) {
            process.nextTick(function() {
              fn(a, b)
            })
          }
        }.call(this, require("_process")))
      },
      { _process: 44 }
    ],
    75: [
      function(require, module, exports) {
        ;(function(setImmediate, clearImmediate) {
          var nextTick = require("process/browser.js").nextTick
          var apply = Function.prototype.apply
          var slice = Array.prototype.slice
          var immediateIds = {}
          var nextImmediateId = 0

          // DOM APIs, for completeness

          exports.setTimeout = function() {
            return new Timeout(
              apply.call(setTimeout, window, arguments),
              clearTimeout
            )
          }
          exports.setInterval = function() {
            return new Timeout(
              apply.call(setInterval, window, arguments),
              clearInterval
            )
          }
          exports.clearTimeout = exports.clearInterval = function(timeout) {
            timeout.close()
          }

          function Timeout(id, clearFn) {
            this._id = id
            this._clearFn = clearFn
          }
          Timeout.prototype.unref = Timeout.prototype.ref = function() {}
          Timeout.prototype.close = function() {
            this._clearFn.call(window, this._id)
          }

          // Does not start the time, just sets up the members needed.
          exports.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId)
            item._idleTimeout = msecs
          }

          exports.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId)
            item._idleTimeout = -1
          }

          exports._unrefActive = exports.active = function(item) {
            clearTimeout(item._idleTimeoutId)

            var msecs = item._idleTimeout
            if (msecs >= 0) {
              item._idleTimeoutId = setTimeout(function onTimeout() {
                if (item._onTimeout) item._onTimeout()
              }, msecs)
            }
          }

          // That's not how node.js implements it but the exposed api is the same.
          exports.setImmediate =
            typeof setImmediate === "function"
              ? setImmediate
              : function(fn) {
                  var id = nextImmediateId++
                  var args =
                    arguments.length < 2 ? false : slice.call(arguments, 1)

                  immediateIds[id] = true

                  nextTick(function onNextTick() {
                    if (immediateIds[id]) {
                      // fn.call() is faster so we optimize for the common use-case
                      // @see http://jsperf.com/call-apply-segu
                      if (args) {
                        fn.apply(null, args)
                      } else {
                        fn.call(null)
                      }
                      // Prevent ids from leaking
                      exports.clearImmediate(id)
                    }
                  })

                  return id
                }

          exports.clearImmediate =
            typeof clearImmediate === "function"
              ? clearImmediate
              : function(id) {
                  delete immediateIds[id]
                }
        }.call(
          this,
          require("timers").setImmediate,
          require("timers").clearImmediate
        ))
      },
      { "process/browser.js": 44, timers: 75 }
    ],
    76: [
      function(require, module, exports) {
        var bufferAlloc = require("buffer-alloc")

        var UINT_32_MAX = Math.pow(2, 32)

        exports.encodingLength = function() {
          return 8
        }

        exports.encode = function(num, buf, offset) {
          if (!buf) buf = bufferAlloc(8)
          if (!offset) offset = 0

          var top = Math.floor(num / UINT_32_MAX)
          var rem = num - top * UINT_32_MAX

          buf.writeUInt32BE(top, offset)
          buf.writeUInt32BE(rem, offset + 4)
          return buf
        }

        exports.decode = function(buf, offset) {
          if (!offset) offset = 0

          var top = buf.readUInt32BE(offset)
          var rem = buf.readUInt32BE(offset + 4)

          return top * UINT_32_MAX + rem
        }

        exports.encode.bytes = 8
        exports.decode.bytes = 8
      },
      { "buffer-alloc": 16 }
    ],
    77: [
      function(require, module, exports) {
        module.exports = remove

        function remove(arr, i) {
          if (i >= arr.length || i < 0) return
          var last = arr.pop()
          if (i < arr.length) {
            var tmp = arr[i]
            arr[i] = last
            return tmp
          }
          return last
        }
      },
      {}
    ],
    78: [
      function(require, module, exports) {
        exports.add = add
        exports.has = has
        exports.remove = remove
        exports.swap = swap

        function add(list, item) {
          if (has(list, item)) return item
          item._index = list.length
          list.push(item)
          return item
        }

        function has(list, item) {
          return item._index < list.length && list[item._index] === item
        }

        function remove(list, item) {
          if (!has(list, item)) return null

          var last = list.pop()
          if (last !== item) {
            list[item._index] = last
            last._index = item._index
          }

          return item
        }

        function swap(list, a, b) {
          if (!has(list, a) || !has(list, b)) return
          var tmp = a._index
          a._index = b._index
          list[a._index] = a
          b._index = tmp
          list[b._index] = b
        }
      },
      {}
    ],
    79: [
      function(require, module, exports) {
        ;(function(global) {
          /**
           * Module exports.
           */

          module.exports = deprecate

          /**
           * Mark that a method should not be used.
           * Returns a modified function which warns once by default.
           *
           * If `localStorage.noDeprecation = true` is set, then it is a no-op.
           *
           * If `localStorage.throwDeprecation = true` is set, then deprecated functions
           * will throw an Error when invoked.
           *
           * If `localStorage.traceDeprecation = true` is set, then deprecated functions
           * will invoke `console.trace()` instead of `console.error()`.
           *
           * @param {Function} fn - the function to deprecate
           * @param {String} msg - the string to print to the console when `fn` is invoked
           * @returns {Function} a new "deprecated" version of `fn`
           * @api public
           */

          function deprecate(fn, msg) {
            if (config("noDeprecation")) {
              return fn
            }

            var warned = false
            function deprecated() {
              if (!warned) {
                if (config("throwDeprecation")) {
                  throw new Error(msg)
                } else if (config("traceDeprecation")) {
                  console.trace(msg)
                } else {
                  console.warn(msg)
                }
                warned = true
              }
              return fn.apply(this, arguments)
            }

            return deprecated
          }

          /**
           * Checks `localStorage` for boolean values for the given `name`.
           *
           * @param {String} name
           * @returns {Boolean}
           * @api private
           */

          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage) return false
            } catch (_) {
              return false
            }
            var val = global.localStorage[name]
            if (null == val) return false
            return String(val).toLowerCase() === "true"
          }
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {}
        ))
      },
      {}
    ],
    80: [
      function(require, module, exports) {
        module.exports = read

        var MSB = 0x80,
          REST = 0x7f

        function read(buf, offset) {
          var res = 0,
            offset = offset || 0,
            shift = 0,
            counter = offset,
            b,
            l = buf.length

          do {
            if (counter >= l) {
              read.bytes = 0
              throw new RangeError("Could not decode varint")
            }
            b = buf[counter++]
            res +=
              shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift)
            shift += 7
          } while (b >= MSB)

          read.bytes = counter - offset

          return res
        }
      },
      {}
    ],
    81: [
      function(require, module, exports) {
        arguments[4][8][0].apply(exports, arguments)
      },
      { dup: 8 }
    ],
    82: [
      function(require, module, exports) {
        arguments[4][9][0].apply(exports, arguments)
      },
      { "./decode.js": 80, "./encode.js": 81, "./length.js": 83, dup: 9 }
    ],
    83: [
      function(require, module, exports) {
        arguments[4][10][0].apply(exports, arguments)
      },
      { dup: 10 }
    ],
    84: [
      function(require, module, exports) {
        var xsalsa20 = require("./xsalsa20")()

        var SIGMA = new Uint8Array([
          101,
          120,
          112,
          97,
          110,
          100,
          32,
          51,
          50,
          45,
          98,
          121,
          116,
          101,
          32,
          107
        ])
        var head = 144
        var top = head
        var free = []

        module.exports = XSalsa20

        XSalsa20.NONCEBYTES = 24
        XSalsa20.KEYBYTES = 32

        function XSalsa20(nonce, key) {
          if (!(this instanceof XSalsa20)) return new XSalsa20(nonce, key)
          if (!nonce || nonce.length < 24)
            throw new Error("nonce must be at least 24 bytes")
          if (!key || key.length < 32)
            throw new Error("key must be at least 32 bytes")
          this._xor =
            xsalsa20 && xsalsa20.exports
              ? new WASM(nonce, key)
              : new Fallback(nonce, key)
        }

        XSalsa20.prototype.update = function(input, output) {
          if (!input) throw new Error("input must be Uint8Array or Buffer")
          if (!output) output = new Uint8Array(input.length)
          if (input.length) this._xor.update(input, output)
          return output
        }

        XSalsa20.prototype.final = XSalsa20.prototype.finalize = function() {
          this._xor.finalize()
          this._xor = null
        }

        function WASM(nonce, key) {
          if (!free.length) {
            free.push(head)
            head += 64
          }

          this._pointer = free.pop()
          this._nonce = this._pointer + 8
          this._key = this._nonce + 24
          this._overflow = 0

          xsalsa20.memory.fill(0, this._pointer, this._pointer + 8)
          xsalsa20.memory.set(nonce, this._nonce)
          xsalsa20.memory.set(key, this._key)
        }

        WASM.prototype.update = function(input, output) {
          var len = this._overflow + input.length
          var start = head + this._overflow

          top = head + len
          if (top >= xsalsa20.memory.length) xsalsa20.realloc(top)

          xsalsa20.memory.set(input, start)
          xsalsa20.exports.xsalsa20_xor(
            this._pointer,
            head,
            head,
            len,
            this._nonce,
            this._key
          )
          output.set(xsalsa20.memory.subarray(start, head + len))

          this._overflow = len & 63
        }

        WASM.prototype.finalize = function() {
          xsalsa20.memory.fill(0, this._pointer, this._key + 32)
          if (top > head) {
            xsalsa20.memory.fill(0, head, top)
            top = 0
          }
          free.push(this._pointer)
        }

        function Fallback(nonce, key) {
          this._s = new Uint8Array(32)
          this._z = new Uint8Array(16)
          this._overflow = 0
          core_hsalsa20(this._s, nonce, key, SIGMA)
          for (var i = 0; i < 8; i++) this._z[i] = nonce[i + 16]
        }

        Fallback.prototype.update = function(input, output) {
          var x = new Uint8Array(64)
          var u = 0
          var i = this._overflow
          var b = input.length + this._overflow
          var z = this._z
          var mpos = -this._overflow
          var cpos = -this._overflow

          while (b >= 64) {
            core_salsa20(x, z, this._s, SIGMA)
            for (; i < 64; i++) output[cpos + i] = input[mpos + i] ^ x[i]
            u = 1
            for (i = 8; i < 16; i++) {
              u += (z[i] & 0xff) | 0
              z[i] = u & 0xff
              u >>>= 8
            }
            b -= 64
            cpos += 64
            mpos += 64
            i = 0
          }
          if (b > 0) {
            core_salsa20(x, z, this._s, SIGMA)
            for (; i < b; i++) output[cpos + i] = input[mpos + i] ^ x[i]
          }

          this._overflow = b & 63
        }

        Fallback.prototype.finalize = function() {
          this._s.fill(0)
          this._z.fill(0)
        }

        // below methods are ported from tweet nacl

        function core_salsa20(o, p, k, c) {
          var j0 =
              (c[0] & 0xff) |
              ((c[1] & 0xff) << 8) |
              ((c[2] & 0xff) << 16) |
              ((c[3] & 0xff) << 24),
            j1 =
              (k[0] & 0xff) |
              ((k[1] & 0xff) << 8) |
              ((k[2] & 0xff) << 16) |
              ((k[3] & 0xff) << 24),
            j2 =
              (k[4] & 0xff) |
              ((k[5] & 0xff) << 8) |
              ((k[6] & 0xff) << 16) |
              ((k[7] & 0xff) << 24),
            j3 =
              (k[8] & 0xff) |
              ((k[9] & 0xff) << 8) |
              ((k[10] & 0xff) << 16) |
              ((k[11] & 0xff) << 24),
            j4 =
              (k[12] & 0xff) |
              ((k[13] & 0xff) << 8) |
              ((k[14] & 0xff) << 16) |
              ((k[15] & 0xff) << 24),
            j5 =
              (c[4] & 0xff) |
              ((c[5] & 0xff) << 8) |
              ((c[6] & 0xff) << 16) |
              ((c[7] & 0xff) << 24),
            j6 =
              (p[0] & 0xff) |
              ((p[1] & 0xff) << 8) |
              ((p[2] & 0xff) << 16) |
              ((p[3] & 0xff) << 24),
            j7 =
              (p[4] & 0xff) |
              ((p[5] & 0xff) << 8) |
              ((p[6] & 0xff) << 16) |
              ((p[7] & 0xff) << 24),
            j8 =
              (p[8] & 0xff) |
              ((p[9] & 0xff) << 8) |
              ((p[10] & 0xff) << 16) |
              ((p[11] & 0xff) << 24),
            j9 =
              (p[12] & 0xff) |
              ((p[13] & 0xff) << 8) |
              ((p[14] & 0xff) << 16) |
              ((p[15] & 0xff) << 24),
            j10 =
              (c[8] & 0xff) |
              ((c[9] & 0xff) << 8) |
              ((c[10] & 0xff) << 16) |
              ((c[11] & 0xff) << 24),
            j11 =
              (k[16] & 0xff) |
              ((k[17] & 0xff) << 8) |
              ((k[18] & 0xff) << 16) |
              ((k[19] & 0xff) << 24),
            j12 =
              (k[20] & 0xff) |
              ((k[21] & 0xff) << 8) |
              ((k[22] & 0xff) << 16) |
              ((k[23] & 0xff) << 24),
            j13 =
              (k[24] & 0xff) |
              ((k[25] & 0xff) << 8) |
              ((k[26] & 0xff) << 16) |
              ((k[27] & 0xff) << 24),
            j14 =
              (k[28] & 0xff) |
              ((k[29] & 0xff) << 8) |
              ((k[30] & 0xff) << 16) |
              ((k[31] & 0xff) << 24),
            j15 =
              (c[12] & 0xff) |
              ((c[13] & 0xff) << 8) |
              ((c[14] & 0xff) << 16) |
              ((c[15] & 0xff) << 24)

          var x0 = j0,
            x1 = j1,
            x2 = j2,
            x3 = j3,
            x4 = j4,
            x5 = j5,
            x6 = j6,
            x7 = j7,
            x8 = j8,
            x9 = j9,
            x10 = j10,
            x11 = j11,
            x12 = j12,
            x13 = j13,
            x14 = j14,
            x15 = j15,
            u

          for (var i = 0; i < 20; i += 2) {
            u = (x0 + x12) | 0
            x4 ^= (u << 7) | (u >>> 25)
            u = (x4 + x0) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x4) | 0
            x12 ^= (u << 13) | (u >>> 19)
            u = (x12 + x8) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x1) | 0
            x9 ^= (u << 7) | (u >>> 25)
            u = (x9 + x5) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x9) | 0
            x1 ^= (u << 13) | (u >>> 19)
            u = (x1 + x13) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x6) | 0
            x14 ^= (u << 7) | (u >>> 25)
            u = (x14 + x10) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x14) | 0
            x6 ^= (u << 13) | (u >>> 19)
            u = (x6 + x2) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x11) | 0
            x3 ^= (u << 7) | (u >>> 25)
            u = (x3 + x15) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x3) | 0
            x11 ^= (u << 13) | (u >>> 19)
            u = (x11 + x7) | 0
            x15 ^= (u << 18) | (u >>> 14)

            u = (x0 + x3) | 0
            x1 ^= (u << 7) | (u >>> 25)
            u = (x1 + x0) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x1) | 0
            x3 ^= (u << 13) | (u >>> 19)
            u = (x3 + x2) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x4) | 0
            x6 ^= (u << 7) | (u >>> 25)
            u = (x6 + x5) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x6) | 0
            x4 ^= (u << 13) | (u >>> 19)
            u = (x4 + x7) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x9) | 0
            x11 ^= (u << 7) | (u >>> 25)
            u = (x11 + x10) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x11) | 0
            x9 ^= (u << 13) | (u >>> 19)
            u = (x9 + x8) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x14) | 0
            x12 ^= (u << 7) | (u >>> 25)
            u = (x12 + x15) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x12) | 0
            x14 ^= (u << 13) | (u >>> 19)
            u = (x14 + x13) | 0
            x15 ^= (u << 18) | (u >>> 14)
          }
          x0 = (x0 + j0) | 0
          x1 = (x1 + j1) | 0
          x2 = (x2 + j2) | 0
          x3 = (x3 + j3) | 0
          x4 = (x4 + j4) | 0
          x5 = (x5 + j5) | 0
          x6 = (x6 + j6) | 0
          x7 = (x7 + j7) | 0
          x8 = (x8 + j8) | 0
          x9 = (x9 + j9) | 0
          x10 = (x10 + j10) | 0
          x11 = (x11 + j11) | 0
          x12 = (x12 + j12) | 0
          x13 = (x13 + j13) | 0
          x14 = (x14 + j14) | 0
          x15 = (x15 + j15) | 0

          o[0] = (x0 >>> 0) & 0xff
          o[1] = (x0 >>> 8) & 0xff
          o[2] = (x0 >>> 16) & 0xff
          o[3] = (x0 >>> 24) & 0xff

          o[4] = (x1 >>> 0) & 0xff
          o[5] = (x1 >>> 8) & 0xff
          o[6] = (x1 >>> 16) & 0xff
          o[7] = (x1 >>> 24) & 0xff

          o[8] = (x2 >>> 0) & 0xff
          o[9] = (x2 >>> 8) & 0xff
          o[10] = (x2 >>> 16) & 0xff
          o[11] = (x2 >>> 24) & 0xff

          o[12] = (x3 >>> 0) & 0xff
          o[13] = (x3 >>> 8) & 0xff
          o[14] = (x3 >>> 16) & 0xff
          o[15] = (x3 >>> 24) & 0xff

          o[16] = (x4 >>> 0) & 0xff
          o[17] = (x4 >>> 8) & 0xff
          o[18] = (x4 >>> 16) & 0xff
          o[19] = (x4 >>> 24) & 0xff

          o[20] = (x5 >>> 0) & 0xff
          o[21] = (x5 >>> 8) & 0xff
          o[22] = (x5 >>> 16) & 0xff
          o[23] = (x5 >>> 24) & 0xff

          o[24] = (x6 >>> 0) & 0xff
          o[25] = (x6 >>> 8) & 0xff
          o[26] = (x6 >>> 16) & 0xff
          o[27] = (x6 >>> 24) & 0xff

          o[28] = (x7 >>> 0) & 0xff
          o[29] = (x7 >>> 8) & 0xff
          o[30] = (x7 >>> 16) & 0xff
          o[31] = (x7 >>> 24) & 0xff

          o[32] = (x8 >>> 0) & 0xff
          o[33] = (x8 >>> 8) & 0xff
          o[34] = (x8 >>> 16) & 0xff
          o[35] = (x8 >>> 24) & 0xff

          o[36] = (x9 >>> 0) & 0xff
          o[37] = (x9 >>> 8) & 0xff
          o[38] = (x9 >>> 16) & 0xff
          o[39] = (x9 >>> 24) & 0xff

          o[40] = (x10 >>> 0) & 0xff
          o[41] = (x10 >>> 8) & 0xff
          o[42] = (x10 >>> 16) & 0xff
          o[43] = (x10 >>> 24) & 0xff

          o[44] = (x11 >>> 0) & 0xff
          o[45] = (x11 >>> 8) & 0xff
          o[46] = (x11 >>> 16) & 0xff
          o[47] = (x11 >>> 24) & 0xff

          o[48] = (x12 >>> 0) & 0xff
          o[49] = (x12 >>> 8) & 0xff
          o[50] = (x12 >>> 16) & 0xff
          o[51] = (x12 >>> 24) & 0xff

          o[52] = (x13 >>> 0) & 0xff
          o[53] = (x13 >>> 8) & 0xff
          o[54] = (x13 >>> 16) & 0xff
          o[55] = (x13 >>> 24) & 0xff

          o[56] = (x14 >>> 0) & 0xff
          o[57] = (x14 >>> 8) & 0xff
          o[58] = (x14 >>> 16) & 0xff
          o[59] = (x14 >>> 24) & 0xff

          o[60] = (x15 >>> 0) & 0xff
          o[61] = (x15 >>> 8) & 0xff
          o[62] = (x15 >>> 16) & 0xff
          o[63] = (x15 >>> 24) & 0xff
        }

        function core_hsalsa20(o, p, k, c) {
          var j0 =
              (c[0] & 0xff) |
              ((c[1] & 0xff) << 8) |
              ((c[2] & 0xff) << 16) |
              ((c[3] & 0xff) << 24),
            j1 =
              (k[0] & 0xff) |
              ((k[1] & 0xff) << 8) |
              ((k[2] & 0xff) << 16) |
              ((k[3] & 0xff) << 24),
            j2 =
              (k[4] & 0xff) |
              ((k[5] & 0xff) << 8) |
              ((k[6] & 0xff) << 16) |
              ((k[7] & 0xff) << 24),
            j3 =
              (k[8] & 0xff) |
              ((k[9] & 0xff) << 8) |
              ((k[10] & 0xff) << 16) |
              ((k[11] & 0xff) << 24),
            j4 =
              (k[12] & 0xff) |
              ((k[13] & 0xff) << 8) |
              ((k[14] & 0xff) << 16) |
              ((k[15] & 0xff) << 24),
            j5 =
              (c[4] & 0xff) |
              ((c[5] & 0xff) << 8) |
              ((c[6] & 0xff) << 16) |
              ((c[7] & 0xff) << 24),
            j6 =
              (p[0] & 0xff) |
              ((p[1] & 0xff) << 8) |
              ((p[2] & 0xff) << 16) |
              ((p[3] & 0xff) << 24),
            j7 =
              (p[4] & 0xff) |
              ((p[5] & 0xff) << 8) |
              ((p[6] & 0xff) << 16) |
              ((p[7] & 0xff) << 24),
            j8 =
              (p[8] & 0xff) |
              ((p[9] & 0xff) << 8) |
              ((p[10] & 0xff) << 16) |
              ((p[11] & 0xff) << 24),
            j9 =
              (p[12] & 0xff) |
              ((p[13] & 0xff) << 8) |
              ((p[14] & 0xff) << 16) |
              ((p[15] & 0xff) << 24),
            j10 =
              (c[8] & 0xff) |
              ((c[9] & 0xff) << 8) |
              ((c[10] & 0xff) << 16) |
              ((c[11] & 0xff) << 24),
            j11 =
              (k[16] & 0xff) |
              ((k[17] & 0xff) << 8) |
              ((k[18] & 0xff) << 16) |
              ((k[19] & 0xff) << 24),
            j12 =
              (k[20] & 0xff) |
              ((k[21] & 0xff) << 8) |
              ((k[22] & 0xff) << 16) |
              ((k[23] & 0xff) << 24),
            j13 =
              (k[24] & 0xff) |
              ((k[25] & 0xff) << 8) |
              ((k[26] & 0xff) << 16) |
              ((k[27] & 0xff) << 24),
            j14 =
              (k[28] & 0xff) |
              ((k[29] & 0xff) << 8) |
              ((k[30] & 0xff) << 16) |
              ((k[31] & 0xff) << 24),
            j15 =
              (c[12] & 0xff) |
              ((c[13] & 0xff) << 8) |
              ((c[14] & 0xff) << 16) |
              ((c[15] & 0xff) << 24)

          var x0 = j0,
            x1 = j1,
            x2 = j2,
            x3 = j3,
            x4 = j4,
            x5 = j5,
            x6 = j6,
            x7 = j7,
            x8 = j8,
            x9 = j9,
            x10 = j10,
            x11 = j11,
            x12 = j12,
            x13 = j13,
            x14 = j14,
            x15 = j15,
            u

          for (var i = 0; i < 20; i += 2) {
            u = (x0 + x12) | 0
            x4 ^= (u << 7) | (u >>> 25)
            u = (x4 + x0) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x4) | 0
            x12 ^= (u << 13) | (u >>> 19)
            u = (x12 + x8) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x1) | 0
            x9 ^= (u << 7) | (u >>> 25)
            u = (x9 + x5) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x9) | 0
            x1 ^= (u << 13) | (u >>> 19)
            u = (x1 + x13) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x6) | 0
            x14 ^= (u << 7) | (u >>> 25)
            u = (x14 + x10) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x14) | 0
            x6 ^= (u << 13) | (u >>> 19)
            u = (x6 + x2) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x11) | 0
            x3 ^= (u << 7) | (u >>> 25)
            u = (x3 + x15) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x3) | 0
            x11 ^= (u << 13) | (u >>> 19)
            u = (x11 + x7) | 0
            x15 ^= (u << 18) | (u >>> 14)

            u = (x0 + x3) | 0
            x1 ^= (u << 7) | (u >>> 25)
            u = (x1 + x0) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x1) | 0
            x3 ^= (u << 13) | (u >>> 19)
            u = (x3 + x2) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x4) | 0
            x6 ^= (u << 7) | (u >>> 25)
            u = (x6 + x5) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x6) | 0
            x4 ^= (u << 13) | (u >>> 19)
            u = (x4 + x7) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x9) | 0
            x11 ^= (u << 7) | (u >>> 25)
            u = (x11 + x10) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x11) | 0
            x9 ^= (u << 13) | (u >>> 19)
            u = (x9 + x8) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x14) | 0
            x12 ^= (u << 7) | (u >>> 25)
            u = (x12 + x15) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x12) | 0
            x14 ^= (u << 13) | (u >>> 19)
            u = (x14 + x13) | 0
            x15 ^= (u << 18) | (u >>> 14)
          }

          o[0] = (x0 >>> 0) & 0xff
          o[1] = (x0 >>> 8) & 0xff
          o[2] = (x0 >>> 16) & 0xff
          o[3] = (x0 >>> 24) & 0xff

          o[4] = (x5 >>> 0) & 0xff
          o[5] = (x5 >>> 8) & 0xff
          o[6] = (x5 >>> 16) & 0xff
          o[7] = (x5 >>> 24) & 0xff

          o[8] = (x10 >>> 0) & 0xff
          o[9] = (x10 >>> 8) & 0xff
          o[10] = (x10 >>> 16) & 0xff
          o[11] = (x10 >>> 24) & 0xff

          o[12] = (x15 >>> 0) & 0xff
          o[13] = (x15 >>> 8) & 0xff
          o[14] = (x15 >>> 16) & 0xff
          o[15] = (x15 >>> 24) & 0xff

          o[16] = (x6 >>> 0) & 0xff
          o[17] = (x6 >>> 8) & 0xff
          o[18] = (x6 >>> 16) & 0xff
          o[19] = (x6 >>> 24) & 0xff

          o[20] = (x7 >>> 0) & 0xff
          o[21] = (x7 >>> 8) & 0xff
          o[22] = (x7 >>> 16) & 0xff
          o[23] = (x7 >>> 24) & 0xff

          o[24] = (x8 >>> 0) & 0xff
          o[25] = (x8 >>> 8) & 0xff
          o[26] = (x8 >>> 16) & 0xff
          o[27] = (x8 >>> 24) & 0xff

          o[28] = (x9 >>> 0) & 0xff
          o[29] = (x9 >>> 8) & 0xff
          o[30] = (x9 >>> 16) & 0xff
          o[31] = (x9 >>> 24) & 0xff
        }
      },
      { "./xsalsa20": 85 }
    ],
    85: [
      function(require, module, exports) {
        module.exports = loadWebAssembly

        loadWebAssembly.supported = typeof WebAssembly !== "undefined"

        function loadWebAssembly(opts) {
          if (!loadWebAssembly.supported) return null

          var imp = opts && opts.imports
          var wasm = toUint8Array(
            "AGFzbQEAAAABGgNgBn9/f39/fwBgBn9/f39+fwF+YAN/f38AAwcGAAEBAgICBQUBAQroBwcoAwZtZW1vcnkCAAx4c2Fsc2EyMF94b3IAAAxjb3JlX3NhbHNhMjAABArqEQYYACAAIAEgAiADIAQgACkDACAFEAE3AwALPQBB8AAgAyAFEAMgACABIAIgA0EQaiAEQfAAEAJB8ABCADcDAEH4AEIANwMAQYABQgA3AwBBiAFCADcDAAuHBQEBfyACQQBGBEBCAA8LQdAAIAUpAwA3AwBB2AAgBUEIaikDADcDAEHgACAFQRBqKQMANwMAQegAIAVBGGopAwA3AwBBACADKQMANwMAQQggBDcDAAJAA0AgAkHAAEkNAUEQQQBB0AAQBSAAIAEpAwBBECkDAIU3AwAgAEEIaiABQQhqKQMAQRgpAwCFNwMAIABBEGogAUEQaikDAEEgKQMAhTcDACAAQRhqIAFBGGopAwBBKCkDAIU3AwAgAEEgaiABQSBqKQMAQTApAwCFNwMAIABBKGogAUEoaikDAEE4KQMAhTcDACAAQTBqIAFBMGopAwBBwAApAwCFNwMAIABBOGogAUE4aikDAEHIACkDAIU3AwBBCEEIKQMAQgF8NwMAIABBwABqIQAgAUHAAGohASACQcAAayECDAALC0EIKQMAIQQgAkEASwRAQRBBAEHQABAFAkACQAJAAkACQAJAAkACQCACQQhuDgcHBgUEAwIBAAsgAEE4aiABQThqKQMAQcgAKQMAhTcDAAsgAEEwaiABQTBqKQMAQcAAKQMAhTcDAAsgAEEoaiABQShqKQMAQTgpAwCFNwMACyAAQSBqIAFBIGopAwBBMCkDAIU3AwALIABBGGogAUEYaikDAEEoKQMAhTcDAAsgAEEQaiABQRBqKQMAQSApAwCFNwMACyAAQQhqIAFBCGopAwBBGCkDAIU3AwALIAAgASkDAEEQKQMAhTcDAAtBEEIANwMAQRhCADcDAEEgQgA3AwBBKEIANwMAQTBCADcDAEE4QgA3AwBBwABCADcDAEHIAEIANwMAQdAAQgA3AwBB2ABCADcDAEHgAEIANwMAQegAQgA3AwAgBA8LnQUBEX9B5fDBiwYhA0HuyIGZAyEIQbLaiMsHIQ1B9MqB2QYhEiACKAIAIQQgAkEEaigCACEFIAJBCGooAgAhBiACQQxqKAIAIQcgAkEQaigCACEOIAJBFGooAgAhDyACQRhqKAIAIRAgAkEcaigCACERIAEoAgAhCSABQQRqKAIAIQogAUEIaigCACELIAFBDGooAgAhDEEUIRMCQANAIBNBAEYNASAHIAMgD2pBB3dzIQcgCyAHIANqQQl3cyELIA8gCyAHakENd3MhDyADIA8gC2pBEndzIQMgDCAIIARqQQd3cyEMIBAgDCAIakEJd3MhECAEIBAgDGpBDXdzIQQgCCAEIBBqQRJ3cyEIIBEgDSAJakEHd3MhESAFIBEgDWpBCXdzIQUgCSAFIBFqQQ13cyEJIA0gCSAFakESd3MhDSAGIBIgDmpBB3dzIQYgCiAGIBJqQQl3cyEKIA4gCiAGakENd3MhDiASIA4gCmpBEndzIRIgBCADIAZqQQd3cyEEIAUgBCADakEJd3MhBSAGIAUgBGpBDXdzIQYgAyAGIAVqQRJ3cyEDIAkgCCAHakEHd3MhCSAKIAkgCGpBCXdzIQogByAKIAlqQQ13cyEHIAggByAKakESd3MhCCAOIA0gDGpBB3dzIQ4gCyAOIA1qQQl3cyELIAwgCyAOakENd3MhDCANIAwgC2pBEndzIQ0gDyASIBFqQQd3cyEPIBAgDyASakEJd3MhECARIBAgD2pBDXdzIREgEiARIBBqQRJ3cyESIBNBAmshEwwACwsgACADNgIAIABBBGogCDYCACAAQQhqIA02AgAgAEEMaiASNgIAIABBEGogCTYCACAAQRRqIAo2AgAgAEEYaiALNgIAIABBHGogDDYCAAsKACAAIAEgAhAFC90GASF/QeXwwYsGIQNB7siBmQMhCEGy2ojLByENQfTKgdkGIRIgAigCACEEIAJBBGooAgAhBSACQQhqKAIAIQYgAkEMaigCACEHIAJBEGooAgAhDiACQRRqKAIAIQ8gAkEYaigCACEQIAJBHGooAgAhESABKAIAIQkgAUEEaigCACEKIAFBCGooAgAhCyABQQxqKAIAIQwgAyETIAQhFCAFIRUgBiEWIAchFyAIIRggCSEZIAohGiALIRsgDCEcIA0hHSAOIR4gDyEfIBAhICARISEgEiEiQRQhIwJAA0AgI0EARg0BIAcgAyAPakEHd3MhByALIAcgA2pBCXdzIQsgDyALIAdqQQ13cyEPIAMgDyALakESd3MhAyAMIAggBGpBB3dzIQwgECAMIAhqQQl3cyEQIAQgECAMakENd3MhBCAIIAQgEGpBEndzIQggESANIAlqQQd3cyERIAUgESANakEJd3MhBSAJIAUgEWpBDXdzIQkgDSAJIAVqQRJ3cyENIAYgEiAOakEHd3MhBiAKIAYgEmpBCXdzIQogDiAKIAZqQQ13cyEOIBIgDiAKakESd3MhEiAEIAMgBmpBB3dzIQQgBSAEIANqQQl3cyEFIAYgBSAEakENd3MhBiADIAYgBWpBEndzIQMgCSAIIAdqQQd3cyEJIAogCSAIakEJd3MhCiAHIAogCWpBDXdzIQcgCCAHIApqQRJ3cyEIIA4gDSAMakEHd3MhDiALIA4gDWpBCXdzIQsgDCALIA5qQQ13cyEMIA0gDCALakESd3MhDSAPIBIgEWpBB3dzIQ8gECAPIBJqQQl3cyEQIBEgECAPakENd3MhESASIBEgEGpBEndzIRIgI0ECayEjDAALCyAAIAMgE2o2AgAgAEEEaiAEIBRqNgIAIABBCGogBSAVajYCACAAQQxqIAYgFmo2AgAgAEEQaiAHIBdqNgIAIABBFGogCCAYajYCACAAQRhqIAkgGWo2AgAgAEEcaiAKIBpqNgIAIABBIGogCyAbajYCACAAQSRqIAwgHGo2AgAgAEEoaiANIB1qNgIAIABBLGogDiAeajYCACAAQTBqIA8gH2o2AgAgAEE0aiAQICBqNgIAIABBOGogESAhajYCACAAQTxqIBIgImo2AgAL"
          )
          var ready = null

          var mod = {
            buffer: wasm,
            memory: null,
            exports: null,
            realloc: realloc,
            onload: onload
          }

          onload(function() {})

          return mod

          function realloc(size) {
            mod.exports.memory.grow(
              Math.ceil(Math.abs(size - mod.memory.length) / 65536)
            )
            mod.memory = new Uint8Array(mod.exports.memory.buffer)
          }

          function onload(cb) {
            if (mod.exports) return cb()

            if (ready) {
              ready.then(cb.bind(null, null)).catch(cb)
              return
            }

            try {
              if (opts && opts.async) throw new Error("async")
              setup({
                instance: new WebAssembly.Instance(
                  new WebAssembly.Module(wasm),
                  imp
                )
              })
            } catch (err) {
              ready = WebAssembly.instantiate(wasm, imp).then(setup)
            }

            onload(cb)
          }

          function setup(w) {
            mod.exports = w.instance.exports
            mod.memory =
              mod.exports.memory &&
              mod.exports.memory.buffer &&
              new Uint8Array(mod.exports.memory.buffer)
          }
        }

        function toUint8Array(s) {
          if (typeof atob === "function")
            return new Uint8Array(
              atob(s)
                .split("")
                .map(charCodeAt)
            )
          return new (require("buf" + "fer")).Buffer(s, "base64")
        }

        function charCodeAt(c) {
          return c.charCodeAt(0)
        }
      },
      {}
    ],
    86: [
      function(require, module, exports) {
        "use strict"

        var hypercore = require("hypercore")
        var RandomAccessFile = require("./random-access-file")

        const main = async () => {
          const volume = await RandomAccessFile.mount()
          var feed = hypercore(volume, { valueEncoding: "json" })

          feed.append({
            hello: "world"
          })

          feed.append({
            hej: "verden"
          })

          feed.append({
            hola: "mundo"
          })

          feed.flush(function() {
            console.log(
              "Appended 3 more blocks, %d in total (%d bytes)\n",
              feed.length,
              feed.byteLength
            )

            feed
              .createReadStream()
              .on("data", console.log.bind(console))
              .on("end", console.log.bind(console, "\n(end)"))
          })
        }

        main()
      },
      { "./random-access-file": 87, hypercore: 30 }
    ],
    87: [
      function(require, module, exports) {
        "use strict"

        const RandomAccess = require("random-access-storage")
        const { Buffer } = require("Buffer")

        const MAX_SIZE = (1 << 30) * 2 - (1 << 12) - 1

        class RandomAccessFile extends RandomAccess {
          constructor(volume, name, options = {}) {
            super()
            this.name = name
            this.options = options
            this.volume = volume
            this.url = `${volume.url}${name}`
            this.file = null
          }
          static async mount(url = null) {
            const volume = await browser.FileSystem.mount({
              url: url,
              read: true,
              write: true
            })

            return (name, options) =>
              new RandomAccessFile(volume, name, options)
          }
          static async open(self, mode) {
            self.file = await browser.FileSystem.open(self.url, mode)

            return self
          }
          static async delete(self, position, size) {
            const stat = await browser.File.stat(self.file)
            if (position + size < stat.size) {
              return null
            } else {
              const data =
                position > 0
                  ? await browser.File.read(file, {
                      position: 0,
                      size: position
                    })
                  : null

              self.file = await browser.FileSystem.open(self.fileURL, {
                truncate: true,
                read: true,
                write: true
              })

              if (data) {
                await browser.File.write(self.file, data, { position: 0 })
              }
            }
          }
          _open(request) {
            console.log("_open", this.url, request)
            RandomAccessFile.open(this, {
              read: true,
              write: true,
              create: true
            })
              .then(self => request.callback(null, self))
              .catch(error => request.callback(error))
          }
          _openReadonly(request) {
            console.log("_openReadonly", this.url, request)
            RandomAccessFile.open(this, { read: true })
              .then(self => request.callback(null, self))
              .catch(error => request.callback(error))
          }
          _write(request) {
            const { offset, size, data } = request
            console.log("_write", this.url, offset, size, data, request)
            browser.File.write(this.file, data.buffer, {
              position: offset,
              size
            })
              .then(() => request.callback(null))
              .catch(error => request.callback)
          }
          static async read(file, buffer, position, size) {
            const content = await browser.File.read(file, {
              position: position,
              size: size //MAX_SIZE < size ? undefined : size
            })
            Buffer.from(content).copy(buffer)
            return buffer

            // if (data.byteLength < options.size) {
            //   const result = new Uint8Array(options.size)
            //   result.set(data)
            //   return result
            // } else {
            //   return data
            // }
          }
          _read(request) {
            const { offset, size } = request
            console.log(`_read`, this.url, offset, size, request)
            const buffer = request.data || Buffer.allocUnsafe(size)
            RandomAccessFile.read(this.file, buffer, offset, size)
              .then(data => request.callback(null, data))
              .catch(error => request.callback(error))
          }
          _del(request) {
            console.log("_del", this.url, request)
            RandomAccessFile.delete(this, request.offset, request.size)
              .then(() => request.callback(null))
              .catch(error => request.callback(null))
          }
          _stat(request) {
            console.log("_stat", this.url, request)
            browser.File.stat(this.file)
              .then(stat => request.callback(null, stat))
              .catch(error => request.callback(error))
          }
          _close(request) {
            console.log("_close", this.url, request)
            browser.File.close(this.file)
              .then(() => request.callback((this.file = null)))
              .catch(error => request.callback(error))
          }
          _destroy(request) {
            console.log("_destroy", this.url, request)
            browser.FileSystem.removeFile(this.fileURL, { ignoreAbsent: true })
              .then(() => request.callback(null))
              .catch(error => request.callback(error))
          }
        }

        module.exports = RandomAccessFile
      },
      { Buffer: 1, "random-access-storage": 47 }
    ]
  },
  {},
  [86]
)
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LWxydS9jcmMxNi5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1scnUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXRvbWljLWJhdGNoZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkLXJsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRmaWVsZC1ybGUvbm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvYml0ZmllbGQtcmxlL25vZGVfbW9kdWxlcy92YXJpbnQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkLXJsZS9ub2RlX21vZHVsZXMvdmFyaW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkLXJsZS9ub2RlX21vZHVsZXMvdmFyaW50L2xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9ibGFrZTJiLXdhc20vYmxha2UyYi5qcyIsIm5vZGVfbW9kdWxlcy9ibGFrZTJiLXdhc20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmxha2UyYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLWFsbG9jLXVuc2FmZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItYWxsb2MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLWVxdWFscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItZmlsbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItZnJvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWxrLXdyaXRlLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2RlY3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmxhdC10cmVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zyb20yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS1wcm90b2NvbC9mZWVkLmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS1wcm90b2NvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcmNvcmUtcHJvdG9jb2wvbWVzc2FnZXMuanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS9saWIvYml0ZmllbGQuanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2xpYi9jcnlwdG8uanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2xpYi9yZXBsaWNhdGUuanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2xpYi9zdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS9saWIvdHJlZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xhc3Qtb25lLXdpbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVtb3J5LXBhZ2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lcmtsZS10cmVlLXN0cmVhbS9nZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvbmFub2Fzc2VydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9jb2wtYnVmZmVycy1lbmNvZGluZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZG9tLWFjY2Vzcy1maWxlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFuZG9tLWFjY2Vzcy1zdG9yYWdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmVkLXZhcmludC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaXBoYXNoMjQvZmFsbGJhY2suanMiLCJub2RlX21vZHVsZXMvc2lwaGFzaDI0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpcGhhc2gyNC9zaXBoYXNoMjQuanMiLCJub2RlX21vZHVsZXMvc29kaXVtLWphdmFzY3JpcHQvY3J5cHRvX2dlbmVyaWNoYXNoLmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS1qYXZhc2NyaXB0L2NyeXB0b19rZGYuanMiLCJub2RlX21vZHVsZXMvc29kaXVtLWphdmFzY3JpcHQvY3J5cHRvX3Nob3J0aGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9zb2RpdW0tamF2YXNjcmlwdC9jcnlwdG9fc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS1qYXZhc2NyaXB0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS1qYXZhc2NyaXB0L3JhbmRvbWJ5dGVzLmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS11bml2ZXJzYWwvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3J0ZWQtaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zcGFyc2UtYml0ZmllbGQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3RodW5reS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3VpbnQ2NGJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Vub3JkZXJlZC1hcnJheS1yZW1vdmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdW5vcmRlcmVkLXNldC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMveHNhbHNhMjAvaW5kZXguanMiLCJub2RlX21vZHVsZXMveHNhbHNhMjAveHNhbHNhMjAuanMiLCJzcmMvaHlwZXIuanMiLCJzcmMvcmFuZG9tLWFjY2Vzcy1maWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelRBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDempDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5UkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzd0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4Q0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8ICh2YWx1ZSAmJiBpc0FycmF5QnVmZmVyKHZhbHVlLmJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWVcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYnVmKSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0FycmF5QnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXJzIGZyb20gYW5vdGhlciBjb250ZXh0IChpLmUuIGFuIGlmcmFtZSkgZG8gbm90IHBhc3MgdGhlIGBpbnN0YW5jZW9mYCBjaGVja1xuLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgICAgdHlwZW9mIG9iai5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJylcbn1cblxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8vIGNyYzE2IGltcGwsIG9wdGltaXplZCBmb3IgbnVtZXJpYyBpbnB1dHNcblxudmFyIFRBQkxFID0gW1xuICAweDAwMDAsIDB4MTAyMSwgMHgyMDQyLCAweDMwNjMsIDB4NDA4NCwgMHg1MGE1LCAweDYwYzYsIDB4NzBlNyxcbiAgMHg4MTA4LCAweDkxMjksIDB4YTE0YSwgMHhiMTZiLCAweGMxOGMsIDB4ZDFhZCwgMHhlMWNlLCAweGYxZWYsXG4gIDB4MTIzMSwgMHgwMjEwLCAweDMyNzMsIDB4MjI1MiwgMHg1MmI1LCAweDQyOTQsIDB4NzJmNywgMHg2MmQ2LFxuICAweDkzMzksIDB4ODMxOCwgMHhiMzdiLCAweGEzNWEsIDB4ZDNiZCwgMHhjMzljLCAweGYzZmYsIDB4ZTNkZSxcbiAgMHgyNDYyLCAweDM0NDMsIDB4MDQyMCwgMHgxNDAxLCAweDY0ZTYsIDB4NzRjNywgMHg0NGE0LCAweDU0ODUsXG4gIDB4YTU2YSwgMHhiNTRiLCAweDg1MjgsIDB4OTUwOSwgMHhlNWVlLCAweGY1Y2YsIDB4YzVhYywgMHhkNThkLFxuICAweDM2NTMsIDB4MjY3MiwgMHgxNjExLCAweDA2MzAsIDB4NzZkNywgMHg2NmY2LCAweDU2OTUsIDB4NDZiNCxcbiAgMHhiNzViLCAweGE3N2EsIDB4OTcxOSwgMHg4NzM4LCAweGY3ZGYsIDB4ZTdmZSwgMHhkNzlkLCAweGM3YmMsXG4gIDB4NDhjNCwgMHg1OGU1LCAweDY4ODYsIDB4NzhhNywgMHgwODQwLCAweDE4NjEsIDB4MjgwMiwgMHgzODIzLFxuICAweGM5Y2MsIDB4ZDllZCwgMHhlOThlLCAweGY5YWYsIDB4ODk0OCwgMHg5OTY5LCAweGE5MGEsIDB4YjkyYixcbiAgMHg1YWY1LCAweDRhZDQsIDB4N2FiNywgMHg2YTk2LCAweDFhNzEsIDB4MGE1MCwgMHgzYTMzLCAweDJhMTIsXG4gIDB4ZGJmZCwgMHhjYmRjLCAweGZiYmYsIDB4ZWI5ZSwgMHg5Yjc5LCAweDhiNTgsIDB4YmIzYiwgMHhhYjFhLFxuICAweDZjYTYsIDB4N2M4NywgMHg0Y2U0LCAweDVjYzUsIDB4MmMyMiwgMHgzYzAzLCAweDBjNjAsIDB4MWM0MSxcbiAgMHhlZGFlLCAweGZkOGYsIDB4Y2RlYywgMHhkZGNkLCAweGFkMmEsIDB4YmQwYiwgMHg4ZDY4LCAweDlkNDksXG4gIDB4N2U5NywgMHg2ZWI2LCAweDVlZDUsIDB4NGVmNCwgMHgzZTEzLCAweDJlMzIsIDB4MWU1MSwgMHgwZTcwLFxuICAweGZmOWYsIDB4ZWZiZSwgMHhkZmRkLCAweGNmZmMsIDB4YmYxYiwgMHhhZjNhLCAweDlmNTksIDB4OGY3OCxcbiAgMHg5MTg4LCAweDgxYTksIDB4YjFjYSwgMHhhMWViLCAweGQxMGMsIDB4YzEyZCwgMHhmMTRlLCAweGUxNmYsXG4gIDB4MTA4MCwgMHgwMGExLCAweDMwYzIsIDB4MjBlMywgMHg1MDA0LCAweDQwMjUsIDB4NzA0NiwgMHg2MDY3LFxuICAweDgzYjksIDB4OTM5OCwgMHhhM2ZiLCAweGIzZGEsIDB4YzMzZCwgMHhkMzFjLCAweGUzN2YsIDB4ZjM1ZSxcbiAgMHgwMmIxLCAweDEyOTAsIDB4MjJmMywgMHgzMmQyLCAweDQyMzUsIDB4NTIxNCwgMHg2Mjc3LCAweDcyNTYsXG4gIDB4YjVlYSwgMHhhNWNiLCAweDk1YTgsIDB4ODU4OSwgMHhmNTZlLCAweGU1NGYsIDB4ZDUyYywgMHhjNTBkLFxuICAweDM0ZTIsIDB4MjRjMywgMHgxNGEwLCAweDA0ODEsIDB4NzQ2NiwgMHg2NDQ3LCAweDU0MjQsIDB4NDQwNSxcbiAgMHhhN2RiLCAweGI3ZmEsIDB4ODc5OSwgMHg5N2I4LCAweGU3NWYsIDB4Zjc3ZSwgMHhjNzFkLCAweGQ3M2MsXG4gIDB4MjZkMywgMHgzNmYyLCAweDA2OTEsIDB4MTZiMCwgMHg2NjU3LCAweDc2NzYsIDB4NDYxNSwgMHg1NjM0LFxuICAweGQ5NGMsIDB4Yzk2ZCwgMHhmOTBlLCAweGU5MmYsIDB4OTljOCwgMHg4OWU5LCAweGI5OGEsIDB4YTlhYixcbiAgMHg1ODQ0LCAweDQ4NjUsIDB4NzgwNiwgMHg2ODI3LCAweDE4YzAsIDB4MDhlMSwgMHgzODgyLCAweDI4YTMsXG4gIDB4Y2I3ZCwgMHhkYjVjLCAweGViM2YsIDB4ZmIxZSwgMHg4YmY5LCAweDliZDgsIDB4YWJiYiwgMHhiYjlhLFxuICAweDRhNzUsIDB4NWE1NCwgMHg2YTM3LCAweDdhMTYsIDB4MGFmMSwgMHgxYWQwLCAweDJhYjMsIDB4M2E5MixcbiAgMHhmZDJlLCAweGVkMGYsIDB4ZGQ2YywgMHhjZDRkLCAweGJkYWEsIDB4YWQ4YiwgMHg5ZGU4LCAweDhkYzksXG4gIDB4N2MyNiwgMHg2YzA3LCAweDVjNjQsIDB4NGM0NSwgMHgzY2EyLCAweDJjODMsIDB4MWNlMCwgMHgwY2MxLFxuICAweGVmMWYsIDB4ZmYzZSwgMHhjZjVkLCAweGRmN2MsIDB4YWY5YiwgMHhiZmJhLCAweDhmZDksIDB4OWZmOCxcbiAgMHg2ZTE3LCAweDdlMzYsIDB4NGU1NSwgMHg1ZTc0LCAweDJlOTMsIDB4M2ViMiwgMHgwZWQxLCAweDFlZjBcbl1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMxNlxuXG5mdW5jdGlvbiBjcmMxNiAobikge1xuICB2YXIgY3JjID0gMFxuICB2YXIgciA9IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIHIgPSBuICYgMHhmZlxuICAgIG4gPSAobiAtIHIpIC8gMjU2XG4gICAgY3JjID0gKChjcmMgPDwgOCkgXiBUQUJMRVsoKGNyYyA+PiA4KSBeIHIpICYgMHhmZl0pICYgMHhmZmZmXG4gIH1cblxuICByZXR1cm4gY3JjXG59XG4iLCJ2YXIgaGFzaCA9IHJlcXVpcmUoJy4vY3JjMTYnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVVxuXG5mdW5jdGlvbiBMUlUgKG1heCwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTFJVKSkgcmV0dXJuIG5ldyBMUlUobWF4LCBvcHRzKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIC8vIGhvdyBtYW55IGNvbGxpc2lvbnMgYmVmb3JlIGV2aWN0aW5nIChmYWN0b3Igb2YgdHdvIGZvciBmYXN0IG1vZHVsbylcbiAgdGhpcy5jb2xsaXNpb25zID0gZmFjdG9yT2ZUd28ob3B0cy5jb2xsaXNpb25zIHx8IG9wdHMuYnVja2V0U2l6ZSB8fCA0KVxuICAvLyBidWNrZXRzIHNob3VsZCBiZSBhIGZhY3RvciBvZiB0d28gZm9yIGZhc3QgbW9kdWxvIGFzIHdlbGxcbiAgdGhpcy5idWNrZXRzID0gZmFjdG9yT2YobWF4LCB0aGlzLmNvbGxpc2lvbnMpIC8gdGhpcy5jb2xsaXNpb25zXG5cbiAgLy8gd2UgdXNlIDE2Yml0IGhhc2hpbmcgdG8gYnVja2V0IGluZGV4IG11c3QgYmUgPDB4ZmZmZlxuICB3aGlsZSAodGhpcy5idWNrZXRzID4gNjU1MzYpIHtcbiAgICB0aGlzLmJ1Y2tldHMgPj49IDFcbiAgICB0aGlzLmNvbGxpc2lvbnMgPDw9IDFcbiAgfVxuXG4gIHRoaXMuc2l6ZSA9IHRoaXMuYnVja2V0cyAqIHRoaXMuY29sbGlzaW9uc1xuICB0aGlzLndyYXAgPSAhb3B0cy5pbmRleGVkVmFsdWVzXG4gIHRoaXMuY2FjaGUgPSBuZXcgQXJyYXkodGhpcy5zaXplKVxuICB0aGlzLmhhc2ggPSB0aGlzLmJ1Y2tldHMgPT09IDY1NTM2ID8gaGFzaCA6IG1hc2tlZEhhc2godGhpcy5idWNrZXRzIC0gMSlcbiAgdGhpcy5ldmljdCA9IG9wdHMuZXZpY3QgfHwgbnVsbFxufVxuXG5MUlUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsKSB7XG4gIHZhciBwYWdlU3RhcnQgPSB0aGlzLmNvbGxpc2lvbnMgKiB0aGlzLmhhc2goaW5kZXgpXG4gIHZhciBwYWdlRW5kID0gcGFnZVN0YXJ0ICsgdGhpcy5jb2xsaXNpb25zXG4gIHZhciBwdHIgPSBwYWdlU3RhcnRcbiAgdmFyIHBhZ2UgPSBudWxsXG5cbiAgd2hpbGUgKHB0ciA8IHBhZ2VFbmQpIHtcbiAgICBwYWdlID0gdGhpcy5jYWNoZVtwdHJdXG5cbiAgICBpZiAoIXBhZ2UpIHtcbiAgICAgIC8vIG5vIGV4aXRpbmcgdmVyc2lvbiwgYnV0IHdlIGhhdmUgc3BhY2UgdG8gc3RvcmUgaXRcbiAgICAgIHBhZ2UgPSB0aGlzLmNhY2hlW3B0cl0gPSB0aGlzLndyYXAgPyBuZXcgTm9kZShpbmRleCwgdmFsKSA6IHZhbFxuICAgICAgbW92ZSh0aGlzLmNhY2hlLCBwYWdlU3RhcnQsIHB0ciwgcGFnZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYWdlLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIHZlcnNpb24gYW5kIG1vdmUgdG8gaGVhZCBvZiBidWNrZXRcbiAgICAgIGlmICh0aGlzLndyYXApIHBhZ2UudmFsdWUgPSB2YWxcbiAgICAgIGVsc2UgdGhpcy5jYWNoZVtwdHJdID0gdmFsXG4gICAgICBtb3ZlKHRoaXMuY2FjaGUsIHBhZ2VTdGFydCwgcHRyLCBwYWdlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcHRyKytcbiAgfVxuXG4gIC8vIGJ1Y2tldCBpcyBmdWxsLCB1cGRhdGUgb2xkZXN0IChsYXN0IGVsZW1lbnQgaW4gYnVja2V0KVxuICBpZiAodGhpcy53cmFwKSB7XG4gICAgaWYgKHRoaXMuZXZpY3QpIHRoaXMuZXZpY3QocGFnZS5pbmRleCwgcGFnZS52YWx1ZSlcbiAgICBwYWdlLmluZGV4ID0gaW5kZXhcbiAgICBwYWdlLnZhbHVlID0gdmFsXG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuZXZpY3QpIHRoaXMuZXZpY3QocGFnZS5pbmRleCwgcGFnZSlcbiAgICB0aGlzLmNhY2hlW3B0ciAtIDFdID0gdmFsXG4gIH1cbiAgbW92ZSh0aGlzLmNhY2hlLCBwYWdlU3RhcnQsIHB0ciAtIDEsIHBhZ2UpXG59XG5cbkxSVS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHZhciBwYWdlU3RhcnQgPSB0aGlzLmNvbGxpc2lvbnMgKiB0aGlzLmhhc2goaW5kZXgpXG4gIHZhciBwYWdlRW5kID0gcGFnZVN0YXJ0ICsgdGhpcy5jb2xsaXNpb25zXG4gIHZhciBwdHIgPSBwYWdlU3RhcnRcblxuICB3aGlsZSAocHRyIDwgcGFnZUVuZCkge1xuICAgIHZhciBwYWdlID0gdGhpcy5jYWNoZVtwdHIrK11cblxuICAgIGlmICghcGFnZSkgcmV0dXJuIG51bGxcbiAgICBpZiAocGFnZS5pbmRleCAhPT0gaW5kZXgpIGNvbnRpbnVlXG5cbiAgICAvLyB3ZSBmb3VuZCBpdCEgbW92ZSB0byBoZWFkIG9mIGJ1Y2tldCBhbmQgcmV0dXJuIHZhbHVlXG4gICAgbW92ZSh0aGlzLmNhY2hlLCBwYWdlU3RhcnQsIHB0ciAtIDEsIHBhZ2UpXG5cbiAgICByZXR1cm4gdGhpcy53cmFwID8gcGFnZS52YWx1ZSA6IHBhZ2VcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG1vdmUgKGxpc3QsIGluZGV4LCBpdGVtSW5kZXgsIGl0ZW0pIHtcbiAgd2hpbGUgKGl0ZW1JbmRleCA+IGluZGV4KSBsaXN0W2l0ZW1JbmRleF0gPSBsaXN0Wy0taXRlbUluZGV4XVxuICBsaXN0W2luZGV4XSA9IGl0ZW1cbn1cblxuZnVuY3Rpb24gTm9kZSAoaW5kZXgsIHZhbHVlKSB7XG4gIHRoaXMuaW5kZXggPSBpbmRleFxuICB0aGlzLnZhbHVlID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gZmFjdG9yT2YgKG4sIGZhY3Rvcikge1xuICBuID0gZmFjdG9yT2ZUd28obilcbiAgd2hpbGUgKG4gJiAoZmFjdG9yIC0gMSkpIG4gPDw9IDFcbiAgcmV0dXJuIG5cbn1cblxuZnVuY3Rpb24gZmFjdG9yT2ZUd28gKG4pIHtcbiAgaWYgKG4gJiYgIShuICYgKG4gLSAxKSkpIHJldHVybiBuXG4gIHZhciBwID0gMVxuICB3aGlsZSAocCA8IG4pIHAgPDw9IDFcbiAgcmV0dXJuIHBcbn1cblxuZnVuY3Rpb24gbWFza2VkSGFzaCAobWFzaykge1xuICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gaGFzaChuKSAmIG1hc2tcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBiYXRjaGVyXG5cbmZ1bmN0aW9uIGJhdGNoZXIgKHJ1bikge1xuICB2YXIgcnVubmluZyA9IGZhbHNlXG4gIHZhciBwZW5kaW5nQmF0Y2ggPSBudWxsXG4gIHZhciBwZW5kaW5nQ2FsbGJhY2tzID0gbnVsbFxuICB2YXIgY2FsbGJhY2tzID0gbnVsbFxuXG4gIHJldHVybiBhcHBlbmRcblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBpZiAoY2FsbGJhY2tzKSBjYWxsQWxsKGNhbGxiYWNrcywgZXJyKVxuXG4gICAgcnVubmluZyA9IGZhbHNlXG4gICAgY2FsbGJhY2tzID0gcGVuZGluZ0NhbGxiYWNrc1xuICAgIHZhciBuZXh0QmF0Y2ggPSBwZW5kaW5nQmF0Y2hcblxuICAgIHBlbmRpbmdCYXRjaCA9IG51bGxcbiAgICBwZW5kaW5nQ2FsbGJhY2tzID0gbnVsbFxuXG4gICAgaWYgKCFuZXh0QmF0Y2ggfHwgIW5leHRCYXRjaC5sZW5ndGgpIHtcbiAgICAgIGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrcyA9IG51bGxcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoIW5leHRCYXRjaCkgbmV4dEJhdGNoID0gW11cbiAgICB9XG5cbiAgICBydW5uaW5nID0gdHJ1ZVxuICAgIHJ1bihuZXh0QmF0Y2gsIGRvbmUpXG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmQgKHZhbCwgY2IpIHtcbiAgICBpZiAocnVubmluZykge1xuICAgICAgaWYgKCFwZW5kaW5nQmF0Y2gpIHtcbiAgICAgICAgcGVuZGluZ0JhdGNoID0gW11cbiAgICAgICAgcGVuZGluZ0NhbGxiYWNrcyA9IFtdXG4gICAgICB9XG4gICAgICBwdXNoQWxsKHBlbmRpbmdCYXRjaCwgdmFsKVxuICAgICAgaWYgKGNiKSBwZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjYikgY2FsbGJhY2tzID0gW2NiXVxuICAgICAgcnVubmluZyA9IHRydWVcbiAgICAgIHJ1bihBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSwgZG9uZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaEFsbCAobGlzdCwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHB1c2hBcnJheShsaXN0LCB2YWwpXG4gIGVsc2UgbGlzdC5wdXNoKHZhbClcbn1cblxuZnVuY3Rpb24gcHVzaEFycmF5IChsaXN0LCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIGxpc3QucHVzaCh2YWxbaV0pXG59XG5cbmZ1bmN0aW9uIGNhbGxBbGwgKGxpc3QsIGVycikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0oZXJyKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJ2YXIgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcblxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGVcbmV4cG9ydHMuZW5jb2RlLmJ5dGVzID0gMFxuZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG5cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlXG5leHBvcnRzLmRlY29kZS5ieXRlcyA9IDBcbmV4cG9ydHMuZGVjb2RpbmdMZW5ndGggPSBkZWNvZGluZ0xlbmd0aFxuXG5mdW5jdGlvbiBTdGF0ZSAoaW5wdXQsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHRoaXMuaW5wdXRPZmZzZXQgPSAwXG4gIHRoaXMuaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGhcbiAgdGhpcy5pbnB1dCA9IGlucHV0XG4gIHRoaXMub3V0cHV0T2Zmc2V0ID0gb2Zmc2V0XG4gIHRoaXMub3V0cHV0ID0gb3V0cHV0XG59XG5cbmZ1bmN0aW9uIGVuY29kZSAoYml0ZmllbGQsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gIGlmICghYnVmZmVyKSBidWZmZXIgPSBuZXcgQnVmZmVyKGVuY29kaW5nTGVuZ3RoKGJpdGZpZWxkKSlcbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKGJpdGZpZWxkLCBidWZmZXIsIG9mZnNldClcbiAgcmxlKHN0YXRlKVxuICBlbmNvZGUuYnl0ZXMgPSBzdGF0ZS5vdXRwdXRPZmZzZXQgLSBvZmZzZXRcbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAoYml0ZmllbGQpIHtcbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKGJpdGZpZWxkLCBudWxsLCAwKVxuICBybGUoc3RhdGUpXG4gIHJldHVybiBzdGF0ZS5vdXRwdXRPZmZzZXRcbn1cblxuZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuXG4gIHZhciBiaXRmaWVsZCA9IG5ldyBCdWZmZXIoZGVjb2RpbmdMZW5ndGgoYnVmZmVyLCBvZmZzZXQpKVxuICB2YXIgcHRyID0gMFxuXG4gIHdoaWxlIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgdmFyIG5leHQgPSB2YXJpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KVxuICAgIHZhciByZXBlYXQgPSBuZXh0ICYgMVxuICAgIHZhciBsZW4gPSByZXBlYXQgPyAobmV4dCAtIChuZXh0ICYgMykpIC8gNCA6IG5leHQgLyAyXG5cbiAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gICAgaWYgKHJlcGVhdCkge1xuICAgICAgYml0ZmllbGQuZmlsbChuZXh0ICYgMiA/IDI1NSA6IDAsIHB0ciwgcHRyICsgbGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIuY29weShiaXRmaWVsZCwgcHRyLCBvZmZzZXQsIG9mZnNldCArIGxlbilcbiAgICAgIG9mZnNldCArPSBsZW5cbiAgICB9XG5cbiAgICBwdHIgKz0gbGVuXG4gIH1cblxuICBkZWNvZGUuYnl0ZXMgPSBidWZmZXIubGVuZ3RoIC0gb2Zmc2V0XG5cbiAgcmV0dXJuIGJpdGZpZWxkXG59XG5cbmZ1bmN0aW9uIGRlY29kaW5nTGVuZ3RoIChidWZmZXIsIG9mZnNldCkge1xuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuXG4gIHZhciBsZW4gPSAwXG5cbiAgd2hpbGUgKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICB2YXIgbmV4dCA9IHZhcmludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcblxuICAgIHZhciByZXBlYXQgPSBuZXh0ICYgMVxuICAgIHZhciBzbGljZSA9IHJlcGVhdCA/IChuZXh0IC0gKG5leHQgJiAzKSkgLyA0IDogbmV4dCAvIDJcblxuICAgIGxlbiArPSBzbGljZVxuICAgIGlmICghcmVwZWF0KSBvZmZzZXQgKz0gc2xpY2VcbiAgfVxuXG4gIGlmIChvZmZzZXQgPiBidWZmZXIubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkxFIGJpdGZpZWxkJylcblxuICByZXR1cm4gbGVuXG59XG5cbmZ1bmN0aW9uIHJsZSAoc3RhdGUpIHtcbiAgdmFyIGxlbiA9IDBcbiAgdmFyIGJpdHMgPSAwXG4gIHZhciBpbnB1dCA9IHN0YXRlLmlucHV0XG5cbiAgd2hpbGUgKHN0YXRlLmlucHV0TGVuZ3RoID4gMCAmJiAhaW5wdXRbc3RhdGUuaW5wdXRMZW5ndGggLSAxXSkgc3RhdGUuaW5wdXRMZW5ndGgtLVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuaW5wdXRMZW5ndGg7IGkrKykge1xuICAgIGlmIChpbnB1dFtpXSA9PT0gYml0cykge1xuICAgICAgbGVuKytcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGxlbikgZW5jb2RlVXBkYXRlKHN0YXRlLCBpLCBsZW4sIGJpdHMpXG5cbiAgICBpZiAoaW5wdXRbaV0gPT09IDAgfHwgaW5wdXRbaV0gPT09IDI1NSkge1xuICAgICAgYml0cyA9IGlucHV0W2ldXG4gICAgICBsZW4gPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbiA9IDBcbiAgICB9XG4gIH1cblxuICBpZiAobGVuKSBlbmNvZGVVcGRhdGUoc3RhdGUsIHN0YXRlLmlucHV0TGVuZ3RoLCBsZW4sIGJpdHMpXG4gIGVuY29kZUZpbmFsKHN0YXRlKVxufVxuXG5mdW5jdGlvbiBlbmNvZGVIZWFkIChzdGF0ZSwgZW5kKSB7XG4gIHZhciBoZWFkTGVuZ3RoID0gZW5kIC0gc3RhdGUuaW5wdXRPZmZzZXRcbiAgdmFyaW50LmVuY29kZSgyICogaGVhZExlbmd0aCwgc3RhdGUub3V0cHV0LCBzdGF0ZS5vdXRwdXRPZmZzZXQpXG4gIHN0YXRlLm91dHB1dE9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG4gIHN0YXRlLmlucHV0LmNvcHkoc3RhdGUub3V0cHV0LCBzdGF0ZS5vdXRwdXRPZmZzZXQsIHN0YXRlLmlucHV0T2Zmc2V0LCBlbmQpXG4gIHN0YXRlLm91dHB1dE9mZnNldCArPSBoZWFkTGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGVuY29kZUZpbmFsIChzdGF0ZSkge1xuICB2YXIgaGVhZExlbmd0aCA9IHN0YXRlLmlucHV0TGVuZ3RoIC0gc3RhdGUuaW5wdXRPZmZzZXRcbiAgaWYgKCFoZWFkTGVuZ3RoKSByZXR1cm5cblxuICBpZiAoIXN0YXRlLm91dHB1dCkge1xuICAgIHN0YXRlLm91dHB1dE9mZnNldCArPSAoaGVhZExlbmd0aCArIHZhcmludC5lbmNvZGluZ0xlbmd0aCgyICogaGVhZExlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgZW5jb2RlSGVhZChzdGF0ZSwgc3RhdGUuaW5wdXRMZW5ndGgpXG4gIH1cblxuICBzdGF0ZS5pbnB1dE9mZnNldCA9IHN0YXRlLmlucHV0TGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGVuY29kZVVwZGF0ZSAoc3RhdGUsIGksIGxlbiwgYml0KSB7XG4gIHZhciBoZWFkTGVuZ3RoID0gaSAtIGxlbiAtIHN0YXRlLmlucHV0T2Zmc2V0XG4gIHZhciBoZWFkQ29zdCA9IChoZWFkTGVuZ3RoID8gdmFyaW50LmVuY29kaW5nTGVuZ3RoKDIgKiBoZWFkTGVuZ3RoKSArIGhlYWRMZW5ndGggOiAwKVxuICB2YXIgZW5jID0gNCAqIGxlbiArIChiaXQgPyAyIDogMCkgKyAxIC8vIGxlbiA8PCAyIHwgYml0IDw8IDEgfCAxXG4gIHZhciBlbmNDb3N0ID0gaGVhZENvc3QgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoZW5jKVxuICB2YXIgYmFzZUNvc3QgPSB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoMiAqIChpIC0gc3RhdGUuaW5wdXRPZmZzZXQpKSArIGkgLSBzdGF0ZS5pbnB1dE9mZnNldFxuXG4gIGlmIChlbmNDb3N0ID49IGJhc2VDb3N0KSByZXR1cm5cblxuICBpZiAoIXN0YXRlLm91dHB1dCkge1xuICAgIHN0YXRlLm91dHB1dE9mZnNldCArPSBlbmNDb3N0XG4gICAgc3RhdGUuaW5wdXRPZmZzZXQgPSBpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoaGVhZExlbmd0aCkgZW5jb2RlSGVhZChzdGF0ZSwgaSAtIGxlbilcblxuICB2YXJpbnQuZW5jb2RlKGVuYywgc3RhdGUub3V0cHV0LCBzdGF0ZS5vdXRwdXRPZmZzZXQpXG4gIHN0YXRlLm91dHB1dE9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG4gIHN0YXRlLmlucHV0T2Zmc2V0ID0gaVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZWFkXG5cbnZhciBNU0IgPSAweDgwXG4gICwgUkVTVCA9IDB4N0ZcblxuZnVuY3Rpb24gcmVhZChidWYsIG9mZnNldCkge1xuICB2YXIgcmVzICAgID0gMFxuICAgICwgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgICAsIHNoaWZ0ICA9IDBcbiAgICAsIGNvdW50ZXIgPSBvZmZzZXRcbiAgICAsIGJcbiAgICAsIGwgPSBidWYubGVuZ3RoXG5cbiAgZG8ge1xuICAgIGlmKGNvdW50ZXIgPj0gbCkge1xuICAgICAgcmVhZC5ieXRlcyA9IDBcbiAgICAgIHJlYWQuYnl0ZXNSZWFkID0gMCAvLyBERVBSRUNBVEVEXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXVxuICAgIHJlcyArPSBzaGlmdCA8IDI4XG4gICAgICA/IChiICYgUkVTVCkgPDwgc2hpZnRcbiAgICAgIDogKGIgJiBSRVNUKSAqIE1hdGgucG93KDIsIHNoaWZ0KVxuICAgIHNoaWZ0ICs9IDdcbiAgfSB3aGlsZSAoYiA+PSBNU0IpXG5cbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXRcblxuICByZXR1cm4gcmVzXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG4gICwgTVNCQUxMID0gflJFU1RcbiAgLCBJTlQgPSBNYXRoLnBvdygyLCAzMSlcblxuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgb3V0ID0gb3V0IHx8IFtdXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICB3aGlsZShudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSAvPSAxMjhcbiAgfVxuICB3aGlsZShudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtID4+Pj0gN1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMFxuICBcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMVxuICBcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZW5jb2RlOiByZXF1aXJlKCcuL2VuY29kZS5qcycpXG4gICwgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZS5qcycpXG4gICwgZW5jb2RpbmdMZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoLmpzJylcbn1cbiIsIlxudmFyIE4xID0gTWF0aC5wb3coMiwgIDcpXG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNClcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKVxudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpXG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSlcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKVxudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpXG52YXIgTjggPSBNYXRoLnBvdygyLCA1NilcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIDwgTjEgPyAxXG4gIDogdmFsdWUgPCBOMiA/IDJcbiAgOiB2YWx1ZSA8IE4zID8gM1xuICA6IHZhbHVlIDwgTjQgPyA0XG4gIDogdmFsdWUgPCBONSA/IDVcbiAgOiB2YWx1ZSA8IE42ID8gNlxuICA6IHZhbHVlIDwgTjcgPyA3XG4gIDogdmFsdWUgPCBOOCA/IDhcbiAgOiB2YWx1ZSA8IE45ID8gOVxuICA6ICAgICAgICAgICAgICAxMFxuICApXG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gbG9hZFdlYkFzc2VtYmx5XG5cbmxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICd1bmRlZmluZWQnXG5cbmZ1bmN0aW9uIGxvYWRXZWJBc3NlbWJseSAob3B0cykge1xuICBpZiAoIWxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQpIHJldHVybiBudWxsXG5cbiAgdmFyIGltcCA9IG9wdHMgJiYgb3B0cy5pbXBvcnRzXG4gIHZhciB3YXNtID0gdG9VaW50OEFycmF5KCdBR0Z6YlFFQUFBQUJFQU5nQW45L0FHQURmMzkvQUdBQmZ3QURCUVFBQVFJQ0JRVUJBUXJvQndkTkJRWnRaVzF2Y25rQ0FBeGliR0ZyWlRKaVgybHVhWFFBQUE1aWJHRnJaVEppWDNWd1pHRjBaUUFCRFdKc1lXdGxNbUpmWm1sdVlXd0FBaEJpYkdGclpUSmlYMk52YlhCeVpYTnpBQU1LMDBBRWxnTUFJQUJDQURjREFDQUFRUWhxUWdBM0F3QWdBRUVRYWtJQU53TUFJQUJCR0dwQ0FEY0RBQ0FBUVNCcVFnQTNBd0FnQUVFb2FrSUFOd01BSUFCQk1HcENBRGNEQUNBQVFUaHFRZ0EzQXdBZ0FFSEFBR3BDQURjREFDQUFRY2dBYWtJQU53TUFJQUJCMEFCcVFnQTNBd0FnQUVIWUFHcENBRGNEQUNBQVFlQUFha0lBTndNQUlBQkI2QUJxUWdBM0F3QWdBRUh3QUdwQ0FEY0RBQ0FBUWZnQWFrSUFOd01BSUFCQmdBRnFRb2lTODUzL3pQbUU2Z0JCQUNrREFJVTNBd0FnQUVHSUFXcEN1ODZxcHRqUTY3TzdmMEVJS1FNQWhUY0RBQ0FBUVpBQmFrS3I4TlAwcis2OHR6eEJFQ2tEQUlVM0F3QWdBRUdZQVdwQzhlMzArS1duL2FlbGYwRVlLUU1BaFRjREFDQUFRYUFCYWtMUmhacnYrcytVaDlFQVFTQXBBd0NGTndNQUlBQkJxQUZxUXAvWStkbkNrZHFDbTM5QktDa0RBSVUzQXdBZ0FFR3dBV3BDNi9xRzJyKzE5c0VmUVRBcEF3Q0ZOd01BSUFCQnVBRnFRdm5DK0p1Um83UHcyd0JCT0NrREFJVTNBd0FnQUVIQUFXcENBRGNEQUNBQVFjZ0Jha0lBTndNQUlBQkIwQUZxUWdBM0F3QUxiUUVEZnlBQVFjQUJhaUVESUFCQnlBRnFJUVFnQkNrREFLY2hCUUpBQTBBZ0FTQUNSZzBCSUFWQmdBRkdCRUFnQXlBREtRTUFJQVd0ZkRjREFFRUFJUVVnQUJBREN5QUFJQVZxSUFFdEFBQTZBQUFnQlVFQmFpRUZJQUZCQVdvaEFRd0FDd3NnQkNBRnJUY0RBQXRrQVFOL0lBQkJ3QUZxSVFFZ0FFSElBV29oQWlBQklBRXBBd0FnQWlrREFIdzNBd0FnQUVIUUFXcENmemNEQUNBQ0tRTUFweUVEQWtBRFFDQURRWUFCUmcwQklBQWdBMnBCQURvQUFDQURRUUZxSVFNTUFBc0xJQUlnQTYwM0F3QWdBQkFEQytVN0FpQitDWDhnQUVHQUFXb2hJU0FBUVlnQmFpRWlJQUJCa0FGcUlTTWdBRUdZQVdvaEpDQUFRYUFCYWlFbElBQkJxQUZxSVNZZ0FFR3dBV29oSnlBQVFiZ0JhaUVvSUNFcEF3QWhBU0FpS1FNQUlRSWdJeWtEQUNFRElDUXBBd0FoQkNBbEtRTUFJUVVnSmlrREFDRUdJQ2NwQXdBaEJ5QW9LUU1BSVFoQ2lKTHpuZi9NK1lUcUFDRUpRcnZPcXFiWTBPdXp1MzhoQ2tLcjhOUDByKzY4dHp3aEMwTHg3ZlQ0cGFmOXA2Vi9JUXhDMFlXYTcvclBsSWZSQUNFTlFwL1krZG5Da2RxQ20zOGhEa0xyK29iYXY3WDJ3UjhoRDBMNXd2aWJrYU96OE5zQUlSQWdBQ2tEQUNFUklBQkJDR29wQXdBaEVpQUFRUkJxS1FNQUlSTWdBRUVZYWlrREFDRVVJQUJCSUdvcEF3QWhGU0FBUVNocUtRTUFJUllnQUVFd2Fpa0RBQ0VYSUFCQk9Hb3BBd0FoR0NBQVFjQUFhaWtEQUNFWklBQkJ5QUJxS1FNQUlSb2dBRUhRQUdvcEF3QWhHeUFBUWRnQWFpa0RBQ0VjSUFCQjRBQnFLUU1BSVIwZ0FFSG9BR29wQXdBaEhpQUFRZkFBYWlrREFDRWZJQUJCK0FCcUtRTUFJU0FnRFNBQVFjQUJhaWtEQUlVaERTQVBJQUJCMEFGcUtRTUFoU0VQSUFFZ0JTQVJmSHdoQVNBTklBR0ZRaUNLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNHSW9oQlNBQklBVWdFbng4SVFFZ0RTQUJoVUlRaWlFTklBa2dEWHdoQ1NBRklBbUZRaitLSVFVZ0FpQUdJQk44ZkNFQ0lBNGdBb1ZDSUlvaERpQUtJQTU4SVFvZ0JpQUtoVUlZaWlFR0lBSWdCaUFVZkh3aEFpQU9JQUtGUWhDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDUDRvaEJpQURJQWNnRlh4OElRTWdEeUFEaFVJZ2lpRVBJQXNnRDN3aEN5QUhJQXVGUWhpS0lRY2dBeUFISUJaOGZDRURJQThnQTRWQ0VJb2hEeUFMSUE5OElRc2dCeUFMaFVJL2lpRUhJQVFnQ0NBWGZId2hCQ0FRSUFTRlFpQ0tJUkFnRENBUWZDRU1JQWdnRElWQ0dJb2hDQ0FFSUFnZ0dIeDhJUVFnRUNBRWhVSVFpaUVRSUF3Z0VId2hEQ0FJSUF5RlFqK0tJUWdnQVNBR0lCbDhmQ0VCSUJBZ0FZVkNJSW9oRUNBTElCQjhJUXNnQmlBTGhVSVlpaUVHSUFFZ0JpQWFmSHdoQVNBUUlBR0ZRaENLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNQNG9oQmlBQ0lBY2dHM3g4SVFJZ0RTQUNoVUlnaWlFTklBd2dEWHdoRENBSElBeUZRaGlLSVFjZ0FpQUhJQng4ZkNFQ0lBMGdBb1ZDRUlvaERTQU1JQTE4SVF3Z0J5QU1oVUkvaWlFSElBTWdDQ0FkZkh3aEF5QU9JQU9GUWlDS0lRNGdDU0FPZkNFSklBZ2dDWVZDR0lvaENDQURJQWdnSG54OElRTWdEaUFEaFVJUWlpRU9JQWtnRG53aENTQUlJQW1GUWorS0lRZ2dCQ0FGSUI5OGZDRUVJQThnQklWQ0lJb2hEeUFLSUE5OElRb2dCU0FLaFVJWWlpRUZJQVFnQlNBZ2ZId2hCQ0FQSUFTRlFoQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ1A0b2hCU0FCSUFVZ0gzeDhJUUVnRFNBQmhVSWdpaUVOSUFrZ0RYd2hDU0FGSUFtRlFoaUtJUVVnQVNBRklCdDhmQ0VCSUEwZ0FZVkNFSW9oRFNBSklBMThJUWtnQlNBSmhVSS9paUVGSUFJZ0JpQVZmSHdoQWlBT0lBS0ZRaUNLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNHSW9oQmlBQ0lBWWdHWHg4SVFJZ0RpQUNoVUlRaWlFT0lBb2dEbndoQ2lBR0lBcUZRaitLSVFZZ0F5QUhJQnA4ZkNFRElBOGdBNFZDSUlvaER5QUxJQTk4SVFzZ0J5QUxoVUlZaWlFSElBTWdCeUFnZkh3aEF5QVBJQU9GUWhDS0lROGdDeUFQZkNFTElBY2dDNFZDUDRvaEJ5QUVJQWdnSG54OElRUWdFQ0FFaFVJZ2lpRVFJQXdnRUh3aERDQUlJQXlGUWhpS0lRZ2dCQ0FJSUJkOGZDRUVJQkFnQklWQ0VJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJL2lpRUlJQUVnQmlBU2ZId2hBU0FRSUFHRlFpQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ0dJb2hCaUFCSUFZZ0hYeDhJUUVnRUNBQmhVSVFpaUVRSUFzZ0VId2hDeUFHSUF1RlFqK0tJUVlnQWlBSElCRjhmQ0VDSUEwZ0FvVkNJSW9oRFNBTUlBMThJUXdnQnlBTWhVSVlpaUVISUFJZ0J5QVRmSHdoQWlBTklBS0ZRaENLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNQNG9oQnlBRElBZ2dISHg4SVFNZ0RpQURoVUlnaWlFT0lBa2dEbndoQ1NBSUlBbUZRaGlLSVFnZ0F5QUlJQmg4ZkNFRElBNGdBNFZDRUlvaERpQUpJQTU4SVFrZ0NDQUpoVUkvaWlFSUlBUWdCU0FXZkh3aEJDQVBJQVNGUWlDS0lROGdDaUFQZkNFS0lBVWdDb1ZDR0lvaEJTQUVJQVVnRkh4OElRUWdEeUFFaFVJUWlpRVBJQW9nRDN3aENpQUZJQXFGUWorS0lRVWdBU0FGSUJ4OGZDRUJJQTBnQVlWQ0lJb2hEU0FKSUExOElRa2dCU0FKaFVJWWlpRUZJQUVnQlNBWmZId2hBU0FOSUFHRlFoQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ1A0b2hCU0FDSUFZZ0hYeDhJUUlnRGlBQ2hVSWdpaUVPSUFvZ0Rud2hDaUFHSUFxRlFoaUtJUVlnQWlBR0lCRjhmQ0VDSUE0Z0FvVkNFSW9oRGlBS0lBNThJUW9nQmlBS2hVSS9paUVHSUFNZ0J5QVdmSHdoQXlBUElBT0ZRaUNLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNHSW9oQnlBRElBY2dFM3g4SVFNZ0R5QURoVUlRaWlFUElBc2dEM3doQ3lBSElBdUZRaitLSVFjZ0JDQUlJQ0I4ZkNFRUlCQWdCSVZDSUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUlZaWlFSUlBUWdDQ0FlZkh3aEJDQVFJQVNGUWhDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDUDRvaENDQUJJQVlnRzN4OElRRWdFQ0FCaFVJZ2lpRVFJQXNnRUh3aEN5QUdJQXVGUWhpS0lRWWdBU0FHSUI5OGZDRUJJQkFnQVlWQ0VJb2hFQ0FMSUJCOElRc2dCaUFMaFVJL2lpRUdJQUlnQnlBVWZId2hBaUFOSUFLRlFpQ0tJUTBnRENBTmZDRU1JQWNnRElWQ0dJb2hCeUFDSUFjZ0YzeDhJUUlnRFNBQ2hVSVFpaUVOSUF3Z0RYd2hEQ0FISUF5RlFqK0tJUWNnQXlBSUlCaDhmQ0VESUE0Z0E0VkNJSW9oRGlBSklBNThJUWtnQ0NBSmhVSVlpaUVJSUFNZ0NDQVNmSHdoQXlBT0lBT0ZRaENLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNQNG9oQ0NBRUlBVWdHbng4SVFRZ0R5QUVoVUlnaWlFUElBb2dEM3doQ2lBRklBcUZRaGlLSVFVZ0JDQUZJQlY4ZkNFRUlBOGdCSVZDRUlvaER5QUtJQTk4SVFvZ0JTQUtoVUkvaWlFRklBRWdCU0FZZkh3aEFTQU5JQUdGUWlDS0lRMGdDU0FOZkNFSklBVWdDWVZDR0lvaEJTQUJJQVVnR254OElRRWdEU0FCaFVJUWlpRU5JQWtnRFh3aENTQUZJQW1GUWorS0lRVWdBaUFHSUJSOGZDRUNJQTRnQW9WQ0lJb2hEaUFLSUE1OElRb2dCaUFLaFVJWWlpRUdJQUlnQmlBU2ZId2hBaUFPSUFLRlFoQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ1A0b2hCaUFESUFjZ0hueDhJUU1nRHlBRGhVSWdpaUVQSUFzZ0Qzd2hDeUFISUF1RlFoaUtJUWNnQXlBSElCMThmQ0VESUE4Z0E0VkNFSW9oRHlBTElBOThJUXNnQnlBTGhVSS9paUVISUFRZ0NDQWNmSHdoQkNBUUlBU0ZRaUNLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNHSW9oQ0NBRUlBZ2dIM3g4SVFRZ0VDQUVoVUlRaWlFUUlBd2dFSHdoRENBSUlBeUZRaitLSVFnZ0FTQUdJQk44ZkNFQklCQWdBWVZDSUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUlZaWlFR0lBRWdCaUFYZkh3aEFTQVFJQUdGUWhDS0lSQWdDeUFRZkNFTElBWWdDNFZDUDRvaEJpQUNJQWNnRm54OElRSWdEU0FDaFVJZ2lpRU5JQXdnRFh3aERDQUhJQXlGUWhpS0lRY2dBaUFISUJ0OGZDRUNJQTBnQW9WQ0VJb2hEU0FNSUExOElRd2dCeUFNaFVJL2lpRUhJQU1nQ0NBVmZId2hBeUFPSUFPRlFpQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ0dJb2hDQ0FESUFnZ0VYeDhJUU1nRGlBRGhVSVFpaUVPSUFrZ0Rud2hDU0FJSUFtRlFqK0tJUWdnQkNBRklDQjhmQ0VFSUE4Z0JJVkNJSW9oRHlBS0lBOThJUW9nQlNBS2hVSVlpaUVGSUFRZ0JTQVpmSHdoQkNBUElBU0ZRaENLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNQNG9oQlNBQklBVWdHbng4SVFFZ0RTQUJoVUlnaWlFTklBa2dEWHdoQ1NBRklBbUZRaGlLSVFVZ0FTQUZJQkY4ZkNFQklBMGdBWVZDRUlvaERTQUpJQTE4SVFrZ0JTQUpoVUkvaWlFRklBSWdCaUFXZkh3aEFpQU9JQUtGUWlDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDR0lvaEJpQUNJQVlnR0h4OElRSWdEaUFDaFVJUWlpRU9JQW9nRG53aENpQUdJQXFGUWorS0lRWWdBeUFISUJOOGZDRURJQThnQTRWQ0lJb2hEeUFMSUE5OElRc2dCeUFMaFVJWWlpRUhJQU1nQnlBVmZId2hBeUFQSUFPRlFoQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ1A0b2hCeUFFSUFnZ0czeDhJUVFnRUNBRWhVSWdpaUVRSUF3Z0VId2hEQ0FJSUF5RlFoaUtJUWdnQkNBSUlDQjhmQ0VFSUJBZ0JJVkNFSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSS9paUVJSUFFZ0JpQWZmSHdoQVNBUUlBR0ZRaUNLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNHSW9oQmlBQklBWWdFbng4SVFFZ0VDQUJoVUlRaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaitLSVFZZ0FpQUhJQng4ZkNFQ0lBMGdBb1ZDSUlvaERTQU1JQTE4SVF3Z0J5QU1oVUlZaWlFSElBSWdCeUFkZkh3aEFpQU5JQUtGUWhDS0lRMGdEQ0FOZkNFTUlBY2dESVZDUDRvaEJ5QURJQWdnRjN4OElRTWdEaUFEaFVJZ2lpRU9JQWtnRG53aENTQUlJQW1GUWhpS0lRZ2dBeUFJSUJsOGZDRURJQTRnQTRWQ0VJb2hEaUFKSUE1OElRa2dDQ0FKaFVJL2lpRUlJQVFnQlNBVWZId2hCQ0FQSUFTRlFpQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ0dJb2hCU0FFSUFVZ0hueDhJUVFnRHlBRWhVSVFpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFqK0tJUVVnQVNBRklCTjhmQ0VCSUEwZ0FZVkNJSW9oRFNBSklBMThJUWtnQlNBSmhVSVlpaUVGSUFFZ0JTQWRmSHdoQVNBTklBR0ZRaENLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNQNG9oQlNBQ0lBWWdGM3g4SVFJZ0RpQUNoVUlnaWlFT0lBb2dEbndoQ2lBR0lBcUZRaGlLSVFZZ0FpQUdJQnQ4ZkNFQ0lBNGdBb1ZDRUlvaERpQUtJQTU4SVFvZ0JpQUtoVUkvaWlFR0lBTWdCeUFSZkh3aEF5QVBJQU9GUWlDS0lROGdDeUFQZkNFTElBY2dDNFZDR0lvaEJ5QURJQWNnSEh4OElRTWdEeUFEaFVJUWlpRVBJQXNnRDN3aEN5QUhJQXVGUWorS0lRY2dCQ0FJSUJsOGZDRUVJQkFnQklWQ0lJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJWWlpRUlJQVFnQ0NBVWZId2hCQ0FRSUFTRlFoQ0tJUkFnRENBUWZDRU1JQWdnRElWQ1A0b2hDQ0FCSUFZZ0ZYeDhJUUVnRUNBQmhVSWdpaUVRSUFzZ0VId2hDeUFHSUF1RlFoaUtJUVlnQVNBR0lCNThmQ0VCSUJBZ0FZVkNFSW9oRUNBTElCQjhJUXNnQmlBTGhVSS9paUVHSUFJZ0J5QVlmSHdoQWlBTklBS0ZRaUNLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNHSW9oQnlBQ0lBY2dGbng4SVFJZ0RTQUNoVUlRaWlFTklBd2dEWHdoRENBSElBeUZRaitLSVFjZ0F5QUlJQ0I4ZkNFRElBNGdBNFZDSUlvaERpQUpJQTU4SVFrZ0NDQUpoVUlZaWlFSUlBTWdDQ0FmZkh3aEF5QU9JQU9GUWhDS0lRNGdDU0FPZkNFSklBZ2dDWVZDUDRvaENDQUVJQVVnRW54OElRUWdEeUFFaFVJZ2lpRVBJQW9nRDN3aENpQUZJQXFGUWhpS0lRVWdCQ0FGSUJwOGZDRUVJQThnQklWQ0VJb2hEeUFLSUE5OElRb2dCU0FLaFVJL2lpRUZJQUVnQlNBZGZId2hBU0FOSUFHRlFpQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ0dJb2hCU0FCSUFVZ0ZueDhJUUVnRFNBQmhVSVFpaUVOSUFrZ0RYd2hDU0FGSUFtRlFqK0tJUVVnQWlBR0lCSjhmQ0VDSUE0Z0FvVkNJSW9oRGlBS0lBNThJUW9nQmlBS2hVSVlpaUVHSUFJZ0JpQWdmSHdoQWlBT0lBS0ZRaENLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNQNG9oQmlBRElBY2dIM3g4SVFNZ0R5QURoVUlnaWlFUElBc2dEM3doQ3lBSElBdUZRaGlLSVFjZ0F5QUhJQjU4ZkNFRElBOGdBNFZDRUlvaER5QUxJQTk4SVFzZ0J5QUxoVUkvaWlFSElBUWdDQ0FWZkh3aEJDQVFJQVNGUWlDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDR0lvaENDQUVJQWdnRzN4OElRUWdFQ0FFaFVJUWlpRVFJQXdnRUh3aERDQUlJQXlGUWorS0lRZ2dBU0FHSUJGOGZDRUJJQkFnQVlWQ0lJb2hFQ0FMSUJCOElRc2dCaUFMaFVJWWlpRUdJQUVnQmlBWWZId2hBU0FRSUFHRlFoQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ1A0b2hCaUFDSUFjZ0YzeDhJUUlnRFNBQ2hVSWdpaUVOSUF3Z0RYd2hEQ0FISUF5RlFoaUtJUWNnQWlBSElCUjhmQ0VDSUEwZ0FvVkNFSW9oRFNBTUlBMThJUXdnQnlBTWhVSS9paUVISUFNZ0NDQWFmSHdoQXlBT0lBT0ZRaUNLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNHSW9oQ0NBRElBZ2dFM3g4SVFNZ0RpQURoVUlRaWlFT0lBa2dEbndoQ1NBSUlBbUZRaitLSVFnZ0JDQUZJQmw4ZkNFRUlBOGdCSVZDSUlvaER5QUtJQTk4SVFvZ0JTQUtoVUlZaWlFRklBUWdCU0FjZkh3aEJDQVBJQVNGUWhDS0lROGdDaUFQZkNFS0lBVWdDb1ZDUDRvaEJTQUJJQVVnSG54OElRRWdEU0FCaFVJZ2lpRU5JQWtnRFh3aENTQUZJQW1GUWhpS0lRVWdBU0FGSUJ4OGZDRUJJQTBnQVlWQ0VJb2hEU0FKSUExOElRa2dCU0FKaFVJL2lpRUZJQUlnQmlBWWZId2hBaUFPSUFLRlFpQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ0dJb2hCaUFDSUFZZ0gzeDhJUUlnRGlBQ2hVSVFpaUVPSUFvZ0Rud2hDaUFHSUFxRlFqK0tJUVlnQXlBSElCMThmQ0VESUE4Z0E0VkNJSW9oRHlBTElBOThJUXNnQnlBTGhVSVlpaUVISUFNZ0J5QVNmSHdoQXlBUElBT0ZRaENLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNQNG9oQnlBRUlBZ2dGSHg4SVFRZ0VDQUVoVUlnaWlFUUlBd2dFSHdoRENBSUlBeUZRaGlLSVFnZ0JDQUlJQnA4ZkNFRUlCQWdCSVZDRUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUkvaWlFSUlBRWdCaUFXZkh3aEFTQVFJQUdGUWlDS0lSQWdDeUFRZkNFTElBWWdDNFZDR0lvaEJpQUJJQVlnRVh4OElRRWdFQ0FCaFVJUWlpRVFJQXNnRUh3aEN5QUdJQXVGUWorS0lRWWdBaUFISUNCOGZDRUNJQTBnQW9WQ0lJb2hEU0FNSUExOElRd2dCeUFNaFVJWWlpRUhJQUlnQnlBVmZId2hBaUFOSUFLRlFoQ0tJUTBnRENBTmZDRU1JQWNnRElWQ1A0b2hCeUFESUFnZ0dYeDhJUU1nRGlBRGhVSWdpaUVPSUFrZ0Rud2hDU0FJSUFtRlFoaUtJUWdnQXlBSUlCZDhmQ0VESUE0Z0E0VkNFSW9oRGlBSklBNThJUWtnQ0NBSmhVSS9paUVJSUFRZ0JTQVRmSHdoQkNBUElBU0ZRaUNLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNHSW9oQlNBRUlBVWdHM3g4SVFRZ0R5QUVoVUlRaWlFUElBb2dEM3doQ2lBRklBcUZRaitLSVFVZ0FTQUZJQmQ4ZkNFQklBMGdBWVZDSUlvaERTQUpJQTE4SVFrZ0JTQUpoVUlZaWlFRklBRWdCU0FnZkh3aEFTQU5JQUdGUWhDS0lRMGdDU0FOZkNFSklBVWdDWVZDUDRvaEJTQUNJQVlnSDN4OElRSWdEaUFDaFVJZ2lpRU9JQW9nRG53aENpQUdJQXFGUWhpS0lRWWdBaUFHSUJwOGZDRUNJQTRnQW9WQ0VJb2hEaUFLSUE1OElRb2dCaUFLaFVJL2lpRUdJQU1nQnlBY2ZId2hBeUFQSUFPRlFpQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ0dJb2hCeUFESUFjZ0ZIeDhJUU1nRHlBRGhVSVFpaUVQSUFzZ0Qzd2hDeUFISUF1RlFqK0tJUWNnQkNBSUlCRjhmQ0VFSUJBZ0JJVkNJSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSVlpaUVJSUFRZ0NDQVpmSHdoQkNBUUlBU0ZRaENLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNQNG9oQ0NBQklBWWdIWHg4SVFFZ0VDQUJoVUlnaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaGlLSVFZZ0FTQUdJQk44ZkNFQklCQWdBWVZDRUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUkvaWlFR0lBSWdCeUFlZkh3aEFpQU5JQUtGUWlDS0lRMGdEQ0FOZkNFTUlBY2dESVZDR0lvaEJ5QUNJQWNnR0h4OElRSWdEU0FDaFVJUWlpRU5JQXdnRFh3aERDQUhJQXlGUWorS0lRY2dBeUFJSUJKOGZDRURJQTRnQTRWQ0lJb2hEaUFKSUE1OElRa2dDQ0FKaFVJWWlpRUlJQU1nQ0NBVmZId2hBeUFPSUFPRlFoQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ1A0b2hDQ0FFSUFVZ0czeDhJUVFnRHlBRWhVSWdpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFoaUtJUVVnQkNBRklCWjhmQ0VFSUE4Z0JJVkNFSW9oRHlBS0lBOThJUW9nQlNBS2hVSS9paUVGSUFFZ0JTQWJmSHdoQVNBTklBR0ZRaUNLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNHSW9oQlNBQklBVWdFM3g4SVFFZ0RTQUJoVUlRaWlFTklBa2dEWHdoQ1NBRklBbUZRaitLSVFVZ0FpQUdJQmw4ZkNFQ0lBNGdBb1ZDSUlvaERpQUtJQTU4SVFvZ0JpQUtoVUlZaWlFR0lBSWdCaUFWZkh3aEFpQU9JQUtGUWhDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDUDRvaEJpQURJQWNnR0h4OElRTWdEeUFEaFVJZ2lpRVBJQXNnRDN3aEN5QUhJQXVGUWhpS0lRY2dBeUFISUJkOGZDRURJQThnQTRWQ0VJb2hEeUFMSUE5OElRc2dCeUFMaFVJL2lpRUhJQVFnQ0NBU2ZId2hCQ0FRSUFTRlFpQ0tJUkFnRENBUWZDRU1JQWdnRElWQ0dJb2hDQ0FFSUFnZ0ZueDhJUVFnRUNBRWhVSVFpaUVRSUF3Z0VId2hEQ0FJSUF5RlFqK0tJUWdnQVNBR0lDQjhmQ0VCSUJBZ0FZVkNJSW9oRUNBTElCQjhJUXNnQmlBTGhVSVlpaUVHSUFFZ0JpQWNmSHdoQVNBUUlBR0ZRaENLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNQNG9oQmlBQ0lBY2dHbng4SVFJZ0RTQUNoVUlnaWlFTklBd2dEWHdoRENBSElBeUZRaGlLSVFjZ0FpQUhJQjk4ZkNFQ0lBMGdBb1ZDRUlvaERTQU1JQTE4SVF3Z0J5QU1oVUkvaWlFSElBTWdDQ0FVZkh3aEF5QU9JQU9GUWlDS0lRNGdDU0FPZkNFSklBZ2dDWVZDR0lvaENDQURJQWdnSFh4OElRTWdEaUFEaFVJUWlpRU9JQWtnRG53aENTQUlJQW1GUWorS0lRZ2dCQ0FGSUI1OGZDRUVJQThnQklWQ0lJb2hEeUFLSUE5OElRb2dCU0FLaFVJWWlpRUZJQVFnQlNBUmZId2hCQ0FQSUFTRlFoQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ1A0b2hCU0FCSUFVZ0VYeDhJUUVnRFNBQmhVSWdpaUVOSUFrZ0RYd2hDU0FGSUFtRlFoaUtJUVVnQVNBRklCSjhmQ0VCSUEwZ0FZVkNFSW9oRFNBSklBMThJUWtnQlNBSmhVSS9paUVGSUFJZ0JpQVRmSHdoQWlBT0lBS0ZRaUNLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNHSW9oQmlBQ0lBWWdGSHg4SVFJZ0RpQUNoVUlRaWlFT0lBb2dEbndoQ2lBR0lBcUZRaitLSVFZZ0F5QUhJQlY4ZkNFRElBOGdBNFZDSUlvaER5QUxJQTk4SVFzZ0J5QUxoVUlZaWlFSElBTWdCeUFXZkh3aEF5QVBJQU9GUWhDS0lROGdDeUFQZkNFTElBY2dDNFZDUDRvaEJ5QUVJQWdnRjN4OElRUWdFQ0FFaFVJZ2lpRVFJQXdnRUh3aERDQUlJQXlGUWhpS0lRZ2dCQ0FJSUJoOGZDRUVJQkFnQklWQ0VJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJL2lpRUlJQUVnQmlBWmZId2hBU0FRSUFHRlFpQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ0dJb2hCaUFCSUFZZ0dueDhJUUVnRUNBQmhVSVFpaUVRSUFzZ0VId2hDeUFHSUF1RlFqK0tJUVlnQWlBSElCdDhmQ0VDSUEwZ0FvVkNJSW9oRFNBTUlBMThJUXdnQnlBTWhVSVlpaUVISUFJZ0J5QWNmSHdoQWlBTklBS0ZRaENLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNQNG9oQnlBRElBZ2dIWHg4SVFNZ0RpQURoVUlnaWlFT0lBa2dEbndoQ1NBSUlBbUZRaGlLSVFnZ0F5QUlJQjU4ZkNFRElBNGdBNFZDRUlvaERpQUpJQTU4SVFrZ0NDQUpoVUkvaWlFSUlBUWdCU0FmZkh3aEJDQVBJQVNGUWlDS0lROGdDaUFQZkNFS0lBVWdDb1ZDR0lvaEJTQUVJQVVnSUh4OElRUWdEeUFFaFVJUWlpRVBJQW9nRDN3aENpQUZJQXFGUWorS0lRVWdBU0FGSUI5OGZDRUJJQTBnQVlWQ0lJb2hEU0FKSUExOElRa2dCU0FKaFVJWWlpRUZJQUVnQlNBYmZId2hBU0FOSUFHRlFoQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ1A0b2hCU0FDSUFZZ0ZYeDhJUUlnRGlBQ2hVSWdpaUVPSUFvZ0Rud2hDaUFHSUFxRlFoaUtJUVlnQWlBR0lCbDhmQ0VDSUE0Z0FvVkNFSW9oRGlBS0lBNThJUW9nQmlBS2hVSS9paUVHSUFNZ0J5QWFmSHdoQXlBUElBT0ZRaUNLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNHSW9oQnlBRElBY2dJSHg4SVFNZ0R5QURoVUlRaWlFUElBc2dEM3doQ3lBSElBdUZRaitLSVFjZ0JDQUlJQjU4ZkNFRUlCQWdCSVZDSUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUlZaWlFSUlBUWdDQ0FYZkh3aEJDQVFJQVNGUWhDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDUDRvaENDQUJJQVlnRW54OElRRWdFQ0FCaFVJZ2lpRVFJQXNnRUh3aEN5QUdJQXVGUWhpS0lRWWdBU0FHSUIxOGZDRUJJQkFnQVlWQ0VJb2hFQ0FMSUJCOElRc2dCaUFMaFVJL2lpRUdJQUlnQnlBUmZId2hBaUFOSUFLRlFpQ0tJUTBnRENBTmZDRU1JQWNnRElWQ0dJb2hCeUFDSUFjZ0UzeDhJUUlnRFNBQ2hVSVFpaUVOSUF3Z0RYd2hEQ0FISUF5RlFqK0tJUWNnQXlBSUlCeDhmQ0VESUE0Z0E0VkNJSW9oRGlBSklBNThJUWtnQ0NBSmhVSVlpaUVJSUFNZ0NDQVlmSHdoQXlBT0lBT0ZRaENLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNQNG9oQ0NBRUlBVWdGbng4SVFRZ0R5QUVoVUlnaWlFUElBb2dEM3doQ2lBRklBcUZRaGlLSVFVZ0JDQUZJQlI4ZkNFRUlBOGdCSVZDRUlvaER5QUtJQTk4SVFvZ0JTQUtoVUkvaWlFRklDRWdJU2tEQUNBQklBbUZoVGNEQUNBaUlDSXBBd0FnQWlBS2hZVTNBd0FnSXlBaktRTUFJQU1nQzRXRk53TUFJQ1FnSkNrREFDQUVJQXlGaFRjREFDQWxJQ1VwQXdBZ0JTQU5oWVUzQXdBZ0ppQW1LUU1BSUFZZ0RvV0ZOd01BSUNjZ0p5a0RBQ0FISUErRmhUY0RBQ0FvSUNncEF3QWdDQ0FRaFlVM0F3QUwnKVxuICB2YXIgcmVhZHkgPSBudWxsXG5cbiAgdmFyIG1vZCA9IHtcbiAgICBidWZmZXI6IHdhc20sXG4gICAgbWVtb3J5OiBudWxsLFxuICAgIGV4cG9ydHM6IG51bGwsXG4gICAgcmVhbGxvYzogcmVhbGxvYyxcbiAgICBvbmxvYWQ6IG9ubG9hZFxuICB9XG5cbiAgb25sb2FkKGZ1bmN0aW9uICgpIHt9KVxuXG4gIHJldHVybiBtb2RcblxuICBmdW5jdGlvbiByZWFsbG9jIChzaXplKSB7XG4gICAgbW9kLmV4cG9ydHMubWVtb3J5Lmdyb3coTWF0aC5jZWlsKE1hdGguYWJzKHNpemUgLSBtb2QubWVtb3J5Lmxlbmd0aCkgLyA2NTUzNikpXG4gICAgbW9kLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBvbmxvYWQgKGNiKSB7XG4gICAgaWYgKG1vZC5leHBvcnRzKSByZXR1cm4gY2IoKVxuXG4gICAgaWYgKHJlYWR5KSB7XG4gICAgICByZWFkeS50aGVuKGNiLmJpbmQobnVsbCwgbnVsbCkpLmNhdGNoKGNiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMnKVxuICAgICAgc2V0dXAoe2luc3RhbmNlOiBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZSh3YXNtKSwgaW1wKX0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZWFkeSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc20sIGltcCkudGhlbihzZXR1cClcbiAgICB9XG5cbiAgICBvbmxvYWQoY2IpXG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cCAodykge1xuICAgIG1vZC5leHBvcnRzID0gdy5pbnN0YW5jZS5leHBvcnRzXG4gICAgbW9kLm1lbW9yeSA9IG1vZC5leHBvcnRzLm1lbW9yeSAmJiBtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyICYmIG5ldyBVaW50OEFycmF5KG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9VaW50OEFycmF5IChzKSB7XG4gIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF0b2Iocykuc3BsaXQoJycpLm1hcChjaGFyQ29kZUF0KSlcbiAgcmV0dXJuIG5ldyAocmVxdWlyZSgnYnVmJyArICdmZXInKS5CdWZmZXIpKHMsICdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiBjaGFyQ29kZUF0IChjKSB7XG4gIHJldHVybiBjLmNoYXJDb2RlQXQoMClcbn1cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCduYW5vYXNzZXJ0JylcbnZhciB3YXNtID0gcmVxdWlyZSgnLi9ibGFrZTJiJykoKVxuXG52YXIgaGVhZCA9IDY0XG52YXIgZnJlZUxpc3QgPSBbXVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJsYWtlMmJcbnZhciBCWVRFU19NSU4gPSBtb2R1bGUuZXhwb3J0cy5CWVRFU19NSU4gPSAxNlxudmFyIEJZVEVTX01BWCA9IG1vZHVsZS5leHBvcnRzLkJZVEVTX01BWCA9IDY0XG52YXIgQllURVMgPSBtb2R1bGUuZXhwb3J0cy5CWVRFUyA9IDMyXG52YXIgS0VZQllURVNfTUlOID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVNfTUlOID0gMTZcbnZhciBLRVlCWVRFU19NQVggPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFU19NQVggPSA2NFxudmFyIEtFWUJZVEVTID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVMgPSAzMlxudmFyIFNBTFRCWVRFUyA9IG1vZHVsZS5leHBvcnRzLlNBTFRCWVRFUyA9IDE2XG52YXIgUEVSU09OQUxCWVRFUyA9IG1vZHVsZS5leHBvcnRzLlBFUlNPTkFMQllURVMgPSAxNlxuXG5mdW5jdGlvbiBCbGFrZTJiIChkaWdlc3RMZW5ndGgsIGtleSwgc2FsdCwgcGVyc29uYWwsIG5vQXNzZXJ0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCbGFrZTJiKSkgcmV0dXJuIG5ldyBCbGFrZTJiKGRpZ2VzdExlbmd0aCwga2V5LCBzYWx0LCBwZXJzb25hbCwgbm9Bc3NlcnQpXG4gIGlmICghKHdhc20gJiYgd2FzbS5leHBvcnRzKSkgdGhyb3cgbmV3IEVycm9yKCdXQVNNIG5vdCBsb2FkZWQuIFdhaXQgZm9yIEJsYWtlMmIucmVhZHkoY2IpJylcbiAgaWYgKCFkaWdlc3RMZW5ndGgpIGRpZ2VzdExlbmd0aCA9IDMyXG5cbiAgaWYgKG5vQXNzZXJ0ICE9PSB0cnVlKSB7XG4gICAgYXNzZXJ0KGRpZ2VzdExlbmd0aCA+PSBCWVRFU19NSU4sICdkaWdlc3RMZW5ndGggbXVzdCBiZSBhdCBsZWFzdCAnICsgQllURVNfTUlOICsgJywgd2FzIGdpdmVuICcgKyBkaWdlc3RMZW5ndGgpXG4gICAgYXNzZXJ0KGRpZ2VzdExlbmd0aCA8PSBCWVRFU19NQVgsICdkaWdlc3RMZW5ndGggbXVzdCBiZSBhdCBtb3N0ICcgKyBCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIGRpZ2VzdExlbmd0aClcbiAgICBpZiAoa2V5ICE9IG51bGwpIGFzc2VydChrZXkubGVuZ3RoID49IEtFWUJZVEVTX01JTiwgJ2tleSBtdXN0IGJlIGF0IGxlYXN0ICcgKyBLRVlCWVRFU19NSU4gKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKGtleSAhPSBudWxsKSBhc3NlcnQoa2V5Lmxlbmd0aCA8PSBLRVlCWVRFU19NQVgsICdrZXkgbXVzdCBiZSBhdCBsZWFzdCAnICsgS0VZQllURVNfTUFYICsgJywgd2FzIGdpdmVuICcgKyBrZXkubGVuZ3RoKVxuICAgIGlmIChzYWx0ICE9IG51bGwpIGFzc2VydChzYWx0Lmxlbmd0aCA9PT0gU0FMVEJZVEVTLCAnc2FsdCBtdXN0IGJlIGV4YWN0bHkgJyArIFNBTFRCWVRFUyArICcsIHdhcyBnaXZlbiAnICsgc2FsdC5sZW5ndGgpXG4gICAgaWYgKHBlcnNvbmFsICE9IG51bGwpIGFzc2VydChwZXJzb25hbC5sZW5ndGggPT09IFBFUlNPTkFMQllURVMsICdwZXJzb25hbCBtdXN0IGJlIGV4YWN0bHkgJyArIFBFUlNPTkFMQllURVMgKyAnLCB3YXMgZ2l2ZW4gJyArIHBlcnNvbmFsLmxlbmd0aClcbiAgfVxuXG4gIGlmICghZnJlZUxpc3QubGVuZ3RoKSB7XG4gICAgZnJlZUxpc3QucHVzaChoZWFkKVxuICAgIGhlYWQgKz0gMjE2XG4gIH1cblxuICB0aGlzLmRpZ2VzdExlbmd0aCA9IGRpZ2VzdExlbmd0aFxuICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlXG4gIHRoaXMucG9pbnRlciA9IGZyZWVMaXN0LnBvcCgpXG5cbiAgd2FzbS5tZW1vcnkuZmlsbCgwLCAwLCA2NClcbiAgd2FzbS5tZW1vcnlbMF0gPSB0aGlzLmRpZ2VzdExlbmd0aFxuICB3YXNtLm1lbW9yeVsxXSA9IGtleSA/IGtleS5sZW5ndGggOiAwXG4gIHdhc20ubWVtb3J5WzJdID0gMSAvLyBmYW5vdXRcbiAgd2FzbS5tZW1vcnlbM10gPSAxIC8vIGRlcHRoXG5cbiAgaWYgKHNhbHQpIHdhc20ubWVtb3J5LnNldChzYWx0LCAzMilcbiAgaWYgKHBlcnNvbmFsKSB3YXNtLm1lbW9yeS5zZXQocGVyc29uYWwsIDQ4KVxuXG4gIGlmICh0aGlzLnBvaW50ZXIgKyAyMTYgPiB3YXNtLm1lbW9yeS5sZW5ndGgpIHdhc20ucmVhbGxvYyh0aGlzLnBvaW50ZXIgKyAyMTYpIC8vIHdlIG5lZWQgMjE2IGJ5dGVzIGZvciB0aGUgc3RhdGVcbiAgd2FzbS5leHBvcnRzLmJsYWtlMmJfaW5pdCh0aGlzLnBvaW50ZXIsIHRoaXMuZGlnZXN0TGVuZ3RoKVxuXG4gIGlmIChrZXkpIHtcbiAgICB0aGlzLnVwZGF0ZShrZXkpXG4gICAgd2FzbS5tZW1vcnkuZmlsbCgwLCBoZWFkLCBoZWFkICsga2V5Lmxlbmd0aCkgLy8gd2hpdGVvdXQga2V5XG4gICAgd2FzbS5tZW1vcnlbdGhpcy5wb2ludGVyICsgMjAwXSA9IDEyOFxuICB9XG59XG5cblxuQmxha2UyYi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGFzc2VydCh0aGlzLmZpbmFsaXplZCA9PT0gZmFsc2UsICdIYXNoIGluc3RhbmNlIGZpbmFsaXplZCcpXG4gIGFzc2VydChpbnB1dCwgJ2lucHV0IG11c3QgYmUgVHlwZWRBcnJheSBvciBCdWZmZXInKVxuXG4gIGlmIChoZWFkICsgaW5wdXQubGVuZ3RoID4gd2FzbS5tZW1vcnkubGVuZ3RoKSB3YXNtLnJlYWxsb2MoaGVhZCArIGlucHV0Lmxlbmd0aClcbiAgd2FzbS5tZW1vcnkuc2V0KGlucHV0LCBoZWFkKVxuICB3YXNtLmV4cG9ydHMuYmxha2UyYl91cGRhdGUodGhpcy5wb2ludGVyLCBoZWFkLCBoZWFkICsgaW5wdXQubGVuZ3RoKVxuICByZXR1cm4gdGhpc1xufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGFzc2VydCh0aGlzLmZpbmFsaXplZCA9PT0gZmFsc2UsICdIYXNoIGluc3RhbmNlIGZpbmFsaXplZCcpXG4gIHRoaXMuZmluYWxpemVkID0gdHJ1ZVxuXG4gIGZyZWVMaXN0LnB1c2godGhpcy5wb2ludGVyKVxuICB3YXNtLmV4cG9ydHMuYmxha2UyYl9maW5hbCh0aGlzLnBvaW50ZXIpXG5cbiAgaWYgKCFlbmMgfHwgZW5jID09PSAnYmluYXJ5Jykge1xuICAgIHJldHVybiB3YXNtLm1lbW9yeS5zbGljZSh0aGlzLnBvaW50ZXIgKyAxMjgsIHRoaXMucG9pbnRlciArIDEyOCArIHRoaXMuZGlnZXN0TGVuZ3RoKVxuICB9XG5cbiAgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICByZXR1cm4gaGV4U2xpY2Uod2FzbS5tZW1vcnksIHRoaXMucG9pbnRlciArIDEyOCwgdGhpcy5kaWdlc3RMZW5ndGgpXG4gIH1cblxuICBhc3NlcnQoZW5jLmxlbmd0aCA+PSB0aGlzLmRpZ2VzdExlbmd0aCwgJ2lucHV0IG11c3QgYmUgVHlwZWRBcnJheSBvciBCdWZmZXInKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlnZXN0TGVuZ3RoOyBpKyspIHtcbiAgICBlbmNbaV0gPSB3YXNtLm1lbW9yeVt0aGlzLnBvaW50ZXIgKyAxMjggKyBpXVxuICB9XG5cbiAgcmV0dXJuIGVuY1xufVxuXG4vLyBsaWJzb2RpdW0gY29tcGF0XG5CbGFrZTJiLnByb3RvdHlwZS5maW5hbCA9IEJsYWtlMmIucHJvdG90eXBlLmRpZ2VzdFxuXG5CbGFrZTJiLldBU00gPSB3YXNtICYmIHdhc20uYnVmZmVyXG5CbGFrZTJiLlNVUFBPUlRFRCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ3VuZGVmaW5lZCdcblxuQmxha2UyYi5yZWFkeSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKCF3YXNtKSByZXR1cm4gY2IobmV3IEVycm9yKCdXZWJBc3NlbWJseSBub3Qgc3VwcG9ydGVkJykpXG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdCwgY2FuIGJlIHJlbW92ZWQgaW4gYSBuZXcgbWFqb3JcbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVqZWN0LCByZXNvbHZlKSB7XG4gICAgd2FzbS5vbmxvYWQoZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikgcmVzb2x2ZSgpXG4gICAgICBlbHNlIHJlamVjdCgpXG4gICAgICBjYihlcnIpXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gcFxufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5yZWFkeSA9IEJsYWtlMmIucmVhZHlcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgbGVuKSB7XG4gIHZhciBzdHIgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gdG9IZXgoYnVmW3N0YXJ0ICsgaV0pXG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ25hbm9hc3NlcnQnKVxudmFyIGIyd2FzbSA9IHJlcXVpcmUoJ2JsYWtlMmItd2FzbScpXG5cbi8vIDY0LWJpdCB1bnNpZ25lZCBhZGRpdGlvblxuLy8gU2V0cyB2W2EsYSsxXSArPSB2W2IsYisxXVxuLy8gdiBzaG91bGQgYmUgYSBVaW50MzJBcnJheVxuZnVuY3Rpb24gQURENjRBQSAodiwgYSwgYikge1xuICB2YXIgbzAgPSB2W2FdICsgdltiXVxuICB2YXIgbzEgPSB2W2EgKyAxXSArIHZbYiArIDFdXG4gIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgIG8xKytcbiAgfVxuICB2W2FdID0gbzBcbiAgdlthICsgMV0gPSBvMVxufVxuXG4vLyA2NC1iaXQgdW5zaWduZWQgYWRkaXRpb25cbi8vIFNldHMgdlthLGErMV0gKz0gYlxuLy8gYjAgaXMgdGhlIGxvdyAzMiBiaXRzIG9mIGIsIGIxIHJlcHJlc2VudHMgdGhlIGhpZ2ggMzIgYml0c1xuZnVuY3Rpb24gQURENjRBQyAodiwgYSwgYjAsIGIxKSB7XG4gIHZhciBvMCA9IHZbYV0gKyBiMFxuICBpZiAoYjAgPCAwKSB7XG4gICAgbzAgKz0gMHgxMDAwMDAwMDBcbiAgfVxuICB2YXIgbzEgPSB2W2EgKyAxXSArIGIxXG4gIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgIG8xKytcbiAgfVxuICB2W2FdID0gbzBcbiAgdlthICsgMV0gPSBvMVxufVxuXG4vLyBMaXR0bGUtZW5kaWFuIGJ5dGUgYWNjZXNzXG5mdW5jdGlvbiBCMkJfR0VUMzIgKGFyciwgaSkge1xuICByZXR1cm4gKGFycltpXSBeXG4gIChhcnJbaSArIDFdIDw8IDgpIF5cbiAgKGFycltpICsgMl0gPDwgMTYpIF5cbiAgKGFycltpICsgM10gPDwgMjQpKVxufVxuXG4vLyBHIE1peGluZyBmdW5jdGlvblxuLy8gVGhlIFJPVFJzIGFyZSBpbmxpbmVkIGZvciBzcGVlZFxuZnVuY3Rpb24gQjJCX0cgKGEsIGIsIGMsIGQsIGl4LCBpeSkge1xuICB2YXIgeDAgPSBtW2l4XVxuICB2YXIgeDEgPSBtW2l4ICsgMV1cbiAgdmFyIHkwID0gbVtpeV1cbiAgdmFyIHkxID0gbVtpeSArIDFdXG5cbiAgQURENjRBQSh2LCBhLCBiKSAvLyB2W2EsYSsxXSArPSB2W2IsYisxXSAuLi4gaW4gSlMgd2UgbXVzdCBzdG9yZSBhIHVpbnQ2NCBhcyB0d28gdWludDMyc1xuICBBREQ2NEFDKHYsIGEsIHgwLCB4MSkgLy8gdlthLCBhKzFdICs9IHggLi4uIHgwIGlzIHRoZSBsb3cgMzIgYml0cyBvZiB4LCB4MSBpcyB0aGUgaGlnaCAzMiBiaXRzXG5cbiAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHRvIHRoZSByaWdodCBieSAzMiBiaXRzXG4gIHZhciB4b3IwID0gdltkXSBeIHZbYV1cbiAgdmFyIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdXG4gIHZbZF0gPSB4b3IxXG4gIHZbZCArIDFdID0geG9yMFxuXG4gIEFERDY0QUEodiwgYywgZClcblxuICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgMjQgYml0c1xuICB4b3IwID0gdltiXSBeIHZbY11cbiAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV1cbiAgdltiXSA9ICh4b3IwID4+PiAyNCkgXiAoeG9yMSA8PCA4KVxuICB2W2IgKyAxXSA9ICh4b3IxID4+PiAyNCkgXiAoeG9yMCA8PCA4KVxuXG4gIEFERDY0QUEodiwgYSwgYilcbiAgQURENjRBQyh2LCBhLCB5MCwgeTEpXG5cbiAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDE2IGJpdHNcbiAgeG9yMCA9IHZbZF0gXiB2W2FdXG4gIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdXG4gIHZbZF0gPSAoeG9yMCA+Pj4gMTYpIF4gKHhvcjEgPDwgMTYpXG4gIHZbZCArIDFdID0gKHhvcjEgPj4+IDE2KSBeICh4b3IwIDw8IDE2KVxuXG4gIEFERDY0QUEodiwgYywgZClcblxuICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgNjMgYml0c1xuICB4b3IwID0gdltiXSBeIHZbY11cbiAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV1cbiAgdltiXSA9ICh4b3IxID4+PiAzMSkgXiAoeG9yMCA8PCAxKVxuICB2W2IgKyAxXSA9ICh4b3IwID4+PiAzMSkgXiAoeG9yMSA8PCAxKVxufVxuXG4vLyBJbml0aWFsaXphdGlvbiBWZWN0b3JcbnZhciBCTEFLRTJCX0lWMzIgPSBuZXcgVWludDMyQXJyYXkoW1xuICAweEYzQkNDOTA4LCAweDZBMDlFNjY3LCAweDg0Q0FBNzNCLCAweEJCNjdBRTg1LFxuICAweEZFOTRGODJCLCAweDNDNkVGMzcyLCAweDVGMUQzNkYxLCAweEE1NEZGNTNBLFxuICAweEFERTY4MkQxLCAweDUxMEU1MjdGLCAweDJCM0U2QzFGLCAweDlCMDU2ODhDLFxuICAweEZCNDFCRDZCLCAweDFGODNEOUFCLCAweDEzN0UyMTc5LCAweDVCRTBDRDE5XG5dKVxuXG52YXIgU0lHTUE4ID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICAxMSwgOCwgMTIsIDAsIDUsIDIsIDE1LCAxMywgMTAsIDE0LCAzLCA2LCA3LCAxLCA5LCA0LFxuICA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LFxuICA5LCAwLCA1LCA3LCAyLCA0LCAxMCwgMTUsIDE0LCAxLCAxMSwgMTIsIDYsIDgsIDMsIDEzLFxuICAyLCAxMiwgNiwgMTAsIDAsIDExLCA4LCAzLCA0LCAxMywgNywgNSwgMTUsIDE0LCAxLCA5LFxuICAxMiwgNSwgMSwgMTUsIDE0LCAxMywgNCwgMTAsIDAsIDcsIDYsIDMsIDksIDIsIDgsIDExLFxuICAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLFxuICA2LCAxNSwgMTQsIDksIDExLCAzLCAwLCA4LCAxMiwgMiwgMTMsIDcsIDEsIDQsIDEwLCA1LFxuICAxMCwgMiwgOCwgNCwgNywgNiwgMSwgNSwgMTUsIDExLCA5LCAxNCwgMywgMTIsIDEzLCAwLFxuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzXG5dXG5cbi8vIFRoZXNlIGFyZSBvZmZzZXRzIGludG8gYSB1aW50NjQgYnVmZmVyLlxuLy8gTXVsdGlwbHkgdGhlbSBhbGwgYnkgMiB0byBtYWtlIHRoZW0gb2Zmc2V0cyBpbnRvIGEgdWludDMyIGJ1ZmZlcixcbi8vIGJlY2F1c2UgdGhpcyBpcyBKYXZhc2NyaXB0IGFuZCB3ZSBkb24ndCBoYXZlIHVpbnQ2NHNcbnZhciBTSUdNQTgyID0gbmV3IFVpbnQ4QXJyYXkoU0lHTUE4Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAqIDIgfSkpXG5cbi8vIENvbXByZXNzaW9uIGZ1bmN0aW9uLiAnbGFzdCcgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9jay5cbi8vIE5vdGUgd2UncmUgcmVwcmVzZW50aW5nIDE2IHVpbnQ2NHMgYXMgMzIgdWludDMyc1xudmFyIHYgPSBuZXcgVWludDMyQXJyYXkoMzIpXG52YXIgbSA9IG5ldyBVaW50MzJBcnJheSgzMilcbmZ1bmN0aW9uIGJsYWtlMmJDb21wcmVzcyAoY3R4LCBsYXN0KSB7XG4gIHZhciBpID0gMFxuXG4gIC8vIGluaXQgd29yayB2YXJpYWJsZXNcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2W2ldID0gY3R4LmhbaV1cbiAgICB2W2kgKyAxNl0gPSBCTEFLRTJCX0lWMzJbaV1cbiAgfVxuXG4gIC8vIGxvdyA2NCBiaXRzIG9mIG9mZnNldFxuICB2WzI0XSA9IHZbMjRdIF4gY3R4LnRcbiAgdlsyNV0gPSB2WzI1XSBeIChjdHgudCAvIDB4MTAwMDAwMDAwKVxuICAvLyBoaWdoIDY0IGJpdHMgbm90IHN1cHBvcnRlZCwgb2Zmc2V0IG1heSBub3QgYmUgaGlnaGVyIHRoYW4gMioqNTMtMVxuXG4gIC8vIGxhc3QgYmxvY2sgZmxhZyBzZXQgP1xuICBpZiAobGFzdCkge1xuICAgIHZbMjhdID0gfnZbMjhdXG4gICAgdlsyOV0gPSB+dlsyOV1cbiAgfVxuXG4gIC8vIGdldCBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgbVtpXSA9IEIyQl9HRVQzMihjdHguYiwgNCAqIGkpXG4gIH1cblxuICAvLyB0d2VsdmUgcm91bmRzIG9mIG1peGluZ1xuICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIEIyQl9HKDAsIDgsIDE2LCAyNCwgU0lHTUE4MltpICogMTYgKyAwXSwgU0lHTUE4MltpICogMTYgKyAxXSlcbiAgICBCMkJfRygyLCAxMCwgMTgsIDI2LCBTSUdNQTgyW2kgKiAxNiArIDJdLCBTSUdNQTgyW2kgKiAxNiArIDNdKVxuICAgIEIyQl9HKDQsIDEyLCAyMCwgMjgsIFNJR01BODJbaSAqIDE2ICsgNF0sIFNJR01BODJbaSAqIDE2ICsgNV0pXG4gICAgQjJCX0coNiwgMTQsIDIyLCAzMCwgU0lHTUE4MltpICogMTYgKyA2XSwgU0lHTUE4MltpICogMTYgKyA3XSlcbiAgICBCMkJfRygwLCAxMCwgMjAsIDMwLCBTSUdNQTgyW2kgKiAxNiArIDhdLCBTSUdNQTgyW2kgKiAxNiArIDldKVxuICAgIEIyQl9HKDIsIDEyLCAyMiwgMjQsIFNJR01BODJbaSAqIDE2ICsgMTBdLCBTSUdNQTgyW2kgKiAxNiArIDExXSlcbiAgICBCMkJfRyg0LCAxNCwgMTYsIDI2LCBTSUdNQTgyW2kgKiAxNiArIDEyXSwgU0lHTUE4MltpICogMTYgKyAxM10pXG4gICAgQjJCX0coNiwgOCwgMTgsIDI4LCBTSUdNQTgyW2kgKiAxNiArIDE0XSwgU0lHTUE4MltpICogMTYgKyAxNV0pXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGN0eC5oW2ldID0gY3R4LmhbaV0gXiB2W2ldIF4gdltpICsgMTZdXG4gIH1cbn1cblxuLy8gcmV1c2FibGUgcGFyYW1ldGVyX2Jsb2NrXG52YXIgcGFyYW1ldGVyX2Jsb2NrID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAwLCAwLCAwLCAwLCAgICAgIC8vICAwOiBvdXRsZW4sIGtleWxlbiwgZmFub3V0LCBkZXB0aFxuICAwLCAwLCAwLCAwLCAgICAgIC8vICA0OiBsZWFmIGxlbmd0aCwgc2VxdWVudGlhbCBtb2RlXG4gIDAsIDAsIDAsIDAsICAgICAgLy8gIDg6IG5vZGUgb2Zmc2V0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMTI6IG5vZGUgb2Zmc2V0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMTY6IG5vZGUgZGVwdGgsIGlubmVyIGxlbmd0aCwgcmZ1XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMjA6IHJmdVxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDI0OiByZnVcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAyODogcmZ1XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMzI6IHNhbHRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAzNjogc2FsdFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDQwOiBzYWx0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gNDQ6IHNhbHRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA0ODogcGVyc29uYWxcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA1MjogcGVyc29uYWxcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA1NjogcGVyc29uYWxcbiAgMCwgMCwgMCwgMCAgICAgICAvLyA2MDogcGVyc29uYWxcbl0pXG5cbi8vIENyZWF0ZXMgYSBCTEFLRTJiIGhhc2hpbmcgY29udGV4dFxuLy8gUmVxdWlyZXMgYW4gb3V0cHV0IGxlbmd0aCBiZXR3ZWVuIDEgYW5kIDY0IGJ5dGVzXG4vLyBUYWtlcyBhbiBvcHRpb25hbCBVaW50OEFycmF5IGtleVxuZnVuY3Rpb24gQmxha2UyYiAob3V0bGVuLCBrZXksIHNhbHQsIHBlcnNvbmFsKSB7XG4gIC8vIHplcm8gb3V0IHBhcmFtZXRlcl9ibG9jayBiZWZvcmUgdXNhZ2VcbiAgcGFyYW1ldGVyX2Jsb2NrLmZpbGwoMClcbiAgLy8gc3RhdGUsICdwYXJhbSBibG9jaydcblxuICB0aGlzLmIgPSBuZXcgVWludDhBcnJheSgxMjgpXG4gIHRoaXMuaCA9IG5ldyBVaW50MzJBcnJheSgxNilcbiAgdGhpcy50ID0gMCAvLyBpbnB1dCBjb3VudFxuICB0aGlzLmMgPSAwIC8vIHBvaW50ZXIgd2l0aGluIGJ1ZmZlclxuICB0aGlzLm91dGxlbiA9IG91dGxlbiAvLyBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzXG5cbiAgcGFyYW1ldGVyX2Jsb2NrWzBdID0gb3V0bGVuXG4gIGlmIChrZXkpIHBhcmFtZXRlcl9ibG9ja1sxXSA9IGtleS5sZW5ndGhcbiAgcGFyYW1ldGVyX2Jsb2NrWzJdID0gMSAvLyBmYW5vdXRcbiAgcGFyYW1ldGVyX2Jsb2NrWzNdID0gMSAvLyBkZXB0aFxuXG4gIGlmIChzYWx0KSBwYXJhbWV0ZXJfYmxvY2suc2V0KHNhbHQsIDMyKVxuICBpZiAocGVyc29uYWwpIHBhcmFtZXRlcl9ibG9jay5zZXQocGVyc29uYWwsIDQ4KVxuXG4gIC8vIGluaXRpYWxpemUgaGFzaCBzdGF0ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB0aGlzLmhbaV0gPSBCTEFLRTJCX0lWMzJbaV0gXiBCMkJfR0VUMzIocGFyYW1ldGVyX2Jsb2NrLCBpICogNClcbiAgfVxuXG4gIC8vIGtleSB0aGUgaGFzaCwgaWYgYXBwbGljYWJsZVxuICBpZiAoa2V5KSB7XG4gICAgYmxha2UyYlVwZGF0ZSh0aGlzLCBrZXkpXG4gICAgLy8gYXQgdGhlIGVuZFxuICAgIHRoaXMuYyA9IDEyOFxuICB9XG59XG5cbkJsYWtlMmIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICBhc3NlcnQoaW5wdXQgIT0gbnVsbCwgJ2lucHV0IG11c3QgYmUgVWludDhBcnJheSBvciBCdWZmZXInKVxuICBibGFrZTJiVXBkYXRlKHRoaXMsIGlucHV0KVxuICByZXR1cm4gdGhpc1xufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAob3V0KSB7XG4gIHZhciBidWYgPSAoIW91dCB8fCBvdXQgPT09ICdiaW5hcnknIHx8IG91dCA9PT0gJ2hleCcpID8gbmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRsZW4pIDogb3V0XG4gIGFzc2VydChidWYubGVuZ3RoID49IHRoaXMub3V0bGVuLCAnb3V0IG11c3QgaGF2ZSBhdCBsZWFzdCBvdXRsZW4gYnl0ZXMgb2Ygc3BhY2UnKVxuICBibGFrZTJiRmluYWwodGhpcywgYnVmKVxuICBpZiAob3V0ID09PSAnaGV4JykgcmV0dXJuIGhleFNsaWNlKGJ1ZilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5maW5hbCA9IEJsYWtlMmIucHJvdG90eXBlLmRpZ2VzdFxuXG5CbGFrZTJiLnJlYWR5ID0gZnVuY3Rpb24gKGNiKSB7XG4gIGIyd2FzbS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgY2IoKSAvLyBpZ25vcmUgdGhlIGVycm9yXG4gIH0pXG59XG5cbi8vIFVwZGF0ZXMgYSBCTEFLRTJiIHN0cmVhbWluZyBoYXNoXG4vLyBSZXF1aXJlcyBoYXNoIGNvbnRleHQgYW5kIFVpbnQ4QXJyYXkgKGJ5dGUgYXJyYXkpXG5mdW5jdGlvbiBibGFrZTJiVXBkYXRlIChjdHgsIGlucHV0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY3R4LmMgPT09IDEyOCkgeyAvLyBidWZmZXIgZnVsbCA/XG4gICAgICBjdHgudCArPSBjdHguYyAvLyBhZGQgY291bnRlcnNcbiAgICAgIGJsYWtlMmJDb21wcmVzcyhjdHgsIGZhbHNlKSAvLyBjb21wcmVzcyAobm90IGxhc3QpXG4gICAgICBjdHguYyA9IDAgLy8gY291bnRlciB0byB6ZXJvXG4gICAgfVxuICAgIGN0eC5iW2N0eC5jKytdID0gaW5wdXRbaV1cbiAgfVxufVxuXG4vLyBDb21wbGV0ZXMgYSBCTEFLRTJiIHN0cmVhbWluZyBoYXNoXG4vLyBSZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBtZXNzYWdlIGRpZ2VzdFxuZnVuY3Rpb24gYmxha2UyYkZpbmFsIChjdHgsIG91dCkge1xuICBjdHgudCArPSBjdHguYyAvLyBtYXJrIGxhc3QgYmxvY2sgb2Zmc2V0XG5cbiAgd2hpbGUgKGN0eC5jIDwgMTI4KSB7IC8vIGZpbGwgdXAgd2l0aCB6ZXJvc1xuICAgIGN0eC5iW2N0eC5jKytdID0gMFxuICB9XG4gIGJsYWtlMmJDb21wcmVzcyhjdHgsIHRydWUpIC8vIGZpbmFsIGJsb2NrIGZsYWcgPSAxXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHgub3V0bGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSBjdHguaFtpID4+IDJdID4+ICg4ICogKGkgJiAzKSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSBzdHIgKz0gdG9IZXgoYnVmW2ldKVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxudmFyIFByb3RvID0gQmxha2UyYlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2ggKG91dGxlbiwga2V5LCBzYWx0LCBwZXJzb25hbCwgbm9Bc3NlcnQpIHtcbiAgaWYgKG5vQXNzZXJ0ICE9PSB0cnVlKSB7XG4gICAgYXNzZXJ0KG91dGxlbiA+PSBCWVRFU19NSU4sICdvdXRsZW4gbXVzdCBiZSBhdCBsZWFzdCAnICsgQllURVNfTUlOICsgJywgd2FzIGdpdmVuICcgKyBvdXRsZW4pXG4gICAgYXNzZXJ0KG91dGxlbiA8PSBCWVRFU19NQVgsICdvdXRsZW4gbXVzdCBiZSBhdCBtb3N0ICcgKyBCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIG91dGxlbilcbiAgICBpZiAoa2V5ICE9IG51bGwpIGFzc2VydChrZXkubGVuZ3RoID49IEtFWUJZVEVTX01JTiwgJ2tleSBtdXN0IGJlIGF0IGxlYXN0ICcgKyBLRVlCWVRFU19NSU4gKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKGtleSAhPSBudWxsKSBhc3NlcnQoa2V5Lmxlbmd0aCA8PSBLRVlCWVRFU19NQVgsICdrZXkgbXVzdCBiZSBhdCBsZWFzdCAnICsgS0VZQllURVNfTUFYICsgJywgd2FzIGdpdmVuICcgKyBrZXkubGVuZ3RoKVxuICAgIGlmIChzYWx0ICE9IG51bGwpIGFzc2VydChzYWx0Lmxlbmd0aCA9PT0gU0FMVEJZVEVTLCAnc2FsdCBtdXN0IGJlIGV4YWN0bHkgJyArIFNBTFRCWVRFUyArICcsIHdhcyBnaXZlbiAnICsgc2FsdC5sZW5ndGgpXG4gICAgaWYgKHBlcnNvbmFsICE9IG51bGwpIGFzc2VydChwZXJzb25hbC5sZW5ndGggPT09IFBFUlNPTkFMQllURVMsICdwZXJzb25hbCBtdXN0IGJlIGV4YWN0bHkgJyArIFBFUlNPTkFMQllURVMgKyAnLCB3YXMgZ2l2ZW4gJyArIHBlcnNvbmFsLmxlbmd0aClcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvdG8ob3V0bGVuLCBrZXksIHNhbHQsIHBlcnNvbmFsKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5yZWFkeSA9IGZ1bmN0aW9uIChjYikge1xuICBiMndhc20ucmVhZHkoZnVuY3Rpb24gKCkgeyAvLyBpZ25vcmUgZXJyb3JzXG4gICAgY2IoKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5XQVNNX1NVUFBPUlRFRCA9IGIyd2FzbS5TVVBQT1JURURcbm1vZHVsZS5leHBvcnRzLldBU01fTE9BREVEID0gZmFsc2VcblxudmFyIEJZVEVTX01JTiA9IG1vZHVsZS5leHBvcnRzLkJZVEVTX01JTiA9IDE2XG52YXIgQllURVNfTUFYID0gbW9kdWxlLmV4cG9ydHMuQllURVNfTUFYID0gNjRcbnZhciBCWVRFUyA9IG1vZHVsZS5leHBvcnRzLkJZVEVTID0gMzJcbnZhciBLRVlCWVRFU19NSU4gPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFU19NSU4gPSAxNlxudmFyIEtFWUJZVEVTX01BWCA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTX01BWCA9IDY0XG52YXIgS0VZQllURVMgPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFUyA9IDMyXG52YXIgU0FMVEJZVEVTID0gbW9kdWxlLmV4cG9ydHMuU0FMVEJZVEVTID0gMTZcbnZhciBQRVJTT05BTEJZVEVTID0gbW9kdWxlLmV4cG9ydHMuUEVSU09OQUxCWVRFUyA9IDE2XG5cbmIyd2FzbS5yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICghZXJyKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMuV0FTTV9MT0FERUQgPSB0cnVlXG4gICAgUHJvdG8gPSBiMndhc21cbiAgfVxufSlcbiIsIiIsImZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cblxuICBpZiAoQnVmZmVyLmFsbG9jVW5zYWZlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhbGxvY1Vuc2FmZVxuIiwidmFyIGJ1ZmZlckZpbGwgPSByZXF1aXJlKCdidWZmZXItZmlsbCcpXG52YXIgYWxsb2NVbnNhZmUgPSByZXF1aXJlKCdidWZmZXItYWxsb2MtdW5zYWZlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxuXG4gIGlmIChCdWZmZXIuYWxsb2MpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IGFsbG9jVW5zYWZlKHNpemUpXG5cbiAgaWYgKHNpemUgPT09IDApIHtcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGJ1ZmZlckZpbGwoYnVmZmVyLCAwKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlckZpbGwoYnVmZmVyLCBmaWxsLCBlbmNvZGluZylcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGEsIGIpIHtcblx0aWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKTtcblx0fVxuXG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAodHlwZW9mIGEuZXF1YWxzID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGEuZXF1YWxzKGIpO1xuXHR9XG5cblx0aWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChhW2ldICE9PSBiW2ldKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiLyogTm9kZS5qcyA2LjQuMCBhbmQgdXAgaGFzIGZ1bGwgc3VwcG9ydCAqL1xudmFyIGhhc0Z1bGxTdXBwb3J0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKCdsYXRpbjEnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyA/IEJ1ZmZlci5hbGxvYyg0KSA6IG5ldyBCdWZmZXIoNClcblxuICAgIGJ1Zi5maWxsKCdhYicsICd1Y3MyJylcblxuICAgIHJldHVybiAoYnVmLnRvU3RyaW5nKCdoZXgnKSA9PT0gJzYxMDA2MjAwJylcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KCkpXG5cbmZ1bmN0aW9uIGlzU2luZ2xlQnl0ZSAodmFsKSB7XG4gIHJldHVybiAodmFsLmxlbmd0aCA9PT0gMSAmJiB2YWwuY2hhckNvZGVBdCgwKSA8IDI1Nilcbn1cblxuZnVuY3Rpb24gZmlsbFdpdGhOdW1iZXIgKGJ1ZmZlciwgdmFsLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gYnVmZmVyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGJ1ZmZlci5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICBidWZmZXIuZmlsbCh2YWwsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGZpbGxXaXRoQnVmZmVyIChidWZmZXIsIHZhbCwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIHZhciBwb3MgPSBzdGFydFxuICB2YXIgbGVuID0gdmFsLmxlbmd0aFxuICB3aGlsZSAocG9zIDw9IChlbmQgLSBsZW4pKSB7XG4gICAgdmFsLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGxlblxuICB9XG5cbiAgaWYgKHBvcyAhPT0gZW5kKSB7XG4gICAgdmFsLmNvcHkoYnVmZmVyLCBwb3MsIDAsIGVuZCAtIHBvcylcbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gZmlsbCAoYnVmZmVyLCB2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIGlmIChoYXNGdWxsU3VwcG9ydCkge1xuICAgIHJldHVybiBidWZmZXIuZmlsbCh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZpbGxXaXRoTnVtYmVyKGJ1ZmZlciwgdmFsLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gYnVmZmVyLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSBidWZmZXIubGVuZ3RoXG4gICAgfVxuXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuXG4gICAgaWYgKGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgZW5jb2RpbmcgPSAnYmluYXJ5J1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgcmV0dXJuIGZpbGxXaXRoTnVtYmVyKGJ1ZmZlciwgMCwgc3RhcnQsIGVuZClcbiAgICB9XG5cbiAgICBpZiAoaXNTaW5nbGVCeXRlKHZhbCkpIHtcbiAgICAgIHJldHVybiBmaWxsV2l0aE51bWJlcihidWZmZXIsIHZhbC5jaGFyQ29kZUF0KDApLCBzdGFydCwgZW5kKVxuICAgIH1cblxuICAgIHZhbCA9IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBmaWxsV2l0aEJ1ZmZlcihidWZmZXIsIHZhbCwgc3RhcnQsIGVuZClcbiAgfVxuXG4gIC8vIE90aGVyIHZhbHVlcyAoZS5nLiB1bmRlZmluZWQsIGJvb2xlYW4sIG9iamVjdCkgcmVzdWx0cyBpbiB6ZXJvLWZpbGxcbiAgcmV0dXJuIGZpbGxXaXRoTnVtYmVyKGJ1ZmZlciwgMCwgc3RhcnQsIGVuZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWxsXG4iLCJ2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbnZhciBpc01vZGVybiA9IChcbiAgdHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuKVxuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChpbnB1dCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpbnB1dCkuc2xpY2UoOCwgLTEpID09PSAnQXJyYXlCdWZmZXInXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAob2JqLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYnl0ZU9mZnNldCA+Pj49IDBcblxuICB2YXIgbWF4TGVuZ3RoID0gb2JqLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0XG5cbiAgaWYgKG1heExlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidvZmZzZXQnIGlzIG91dCBvZiBib3VuZHNcIilcbiAgfVxuXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IG1heExlbmd0aFxuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA+Pj49IDBcblxuICAgIGlmIChsZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2xlbmd0aCcgaXMgb3V0IG9mIGJvdW5kc1wiKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc01vZGVyblxuICAgID8gQnVmZmVyLmZyb20ob2JqLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBsZW5ndGgpKVxuICAgIDogbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShvYmouc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGxlbmd0aCkpKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHJldHVybiBpc01vZGVyblxuICAgID8gQnVmZmVyLmZyb20oc3RyaW5nLCBlbmNvZGluZylcbiAgICA6IG5ldyBCdWZmZXIoc3RyaW5nLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYnVmZmVyRnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGlzTW9kZXJuXG4gICAgPyBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICA6IG5ldyBCdWZmZXIodmFsdWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVmZmVyRnJvbVxuIiwidmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgYnVmZmVyRnJvbSA9IHJlcXVpcmUoJ2J1ZmZlci1mcm9tJylcblxudmFyIFNJR05BTF9GTFVTSCA9IGJ1ZmZlckZyb20oWzBdKVxuXG52YXIgQnVsayA9IGZ1bmN0aW9uIChvcHRzLCB3b3JrZXIsIGZsdXNoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWxrKSkgcmV0dXJuIG5ldyBCdWxrKG9wdHMsIHdvcmtlciwgZmx1c2gpXG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmx1c2ggPSB3b3JrZXJcbiAgICB3b3JrZXIgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cblxuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRzKVxuICB0aGlzLl93b3JrZXIgPSB3b3JrZXJcbiAgdGhpcy5fZmx1c2ggPSBmbHVzaFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKEJ1bGssIHN0cmVhbS5Xcml0YWJsZSlcblxuQnVsay5vYmogPSBmdW5jdGlvbiAob3B0cywgd29ya2VyLCBmbHVzaCkge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBCdWxrLm9iaihudWxsLCBvcHRzLCB3b3JrZXIpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIG9wdHMub2JqZWN0TW9kZSA9IHRydWVcbiAgcmV0dXJuIG5ldyBCdWxrKG9wdHMsIHdvcmtlciwgZmx1c2gpXG59XG5cbkJ1bGsucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChkYXRhLCBlbmMsIGNiKSB7XG4gIGlmICghdGhpcy5fZmx1c2gpIHJldHVybiBzdHJlYW0uV3JpdGFibGUucHJvdG90eXBlLmVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZW5kKG51bGwsIG51bGwsIGRhdGEpXG4gIGlmICh0eXBlb2YgZW5jID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5lbmQoZGF0YSwgbnVsbCwgZW5jKVxuICBpZiAoZGF0YSkgdGhpcy53cml0ZShkYXRhKVxuICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nKSB0aGlzLndyaXRlKFNJR05BTF9GTFVTSClcbiAgcmV0dXJuIHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmNhbGwodGhpcywgY2IpXG59XG5cbkJ1bGsucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJylcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG5cbkJ1bGsucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMsIGNiKSB7XG4gIGlmIChkYXRhID09PSBTSUdOQUxfRkxVU0gpIHRoaXMuX2ZsdXNoKGNiKVxuICBlbHNlIHRoaXMuX3dvcmtlcihbZGF0YV0sIGNiKVxufVxuXG5CdWxrLnByb3RvdHlwZS5fd3JpdGV2ID0gZnVuY3Rpb24gKGJhdGNoLCBjYikge1xuICB2YXIgbGVuID0gYmF0Y2gubGVuZ3RoXG4gIGlmIChiYXRjaFtiYXRjaC5sZW5ndGggLSAxXS5jaHVuayA9PT0gU0lHTkFMX0ZMVVNIKSB7XG4gICAgY2IgPSB0aGlzLl9mbHVzaGVyKGNiKVxuICAgIGlmICghLS1sZW4pIHJldHVybiBjYigpXG4gIH1cbiAgdmFyIGFyciA9IG5ldyBBcnJheShsZW4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFycltpXSA9IGJhdGNoW2ldLmNodW5rXG4gIHRoaXMuX3dvcmtlcihhcnIsIGNiKVxufVxuXG5CdWxrLnByb3RvdHlwZS5fZmx1c2hlciA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHNlbGYuX2ZsdXNoKGNiKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnVsa1xuIiwibW9kdWxlLmV4cG9ydHMgPSBjb2RlY3NcblxudmFyIGZyb21CdWZmZXIgPSAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSlcbiAgPyBCdWZmZXIuZnJvbVxuICA6IEJ1ZmZlclxuXG5jb2RlY3MuYXNjaWkgPSBjcmVhdGVTdHJpbmcoJ2FzY2lpJylcbmNvZGVjcy51dGY4ID0gY3JlYXRlU3RyaW5nKCd1dGYtOCcpXG5jb2RlY3MuaGV4ID0gY3JlYXRlU3RyaW5nKCdoZXgnKVxuY29kZWNzLmJhc2U2NCA9IGNyZWF0ZVN0cmluZygnYmFzZTY0JylcbmNvZGVjcy51Y3MyID0gY3JlYXRlU3RyaW5nKCd1Y3MyJylcbmNvZGVjcy51dGYxNmxlID0gY3JlYXRlU3RyaW5nKCd1dGYxNmxlJylcbmNvZGVjcy5uZGpzb24gPSBjcmVhdGVKU09OKHRydWUpXG5jb2RlY3MuanNvbiA9IGNyZWF0ZUpTT04oZmFsc2UpXG5jb2RlY3MuYmluYXJ5ID0ge1xuICBlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZUJpbmFyeSAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnID8gZnJvbUJ1ZmZlcihvYmosICd1dGYtOCcpIDogb2JqXG4gIH0sXG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlQmluYXJ5IChidWYpIHtcbiAgICByZXR1cm4gYnVmXG4gIH1cbn1cblxuZnVuY3Rpb24gY29kZWNzIChmbXQpIHtcbiAgaWYgKHR5cGVvZiBmbXQgPT09ICdvYmplY3QnICYmIGZtdCAmJiBmbXQuZW5jb2RlICYmIGZtdC5kZWNvZGUpIHJldHVybiBmbXRcblxuICBzd2l0Y2ggKGZtdCkge1xuICAgIGNhc2UgJ25kanNvbic6IHJldHVybiBjb2RlY3MubmRqc29uXG4gICAgY2FzZSAnanNvbic6IHJldHVybiBjb2RlY3MuanNvblxuICAgIGNhc2UgJ2FzY2lpJzogcmV0dXJuIGNvZGVjcy5hc2NpaVxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICd1dGY4JzogcmV0dXJuIGNvZGVjcy51dGY4XG4gICAgY2FzZSAnaGV4JzogcmV0dXJuIGNvZGVjcy5oZXhcbiAgICBjYXNlICdiYXNlNjQnOiByZXR1cm4gY29kZWNzLmJhc2U2NFxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1Y3MyJzogcmV0dXJuIGNvZGVjcy51Y3MyXG4gICAgY2FzZSAndXRmMTYtbGUnOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOiByZXR1cm4gY29kZWNzLnV0ZjE2bGVcbiAgfVxuXG4gIHJldHVybiBjb2RlY3MuYmluYXJ5XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUpTT04gKG5ld2xpbmUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IG5ld2xpbmUgPyBlbmNvZGVOREpTT04gOiBlbmNvZGVKU09OLFxuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlSlNPTiAoYnVmKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShidWYudG9TdHJpbmcoKSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVKU09OICh2YWwpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh2YWwpKVxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlTkRKU09OICh2YWwpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh2YWwpICsgJ1xcbicpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nICh0eXBlKSB7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGVTdHJpbmcgKHZhbCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB2YWwgPSB2YWwudG9TdHJpbmcoKVxuICAgICAgcmV0dXJuIGZyb21CdWZmZXIodmFsLCB0eXBlKVxuICAgIH0sXG4gICAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGVTdHJpbmcgKGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0eXBlKVxuICAgIH1cbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiZXhwb3J0cy5mdWxsUm9vdHMgPSBmdW5jdGlvbiAoaW5kZXgsIHJlc3VsdCkge1xuICBpZiAoaW5kZXggJiAxKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW4gb25seSBsb29rIHVwIHJvb3RzIGZvciBkZXB0aCgwKSBibG9ja3MnKVxuICBpZiAoIXJlc3VsdCkgcmVzdWx0ID0gW11cblxuICBpbmRleCAvPSAyXG5cbiAgdmFyIG9mZnNldCA9IDBcbiAgdmFyIGZhY3RvciA9IDFcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghaW5kZXgpIHJldHVybiByZXN1bHRcbiAgICB3aGlsZSAoZmFjdG9yICogMiA8PSBpbmRleCkgZmFjdG9yICo9IDJcbiAgICByZXN1bHQucHVzaChvZmZzZXQgKyBmYWN0b3IgLSAxKVxuICAgIG9mZnNldCA9IG9mZnNldCArIDIgKiBmYWN0b3JcbiAgICBpbmRleCAtPSBmYWN0b3JcbiAgICBmYWN0b3IgPSAxXG4gIH1cbn1cblxuZXhwb3J0cy5kZXB0aCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB2YXIgZGVwdGggPSAwXG5cbiAgaW5kZXggKz0gMVxuICB3aGlsZSAoIShpbmRleCAmIDEpKSB7XG4gICAgZGVwdGgrK1xuICAgIGluZGV4ID0gcmlnaHRTaGlmdChpbmRleClcbiAgfVxuXG4gIHJldHVybiBkZXB0aFxufVxuXG5leHBvcnRzLnNpYmxpbmcgPSBmdW5jdGlvbiAoaW5kZXgsIGRlcHRoKSB7XG4gIGlmICghZGVwdGgpIGRlcHRoID0gZXhwb3J0cy5kZXB0aChpbmRleClcbiAgdmFyIG9mZnNldCA9IGV4cG9ydHMub2Zmc2V0KGluZGV4LCBkZXB0aClcblxuICByZXR1cm4gZXhwb3J0cy5pbmRleChkZXB0aCwgb2Zmc2V0ICYgMSA/IG9mZnNldCAtIDEgOiBvZmZzZXQgKyAxKVxufVxuXG5leHBvcnRzLnBhcmVudCA9IGZ1bmN0aW9uIChpbmRleCwgZGVwdGgpIHtcbiAgaWYgKCFkZXB0aCkgZGVwdGggPSBleHBvcnRzLmRlcHRoKGluZGV4KVxuICB2YXIgb2Zmc2V0ID0gZXhwb3J0cy5vZmZzZXQoaW5kZXgsIGRlcHRoKVxuXG4gIHJldHVybiBleHBvcnRzLmluZGV4KGRlcHRoICsgMSwgcmlnaHRTaGlmdChvZmZzZXQpKVxufVxuXG5leHBvcnRzLmxlZnRDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCwgZGVwdGgpIHtcbiAgaWYgKCEoaW5kZXggJiAxKSkgcmV0dXJuIC0xXG4gIGlmICghZGVwdGgpIGRlcHRoID0gZXhwb3J0cy5kZXB0aChpbmRleClcbiAgcmV0dXJuIGV4cG9ydHMuaW5kZXgoZGVwdGggLSAxLCBleHBvcnRzLm9mZnNldChpbmRleCwgZGVwdGgpICogMilcbn1cblxuZXhwb3J0cy5yaWdodENoaWxkID0gZnVuY3Rpb24gKGluZGV4LCBkZXB0aCkge1xuICBpZiAoIShpbmRleCAmIDEpKSByZXR1cm4gLTFcbiAgaWYgKCFkZXB0aCkgZGVwdGggPSBleHBvcnRzLmRlcHRoKGluZGV4KVxuICByZXR1cm4gZXhwb3J0cy5pbmRleChkZXB0aCAtIDEsIDEgKyAoZXhwb3J0cy5vZmZzZXQoaW5kZXgsIGRlcHRoKSAqIDIpKVxufVxuXG5leHBvcnRzLmNoaWxkcmVuID0gZnVuY3Rpb24gKGluZGV4LCBkZXB0aCkge1xuICBpZiAoIShpbmRleCAmIDEpKSByZXR1cm4gbnVsbFxuXG4gIGlmICghZGVwdGgpIGRlcHRoID0gZXhwb3J0cy5kZXB0aChpbmRleClcbiAgdmFyIG9mZnNldCA9IGV4cG9ydHMub2Zmc2V0KGluZGV4LCBkZXB0aCkgKiAyXG5cbiAgcmV0dXJuIFtcbiAgICBleHBvcnRzLmluZGV4KGRlcHRoIC0gMSwgb2Zmc2V0KSxcbiAgICBleHBvcnRzLmluZGV4KGRlcHRoIC0gMSwgb2Zmc2V0ICsgMSlcbiAgXVxufVxuXG5leHBvcnRzLmxlZnRTcGFuID0gZnVuY3Rpb24gKGluZGV4LCBkZXB0aCkge1xuICBpZiAoIShpbmRleCAmIDEpKSByZXR1cm4gaW5kZXhcbiAgaWYgKCFkZXB0aCkgZGVwdGggPSBleHBvcnRzLmRlcHRoKGluZGV4KVxuICByZXR1cm4gZXhwb3J0cy5vZmZzZXQoaW5kZXgsIGRlcHRoKSAqIHR3b1BvdyhkZXB0aCArIDEpXG59XG5cbmV4cG9ydHMucmlnaHRTcGFuID0gZnVuY3Rpb24gKGluZGV4LCBkZXB0aCkge1xuICBpZiAoIShpbmRleCAmIDEpKSByZXR1cm4gaW5kZXhcbiAgaWYgKCFkZXB0aCkgZGVwdGggPSBleHBvcnRzLmRlcHRoKGluZGV4KVxuICByZXR1cm4gKGV4cG9ydHMub2Zmc2V0KGluZGV4LCBkZXB0aCkgKyAxKSAqIHR3b1BvdyhkZXB0aCArIDEpIC0gMlxufVxuXG5leHBvcnRzLmNvdW50ID0gZnVuY3Rpb24gKGluZGV4LCBkZXB0aCkge1xuICBpZiAoIShpbmRleCAmIDEpKSByZXR1cm4gMVxuICBpZiAoIWRlcHRoKSBkZXB0aCA9IGV4cG9ydHMuZGVwdGgoaW5kZXgpXG4gIHJldHVybiB0d29Qb3coZGVwdGggKyAxKSAtIDFcbn1cblxuZXhwb3J0cy5zcGFucyA9IGZ1bmN0aW9uIChpbmRleCwgZGVwdGgpIHtcbiAgaWYgKCEoaW5kZXggJiAxKSkgcmV0dXJuIFtpbmRleCwgaW5kZXhdXG4gIGlmICghZGVwdGgpIGRlcHRoID0gZXhwb3J0cy5kZXB0aChpbmRleClcblxuICB2YXIgb2Zmc2V0ID0gZXhwb3J0cy5vZmZzZXQoaW5kZXgsIGRlcHRoKVxuICB2YXIgd2lkdGggPSB0d29Qb3coZGVwdGggKyAxKVxuXG4gIHJldHVybiBbb2Zmc2V0ICogd2lkdGgsIChvZmZzZXQgKyAxKSAqIHdpZHRoIC0gMl1cbn1cblxuZXhwb3J0cy5pbmRleCA9IGZ1bmN0aW9uIChkZXB0aCwgb2Zmc2V0KSB7XG4gIHJldHVybiAoMSArIDIgKiBvZmZzZXQpICogdHdvUG93KGRlcHRoKSAtIDFcbn1cblxuZXhwb3J0cy5vZmZzZXQgPSBmdW5jdGlvbiAoaW5kZXgsIGRlcHRoKSB7XG4gIGlmICghKGluZGV4ICYgMSkpIHJldHVybiBpbmRleCAvIDJcbiAgaWYgKCFkZXB0aCkgZGVwdGggPSBleHBvcnRzLmRlcHRoKGluZGV4KVxuXG4gIHJldHVybiAoKGluZGV4ICsgMSkgLyB0d29Qb3coZGVwdGgpIC0gMSkgLyAyXG59XG5cbmV4cG9ydHMuaXRlcmF0b3IgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdmFyIGl0ZSA9IG5ldyBJdGVyYXRvcigpXG4gIGl0ZS5zZWVrKGluZGV4IHx8IDApXG4gIHJldHVybiBpdGVcbn1cblxuZnVuY3Rpb24gdHdvUG93IChuKSB7XG4gIHJldHVybiBuIDwgMzEgPyAxIDw8IG4gOiAoKDEgPDwgMzApICogKDEgPDwgKG4gLSAzMCkpKVxufVxuXG5mdW5jdGlvbiByaWdodFNoaWZ0IChuKSB7XG4gIHJldHVybiAobiAtIChuICYgMSkpIC8gMlxufVxuXG5mdW5jdGlvbiBJdGVyYXRvciAoaW5kZXgpIHtcbiAgdGhpcy5pbmRleCA9IDBcbiAgdGhpcy5vZmZzZXQgPSAwXG4gIHRoaXMuZmFjdG9yID0gMFxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB0aGlzLmluZGV4ID0gaW5kZXhcbiAgaWYgKHRoaXMuaW5kZXggJiAxKSB7XG4gICAgdGhpcy5vZmZzZXQgPSBleHBvcnRzLm9mZnNldChpbmRleClcbiAgICB0aGlzLmZhY3RvciA9IHR3b1BvdyhleHBvcnRzLmRlcHRoKGluZGV4KSArIDEpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vZmZzZXQgPSBpbmRleCAvIDJcbiAgICB0aGlzLmZhY3RvciA9IDJcbiAgfVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuaXNMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISh0aGlzLm9mZnNldCAmIDEpXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5pc1JpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIXRoaXMuaXNMZWZ0KClcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5vZmZzZXQpIHJldHVybiB0aGlzLmluZGV4XG4gIHRoaXMub2Zmc2V0LS1cbiAgdGhpcy5pbmRleCAtPSB0aGlzLmZhY3RvclxuICByZXR1cm4gdGhpcy5pbmRleFxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vZmZzZXQrK1xuICB0aGlzLmluZGV4ICs9IHRoaXMuZmFjdG9yXG4gIHJldHVybiB0aGlzLmluZGV4XG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5zaWJsaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc0xlZnQoKSA/IHRoaXMubmV4dCgpIDogdGhpcy5wcmV2KClcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMub2Zmc2V0ICYgMSkge1xuICAgIHRoaXMuaW5kZXggLT0gdGhpcy5mYWN0b3IgLyAyXG4gICAgdGhpcy5vZmZzZXQgPSAodGhpcy5vZmZzZXQgLSAxKSAvIDJcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmluZGV4ICs9IHRoaXMuZmFjdG9yIC8gMlxuICAgIHRoaXMub2Zmc2V0IC89IDJcbiAgfVxuICB0aGlzLmZhY3RvciAqPSAyXG4gIHJldHVybiB0aGlzLmluZGV4XG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5sZWZ0U3BhbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pbmRleCA9IHRoaXMuaW5kZXggLSB0aGlzLmZhY3RvciAvIDIgKyAxXG4gIHRoaXMub2Zmc2V0ID0gdGhpcy5pbmRleCAvIDJcbiAgdGhpcy5mYWN0b3IgPSAyXG4gIHJldHVybiB0aGlzLmluZGV4XG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5yaWdodFNwYW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaW5kZXggPSB0aGlzLmluZGV4ICsgdGhpcy5mYWN0b3IgLyAyIC0gMVxuICB0aGlzLm9mZnNldCA9IHRoaXMuaW5kZXggLyAyXG4gIHRoaXMuZmFjdG9yID0gMlxuICByZXR1cm4gdGhpcy5pbmRleFxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUubGVmdENoaWxkID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5mYWN0b3IgPT09IDIpIHJldHVybiB0aGlzLmluZGV4XG4gIHRoaXMuZmFjdG9yIC89IDJcbiAgdGhpcy5pbmRleCAtPSB0aGlzLmZhY3RvciAvIDJcbiAgdGhpcy5vZmZzZXQgKj0gMlxuICByZXR1cm4gdGhpcy5pbmRleFxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUucmlnaHRDaGlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZmFjdG9yID09PSAyKSByZXR1cm4gdGhpcy5pbmRleFxuICB0aGlzLmZhY3RvciAvPSAyXG4gIHRoaXMuaW5kZXggKz0gdGhpcy5mYWN0b3IgLyAyXG4gIHRoaXMub2Zmc2V0ID0gMiAqIHRoaXMub2Zmc2V0ICsgMVxuICByZXR1cm4gdGhpcy5pbmRleFxufVxuIiwidmFyIFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGVcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmcm9tMlxuXG5mcm9tMi5jdG9yID0gY3RvclxuZnJvbTIub2JqID0gb2JqXG5cbnZhciBQcm90byA9IGN0b3IoKVxuXG5mdW5jdGlvbiB0b0Z1bmN0aW9uKGxpc3QpIHtcbiAgbGlzdCA9IGxpc3Quc2xpY2UoKVxuICByZXR1cm4gZnVuY3Rpb24gKF8sIGNiKSB7XG4gICAgdmFyIGVyciA9IG51bGxcbiAgICB2YXIgaXRlbSA9IGxpc3QubGVuZ3RoID8gbGlzdC5zaGlmdCgpIDogbnVsbFxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGVyciA9IGl0ZW1cbiAgICAgIGl0ZW0gPSBudWxsXG4gICAgfVxuXG4gICAgY2IoZXJyLCBpdGVtKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZyb20yKG9wdHMsIHJlYWQpIHtcbiAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgcmVhZCA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuXG4gIHZhciBycyA9IG5ldyBQcm90byhvcHRzKVxuICBycy5fZnJvbSA9IEFycmF5LmlzQXJyYXkocmVhZCkgPyB0b0Z1bmN0aW9uKHJlYWQpIDogKHJlYWQgfHwgbm9vcClcbiAgcmV0dXJuIHJzXG59XG5cbmZ1bmN0aW9uIGN0b3Iob3B0cywgcmVhZCkge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWFkID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG5cbiAgb3B0cyA9IGRlZmF1bHRzKG9wdHMpXG5cbiAgaW5oZXJpdHMoQ2xhc3MsIFJlYWRhYmxlKVxuICBmdW5jdGlvbiBDbGFzcyhvdmVycmlkZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDbGFzcykpIHJldHVybiBuZXcgQ2xhc3Mob3ZlcnJpZGUpXG4gICAgdGhpcy5fcmVhZGluZyA9IGZhbHNlXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjaGVja1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgICBSZWFkYWJsZS5jYWxsKHRoaXMsIG92ZXJyaWRlIHx8IG9wdHMpXG5cbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB2YXIgaHdtID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrXG5cbiAgICBmdW5jdGlvbiBjaGVjayhlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5kZXN0cm95KGVycilcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gc2VsZi5wdXNoKG51bGwpXG4gICAgICBzZWxmLl9yZWFkaW5nID0gZmFsc2VcbiAgICAgIGlmIChzZWxmLnB1c2goZGF0YSkpIHNlbGYuX3JlYWQoaHdtKVxuICAgIH1cbiAgfVxuXG4gIENsYXNzLnByb3RvdHlwZS5fZnJvbSA9IHJlYWQgfHwgbm9vcFxuICBDbGFzcy5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRpbmcgfHwgdGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIHRoaXMuX3JlYWRpbmcgPSB0cnVlXG4gICAgdGhpcy5fZnJvbShzaXplLCB0aGlzLl9jYWxsYmFjaylcbiAgfVxuXG4gIENsYXNzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcblxuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZXJyKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBDbGFzc1xufVxuXG5mdW5jdGlvbiBvYmoob3B0cywgcmVhZCkge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgIHJlYWQgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cblxuICBvcHRzID0gZGVmYXVsdHMob3B0cylcbiAgb3B0cy5vYmplY3RNb2RlID0gdHJ1ZVxuICBvcHRzLmhpZ2hXYXRlck1hcmsgPSAxNlxuXG4gIHJldHVybiBmcm9tMihvcHRzLCByZWFkKVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIGRlZmF1bHRzKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgcmV0dXJuIG9wdHNcbn1cbiIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJylcbnZhciBidWZmZXJBbGxvYyA9IHJlcXVpcmUoJ2J1ZmZlci1hbGxvYy11bnNhZmUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZlZWRcblxuZnVuY3Rpb24gRmVlZCAoc3RyZWFtKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWVkKSkgcmV0dXJuIG5ldyBGZWVkKHN0cmVhbSlcbiAgZXZlbnRzLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG5cbiAgdGhpcy5rZXkgPSBudWxsXG4gIHRoaXMuZGlzY292ZXJ5S2V5ID0gbnVsbFxuICB0aGlzLnN0cmVhbSA9IHN0cmVhbVxuICB0aGlzLnBlZXIgPSBudWxsIC8vIHN1cHBvcnQgYSBwZWVyIG9iamVjdCB0byBhdm9pZCBldmVudCBlbWl0dGVyICsgY2xvc3VyZXMgb3ZlcmhlYWRcblxuICB0aGlzLmlkID0gLTFcbiAgdGhpcy5yZW1vdGVJZCA9IC0xXG4gIHRoaXMuaGVhZGVyID0gMFxuICB0aGlzLmhlYWRlckxlbmd0aCA9IDBcbiAgdGhpcy5jbG9zZWQgPSBmYWxzZVxuXG4gIHRoaXMuX2J1ZmZlciA9IFtdXG59XG5cbmluaGVyaXRzKEZlZWQsIGV2ZW50cy5FdmVudEVtaXR0ZXIpXG5cbkZlZWQucHJvdG90eXBlLmhhbmRzaGFrZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLl9zZW5kKDEsIG1lc3NhZ2VzLkhhbmRzaGFrZSwgbWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLl9zZW5kKDIsIG1lc3NhZ2VzLkluZm8sIG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLmhhdmUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy5fc2VuZCgzLCBtZXNzYWdlcy5IYXZlLCBtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS51bmhhdmUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy5fc2VuZCg0LCBtZXNzYWdlcy5VbmhhdmUsIG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLndhbnQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy5fc2VuZCg1LCBtZXNzYWdlcy5XYW50LCBtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS51bndhbnQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy5fc2VuZCg2LCBtZXNzYWdlcy5VbndhbnQsIG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy5fc2VuZCg3LCBtZXNzYWdlcy5SZXF1ZXN0LCBtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy5fc2VuZCg4LCBtZXNzYWdlcy5DYW5jZWwsIG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy5fc2VuZCg5LCBtZXNzYWdlcy5EYXRhLCBtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS5leHRlbnNpb24gPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xuICB2YXIgaWQgPSB0aGlzLnN0cmVhbS5leHRlbnNpb25zLmluZGV4T2YodHlwZSlcbiAgaWYgKGlkID09PSAtMSkgcmV0dXJuIGZhbHNlXG5cbiAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyIHwgMTVcbiAgdmFyIGxlbiA9IHRoaXMuaGVhZGVyTGVuZ3RoICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKGlkKSArIG1lc3NhZ2UubGVuZ3RoXG4gIHZhciBib3ggPSBidWZmZXJBbGxvYyh2YXJpbnQuZW5jb2RpbmdMZW5ndGgobGVuKSArIGxlbilcbiAgdmFyIG9mZnNldCA9IDBcblxuICB2YXJpbnQuZW5jb2RlKGxlbiwgYm94LCBvZmZzZXQpXG4gIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG5cbiAgdmFyaW50LmVuY29kZShoZWFkZXIsIGJveCwgb2Zmc2V0KVxuICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuXG4gIHZhcmludC5lbmNvZGUoaWQsIGJveCwgb2Zmc2V0KVxuICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuXG4gIG1lc3NhZ2UuY29weShib3gsIG9mZnNldClcbiAgcmV0dXJuIHRoaXMuc3RyZWFtLl9wdXNoKGJveClcbn1cblxuRmVlZC5wcm90b3R5cGUucmVtb3RlU3VwcG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5zdHJlYW0ucmVtb3RlU3VwcG9ydHMobmFtZSlcbn1cblxuRmVlZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5zdHJlYW0uZGVzdHJveShlcnIpXG59XG5cbkZlZWQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IHRoaXMuc3RyZWFtLmZlZWRzLmluZGV4T2YodGhpcylcblxuICBpZiAoaSA+IC0xKSB7XG4gICAgdGhpcy5zdHJlYW0uZmVlZHNbaV0gPSB0aGlzLnN0cmVhbS5mZWVkc1t0aGlzLnN0cmVhbS5mZWVkcy5sZW5ndGggLSAxXVxuICAgIHRoaXMuc3RyZWFtLmZlZWRzLnBvcCgpXG4gICAgdGhpcy5zdHJlYW0uX2xvY2FsRmVlZHNbdGhpcy5pZF0gPSBudWxsXG4gICAgdGhpcy5pZCA9IC0xXG5cbiAgICBpZiAodGhpcy5zdHJlYW0uZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAodGhpcy5zdHJlYW0uZXhwZWN0ZWRGZWVkcyA8PSAwIHx8IC0tdGhpcy5zdHJlYW0uZXhwZWN0ZWRGZWVkcykgcmV0dXJuXG5cbiAgICB0aGlzLnN0cmVhbS5fcHJlZmluYWxpemUoKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jbG9zZWQpIHJldHVyblxuICB0aGlzLmNsb3NlZCA9IHRydWVcblxuICBpZiAoIXRoaXMuc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuY2xvc2UoKVxuICAgIGlmICh0aGlzLnJlbW90ZUlkID4gLTEpIHRoaXMuc3RyZWFtLl9yZW1vdGVGZWVkc1t0aGlzLnJlbW90ZUlkXSA9IG51bGxcbiAgICB2YXIgaGV4ID0gdGhpcy5kaXNjb3ZlcnlLZXkudG9TdHJpbmcoJ2hleCcpXG4gICAgaWYgKHRoaXMuc3RyZWFtLl9mZWVkc1toZXhdID09PSB0aGlzKSBkZWxldGUgdGhpcy5zdHJlYW0uX2ZlZWRzW2hleF1cbiAgfVxuXG4gIGlmICh0aGlzLnBlZXIpIHRoaXMucGVlci5vbmNsb3NlKClcbiAgZWxzZSB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuRmVlZC5wcm90b3R5cGUuX3Jlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lKVxuXG4gIGZ1bmN0aW9uIHJlc3VtZSAoKSB7XG4gICAgd2hpbGUgKHNlbGYuX2J1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHZhciBuZXh0ID0gc2VsZi5fYnVmZmVyLnNoaWZ0KClcbiAgICAgIHNlbGYuX2VtaXQobmV4dC50eXBlLCBuZXh0Lm1lc3NhZ2UpXG4gICAgfVxuICAgIHNlbGYuX2J1ZmZlciA9IG51bGxcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fb25leHRlbnNpb24gPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm5cblxuICB2YXIgaWQgPSB2YXJpbnQuZGVjb2RlKGRhdGEsIHN0YXJ0KVxuICB2YXIgciA9IHRoaXMuc3RyZWFtLnJlbW90ZUV4dGVuc2lvbnNcbiAgdmFyIGxvY2FsSWQgPSAhciB8fCBpZCA+PSByLmxlbmd0aCA/IC0xIDogcltpZF1cblxuICBpZiAobG9jYWxJZCA9PT0gLTEpIHJldHVyblxuXG4gIHZhciBtZXNzYWdlID0gZGF0YS5zbGljZShzdGFydCArIHZhcmludC5kZWNvZGUuYnl0ZXMsIGVuZClcbiAgdmFyIG5hbWUgPSB0aGlzLnN0cmVhbS5leHRlbnNpb25zW2xvY2FsSWRdXG5cbiAgaWYgKHRoaXMucGVlciAmJiB0aGlzLnBlZXIub25leHRlbnNpb24pIHRoaXMucGVlci5vbmV4dGVuc2lvbihuYW1lLCBtZXNzYWdlKVxuICBlbHNlIHRoaXMuZW1pdCgnZXh0ZW5zaW9uJywgbmFtZSwgbWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUuX29ubWVzc2FnZSA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBzdGFydCwgZW5kKSB7XG4gIHZhciBtZXNzYWdlID0gZGVjb2RlTWVzc2FnZSh0eXBlLCBkYXRhLCBzdGFydCwgZW5kKVxuICBpZiAoIW1lc3NhZ2UgfHwgdGhpcy5jbG9zZWQpIHJldHVyblxuXG4gIGlmICh0eXBlID09PSAxKSByZXR1cm4gdGhpcy5zdHJlYW0uX29uaGFuZHNoYWtlKG1lc3NhZ2UpXG5cbiAgaWYgKCF0aGlzLl9idWZmZXIpIHtcbiAgICB0aGlzLl9lbWl0KHR5cGUsIG1lc3NhZ2UpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA+IDE2KSB7XG4gICAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignUmVtb3RlIHNlbnQgdG9vIG1hbnkgbWVzc2FnZXMgb24gYW4gdW5vcGVuZWQgZmVlZCcpKVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5fYnVmZmVyLnB1c2goe3R5cGU6IHR5cGUsIG1lc3NhZ2U6IG1lc3NhZ2V9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5fZW1pdCA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLnBlZXIpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgMjogcmV0dXJuIHRoaXMucGVlci5vbmluZm8obWVzc2FnZSlcbiAgICAgIGNhc2UgMzogcmV0dXJuIHRoaXMucGVlci5vbmhhdmUobWVzc2FnZSlcbiAgICAgIGNhc2UgNDogcmV0dXJuIHRoaXMucGVlci5vbnVuaGF2ZShtZXNzYWdlKVxuICAgICAgY2FzZSA1OiByZXR1cm4gdGhpcy5wZWVyLm9ud2FudChtZXNzYWdlKVxuICAgICAgY2FzZSA2OiByZXR1cm4gdGhpcy5wZWVyLm9udW53YW50KG1lc3NhZ2UpXG4gICAgICBjYXNlIDc6IHJldHVybiB0aGlzLnBlZXIub25yZXF1ZXN0KG1lc3NhZ2UpXG4gICAgICBjYXNlIDg6IHJldHVybiB0aGlzLnBlZXIub25jYW5jZWwobWVzc2FnZSlcbiAgICAgIGNhc2UgOTogcmV0dXJuIHRoaXMucGVlci5vbmRhdGEobWVzc2FnZSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIDI6IHJldHVybiB0aGlzLmVtaXQoJ2luZm8nLCBtZXNzYWdlKVxuICAgICAgY2FzZSAzOiByZXR1cm4gdGhpcy5lbWl0KCdoYXZlJywgbWVzc2FnZSlcbiAgICAgIGNhc2UgNDogcmV0dXJuIHRoaXMuZW1pdCgndW5oYXZlJywgbWVzc2FnZSlcbiAgICAgIGNhc2UgNTogcmV0dXJuIHRoaXMuZW1pdCgnd2FudCcsIG1lc3NhZ2UpXG4gICAgICBjYXNlIDY6IHJldHVybiB0aGlzLmVtaXQoJ3Vud2FudCcsIG1lc3NhZ2UpXG4gICAgICBjYXNlIDc6IHJldHVybiB0aGlzLmVtaXQoJ3JlcXVlc3QnLCBtZXNzYWdlKVxuICAgICAgY2FzZSA4OiByZXR1cm4gdGhpcy5lbWl0KCdjYW5jZWwnLCBtZXNzYWdlKVxuICAgICAgY2FzZSA5OiByZXR1cm4gdGhpcy5lbWl0KCdkYXRhJywgbWVzc2FnZSlcbiAgICB9XG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiAodHlwZSwgZW5jLCBtZXNzYWdlKSB7XG4gIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlciB8IHR5cGVcbiAgdmFyIGxlbiA9IHRoaXMuaGVhZGVyTGVuZ3RoICsgZW5jLmVuY29kaW5nTGVuZ3RoKG1lc3NhZ2UpXG4gIHZhciBib3ggPSBidWZmZXJBbGxvYyh2YXJpbnQuZW5jb2RpbmdMZW5ndGgobGVuKSArIGxlbilcbiAgdmFyIG9mZnNldCA9IDBcblxuICB2YXJpbnQuZW5jb2RlKGxlbiwgYm94LCBvZmZzZXQpXG4gIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG5cbiAgdmFyaW50LmVuY29kZShoZWFkZXIsIGJveCwgb2Zmc2V0KVxuICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuXG4gIGVuYy5lbmNvZGUobWVzc2FnZSwgYm94LCBvZmZzZXQpXG5cbiAgcmV0dXJuIHRoaXMuc3RyZWFtLl9wdXNoKGJveClcbn1cblxuZnVuY3Rpb24gZGVjb2RlTWVzc2FnZSAodHlwZSwgZGF0YSwgc3RhcnQsIGVuZCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIDE6IHJldHVybiBkZWNvZGUobWVzc2FnZXMuSGFuZHNoYWtlLCBkYXRhLCBzdGFydCwgZW5kKVxuICAgIGNhc2UgMjogcmV0dXJuIGRlY29kZShtZXNzYWdlcy5JbmZvLCBkYXRhLCBzdGFydCwgZW5kKVxuICAgIGNhc2UgMzogcmV0dXJuIGRlY29kZShtZXNzYWdlcy5IYXZlLCBkYXRhLCBzdGFydCwgZW5kKVxuICAgIGNhc2UgNDogcmV0dXJuIGRlY29kZShtZXNzYWdlcy5VbmhhdmUsIGRhdGEsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSA1OiByZXR1cm4gZGVjb2RlKG1lc3NhZ2VzLldhbnQsIGRhdGEsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSA2OiByZXR1cm4gZGVjb2RlKG1lc3NhZ2VzLlVud2FudCwgZGF0YSwgc3RhcnQsIGVuZClcbiAgICBjYXNlIDc6IHJldHVybiBkZWNvZGUobWVzc2FnZXMuUmVxdWVzdCwgZGF0YSwgc3RhcnQsIGVuZClcbiAgICBjYXNlIDg6IHJldHVybiBkZWNvZGUobWVzc2FnZXMuQ2FuY2VsLCBkYXRhLCBzdGFydCwgZW5kKVxuICAgIGNhc2UgOTogcmV0dXJuIGRlY29kZShtZXNzYWdlcy5EYXRhLCBkYXRhLCBzdGFydCwgZW5kKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29kZSAoZW5jLCBkYXRhLCBzdGFydCwgZW5kKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVuYy5kZWNvZGUoZGF0YSwgc3RhcnQsIGVuZClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwidmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbnZhciBzb2RpdW0gPSByZXF1aXJlKCdzb2RpdW0tdW5pdmVyc2FsJylcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnc29ydGVkLWluZGV4b2YnKVxudmFyIGZlZWQgPSByZXF1aXJlKCcuL2ZlZWQnKVxudmFyIG1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpXG52YXIgYnVmZmVyQWxsb2MgPSByZXF1aXJlKCdidWZmZXItYWxsb2MtdW5zYWZlJylcbnZhciBidWZmZXJGcm9tID0gcmVxdWlyZSgnYnVmZmVyLWZyb20nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3RvY29sXG5cbmZ1bmN0aW9uIFByb3RvY29sIChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm90b2NvbCkpIHJldHVybiBuZXcgUHJvdG9jb2wob3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBzdHJlYW0uRHVwbGV4LmNhbGwodGhpcylcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgcmFuZG9tQnl0ZXMoMzIpXG4gIHRoaXMubGl2ZSA9ICEhb3B0cy5saXZlXG4gIHRoaXMuYWNrID0gISFvcHRzLmFja1xuICB0aGlzLnVzZXJEYXRhID0gb3B0cy51c2VyRGF0YSB8fCBudWxsXG4gIHRoaXMucmVtb3RlSWQgPSBudWxsXG4gIHRoaXMucmVtb3RlTGl2ZSA9IGZhbHNlXG4gIHRoaXMucmVtb3RlVXNlckRhdGEgPSBudWxsXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICB0aGlzLmVuY3J5cHRlZCA9IG9wdHMuZW5jcnlwdCAhPT0gZmFsc2VcbiAgdGhpcy5rZXkgPSBudWxsXG4gIHRoaXMuZGlzY292ZXJ5S2V5ID0gbnVsbFxuICB0aGlzLnJlbW90ZURpc2NvdmVyeUtleSA9IG51bGxcbiAgdGhpcy5mZWVkcyA9IFtdXG4gIHRoaXMuZXhwZWN0ZWRGZWVkcyA9IG9wdHMuZXhwZWN0ZWRGZWVkcyB8fCAwXG4gIHRoaXMuZXh0ZW5zaW9ucyA9IG9wdHMuZXh0ZW5zaW9ucyB8fCBbXVxuICB0aGlzLnJlbW90ZUV4dGVuc2lvbnMgPSBudWxsXG5cbiAgdGhpcy5fbG9jYWxGZWVkcyA9IFtdXG4gIHRoaXMuX3JlbW90ZUZlZWRzID0gW11cbiAgdGhpcy5fZmVlZHMgPSB7fVxuXG4gIHRoaXMuX25vbmNlID0gbnVsbFxuICB0aGlzLl9yZW1vdGVOb25jZSA9IG51bGxcbiAgdGhpcy5feG9yID0gbnVsbFxuICB0aGlzLl9yZW1vdGVYb3IgPSBudWxsXG4gIHRoaXMuX25lZWRzS2V5ID0gZmFsc2VcbiAgdGhpcy5fbGVuZ3RoID0gYnVmZmVyQWxsb2ModmFyaW50LmVuY29kaW5nTGVuZ3RoKDgzODg2MDgpKVxuICB0aGlzLl9taXNzaW5nID0gMFxuICB0aGlzLl9idWYgPSBudWxsXG4gIHRoaXMuX3BvaW50ZXIgPSAwXG4gIHRoaXMuX2RhdGEgPSBudWxsXG4gIHRoaXMuX3N0YXJ0ID0gMFxuICB0aGlzLl9jYiA9IG51bGxcbiAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG4gIHRoaXMuX2tlZXBBbGl2ZSA9IDBcbiAgdGhpcy5fcmVtb3RlS2VlcEFsaXZlID0gMFxuICB0aGlzLl9tYXliZUZpbmFsaXplID0gbWF5YmVGaW5hbGl6ZVxuXG4gIGlmIChvcHRzLnRpbWVvdXQgIT09IDAgJiYgb3B0cy50aW1lb3V0ICE9PSBmYWxzZSkgdGhpcy5zZXRUaW1lb3V0KG9wdHMudGltZW91dCB8fCA1MDAwLCB0aGlzLl9vbnRpbWVvdXQpXG4gIHRoaXMub24oJ2ZpbmlzaCcsIHRoaXMuZmluYWxpemUpXG5cbiAgZnVuY3Rpb24gbWF5YmVGaW5hbGl6ZSAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZGVzdHJveShlcnIpXG4gICAgaWYgKCFzZWxmLmV4cGVjdGVkRmVlZHMpIHNlbGYuZmluYWxpemUoKVxuICB9XG59XG5cbmluaGVyaXRzKFByb3RvY29sLCBzdHJlYW0uRHVwbGV4KVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3ByZWZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZW1pdCgncHJlZmluYWxpemUnLCB0aGlzLl9tYXliZUZpbmFsaXplKSkgdGhpcy5maW5hbGl6ZSgpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBvbnRpbWVvdXQpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgaWYgKG9udGltZW91dCkgdGhpcy5vbmNlKCd0aW1lb3V0Jywgb250aW1lb3V0KVxuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMuX2tlZXBBbGl2ZSA9IDBcbiAgdGhpcy5fcmVtb3RlS2VlcEFsaXZlID0gMFxuXG4gIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gIGlmICghbXMpIHJldHVyblxuXG4gIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoa2ljaywgKG1zIC8gNCkgfCAwKVxuICBpZiAodGhpcy5faW50ZXJ2YWwudW5yZWYpIHRoaXMuX2ludGVydmFsLnVucmVmKClcblxuICBmdW5jdGlvbiBraWNrICgpIHtcbiAgICBzZWxmLl9raWNrKClcbiAgfVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuZmVlZCA9IGZ1bmN0aW9uIChrZXksIG9wdHMpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm4gbnVsbFxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIHZhciBkayA9IG9wdHMuZGlzY292ZXJ5S2V5IHx8IGRpc2NvdmVyeUtleShrZXkpXG4gIHZhciBjaCA9IHRoaXMuX2ZlZWQoZGspXG5cbiAgaWYgKGNoLmlkID4gLTEpIHtcbiAgICBpZiAob3B0cy5wZWVyKSBjaC5wZWVyID0gb3B0cy5wZWVyXG4gICAgcmV0dXJuIGNoXG4gIH1cblxuICBpZiAodGhpcy5fbG9jYWxGZWVkcy5sZW5ndGggPj0gMTI4KSB7XG4gICAgdGhpcy5fdG9vTWFueUZlZWRzKClcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY2guaWQgPSB0aGlzLl9sb2NhbEZlZWRzLnB1c2goY2gpIC0gMVxuICBjaC5oZWFkZXIgPSBjaC5pZCA8PCA0XG4gIGNoLmhlYWRlckxlbmd0aCA9IHZhcmludC5lbmNvZGluZ0xlbmd0aChjaC5oZWFkZXIpXG4gIGNoLmtleSA9IGtleVxuICBjaC5kaXNjb3ZlcnlLZXkgPSBka1xuICBpZiAob3B0cy5wZWVyKSBjaC5wZWVyID0gb3B0cy5wZWVyXG5cbiAgdGhpcy5mZWVkcy5wdXNoKGNoKVxuXG4gIHZhciBmaXJzdCA9ICF0aGlzLmtleVxuICB2YXIgZmVlZCA9IHtcbiAgICBkaXNjb3ZlcnlLZXk6IGRrLFxuICAgIG5vbmNlOiBudWxsXG4gIH1cblxuICBpZiAoZmlyc3QpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMuZGlzY292ZXJ5S2V5ID0gZGtcblxuICAgIGlmICghdGhpcy5fc2FtZUtleSgpKSByZXR1cm4gbnVsbFxuXG4gICAgaWYgKHRoaXMuZW5jcnlwdGVkKSB7XG4gICAgICBmZWVkLm5vbmNlID0gdGhpcy5fbm9uY2UgPSByYW5kb21CeXRlcygyNClcbiAgICAgIHRoaXMuX3hvciA9IHNvZGl1bS5jcnlwdG9fc3RyZWFtX3hvcl9pbnN0YW5jZSh0aGlzLl9ub25jZSwgdGhpcy5rZXkpXG4gICAgICBpZiAodGhpcy5fcmVtb3RlTm9uY2UpIHtcbiAgICAgICAgdGhpcy5fcmVtb3RlWG9yID0gc29kaXVtLmNyeXB0b19zdHJlYW1feG9yX2luc3RhbmNlKHRoaXMuX3JlbW90ZU5vbmNlLCB0aGlzLmtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmVlZHNLZXkpIHtcbiAgICAgIHRoaXMuX25lZWRzS2V5ID0gZmFsc2VcbiAgICAgIHRoaXMuX3Jlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgdmFyIGJveCA9IGVuY29kZUZlZWQoZmVlZCwgY2guaWQpXG4gIGlmICghZmVlZC5ub25jZSAmJiB0aGlzLmVuY3J5cHRlZCkgdGhpcy5feG9yLnVwZGF0ZShib3gsIGJveClcbiAgdGhpcy5fa2VlcEFsaXZlID0gMFxuICB0aGlzLnB1c2goYm94KVxuXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIG51bGxcblxuICBpZiAoZmlyc3QpIHtcbiAgICBjaC5oYW5kc2hha2Uoe1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBsaXZlOiB0aGlzLmxpdmUsXG4gICAgICB1c2VyRGF0YTogdGhpcy51c2VyRGF0YSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZXh0ZW5zaW9ucyxcbiAgICAgIGFjazogdGhpcy5hY2tcbiAgICB9KVxuICB9XG5cbiAgaWYgKGNoLl9idWZmZXIubGVuZ3RoKSBjaC5fcmVzdW1lKClcbiAgZWxzZSBjaC5fYnVmZmVyID0gbnVsbFxuXG4gIHJldHVybiBjaFxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3Jlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lKVxuXG4gIGZ1bmN0aW9uIHJlc3VtZSAoKSB7XG4gICAgaWYgKCFzZWxmLl9kYXRhKSByZXR1cm5cblxuICAgIHZhciBkYXRhID0gc2VsZi5fZGF0YVxuICAgIHZhciBzdGFydCA9IHNlbGYuX3N0YXJ0XG4gICAgdmFyIGNiID0gc2VsZi5fY2JcblxuICAgIHNlbGYuX2RhdGEgPSBudWxsXG4gICAgc2VsZi5fc3RhcnQgPSAwXG4gICAgc2VsZi5fY2IgPSBudWxsXG4gICAgc2VsZi5fcGFyc2UoZGF0YSwgc3RhcnQsIGNiKVxuICB9XG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fa2ljayA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3JlbW90ZUtlZXBBbGl2ZSA+IDQpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKVxuICAgIHRoaXMuZW1pdCgndGltZW91dCcpXG4gICAgcmV0dXJuXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmVlZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2ggPSB0aGlzLmZlZWRzW2ldXG4gICAgaWYgKGNoLnBlZXIpIGNoLnBlZXIub250aWNrKClcbiAgICBlbHNlIGNoLmVtaXQoJ3RpY2snKVxuICB9XG5cbiAgdGhpcy5fcmVtb3RlS2VlcEFsaXZlKytcblxuICBpZiAodGhpcy5fa2VlcEFsaXZlID4gMikge1xuICAgIHRoaXMucGluZygpXG4gICAgdGhpcy5fa2VlcEFsaXZlID0gMFxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2tlZXBBbGl2ZSsrXG4gIH1cbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5rZXkpIHJldHVybiB0cnVlXG4gIHZhciBwaW5nID0gYnVmZmVyRnJvbShbMF0pXG4gIGlmICh0aGlzLl94b3IpIHRoaXMuX3hvci51cGRhdGUocGluZywgcGluZylcbiAgcmV0dXJuIHRoaXMucHVzaChwaW5nKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHRoaXMuX2Nsb3NlKClcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX2Nsb3NlKClcbiAgdGhpcy5wdXNoKG51bGwpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG5cbiAgdmFyIGZlZWRzID0gdGhpcy5mZWVkc1xuICB0aGlzLmZlZWRzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWVkcy5sZW5ndGg7IGkrKykgZmVlZHNbaV0uX29uY2xvc2UoKVxuXG4gIGlmICh0aGlzLl94b3IpIHtcbiAgICB0aGlzLl94b3IuZmluYWwoKVxuICAgIHRoaXMuX3hvciA9IG51bGxcbiAgfVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGRvIG5vdGhpbmcsIHVzZXIgYmFjay1wcmVzc3VyZXNcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fa2VlcEFsaXZlID0gMFxuICBpZiAodGhpcy5feG9yKSB0aGlzLl94b3IudXBkYXRlKGRhdGEsIGRhdGEpXG4gIHJldHVybiB0aGlzLnB1c2goZGF0YSlcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMsIGNiKSB7XG4gIHRoaXMuX3JlbW90ZUtlZXBBbGl2ZSA9IDBcbiAgdGhpcy5fcGFyc2UoZGF0YSwgMCwgY2IpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fZmVlZCA9IGZ1bmN0aW9uIChkaykge1xuICB2YXIgaGV4ID0gZGsudG9TdHJpbmcoJ2hleCcpXG4gIHZhciBjaCA9IHRoaXMuX2ZlZWRzW2hleF1cbiAgaWYgKGNoKSByZXR1cm4gY2hcbiAgY2ggPSB0aGlzLl9mZWVkc1toZXhdID0gZmVlZCh0aGlzKVxuICByZXR1cm4gY2hcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLnJlbW90ZVN1cHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGkgPSB0aGlzLmV4dGVuc2lvbnMuaW5kZXhPZihuYW1lKVxuICByZXR1cm4gaSA+IC0xICYmICEhdGhpcy5yZW1vdGVFeHRlbnNpb25zICYmIHRoaXMucmVtb3RlRXh0ZW5zaW9ucy5pbmRleE9mKGkpID4gLTFcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9vbmhhbmRzaGFrZSA9IGZ1bmN0aW9uIChoYW5kc2hha2UpIHtcbiAgaWYgKHRoaXMucmVtb3RlSWQpIHJldHVyblxuXG4gIHRoaXMucmVtb3RlSWQgPSBoYW5kc2hha2UuaWQgfHwgcmFuZG9tQnl0ZXMoMzIpXG4gIHRoaXMucmVtb3RlTGl2ZSA9IGhhbmRzaGFrZS5saXZlXG4gIHRoaXMucmVtb3RlVXNlckRhdGEgPSBoYW5kc2hha2UudXNlckRhdGFcbiAgdGhpcy5yZW1vdGVFeHRlbnNpb25zID0gaW5kZXhPZih0aGlzLmV4dGVuc2lvbnMsIGhhbmRzaGFrZS5leHRlbnNpb25zKVxuICB0aGlzLnJlbW90ZUFjayA9IGhhbmRzaGFrZS5hY2tcblxuICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fb25vcGVuID0gZnVuY3Rpb24gKGlkLCBkYXRhLCBzdGFydCwgZW5kKSB7XG4gIHZhciBmZWVkID0gZGVjb2RlRmVlZChkYXRhLCBzdGFydCwgZW5kKVxuXG4gIGlmICghZmVlZCkgcmV0dXJuIHRoaXMuX2JhZEZlZWQoKVxuXG4gIGlmICghdGhpcy5yZW1vdGVEaXNjb3ZlcnlLZXkpIHtcbiAgICB0aGlzLnJlbW90ZURpc2NvdmVyeUtleSA9IGZlZWQuZGlzY292ZXJ5S2V5XG4gICAgaWYgKCF0aGlzLl9zYW1lS2V5KCkpIHJldHVyblxuXG4gICAgaWYgKHRoaXMuZW5jcnlwdGVkICYmICF0aGlzLl9yZW1vdGVOb25jZSkge1xuICAgICAgaWYgKCFmZWVkLm5vbmNlKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ1JlbW90ZSBkaWQgbm90IGluY2x1ZGUgYSBub25jZScpKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbW90ZU5vbmNlID0gZmVlZC5ub25jZVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY3J5cHRlZCAmJiB0aGlzLmtleSAmJiAhdGhpcy5fcmVtb3RlWG9yKSB7XG4gICAgICB0aGlzLl9yZW1vdGVYb3IgPSBzb2RpdW0uY3J5cHRvX3N0cmVhbV94b3JfaW5zdGFuY2UodGhpcy5fcmVtb3RlTm9uY2UsIHRoaXMua2V5KVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3JlbW90ZUZlZWRzW2lkXSA9IHRoaXMuX2ZlZWQoZmVlZC5kaXNjb3ZlcnlLZXkpXG4gIGZlZWQucmVtb3RlSWQgPSBpZFxuXG4gIHRoaXMuZW1pdCgnZmVlZCcsIGZlZWQuZGlzY292ZXJ5S2V5KVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX29ubWVzc2FnZSA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgLSBzdGFydCA8IDIpIHJldHVyblxuXG4gIHZhciBoZWFkZXIgPSBkZWNvZGVIZWFkZXIoZGF0YSwgc3RhcnQpXG4gIGlmIChoZWFkZXIgPT09IC0xKSByZXR1cm4gdGhpcy5kZXN0cm95KG5ldyBFcnJvcignUmVtb3RlIHNlbnQgaW52YWxpZCBoZWFkZXInKSlcblxuICBzdGFydCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG5cbiAgdmFyIGlkID0gaGVhZGVyID4+IDRcbiAgdmFyIHR5cGUgPSBoZWFkZXIgJiAxNVxuXG4gIGlmIChpZCA+PSAxMjgpIHJldHVybiB0aGlzLl90b29NYW55RmVlZHMoKVxuICB3aGlsZSAodGhpcy5fcmVtb3RlRmVlZHMubGVuZ3RoIDwgaWQpIHRoaXMuX3JlbW90ZUZlZWRzLnB1c2gobnVsbClcblxuICB2YXIgY2ggPSB0aGlzLl9yZW1vdGVGZWVkc1tpZF1cblxuICBpZiAodHlwZSA9PT0gMCkge1xuICAgIGlmIChjaCkgY2guX29uY2xvc2UoKVxuICAgIHJldHVybiB0aGlzLl9vbm9wZW4oaWQsIGRhdGEsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICBpZiAoIWNoKSByZXR1cm4gdGhpcy5fYmFkRmVlZCgpXG4gIGlmICh0eXBlID09PSAxNSkgcmV0dXJuIGNoLl9vbmV4dGVuc2lvbihkYXRhLCBzdGFydCwgZW5kKVxuICBjaC5fb25tZXNzYWdlKHR5cGUsIGRhdGEsIHN0YXJ0LCBlbmQpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGNiKSB7XG4gIHZhciBkZWNyeXB0ZWQgPSAhIXRoaXMuX3JlbW90ZVhvclxuXG4gIGlmIChzdGFydCkge1xuICAgIGRhdGEgPSBkYXRhLnNsaWNlKHN0YXJ0KVxuICAgIHN0YXJ0ID0gMFxuICB9XG5cbiAgaWYgKHRoaXMuX3JlbW90ZVhvcikgdGhpcy5fcmVtb3RlWG9yLnVwZGF0ZShkYXRhLCBkYXRhKVxuXG4gIHdoaWxlIChzdGFydCA8IGRhdGEubGVuZ3RoICYmICF0aGlzLmRlc3Ryb3llZCkge1xuICAgIGlmICh0aGlzLl9taXNzaW5nKSBzdGFydCA9IHRoaXMuX3BhcnNlTWVzc2FnZShkYXRhLCBzdGFydClcbiAgICBlbHNlIHN0YXJ0ID0gdGhpcy5fcGFyc2VMZW5ndGgoZGF0YSwgc3RhcnQpXG5cbiAgICBpZiAodGhpcy5fbmVlZHNLZXkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgICB0aGlzLl9zdGFydCA9IHN0YXJ0XG4gICAgICB0aGlzLl9jYiA9IGNiXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWRlY3J5cHRlZCAmJiB0aGlzLl9yZW1vdGVYb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZShkYXRhLCBzdGFydCwgY2IpXG4gICAgfVxuICB9XG5cbiAgY2IoKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3BhcnNlTWVzc2FnZSA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCkge1xuICB2YXIgZW5kID0gc3RhcnQgKyB0aGlzLl9taXNzaW5nXG5cbiAgaWYgKGVuZCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIHZhciByZXQgPSBlbmRcblxuICAgIGlmICh0aGlzLl9idWYpIHtcbiAgICAgIGRhdGEuY29weSh0aGlzLl9idWYsIHRoaXMuX3BvaW50ZXIsIHN0YXJ0KVxuICAgICAgZGF0YSA9IHRoaXMuX2J1ZlxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSBkYXRhLmxlbmd0aFxuICAgICAgdGhpcy5fYnVmID0gbnVsbFxuICAgIH1cblxuICAgIHRoaXMuX21pc3NpbmcgPSAwXG4gICAgdGhpcy5fcG9pbnRlciA9IDBcbiAgICBpZiAodGhpcy5lbmNyeXB0ZWQgJiYgIXRoaXMua2V5KSB0aGlzLl9uZWVkc0tleSA9IHRydWVcbiAgICB0aGlzLl9vbm1lc3NhZ2UoZGF0YSwgc3RhcnQsIGVuZClcblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGlmICghdGhpcy5fYnVmKSB7XG4gICAgdGhpcy5fYnVmID0gYnVmZmVyQWxsb2ModGhpcy5fbWlzc2luZylcbiAgICB0aGlzLl9wb2ludGVyID0gMFxuICB9XG5cbiAgdmFyIHJlbSA9IGRhdGEubGVuZ3RoIC0gc3RhcnRcblxuICBkYXRhLmNvcHkodGhpcy5fYnVmLCB0aGlzLl9wb2ludGVyLCBzdGFydClcbiAgdGhpcy5fcG9pbnRlciArPSByZW1cbiAgdGhpcy5fbWlzc2luZyAtPSByZW1cblxuICByZXR1cm4gZGF0YS5sZW5ndGhcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9wYXJzZUxlbmd0aCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCkge1xuICB3aGlsZSAoIXRoaXMuX21pc3NpbmcgJiYgc3RhcnQgPCBkYXRhLmxlbmd0aCkge1xuICAgIHZhciBieXRlID0gdGhpcy5fbGVuZ3RoW3RoaXMuX3BvaW50ZXIrK10gPSBkYXRhW3N0YXJ0KytdXG5cbiAgICBpZiAoIShieXRlICYgMHg4MCkpIHtcbiAgICAgIHRoaXMuX21pc3NpbmcgPSB2YXJpbnQuZGVjb2RlKHRoaXMuX2xlbmd0aClcbiAgICAgIHRoaXMuX3BvaW50ZXIgPSAwXG4gICAgICBpZiAodGhpcy5fbWlzc2luZyA+IDgzODg2MDgpIHJldHVybiB0aGlzLl90b29CaWcoZGF0YS5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhcnRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcG9pbnRlciA+PSB0aGlzLl9sZW5ndGgubGVuZ3RoKSByZXR1cm4gdGhpcy5fdG9vQmlnKGRhdGEubGVuZ3RoKVxuICB9XG5cbiAgcmV0dXJuIHN0YXJ0XG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fc2FtZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmRpc2NvdmVyeUtleSB8fCAhdGhpcy5yZW1vdGVEaXNjb3ZlcnlLZXkpIHJldHVybiB0cnVlXG4gIGlmICh0aGlzLnJlbW90ZURpc2NvdmVyeUtleS50b1N0cmluZygnaGV4JykgPT09IHRoaXMuZGlzY292ZXJ5S2V5LnRvU3RyaW5nKCdoZXgnKSkgcmV0dXJuIHRydWVcbiAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignRmlyc3Qgc2hhcmVkIGh5cGVyY29yZSBtdXN0IGJlIHRoZSBzYW1lJykpXG4gIHJldHVybiBmYWxzZVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3Rvb01hbnlGZWVkcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignT25seSAxMjggZmVlZHMgY3VycmVudGx5IHN1cHBvcnRlZC4gT3BlbiBhIEdpdGh1YiBpc3N1ZSBpZiB5b3UgbmVlZCBtb3JlJykpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fdG9vQmlnID0gZnVuY3Rpb24gKGxlbikge1xuICB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdSZW1vdGUgbWVzc2FnZSBpcyBsYXJnZXIgdGhhbiA4TUIgKG1heCBhbGxvd2VkKScpKVxuICByZXR1cm4gbGVuXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fYmFkRmVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignUmVtb3RlIHNlbnQgaW52YWxpZCBmZWVkIG1lc3NhZ2UnKSlcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ1JlbW90ZSB0aW1lZCBvdXQnKSlcbn1cblxuZnVuY3Rpb24gZGVjb2RlSGVhZGVyIChkYXRhLCBzdGFydCkge1xuICB0cnkge1xuICAgIHJldHVybiB2YXJpbnQuZGVjb2RlKGRhdGEsIHN0YXJ0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNvZGVGZWVkIChkYXRhLCBzdGFydCwgZW5kKSB7XG4gIHZhciBmZWVkID0gbnVsbFxuXG4gIHRyeSB7XG4gICAgZmVlZCA9IG1lc3NhZ2VzLkZlZWQuZGVjb2RlKGRhdGEsIHN0YXJ0LCBlbmQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAoZmVlZC5kaXNjb3ZlcnlLZXkubGVuZ3RoICE9PSAzMikgcmV0dXJuIG51bGxcbiAgaWYgKGZlZWQubm9uY2UgJiYgZmVlZC5ub25jZS5sZW5ndGggIT09IDI0KSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBmZWVkXG59XG5cbmZ1bmN0aW9uIGVuY29kZUZlZWQgKGZlZWQsIGlkKSB7XG4gIHZhciBoZWFkZXIgPSBpZCA8PCA0XG4gIHZhciBsZW4gPSB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoaGVhZGVyKSArIG1lc3NhZ2VzLkZlZWQuZW5jb2RpbmdMZW5ndGgoZmVlZClcbiAgdmFyIGJveCA9IGJ1ZmZlckFsbG9jKHZhcmludC5lbmNvZGluZ0xlbmd0aChsZW4pICsgbGVuKVxuICB2YXIgb2Zmc2V0ID0gMFxuXG4gIHZhcmludC5lbmNvZGUobGVuLCBib3gsIG9mZnNldClcbiAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcblxuICB2YXJpbnQuZW5jb2RlKGhlYWRlciwgYm94LCBvZmZzZXQpXG4gIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG5cbiAgbWVzc2FnZXMuRmVlZC5lbmNvZGUoZmVlZCwgYm94LCBvZmZzZXQpXG4gIHJldHVybiBib3hcbn1cblxuZnVuY3Rpb24gZGlzY292ZXJ5S2V5IChrZXkpIHtcbiAgdmFyIGJ1ZiA9IGJ1ZmZlckFsbG9jKDMyKVxuICBzb2RpdW0uY3J5cHRvX2dlbmVyaWNoYXNoKGJ1ZiwgYnVmZmVyRnJvbSgnaHlwZXJjb3JlJyksIGtleSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiByYW5kb21CeXRlcyAobikge1xuICB2YXIgYnVmID0gYnVmZmVyQWxsb2MobilcbiAgc29kaXVtLnJhbmRvbWJ5dGVzX2J1ZihidWYpXG4gIHJldHVybiBidWZcbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBhdXRvIGdlbmVyYXRlZCBieSB0aGUgcHJvdG9jb2wtYnVmZmVycyBjbGkgdG9vbFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBxdW90ZXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG5cbi8vIFJlbWVtYmVyIHRvIGBucG0gaW5zdGFsbCAtLXNhdmUgcHJvdG9jb2wtYnVmZmVycy1lbmNvZGluZ3NgXG52YXIgZW5jb2RpbmdzID0gcmVxdWlyZSgncHJvdG9jb2wtYnVmZmVycy1lbmNvZGluZ3MnKVxudmFyIHZhcmludCA9IGVuY29kaW5ncy52YXJpbnRcbnZhciBza2lwID0gZW5jb2RpbmdzLnNraXBcblxudmFyIEZlZWQgPSBleHBvcnRzLkZlZWQgPSB7XG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gIGVuY29kZTogbnVsbCxcbiAgZGVjb2RlOiBudWxsXG59XG5cbnZhciBIYW5kc2hha2UgPSBleHBvcnRzLkhhbmRzaGFrZSA9IHtcbiAgYnVmZmVyOiB0cnVlLFxuICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgZW5jb2RlOiBudWxsLFxuICBkZWNvZGU6IG51bGxcbn1cblxudmFyIEluZm8gPSBleHBvcnRzLkluZm8gPSB7XG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gIGVuY29kZTogbnVsbCxcbiAgZGVjb2RlOiBudWxsXG59XG5cbnZhciBIYXZlID0gZXhwb3J0cy5IYXZlID0ge1xuICBidWZmZXI6IHRydWUsXG4gIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICBlbmNvZGU6IG51bGwsXG4gIGRlY29kZTogbnVsbFxufVxuXG52YXIgVW5oYXZlID0gZXhwb3J0cy5VbmhhdmUgPSB7XG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gIGVuY29kZTogbnVsbCxcbiAgZGVjb2RlOiBudWxsXG59XG5cbnZhciBXYW50ID0gZXhwb3J0cy5XYW50ID0ge1xuICBidWZmZXI6IHRydWUsXG4gIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICBlbmNvZGU6IG51bGwsXG4gIGRlY29kZTogbnVsbFxufVxuXG52YXIgVW53YW50ID0gZXhwb3J0cy5VbndhbnQgPSB7XG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gIGVuY29kZTogbnVsbCxcbiAgZGVjb2RlOiBudWxsXG59XG5cbnZhciBSZXF1ZXN0ID0gZXhwb3J0cy5SZXF1ZXN0ID0ge1xuICBidWZmZXI6IHRydWUsXG4gIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICBlbmNvZGU6IG51bGwsXG4gIGRlY29kZTogbnVsbFxufVxuXG52YXIgQ2FuY2VsID0gZXhwb3J0cy5DYW5jZWwgPSB7XG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gIGVuY29kZTogbnVsbCxcbiAgZGVjb2RlOiBudWxsXG59XG5cbnZhciBEYXRhID0gZXhwb3J0cy5EYXRhID0ge1xuICBidWZmZXI6IHRydWUsXG4gIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICBlbmNvZGU6IG51bGwsXG4gIGRlY29kZTogbnVsbFxufVxuXG5kZWZpbmVGZWVkKClcbmRlZmluZUhhbmRzaGFrZSgpXG5kZWZpbmVJbmZvKClcbmRlZmluZUhhdmUoKVxuZGVmaW5lVW5oYXZlKClcbmRlZmluZVdhbnQoKVxuZGVmaW5lVW53YW50KClcbmRlZmluZVJlcXVlc3QoKVxuZGVmaW5lQ2FuY2VsKClcbmRlZmluZURhdGEoKVxuXG5mdW5jdGlvbiBkZWZpbmVGZWVkICgpIHtcbiAgdmFyIGVuYyA9IFtcbiAgICBlbmNvZGluZ3MuYnl0ZXNcbiAgXVxuXG4gIEZlZWQuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICBGZWVkLmVuY29kZSA9IGVuY29kZVxuICBGZWVkLmRlY29kZSA9IGRlY29kZVxuXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmICghZGVmaW5lZChvYmouZGlzY292ZXJ5S2V5KSkgdGhyb3cgbmV3IEVycm9yKFwiZGlzY292ZXJ5S2V5IGlzIHJlcXVpcmVkXCIpXG4gICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouZGlzY292ZXJ5S2V5KVxuICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgaWYgKGRlZmluZWQob2JqLm5vbmNlKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmoubm9uY2UpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgaWYgKCFkZWZpbmVkKG9iai5kaXNjb3ZlcnlLZXkpKSB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjb3ZlcnlLZXkgaXMgcmVxdWlyZWRcIilcbiAgICBidWZbb2Zmc2V0KytdID0gMTBcbiAgICBlbmNbMF0uZW5jb2RlKG9iai5kaXNjb3ZlcnlLZXksIGJ1Ziwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgaWYgKGRlZmluZWQob2JqLm5vbmNlKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDE4XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5ub25jZSwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmogPSB7XG4gICAgICBkaXNjb3ZlcnlLZXk6IG51bGwsXG4gICAgICBub25jZTogbnVsbFxuICAgIH1cbiAgICB2YXIgZm91bmQwID0gZmFsc2VcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFmb3VuZDApIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBvYmouZGlzY292ZXJ5S2V5ID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgZm91bmQwID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIG9iai5ub25jZSA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUhhbmRzaGFrZSAoKSB7XG4gIHZhciBlbmMgPSBbXG4gICAgZW5jb2RpbmdzLmJ5dGVzLFxuICAgIGVuY29kaW5ncy5ib29sLFxuICAgIGVuY29kaW5ncy5zdHJpbmdcbiAgXVxuXG4gIEhhbmRzaGFrZS5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gIEhhbmRzaGFrZS5lbmNvZGUgPSBlbmNvZGVcbiAgSGFuZHNoYWtlLmRlY29kZSA9IGRlY29kZVxuXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmIChkZWZpbmVkKG9iai5pZCkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmlkKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmxpdmUpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzFdLmVuY29kaW5nTGVuZ3RoKG9iai5saXZlKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLnVzZXJEYXRhKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmoudXNlckRhdGEpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouZXh0ZW5zaW9ucykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFkZWZpbmVkKG9iai5leHRlbnNpb25zW2ldKSkgY29udGludWVcbiAgICAgICAgdmFyIGxlbiA9IGVuY1syXS5lbmNvZGluZ0xlbmd0aChvYmouZXh0ZW5zaW9uc1tpXSlcbiAgICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmFjaykpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMV0uZW5jb2RpbmdMZW5ndGgob2JqLmFjaylcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICBpZiAoZGVmaW5lZChvYmouaWQpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMTBcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLmlkLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5saXZlKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDE2XG4gICAgICBlbmNbMV0uZW5jb2RlKG9iai5saXZlLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMV0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai51c2VyRGF0YSkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAyNlxuICAgICAgZW5jWzBdLmVuY29kZShvYmoudXNlckRhdGEsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmV4dGVuc2lvbnMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5leHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZGVmaW5lZChvYmouZXh0ZW5zaW9uc1tpXSkpIGNvbnRpbnVlXG4gICAgICAgIGJ1ZltvZmZzZXQrK10gPSAzNFxuICAgICAgICBlbmNbMl0uZW5jb2RlKG9iai5leHRlbnNpb25zW2ldLCBidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1syXS5lbmNvZGUuYnl0ZXNcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmFjaykpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSA0MFxuICAgICAgZW5jWzFdLmVuY29kZShvYmouYWNrLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMV0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGlkOiBudWxsLFxuICAgICAgbGl2ZTogZmFsc2UsXG4gICAgICB1c2VyRGF0YTogbnVsbCxcbiAgICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgICAgYWNrOiBmYWxzZVxuICAgIH1cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBvYmouaWQgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIG9iai5saXZlID0gZW5jWzFdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBvYmoudXNlckRhdGEgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIG9iai5leHRlbnNpb25zLnB1c2goZW5jWzJdLmRlY29kZShidWYsIG9mZnNldCkpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMl0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgb2JqLmFjayA9IGVuY1sxXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMV0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUluZm8gKCkge1xuICB2YXIgZW5jID0gW1xuICAgIGVuY29kaW5ncy5ib29sXG4gIF1cblxuICBJbmZvLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgSW5mby5lbmNvZGUgPSBlbmNvZGVcbiAgSW5mby5kZWNvZGUgPSBkZWNvZGVcblxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoZGVmaW5lZChvYmoudXBsb2FkaW5nKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmoudXBsb2FkaW5nKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmRvd25sb2FkaW5nKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouZG93bmxvYWRpbmcpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgaWYgKGRlZmluZWQob2JqLnVwbG9hZGluZykpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSA4XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai51cGxvYWRpbmcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmRvd25sb2FkaW5nKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDE2XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5kb3dubG9hZGluZywgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmogPSB7XG4gICAgICB1cGxvYWRpbmc6IGZhbHNlLFxuICAgICAgZG93bmxvYWRpbmc6IGZhbHNlXG4gICAgfVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIG9iai51cGxvYWRpbmcgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIG9iai5kb3dubG9hZGluZyA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUhhdmUgKCkge1xuICB2YXIgZW5jID0gW1xuICAgIGVuY29kaW5ncy52YXJpbnQsXG4gICAgZW5jb2RpbmdzLmJ5dGVzXG4gIF1cblxuICBIYXZlLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgSGF2ZS5lbmNvZGUgPSBlbmNvZGVcbiAgSGF2ZS5kZWNvZGUgPSBkZWNvZGVcblxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoIWRlZmluZWQob2JqLnN0YXJ0KSkgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQgaXMgcmVxdWlyZWRcIilcbiAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5zdGFydClcbiAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIGlmIChkZWZpbmVkKG9iai5sZW5ndGgpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5sZW5ndGgpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouYml0ZmllbGQpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzFdLmVuY29kaW5nTGVuZ3RoKG9iai5iaXRmaWVsZClcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICBpZiAoIWRlZmluZWQob2JqLnN0YXJ0KSkgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQgaXMgcmVxdWlyZWRcIilcbiAgICBidWZbb2Zmc2V0KytdID0gOFxuICAgIGVuY1swXS5lbmNvZGUob2JqLnN0YXJ0LCBidWYsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIGlmIChkZWZpbmVkKG9iai5sZW5ndGgpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMTZcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLmxlbmd0aCwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouYml0ZmllbGQpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMjZcbiAgICAgIGVuY1sxXS5lbmNvZGUob2JqLmJpdGZpZWxkLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMV0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgbGVuZ3RoOiAxLFxuICAgICAgYml0ZmllbGQ6IG51bGxcbiAgICB9XG4gICAgdmFyIGZvdW5kMCA9IGZhbHNlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgIGlmICghZm91bmQwKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgb2JqLnN0YXJ0ID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgZm91bmQwID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIG9iai5sZW5ndGggPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIG9iai5iaXRmaWVsZCA9IGVuY1sxXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMV0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVVuaGF2ZSAoKSB7XG4gIHZhciBlbmMgPSBbXG4gICAgZW5jb2RpbmdzLnZhcmludFxuICBdXG5cbiAgVW5oYXZlLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgVW5oYXZlLmVuY29kZSA9IGVuY29kZVxuICBVbmhhdmUuZGVjb2RlID0gZGVjb2RlXG5cbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgIHZhciBsZW5ndGggPSAwXG4gICAgaWYgKCFkZWZpbmVkKG9iai5zdGFydCkpIHRocm93IG5ldyBFcnJvcihcInN0YXJ0IGlzIHJlcXVpcmVkXCIpXG4gICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouc3RhcnQpXG4gICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICBpZiAoZGVmaW5lZChvYmoubGVuZ3RoKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmoubGVuZ3RoKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIGlmICghZGVmaW5lZChvYmouc3RhcnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCBpcyByZXF1aXJlZFwiKVxuICAgIGJ1ZltvZmZzZXQrK10gPSA4XG4gICAgZW5jWzBdLmVuY29kZShvYmouc3RhcnQsIGJ1Ziwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgaWYgKGRlZmluZWQob2JqLmxlbmd0aCkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxNlxuICAgICAgZW5jWzBdLmVuY29kZShvYmoubGVuZ3RoLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgbGVuZ3RoOiAxXG4gICAgfVxuICAgIHZhciBmb3VuZDAgPSBmYWxzZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICBpZiAoIWZvdW5kMCkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIG9iai5zdGFydCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGZvdW5kMCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBvYmoubGVuZ3RoID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lV2FudCAoKSB7XG4gIHZhciBlbmMgPSBbXG4gICAgZW5jb2RpbmdzLnZhcmludFxuICBdXG5cbiAgV2FudC5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gIFdhbnQuZW5jb2RlID0gZW5jb2RlXG4gIFdhbnQuZGVjb2RlID0gZGVjb2RlXG5cbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgIHZhciBsZW5ndGggPSAwXG4gICAgaWYgKCFkZWZpbmVkKG9iai5zdGFydCkpIHRocm93IG5ldyBFcnJvcihcInN0YXJ0IGlzIHJlcXVpcmVkXCIpXG4gICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouc3RhcnQpXG4gICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICBpZiAoZGVmaW5lZChvYmoubGVuZ3RoKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmoubGVuZ3RoKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIGlmICghZGVmaW5lZChvYmouc3RhcnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCBpcyByZXF1aXJlZFwiKVxuICAgIGJ1ZltvZmZzZXQrK10gPSA4XG4gICAgZW5jWzBdLmVuY29kZShvYmouc3RhcnQsIGJ1Ziwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgaWYgKGRlZmluZWQob2JqLmxlbmd0aCkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxNlxuICAgICAgZW5jWzBdLmVuY29kZShvYmoubGVuZ3RoLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgbGVuZ3RoOiAwXG4gICAgfVxuICAgIHZhciBmb3VuZDAgPSBmYWxzZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICBpZiAoIWZvdW5kMCkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIG9iai5zdGFydCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGZvdW5kMCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBvYmoubGVuZ3RoID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lVW53YW50ICgpIHtcbiAgdmFyIGVuYyA9IFtcbiAgICBlbmNvZGluZ3MudmFyaW50XG4gIF1cblxuICBVbndhbnQuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICBVbndhbnQuZW5jb2RlID0gZW5jb2RlXG4gIFVud2FudC5kZWNvZGUgPSBkZWNvZGVcblxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoIWRlZmluZWQob2JqLnN0YXJ0KSkgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQgaXMgcmVxdWlyZWRcIilcbiAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5zdGFydClcbiAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIGlmIChkZWZpbmVkKG9iai5sZW5ndGgpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5sZW5ndGgpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgaWYgKCFkZWZpbmVkKG9iai5zdGFydCkpIHRocm93IG5ldyBFcnJvcihcInN0YXJ0IGlzIHJlcXVpcmVkXCIpXG4gICAgYnVmW29mZnNldCsrXSA9IDhcbiAgICBlbmNbMF0uZW5jb2RlKG9iai5zdGFydCwgYnVmLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICBpZiAoZGVmaW5lZChvYmoubGVuZ3RoKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDE2XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5sZW5ndGgsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBsZW5ndGg6IDBcbiAgICB9XG4gICAgdmFyIGZvdW5kMCA9IGZhbHNlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgIGlmICghZm91bmQwKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgb2JqLnN0YXJ0ID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgZm91bmQwID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIG9iai5sZW5ndGggPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZXF1ZXN0ICgpIHtcbiAgdmFyIGVuYyA9IFtcbiAgICBlbmNvZGluZ3MudmFyaW50LFxuICAgIGVuY29kaW5ncy5ib29sXG4gIF1cblxuICBSZXF1ZXN0LmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgUmVxdWVzdC5lbmNvZGUgPSBlbmNvZGVcbiAgUmVxdWVzdC5kZWNvZGUgPSBkZWNvZGVcblxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoIWRlZmluZWQob2JqLmluZGV4KSkgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgcmVxdWlyZWRcIilcbiAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5pbmRleClcbiAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIGlmIChkZWZpbmVkKG9iai5ieXRlcykpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmJ5dGVzKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmhhc2gpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzFdLmVuY29kaW5nTGVuZ3RoKG9iai5oYXNoKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLm5vZGVzKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmoubm9kZXMpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgaWYgKCFkZWZpbmVkKG9iai5pbmRleCkpIHRocm93IG5ldyBFcnJvcihcImluZGV4IGlzIHJlcXVpcmVkXCIpXG4gICAgYnVmW29mZnNldCsrXSA9IDhcbiAgICBlbmNbMF0uZW5jb2RlKG9iai5pbmRleCwgYnVmLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICBpZiAoZGVmaW5lZChvYmouYnl0ZXMpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMTZcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLmJ5dGVzLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5oYXNoKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDI0XG4gICAgICBlbmNbMV0uZW5jb2RlKG9iai5oYXNoLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMV0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5ub2RlcykpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAzMlxuICAgICAgZW5jWzBdLmVuY29kZShvYmoubm9kZXMsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge1xuICAgICAgaW5kZXg6IDAsXG4gICAgICBieXRlczogMCxcbiAgICAgIGhhc2g6IGZhbHNlLFxuICAgICAgbm9kZXM6IDBcbiAgICB9XG4gICAgdmFyIGZvdW5kMCA9IGZhbHNlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgIGlmICghZm91bmQwKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgb2JqLmluZGV4ID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgZm91bmQwID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIG9iai5ieXRlcyA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgb2JqLmhhc2ggPSBlbmNbMV0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzFdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIG9iai5ub2RlcyA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNhbmNlbCAoKSB7XG4gIHZhciBlbmMgPSBbXG4gICAgZW5jb2RpbmdzLnZhcmludCxcbiAgICBlbmNvZGluZ3MuYm9vbFxuICBdXG5cbiAgQ2FuY2VsLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgQ2FuY2VsLmVuY29kZSA9IGVuY29kZVxuICBDYW5jZWwuZGVjb2RlID0gZGVjb2RlXG5cbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgIHZhciBsZW5ndGggPSAwXG4gICAgaWYgKCFkZWZpbmVkKG9iai5pbmRleCkpIHRocm93IG5ldyBFcnJvcihcImluZGV4IGlzIHJlcXVpcmVkXCIpXG4gICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouaW5kZXgpXG4gICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICBpZiAoZGVmaW5lZChvYmouYnl0ZXMpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5ieXRlcylcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5oYXNoKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1sxXS5lbmNvZGluZ0xlbmd0aChvYmouaGFzaClcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICBpZiAoIWRlZmluZWQob2JqLmluZGV4KSkgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgcmVxdWlyZWRcIilcbiAgICBidWZbb2Zmc2V0KytdID0gOFxuICAgIGVuY1swXS5lbmNvZGUob2JqLmluZGV4LCBidWYsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIGlmIChkZWZpbmVkKG9iai5ieXRlcykpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxNlxuICAgICAgZW5jWzBdLmVuY29kZShvYmouYnl0ZXMsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmhhc2gpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMjRcbiAgICAgIGVuY1sxXS5lbmNvZGUob2JqLmhhc2gsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge1xuICAgICAgaW5kZXg6IDAsXG4gICAgICBieXRlczogMCxcbiAgICAgIGhhc2g6IGZhbHNlXG4gICAgfVxuICAgIHZhciBmb3VuZDAgPSBmYWxzZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICBpZiAoIWZvdW5kMCkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIG9iai5pbmRleCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGZvdW5kMCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBvYmouYnl0ZXMgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIG9iai5oYXNoID0gZW5jWzFdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lRGF0YSAoKSB7XG4gIHZhciBOb2RlID0gRGF0YS5Ob2RlID0ge1xuICAgIGJ1ZmZlcjogdHJ1ZSxcbiAgICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgICBlbmNvZGU6IG51bGwsXG4gICAgZGVjb2RlOiBudWxsXG4gIH1cblxuICBkZWZpbmVOb2RlKClcblxuICBmdW5jdGlvbiBkZWZpbmVOb2RlICgpIHtcbiAgICB2YXIgZW5jID0gW1xuICAgICAgZW5jb2RpbmdzLnZhcmludCxcbiAgICAgIGVuY29kaW5ncy5ieXRlc1xuICAgIF1cblxuICAgIE5vZGUuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICAgIE5vZGUuZW5jb2RlID0gZW5jb2RlXG4gICAgTm9kZS5kZWNvZGUgPSBkZWNvZGVcblxuICAgIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSAwXG4gICAgICBpZiAoIWRlZmluZWQob2JqLmluZGV4KSkgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgcmVxdWlyZWRcIilcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmluZGV4KVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICAgIGlmICghZGVmaW5lZChvYmouaGFzaCkpIHRocm93IG5ldyBFcnJvcihcImhhc2ggaXMgcmVxdWlyZWRcIilcbiAgICAgIHZhciBsZW4gPSBlbmNbMV0uZW5jb2RpbmdMZW5ndGgob2JqLmhhc2gpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgICAgaWYgKCFkZWZpbmVkKG9iai5zaXplKSkgdGhyb3cgbmV3IEVycm9yKFwic2l6ZSBpcyByZXF1aXJlZFwiKVxuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouc2l6ZSlcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgICByZXR1cm4gbGVuZ3RoXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgICAgaWYgKCFkZWZpbmVkKG9iai5pbmRleCkpIHRocm93IG5ldyBFcnJvcihcImluZGV4IGlzIHJlcXVpcmVkXCIpXG4gICAgICBidWZbb2Zmc2V0KytdID0gOFxuICAgICAgZW5jWzBdLmVuY29kZShvYmouaW5kZXgsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICAgIGlmICghZGVmaW5lZChvYmouaGFzaCkpIHRocm93IG5ldyBFcnJvcihcImhhc2ggaXMgcmVxdWlyZWRcIilcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxOFxuICAgICAgZW5jWzFdLmVuY29kZShvYmouaGFzaCwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzFdLmVuY29kZS5ieXRlc1xuICAgICAgaWYgKCFkZWZpbmVkKG9iai5zaXplKSkgdGhyb3cgbmV3IEVycm9yKFwic2l6ZSBpcyByZXF1aXJlZFwiKVxuICAgICAgYnVmW29mZnNldCsrXSA9IDI0XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5zaXplLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgaGFzaDogbnVsbCxcbiAgICAgICAgc2l6ZTogMFxuICAgICAgfVxuICAgICAgdmFyIGZvdW5kMCA9IGZhbHNlXG4gICAgICB2YXIgZm91bmQxID0gZmFsc2VcbiAgICAgIHZhciBmb3VuZDIgPSBmYWxzZVxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICBpZiAoIWZvdW5kMCB8fCAhZm91bmQxIHx8ICFmb3VuZDIpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBvYmouaW5kZXggPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgICAgZm91bmQwID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG9iai5oYXNoID0gZW5jWzFdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgICBvZmZzZXQgKz0gZW5jWzFdLmRlY29kZS5ieXRlc1xuICAgICAgICAgIGZvdW5kMSA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBvYmouc2l6ZSA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgICBmb3VuZDIgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZW5jID0gW1xuICAgIGVuY29kaW5ncy52YXJpbnQsXG4gICAgZW5jb2RpbmdzLmJ5dGVzLFxuICAgIE5vZGVcbiAgXVxuXG4gIERhdGEuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICBEYXRhLmVuY29kZSA9IGVuY29kZVxuICBEYXRhLmRlY29kZSA9IGRlY29kZVxuXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmICghZGVmaW5lZChvYmouaW5kZXgpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyByZXF1aXJlZFwiKVxuICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmluZGV4KVxuICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgaWYgKGRlZmluZWQob2JqLnZhbHVlKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1sxXS5lbmNvZGluZ0xlbmd0aChvYmoudmFsdWUpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmoubm9kZXMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWRlZmluZWQob2JqLm5vZGVzW2ldKSkgY29udGludWVcbiAgICAgICAgdmFyIGxlbiA9IGVuY1syXS5lbmNvZGluZ0xlbmd0aChvYmoubm9kZXNbaV0pXG4gICAgICAgIGxlbmd0aCArPSB2YXJpbnQuZW5jb2RpbmdMZW5ndGgobGVuKVxuICAgICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouc2lnbmF0dXJlKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1sxXS5lbmNvZGluZ0xlbmd0aChvYmouc2lnbmF0dXJlKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIGlmICghZGVmaW5lZChvYmouaW5kZXgpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyByZXF1aXJlZFwiKVxuICAgIGJ1ZltvZmZzZXQrK10gPSA4XG4gICAgZW5jWzBdLmVuY29kZShvYmouaW5kZXgsIGJ1Ziwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgaWYgKGRlZmluZWQob2JqLnZhbHVlKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDE4XG4gICAgICBlbmNbMV0uZW5jb2RlKG9iai52YWx1ZSwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzFdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmoubm9kZXMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWRlZmluZWQob2JqLm5vZGVzW2ldKSkgY29udGludWVcbiAgICAgICAgYnVmW29mZnNldCsrXSA9IDI2XG4gICAgICAgIHZhcmludC5lbmNvZGUoZW5jWzJdLmVuY29kaW5nTGVuZ3RoKG9iai5ub2Rlc1tpXSksIGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuICAgICAgICBlbmNbMl0uZW5jb2RlKG9iai5ub2Rlc1tpXSwgYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMl0uZW5jb2RlLmJ5dGVzXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5zaWduYXR1cmUpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMzRcbiAgICAgIGVuY1sxXS5lbmNvZGUob2JqLnNpZ25hdHVyZSwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzFdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmogPSB7XG4gICAgICBpbmRleDogMCxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgbm9kZXM6IFtdLFxuICAgICAgc2lnbmF0dXJlOiBudWxsXG4gICAgfVxuICAgIHZhciBmb3VuZDAgPSBmYWxzZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICBpZiAoIWZvdW5kMCkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIG9iai5pbmRleCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGZvdW5kMCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBvYmoudmFsdWUgPSBlbmNbMV0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzFdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIHZhciBsZW4gPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgICBvYmoubm9kZXMucHVzaChlbmNbMl0uZGVjb2RlKGJ1Ziwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pKVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzJdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIG9iai5zaWduYXR1cmUgPSBlbmNbMV0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzFdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVkICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicgfHwgIWlzTmFOKHZhbCkpXG59XG4iLCJ2YXIgZXF1YWxzID0gcmVxdWlyZSgnYnVmZmVyLWVxdWFscycpXG52YXIgbG93ID0gcmVxdWlyZSgnbGFzdC1vbmUtd2lucycpXG52YXIgcmVtb3ZlID0gcmVxdWlyZSgndW5vcmRlcmVkLWFycmF5LXJlbW92ZScpXG52YXIgc2V0ID0gcmVxdWlyZSgndW5vcmRlcmVkLXNldCcpXG52YXIgbWVya2xlID0gcmVxdWlyZSgnbWVya2xlLXRyZWUtc3RyZWFtL2dlbmVyYXRvcicpXG52YXIgZmxhdCA9IHJlcXVpcmUoJ2ZsYXQtdHJlZScpXG52YXIgYnVsayA9IHJlcXVpcmUoJ2J1bGstd3JpdGUtc3RyZWFtJylcbnZhciBmcm9tID0gcmVxdWlyZSgnZnJvbTInKVxudmFyIGNvZGVjcyA9IHJlcXVpcmUoJ2NvZGVjcycpXG52YXIgdGh1bmt5ID0gcmVxdWlyZSgndGh1bmt5JylcbnZhciBiYXRjaGVyID0gcmVxdWlyZSgnYXRvbWljLWJhdGNoZXInKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpXG52YXIgcmFmID0gcmVxdWlyZSgncmFuZG9tLWFjY2Vzcy1maWxlJylcbnZhciBiaXRmaWVsZCA9IHJlcXVpcmUoJy4vbGliL2JpdGZpZWxkJylcbnZhciBzcGFyc2VCaXRmaWVsZCA9IHJlcXVpcmUoJ3NwYXJzZS1iaXRmaWVsZCcpXG52YXIgdHJlZUluZGV4ID0gcmVxdWlyZSgnLi9saWIvdHJlZS1pbmRleCcpXG52YXIgc3RvcmFnZSA9IHJlcXVpcmUoJy4vbGliL3N0b3JhZ2UnKVxudmFyIGNyeXB0byA9IHJlcXVpcmUoJy4vbGliL2NyeXB0bycpXG52YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpXG52YXIgYnVmZmVyRnJvbSA9IHJlcXVpcmUoJ2J1ZmZlci1mcm9tJylcbnZhciBidWZmZXJBbGxvYyA9IHJlcXVpcmUoJ2J1ZmZlci1hbGxvYy11bnNhZmUnKVxudmFyIHJlcGxpY2F0ZSA9IG51bGxcblxubW9kdWxlLmV4cG9ydHMgPSBGZWVkXG5cbmZ1bmN0aW9uIEZlZWQgKGNyZWF0ZVN0b3JhZ2UsIGtleSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmVlZCkpIHJldHVybiBuZXcgRmVlZChjcmVhdGVTdG9yYWdlLCBrZXksIG9wdHMpXG4gIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuXG4gIGlmICh0eXBlb2YgY3JlYXRlU3RvcmFnZSA9PT0gJ3N0cmluZycpIGNyZWF0ZVN0b3JhZ2UgPSBkZWZhdWx0U3RvcmFnZShjcmVhdGVTdG9yYWdlKVxuICBpZiAodHlwZW9mIGNyZWF0ZVN0b3JhZ2UgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignU3RvcmFnZSBzaG91bGQgYmUgYSBmdW5jdGlvbiBvciBzdHJpbmcnKVxuXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykga2V5ID0gYnVmZmVyRnJvbShrZXksICdoZXgnKVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGtleSkgJiYgIW9wdHMpIHtcbiAgICBvcHRzID0ga2V5XG4gICAga2V5ID0gbnVsbFxuICB9XG5cbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIgc2VjcmV0S2V5ID0gb3B0cy5zZWNyZXRLZXkgfHwgbnVsbFxuICBpZiAodHlwZW9mIHNlY3JldEtleSA9PT0gJ3N0cmluZycpIHNlY3JldEtleSA9IGJ1ZmZlckZyb20oc2VjcmV0S2V5LCAnaGV4JylcblxuICB0aGlzLmlkID0gb3B0cy5pZCB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpXG4gIHRoaXMubGl2ZSA9IG9wdHMubGl2ZSAhPT0gZmFsc2VcbiAgdGhpcy5zcGFyc2UgPSAhIW9wdHMuc3BhcnNlXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLmJ5dGVMZW5ndGggPSAwXG4gIHRoaXMubWF4UmVxdWVzdHMgPSBvcHRzLm1heFJlcXVlc3RzIHx8IDE2XG4gIHRoaXMua2V5ID0ga2V5IHx8IG51bGxcbiAgdGhpcy5kaXNjb3ZlcnlLZXkgPSB0aGlzLmtleSAmJiBjcnlwdG8uZGlzY292ZXJ5S2V5KHRoaXMua2V5KVxuICB0aGlzLnNlY3JldEtleSA9IHNlY3JldEtleVxuICB0aGlzLmJpdGZpZWxkID0gbnVsbFxuICB0aGlzLnRyZWUgPSBudWxsXG4gIHRoaXMud3JpdGFibGUgPSAhIW9wdHMud3JpdGFibGVcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWVcbiAgdGhpcy5vcGVuZWQgPSBmYWxzZVxuICB0aGlzLmNsb3NlZCA9IGZhbHNlXG4gIHRoaXMuYWxsb3dQdXNoID0gISFvcHRzLmFsbG93UHVzaFxuICB0aGlzLnBlZXJzID0gW11cblxuICAvLyBob29rc1xuICB0aGlzLl9vbndyaXRlID0gb3B0cy5vbndyaXRlIHx8IG51bGxcblxuICB0aGlzLl9yZWFkeSA9IHRodW5reShvcGVuKSAvLyBUT0RPOiBpZiBvcGVuIGZhaWxzLCBkbyBub3QgcmVvcGVuIG5leHQgdGltZVxuICB0aGlzLl9pbmRleGluZyA9ICEhb3B0cy5pbmRleGluZ1xuICB0aGlzLl9jcmVhdGVJZk1pc3NpbmcgPSBvcHRzLmNyZWF0ZUlmTWlzc2luZyAhPT0gZmFsc2VcbiAgdGhpcy5fb3ZlcndyaXRlID0gISFvcHRzLm92ZXJ3cml0ZVxuICB0aGlzLl9zdG9yZVNlY3JldEtleSA9IG9wdHMuc3RvcmVTZWNyZXRLZXkgIT09IGZhbHNlXG4gIHRoaXMuX21lcmtsZSA9IG51bGxcbiAgdGhpcy5fc3RvcmFnZSA9IHN0b3JhZ2UoY3JlYXRlU3RvcmFnZSwgb3B0cy5zdG9yYWdlQ2FjaGVTaXplKVxuICB0aGlzLl9iYXRjaCA9IGJhdGNoZXIodGhpcy5fb253cml0ZSA/IHdvcmtIb29rIDogd29yaylcblxuICB0aGlzLl93YWl0aW5nID0gW11cbiAgdGhpcy5fc2VsZWN0aW9ucyA9IFtdXG4gIHRoaXMuX3Jlc2VydmVkID0gc3BhcnNlQml0ZmllbGQoKVxuICB0aGlzLl9zeW5jZWQgPSBudWxsXG5cbiAgdGhpcy5fY29kZWMgPSB0b0NvZGVjKG9wdHMudmFsdWVFbmNvZGluZylcbiAgdGhpcy5fc3luYyA9IGxvdyhzeW5jKVxuICBpZiAoIXRoaXMuc3BhcnNlKSB0aGlzLmRvd25sb2FkKHtzdGFydDogMCwgZW5kOiAtMX0pXG5cbiAgLy8gb3BlbiBpdCByaWdodCBhd2F5LiBUT0RPOiBkbyBub3QgcmVvcGVuIChpLmUsIHNldCBhIGZsYWcgbm90IHRvIHJldHJ5KVxuICB0aGlzLl9yZWFkeShvbmVycm9yKVxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IgKGVycikge1xuICAgIGlmIChlcnIpIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cblxuICBmdW5jdGlvbiB3b3JrSG9vayAodmFsdWVzLCBjYikge1xuICAgIHNlbGYuX2FwcGVuZEhvb2sodmFsdWVzLCBjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmsgKHZhbHVlcywgY2IpIHtcbiAgICBzZWxmLl9hcHBlbmQodmFsdWVzLCBjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmMgKF8sIGNiKSB7XG4gICAgc2VsZi5fc3luY0JpdGZpZWxkKGNiKVxuICB9XG5cbiAgZnVuY3Rpb24gb3BlbiAoY2IpIHtcbiAgICBzZWxmLl9vcGVuKGNiKVxuICB9XG59XG5cbmluaGVyaXRzKEZlZWQsIGV2ZW50cy5FdmVudEVtaXR0ZXIpXG5cbkZlZWQuZGlzY292ZXJ5S2V5ID0gY3J5cHRvLmRpc2NvdmVyeUtleVxuXG4vLyBUT0RPOiBpbnN0ZWFkIG9mIHVzaW5nIGEgZ2V0dGVyLCB1cGRhdGUgb24gcmVtb3RlLXVwZGF0ZS9hZGQvcmVtb3ZlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmVlZC5wcm90b3R5cGUsICdyZW1vdGVMZW5ndGgnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSAwXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVtb3RlTGVuZ3RoID0gdGhpcy5wZWVyc1tpXS5yZW1vdGVMZW5ndGhcbiAgICAgIGlmIChyZW1vdGVMZW5ndGggPiBsZW4pIGxlbiA9IHJlbW90ZUxlbmd0aFxuICAgIH1cbiAgICByZXR1cm4gbGVuXG4gIH1cbn0pXG5cbkZlZWQucHJvdG90eXBlLnJlcGxpY2F0ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIC8vIExhenkgbG9hZCByZXBsaWNhdGlvbiBkZXBzXG4gIGlmICghcmVwbGljYXRlKSByZXBsaWNhdGUgPSByZXF1aXJlKCcuL2xpYi9yZXBsaWNhdGUnKVxuXG4gIGlmICgoIXRoaXMuX3NlbGVjdGlvbnMubGVuZ3RoIHx8IHRoaXMuX3NlbGVjdGlvbnNbMF0uZW5kICE9PSAtMSkgJiYgIXRoaXMuc3BhcnNlICYmICEob3B0cyAmJiBvcHRzLmxpdmUpKSB7XG4gICAgLy8gaGFjayEhIHByb3BlciBmaXggaXMgdG8gcmVmYWN0b3IgLi9yZXBsaWNhdGUgdG8gKm5vdCogY2xlYXIgb3VyIG5vbi1zcGFyc2Ugc2VsZWN0aW9uXG4gICAgdGhpcy5kb3dubG9hZCh7c3RhcnQ6IDAsIGVuZDogLTF9KVxuICB9XG5cbiAgcmV0dXJuIHJlcGxpY2F0ZSh0aGlzLCBvcHRzIHx8IHt9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIChvbnJlYWR5KSB7XG4gIHRoaXMuX3JlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWVycikgb25yZWFkeSgpXG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChsZW4sIGNiKSB7XG4gIGlmICh0eXBlb2YgbGVuID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy51cGRhdGUoLTEsIGxlbilcbiAgaWYgKHR5cGVvZiBsZW4gIT09ICdudW1iZXInKSBsZW4gPSAtMVxuICBpZiAoIWNiKSBjYiA9IG5vb3BcblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLnJlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChsZW4gPT09IC0xKSBsZW4gPSBzZWxmLmxlbmd0aCArIDFcbiAgICBpZiAoc2VsZi5sZW5ndGggPj0gbGVuKSByZXR1cm4gY2IobnVsbClcblxuICAgIGlmIChzZWxmLndyaXRhYmxlKSBjYiA9IHNlbGYuX3dyaXRlU3RhdGVSZWxvYWRlcihjYilcblxuICAgIHNlbGYuX3dhaXRpbmcucHVzaCh7XG4gICAgICBoYXNoOiB0cnVlLFxuICAgICAgYnl0ZXM6IDAsXG4gICAgICBpbmRleDogbGVuIC0gMSxcbiAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgIGNhbGxiYWNrOiBjYlxuICAgIH0pXG5cbiAgICBzZWxmLl91cGRhdGVQZWVycygpXG4gIH0pXG59XG5cbi8vIHdpbGwgcmVsb2FkIHRoZSB3cml0YWJsZSBzdGF0ZS4gdXNlZCBieSAudXBkYXRlIG9uIGEgd3JpdGFibGUgcGVlclxuRmVlZC5wcm90b3R5cGUuX3dyaXRlU3RhdGVSZWxvYWRlciA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgc2VsZi5fcm9vdHMoc2VsZi5sZW5ndGgsIGZ1bmN0aW9uIChlcnIsIHJvb3RzKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgc2VsZi5fbWVya2xlID0gbWVya2xlKGNyeXB0bywgcm9vdHMpXG4gICAgICBjYihudWxsKVxuICAgIH0pXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBnZW5lcmF0ZWRLZXkgPSBmYWxzZVxuXG4gIC8vIFRPRE86IGNsZWFuIHVwIHRoZSBkdXBsaWNhdGUgY29kZSBiZWxvdyAuLi5cblxuICB0aGlzLl9zdG9yYWdlLm9wZW5LZXkoZnVuY3Rpb24gKF8sIGtleSkge1xuICAgIGlmIChrZXkgJiYgIXNlbGYuX292ZXJ3cml0ZSAmJiAhc2VsZi5rZXkpIHNlbGYua2V5ID0ga2V5XG5cbiAgICBpZiAoIXNlbGYua2V5ICYmIHNlbGYubGl2ZSkge1xuICAgICAgdmFyIGtleVBhaXIgPSBjcnlwdG8ua2V5UGFpcigpXG4gICAgICBzZWxmLnNlY3JldEtleSA9IGtleVBhaXIuc2VjcmV0S2V5XG4gICAgICBzZWxmLmtleSA9IGtleVBhaXIucHVibGljS2V5XG4gICAgICBnZW5lcmF0ZWRLZXkgPSB0cnVlXG4gICAgfVxuXG4gICAgc2VsZi5kaXNjb3ZlcnlLZXkgPSBzZWxmLmtleSAmJiBjcnlwdG8uZGlzY292ZXJ5S2V5KHNlbGYua2V5KVxuICAgIHNlbGYuX3N0b3JhZ2Uub3Blbih7a2V5OiBzZWxmLmtleSwgZGlzY292ZXJ5S2V5OiBzZWxmLmRpc2NvdmVyeUtleX0sIG9ub3BlbilcbiAgfSlcblxuICBmdW5jdGlvbiBvbm9wZW4gKGVyciwgc3RhdGUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgLy8gaWYgbm8ga2V5IGJ1dCB3ZSBoYXZlIGRhdGEgZG8gYSBiaXRmaWVsZCByZXNldCBzaW5jZSB3ZSBjYW5ub3QgdmVyaWZ5IHRoZSBkYXRhLlxuICAgIGlmICghc3RhdGUua2V5ICYmIHN0YXRlLmJpdGZpZWxkLmxlbmd0aCkge1xuICAgICAgc2VsZi5fb3ZlcndyaXRlID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzZWxmLl9vdmVyd3JpdGUpIHtcbiAgICAgIHN0YXRlLmJpdGZpZWxkLmZpbGwoMClcbiAgICAgIHN0YXRlLmtleSA9IHN0YXRlLnNlY3JldEtleSA9IG51bGxcbiAgICB9XG5cbiAgICBzZWxmLmJpdGZpZWxkID0gYml0ZmllbGQoc3RhdGUuYml0ZmllbGQpXG4gICAgc2VsZi50cmVlID0gdHJlZUluZGV4KHNlbGYuYml0ZmllbGQudHJlZSlcbiAgICBzZWxmLmxlbmd0aCA9IHNlbGYudHJlZS5ibG9ja3MoKVxuXG4gICAgaWYgKHN0YXRlLmtleSAmJiBzZWxmLmtleSAmJiAhZXF1YWxzKHN0YXRlLmtleSwgc2VsZi5rZXkpKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdBbm90aGVyIGh5cGVyY29yZSBpcyBzdG9yZWQgaGVyZScpKVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5rZXkpIHNlbGYua2V5ID0gc3RhdGUua2V5XG4gICAgaWYgKHN0YXRlLnNlY3JldEtleSkgc2VsZi5zZWNyZXRLZXkgPSBzdGF0ZS5zZWNyZXRLZXlcblxuICAgIC8vIHZlcmlmeSBrZXkgYW5kIHNlY3JldEtleSBnbyB0b2dldGhlclxuICAgIGlmIChzZWxmLmtleSAmJiBzZWxmLnNlY3JldEtleSkge1xuICAgICAgdmFyIGNoYWxsZW5nZSA9IGJ1ZmZlckFsbG9jKDApXG4gICAgICBpZiAoIWNyeXB0by52ZXJpZnkoY2hhbGxlbmdlLCBjcnlwdG8uc2lnbihjaGFsbGVuZ2UsIHNlbGYuc2VjcmV0S2V5KSwgc2VsZi5rZXkpKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0tleSBhbmQgc2VjcmV0IGRvIG5vdCBtYXRjaCcpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2VsZi5sZW5ndGgpIHJldHVybiBvbnNpZ25hdHVyZShudWxsLCBudWxsKVxuICAgIHNlbGYuX3N0b3JhZ2UuZ2V0U2lnbmF0dXJlKHNlbGYubGVuZ3RoIC0gMSwgb25zaWduYXR1cmUpXG5cbiAgICBmdW5jdGlvbiBvbnNpZ25hdHVyZSAoXywgc2lnKSB7XG4gICAgICBpZiAoc2VsZi5sZW5ndGgpIHNlbGYubGl2ZSA9ICEhc2lnXG5cbiAgICAgIGlmICgoZ2VuZXJhdGVkS2V5IHx8ICFzZWxmLmtleSkgJiYgIXNlbGYuX2NyZWF0ZUlmTWlzc2luZykge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdObyBoeXBlcmNvcmUgaXMgc3RvcmVkIGhlcmUnKSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmLmtleSAmJiBzZWxmLmxpdmUpIHtcbiAgICAgICAgdmFyIGtleVBhaXIgPSBjcnlwdG8ua2V5UGFpcigpXG4gICAgICAgIHNlbGYuc2VjcmV0S2V5ID0ga2V5UGFpci5zZWNyZXRLZXlcbiAgICAgICAgc2VsZi5rZXkgPSBrZXlQYWlyLnB1YmxpY0tleVxuICAgICAgfVxuXG4gICAgICB2YXIgd3JpdGFibGUgPSAhIXNlbGYuc2VjcmV0S2V5IHx8IHNlbGYua2V5ID09PSBudWxsXG5cbiAgICAgIGlmICghd3JpdGFibGUgJiYgc2VsZi53cml0YWJsZSkgcmV0dXJuIGNiKG5ldyBFcnJvcignRmVlZCBpcyBub3Qgd3JpdGFibGUnKSlcbiAgICAgIHNlbGYud3JpdGFibGUgPSB3cml0YWJsZVxuICAgICAgc2VsZi5kaXNjb3ZlcnlLZXkgPSBzZWxmLmtleSAmJiBjcnlwdG8uZGlzY292ZXJ5S2V5KHNlbGYua2V5KVxuXG4gICAgICBpZiAoc2VsZi5fc3RvcmVTZWNyZXRLZXkgJiYgIXNlbGYuc2VjcmV0S2V5KSB7XG4gICAgICAgIHNlbGYuX3N0b3JlU2VjcmV0S2V5ID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3VsZFdyaXRlS2V5ID0gZ2VuZXJhdGVkS2V5IHx8ICFzYWZlQnVmZmVyRXF1YWxzKHNlbGYua2V5LCBzdGF0ZS5rZXkpXG4gICAgICB2YXIgc2hvdWxkV3JpdGVTZWNyZXRLZXkgPSBzZWxmLl9zdG9yZVNlY3JldEtleSAmJiAoZ2VuZXJhdGVkS2V5IHx8ICFzYWZlQnVmZmVyRXF1YWxzKHNlbGYuc2VjcmV0S2V5LCBzdGF0ZS5zZWNyZXRLZXkpKVxuXG4gICAgICB2YXIgbWlzc2luZyA9IDEgK1xuICAgICAgICAoc2hvdWxkV3JpdGVLZXkgPyAxIDogMCkgK1xuICAgICAgICAoc2hvdWxkV3JpdGVTZWNyZXRLZXkgPyAxIDogMCkgK1xuICAgICAgICAoc2VsZi5fb3ZlcndyaXRlID8gMSA6IDApXG4gICAgICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgICAgIGlmIChzaG91bGRXcml0ZUtleSkgc2VsZi5fc3RvcmFnZS5rZXkud3JpdGUoMCwgc2VsZi5rZXksIGRvbmUpXG4gICAgICBpZiAoc2hvdWxkV3JpdGVTZWNyZXRLZXkpIHNlbGYuX3N0b3JhZ2Uuc2VjcmV0S2V5LndyaXRlKDAsIHNlbGYuc2VjcmV0S2V5LCBkb25lKVxuXG4gICAgICBpZiAoc2VsZi5fb3ZlcndyaXRlKSB7IC8vIFRPRE86IHN1cHBvcnQgc3RvcmFnZS5yZXNpemUgZm9yIHRoaXMgaW5zdGVhZFxuICAgICAgICBzZWxmLl9zdG9yYWdlLnB1dEJpdGZpZWxkKDAsIHN0YXRlLmJpdGZpZWxkLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBkb25lKG51bGwpXG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgICAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgICAgICBpZiAoLS1taXNzaW5nKSByZXR1cm5cbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY2IoZXJyb3IpXG4gICAgICAgIHNlbGYuX3Jvb3RzKHNlbGYubGVuZ3RoLCBvbnJvb3RzKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbnJvb3RzIChlcnIsIHJvb3RzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICAgICAgc2VsZi5fbWVya2xlID0gbWVya2xlKGNyeXB0bywgcm9vdHMpXG4gICAgICAgIHNlbGYuYnl0ZUxlbmd0aCA9IHJvb3RzLnJlZHVjZShhZGRTaXplLCAwKVxuICAgICAgICBzZWxmLm9wZW5lZCA9IHRydWVcbiAgICAgICAgc2VsZi5lbWl0KCdyZWFkeScpXG5cbiAgICAgICAgY2IobnVsbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbiAocmFuZ2UsIGNiKSB7XG4gIGlmICh0eXBlb2YgcmFuZ2UgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmRvd25sb2FkKG51bGwsIHJhbmdlKVxuICBpZiAodHlwZW9mIHJhbmdlID09PSAnbnVtYmVyJykgcmFuZ2UgPSB7c3RhcnQ6IHJhbmdlLCBlbmQ6IHJhbmdlICsgMX1cbiAgaWYgKCFyYW5nZSkgcmFuZ2UgPSB7fVxuXG4gIC8vIFRPRE86IGlmIG5vIHBlZXJzLCBjaGVjayBpZiByYW5nZSBpcyBhbHJlYWR5IHNhdGlzZmllZCBhbmQgbmV4dFRpY2soY2IpIGlmIHNvXG4gIC8vIHRoaXMuX3VwZGF0ZVBlZXJzIGRvZXMgdGhpcyBmb3IgdXMgd2hlbiB0aGVyZSBpcyBhIHBlZXIgdGhvdWdoLCBzbyBub3QgY3JpdGljYWxcblxuICB2YXIgc2VsID0ge1xuICAgIF9pbmRleDogdGhpcy5fc2VsZWN0aW9ucy5sZW5ndGgsXG4gICAgaGFzaDogISFyYW5nZS5oYXNoLFxuICAgIGl0ZXJhdG9yOiBudWxsLFxuICAgIHN0YXJ0OiByYW5nZS5zdGFydCB8fCAwLFxuICAgIGVuZDogcmFuZ2UuZW5kIHx8IC0xLFxuICAgIGxpbmVhcjogISFyYW5nZS5saW5lYXIsXG4gICAgY2FsbGJhY2s6IGNiIHx8IG5vb3BcbiAgfVxuXG4gIHRoaXMuX3NlbGVjdGlvbnMucHVzaChzZWwpXG4gIHRoaXMuX3VwZGF0ZVBlZXJzKClcblxuICByZXR1cm4gc2VsXG59XG5cbkZlZWQucHJvdG90eXBlLnVuZG93bmxvYWQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgaWYgKHR5cGVvZiByYW5nZSA9PT0gJ251bWJlcicpIHJhbmdlID0ge3N0YXJ0OiByYW5nZSwgZW5kOiByYW5nZSArIDF9XG4gIGlmICghcmFuZ2UpIHJhbmdlID0ge31cblxuICBpZiAocmFuZ2UuY2FsbGJhY2sgJiYgcmFuZ2UuX2luZGV4ID4gLTEpIHtcbiAgICBzZXQucmVtb3ZlKHRoaXMuX3NlbGVjdGlvbnMsIHJhbmdlKVxuICAgIG5leHRUaWNrKHJhbmdlLmNhbGxiYWNrLCBuZXcgRXJyb3IoJ0Rvd25sb2FkIHdhcyBjYW5jZWxsZWQnKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0IHx8IDBcbiAgdmFyIGVuZCA9IHJhbmdlLmVuZCB8fCAtMVxuICB2YXIgaGFzaCA9ICEhcmFuZ2UuaGFzaFxuICB2YXIgbGluZWFyID0gISFyYW5nZS5saW5lYXJcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcyA9IHRoaXMuX3NlbGVjdGlvbnNbaV1cblxuICAgIGlmIChzLnN0YXJ0ID09PSBzdGFydCAmJiBzLmVuZCA9PT0gZW5kICYmIHMuaGFzaCA9PT0gaGFzaCAmJiBzLmxpbmVhciA9PT0gbGluZWFyKSB7XG4gICAgICBzZXQucmVtb3ZlKHRoaXMuX3NlbGVjdGlvbnMsIHMpXG4gICAgICBuZXh0VGljayhzLmNhbGxiYWNrLCBuZXcgRXJyb3IoJ0Rvd25sb2FkIHdhcyBjYW5jZWxsZWQnKSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMudHJlZS5kaWdlc3QoMiAqIGluZGV4KVxufVxuXG5GZWVkLnByb3RvdHlwZS5wcm9vZiA9IGZ1bmN0aW9uIChpbmRleCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5wcm9vZihpbmRleCwgbnVsbCwgb3B0cylcbiAgaWYgKCF0aGlzLm9wZW5lZCkgcmV0dXJuIHRoaXMuX3JlYWR5QW5kUHJvb2YoaW5kZXgsIG9wdHMsIGNiKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIHZhciBwcm9vZiA9IHRoaXMudHJlZS5wcm9vZigyICogaW5kZXgsIG9wdHMpXG4gIGlmICghcHJvb2YpIHJldHVybiBjYihuZXcgRXJyb3IoJ05vIHByb29mIGF2YWlsYWJsZSBmb3IgdGhpcyBpbmRleCcpKVxuXG4gIHZhciBuZWVkc1NpZyA9IHRoaXMubGl2ZSAmJiAhIXByb29mLnZlcmlmaWVkQnlcbiAgdmFyIHBlbmRpbmcgPSBwcm9vZi5ub2Rlcy5sZW5ndGggKyAobmVlZHNTaWcgPyAxIDogMClcbiAgdmFyIGVycm9yID0gbnVsbFxuICB2YXIgc2lnbmF0dXJlID0gbnVsbFxuICB2YXIgbm9kZXMgPSBuZXcgQXJyYXkocHJvb2Yubm9kZXMubGVuZ3RoKVxuXG4gIGlmICghcGVuZGluZykgcmV0dXJuIGNiKG51bGwsIHtub2Rlczogbm9kZXMsIHNpZ25hdHVyZTogbnVsbH0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9vZi5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX3N0b3JhZ2UuZ2V0Tm9kZShwcm9vZi5ub2Rlc1tpXSwgb25ub2RlKVxuICB9XG4gIGlmIChuZWVkc1NpZykge1xuICAgIHRoaXMuX3N0b3JhZ2UuZ2V0U2lnbmF0dXJlKHByb29mLnZlcmlmaWVkQnkgLyAyIC0gMSwgb25zaWduYXR1cmUpXG4gIH1cblxuICBmdW5jdGlvbiBvbnNpZ25hdHVyZSAoZXJyLCBzaWcpIHtcbiAgICBpZiAoc2lnKSBzaWduYXR1cmUgPSBzaWdcbiAgICBvbm5vZGUoZXJyLCBudWxsKVxuICB9XG5cbiAgZnVuY3Rpb24gb25ub2RlIChlcnIsIG5vZGUpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGVzW3Byb29mLm5vZGVzLmluZGV4T2Yobm9kZS5pbmRleCldID0gbm9kZVxuICAgIH1cblxuICAgIGlmICgtLXBlbmRpbmcpIHJldHVyblxuICAgIGlmIChlcnJvcikgcmV0dXJuIGNiKGVycm9yKVxuICAgIGNiKG51bGwsIHtub2Rlczogbm9kZXMsIHNpZ25hdHVyZTogc2lnbmF0dXJlfSlcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fcmVhZHlBbmRQcm9vZiA9IGZ1bmN0aW9uIChpbmRleCwgb3B0cywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHNlbGYucHJvb2YoaW5kZXgsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoaW5kZXgsIGRhdGEsIHByb29mLCBjYikge1xuICBpZiAoIXRoaXMub3BlbmVkKSByZXR1cm4gdGhpcy5fcmVhZHlBbmRQdXQoaW5kZXgsIGRhdGEsIHByb29mLCBjYilcbiAgdGhpcy5fcHV0QnVmZmVyKGluZGV4LCB0aGlzLl9jb2RlYy5lbmNvZGUoZGF0YSksIHByb29mLCBudWxsLCBjYilcbn1cblxuRmVlZC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHsgIC8vIFRPRE86IHVzZSBzYW1lIGFyZ3VtZW50IHNjaGVtZSBhcyBkb3dubG9hZFxuICBpZiAoIWVuZCkgZW5kID0gc3RhcnQgKyAxXG5cbiAgLy8gY2FuY2VsIHRoZXNlIHJpZ2h0IGF3YXkgYXMgLmRvd25sb2FkIGRvZXMgbm90IHdhaXQgZm9yIHJlYWR5XG4gIGZvciAodmFyIGkgPSB0aGlzLl9zZWxlY3Rpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuX3NlbGVjdGlvbnNbaV1cbiAgICBpZiAoc3RhcnQgPD0gc2VsLnN0YXJ0ICYmIHNlbC5lbmQgPD0gZW5kKSB7XG4gICAgICB0aGlzLnVuZG93bmxvYWQoc2VsKVxuICAgIH1cbiAgfVxuXG4gIC8vIGRlZmVyIHRoZSBsYXN0IHBhcnQgdW50aWwgYWZ0ZXIgcmVhZHkgYXMgLmdldCBkb2VzIHRoYXQgYXMgd2VsbFxuICBpZiAodGhpcy5vcGVuZWQpIHRoaXMuX2NhbmNlbChzdGFydCwgZW5kKVxuICBlbHNlIHRoaXMuX3JlYWR5QW5kQ2FuY2VsKHN0YXJ0LCBlbmQpXG59XG5cbkZlZWQucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgaSA9IDBcblxuICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpcy5fcmVzZXJ2ZWQuc2V0KGksIGZhbHNlKSAvLyBUT0RPOiBzZW5kIGNhbmNlbCBtZXNzYWdlIGlmIHNldCByZXR1cm5zIHRydWVcbiAgfVxuXG4gIGZvciAoaSA9IHRoaXMuX3dhaXRpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgdyA9IHRoaXMuX3dhaXRpbmdbaV1cbiAgICBpZiAoKHN0YXJ0IDw9IHcuc3RhcnQgJiYgdy5lbmQgPD0gZW5kKSB8fCAoc3RhcnQgPD0gdy5pbmRleCAmJiB3LmluZGV4IDwgZW5kKSkge1xuICAgICAgcmVtb3ZlKHRoaXMuX3dhaXRpbmcsIGkpXG4gICAgICBpZiAody5jYWxsYmFjaykgbmV4dFRpY2sody5jYWxsYmFjaywgbmV3IEVycm9yKCdSZXF1ZXN0IGNhbmNlbGxlZCcpKVxuICAgIH1cbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBvcHRzLCBjYikgeyAvLyBUT0RPOiB1c2Ugc2FtZSBhcmd1bWVudCBzY2hlbWUgYXMgZG93bmxvYWRcbiAgaWYgKHR5cGVvZiBlbmQgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmNsZWFyKHN0YXJ0LCBzdGFydCArIDEsIG51bGwsIGVuZClcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5jbGVhcihzdGFydCwgZW5kLCBudWxsLCBvcHRzKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBpZiAoIWVuZCkgZW5kID0gc3RhcnQgKyAxXG4gIGlmICghY2IpIGNiID0gbm9vcFxuXG4gIC8vIFRPRE86IHRoaXMgbmVlZHMgc29tZSB3b3JrLiBmeCB3ZSBjYW4gb25seSBjYWxjIGJ5dGUgb2Zmc2V0IGZvciBibG9ja3Mgd2Uga25vdyBhYm91dFxuICAvLyBzbyBpbnRlcm5hbGx5IHdlIHNob3VsZCBtYWtlIHN1cmUgdG8gb25seSBkbyB0aGF0LiBXZSBzaG91bGQgdXNlIHRoZSBtZXJrbGUgdHJlZSBmb3IgdGhpc1xuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgYnl0ZU9mZnNldCA9IHN0YXJ0ID09PSAwID8gMCA6ICh0eXBlb2Ygb3B0cy5ieXRlT2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9wdHMuYnl0ZU9mZnNldCA6IC0xKVxuICB2YXIgYnl0ZUxlbmd0aCA9IHR5cGVvZiBvcHRzLmJ5dGVMZW5ndGggPT09ICdudW1iZXInID8gb3B0cy5ieXRlTGVuZ3RoIDogLTFcblxuICB0aGlzLl9yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIHZhciBtb2RpZmllZCA9IGZhbHNlXG5cbiAgICAvLyBUT0RPOiB1c2UgYSBidWZmZXIuZmlsbCB0aGluZyBoZXJlIHRvIHNwZWVkIHRoaXMgdXAhXG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgaWYgKHNlbGYuYml0ZmllbGQuc2V0KGksIGZhbHNlKSkgbW9kaWZpZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCFtb2RpZmllZCkgcmV0dXJuIG5leHRUaWNrKGNiKVxuXG4gICAgLy8gVE9ETzogd3JpdGUgdG8gYSB0bXAvdXBkYXRlIGZpbGUgdGhhdCB3ZSB3YW50IHRvIGRlbCB0aGlzIGluY2FzZSBpdCBjcmFzaGVzIHdpbGwgZGVsJ2luZ1xuXG4gICAgc2VsZi5fdW5hbm5vdW5jZSh7c3RhcnQ6IHN0YXJ0LCBsZW5ndGg6IGVuZCAtIHN0YXJ0fSlcbiAgICBpZiAob3B0cy5kZWxldGUgPT09IGZhbHNlIHx8IHNlbGYuX2luZGV4aW5nKSByZXR1cm4gc3luYygpXG4gICAgaWYgKGJ5dGVPZmZzZXQgPiAtMSkgcmV0dXJuIG9uc3RhcnRieXRlcyhudWxsLCBieXRlT2Zmc2V0KVxuICAgIHNlbGYuX3N0b3JhZ2UuZGF0YU9mZnNldChzdGFydCwgW10sIG9uc3RhcnRieXRlcylcblxuICAgIGZ1bmN0aW9uIHN5bmMgKCkge1xuICAgICAgc2VsZi5lbWl0KCdjbGVhcicsIHN0YXJ0LCBlbmQpXG4gICAgICBzZWxmLl9zeW5jKG51bGwsIGNiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uc3RhcnRieXRlcyAoZXJyLCBvZmZzZXQpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBieXRlT2Zmc2V0ID0gb2Zmc2V0XG4gICAgICBpZiAoYnl0ZUxlbmd0aCA+IC0xKSByZXR1cm4gb25lbmRieXRlcyhudWxsLCBieXRlTGVuZ3RoICsgYnl0ZU9mZnNldClcbiAgICAgIGlmIChlbmQgPT09IHNlbGYubGVuZ3RoKSByZXR1cm4gb25lbmRieXRlcyhudWxsLCBzZWxmLmJ5dGVMZW5ndGgpXG4gICAgICBzZWxmLl9zdG9yYWdlLmRhdGFPZmZzZXQoZW5kLCBbXSwgb25lbmRieXRlcylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmVuZGJ5dGVzIChlcnIsIGVuZCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmICghc2VsZi5fc3RvcmFnZS5kYXRhLmRlbCkgcmV0dXJuIHN5bmMoKSAvLyBOb3QgYWxsIGRhdGEgc3RvcmFnZSBpbXBscyBkZWxcbiAgICAgIHNlbGYuX3N0b3JhZ2UuZGF0YS5kZWwoYnl0ZU9mZnNldCwgZW5kIC0gYnl0ZU9mZnNldCwgc3luYylcbiAgICB9XG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLnNpZ25hdHVyZSA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuc2lnbmF0dXJlKHRoaXMubGVuZ3RoIC0gMSwgaW5kZXgpXG5cbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIGNiKG5ldyBFcnJvcignTm8gc2lnbmF0dXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBpbmRleCcpKVxuXG4gIHRoaXMuX3N0b3JhZ2UubmV4dFNpZ25hdHVyZShpbmRleCwgY2IpXG59XG5cbkZlZWQucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIChpbmRleCwgc2lnbmF0dXJlLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLnJvb3RIYXNoZXMoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIHJvb3RzKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIHZhciBjaGVja3N1bSA9IGNyeXB0by50cmVlKHJvb3RzKVxuXG4gICAgaWYgKCFjcnlwdG8udmVyaWZ5KGNoZWNrc3VtLCBzaWduYXR1cmUsIHNlbGYua2V5KSkge1xuICAgICAgY2IobmV3IEVycm9yKCdTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCcpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYihudWxsLCB0cnVlKVxuICAgIH1cbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUucm9vdEhhc2hlcyA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgdGhpcy5fZ2V0Um9vdHNUb1ZlcmlmeShpbmRleCAqIDIgKyAyLCB7fSwgW10sIGNiKVxufVxuXG5GZWVkLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKGJ5dGVzLCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLnNlZWsoYnl0ZXMsIG51bGwsIG9wdHMpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIGlmICghdGhpcy5vcGVuZWQpIHJldHVybiB0aGlzLl9yZWFkeUFuZFNlZWsoYnl0ZXMsIG9wdHMsIGNiKVxuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMuX3NlZWsoYnl0ZXMsIGZ1bmN0aW9uIChlcnIsIGluZGV4LCBvZmZzZXQpIHtcbiAgICBpZiAoIWVyciAmJiBpc0Jsb2NrKGluZGV4KSkgcmV0dXJuIGRvbmUoaW5kZXggLyAyLCBvZmZzZXQpXG4gICAgaWYgKG9wdHMud2FpdCA9PT0gZmFsc2UpIHJldHVybiBjYihlcnIgfHwgbmV3IEVycm9yKCdVbmFibGUgdG8gc2VlayB0byB0aGlzIG9mZnNldCcpKVxuXG4gICAgdmFyIHN0YXJ0ID0gb3B0cy5zdGFydCB8fCAwXG4gICAgdmFyIGVuZCA9IG9wdHMuZW5kIHx8IC0xXG5cbiAgICBpZiAoIWVycikge1xuICAgICAgdmFyIGxlZnQgPSBmbGF0LmxlZnRTcGFuKGluZGV4KSAvIDJcbiAgICAgIHZhciByaWdodCA9IGZsYXQucmlnaHRTcGFuKGluZGV4KSAvIDIgKyAxXG5cbiAgICAgIGlmIChsZWZ0ID4gc3RhcnQpIHN0YXJ0ID0gbGVmdFxuICAgICAgaWYgKHJpZ2h0IDwgZW5kIHx8IGVuZCA9PT0gLTEpIGVuZCA9IHJpZ2h0XG4gICAgfVxuXG4gICAgaWYgKGVuZCA+IC0xICYmIGVuZCA8PSBzdGFydCkgcmV0dXJuIGNiKG5ldyBFcnJvcignVW5hYmxlIHRvIHNlZWsgdG8gdGhpcyBvZmZzZXQnKSlcblxuICAgIHNlbGYuX3dhaXRpbmcucHVzaCh7XG4gICAgICBoYXNoOiBvcHRzLmhhc2ggIT09IGZhbHNlLFxuICAgICAgYnl0ZXM6IGJ5dGVzLFxuICAgICAgaW5kZXg6IC0xLFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmQsXG4gICAgICBjYWxsYmFjazogY2IgfHwgbm9vcFxuICAgIH0pXG5cbiAgICBzZWxmLl91cGRhdGVQZWVycygpXG4gIH0pXG5cbiAgZnVuY3Rpb24gZG9uZSAoaW5kZXgsIG9mZnNldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wZWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZi5wZWVyc1tpXS5oYXZlQnl0ZXMoYnl0ZXMpXG4gICAgfVxuICAgIGNiKG51bGwsIGluZGV4LCBvZmZzZXQpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3NlZWsgPSBmdW5jdGlvbiAob2Zmc2V0LCBjYikge1xuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gY2IobnVsbCwgMCwgMClcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJvb3RzID0gZmxhdC5mdWxsUm9vdHModGhpcy5sZW5ndGggKiAyKVxuICB2YXIgbmVhcmVzdFJvb3QgPSAwXG5cbiAgbG9vcChudWxsLCBudWxsKVxuXG4gIGZ1bmN0aW9uIG9ucm9vdCAodG9wKSB7XG4gICAgaWYgKGlzQmxvY2sodG9wKSkgcmV0dXJuIGNiKG51bGwsIHRvcCwgb2Zmc2V0KVxuXG4gICAgdmFyIGxlZnQgPSBmbGF0LmxlZnRDaGlsZCh0b3ApXG4gICAgd2hpbGUgKCFzZWxmLnRyZWUuZ2V0KGxlZnQpKSB7XG4gICAgICBpZiAoaXNCbG9jayhsZWZ0KSkgcmV0dXJuIGNiKG51bGwsIG5lYXJlc3RSb290LCBvZmZzZXQpXG4gICAgICBsZWZ0ID0gZmxhdC5sZWZ0Q2hpbGQobGVmdClcbiAgICB9XG5cbiAgICBzZWxmLl9zdG9yYWdlLmdldE5vZGUobGVmdCwgb25sZWZ0Y2hpbGQpXG4gIH1cblxuICBmdW5jdGlvbiBvbmxlZnRjaGlsZCAoZXJyLCBub2RlKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIGlmIChub2RlLnNpemUgPiBvZmZzZXQpIHtcbiAgICAgIG5lYXJlc3RSb290ID0gbm9kZS5pbmRleFxuICAgICAgb25yb290KG5vZGUuaW5kZXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCAtPSBub2RlLnNpemVcbiAgICAgIG9ucm9vdChmbGF0LnNpYmxpbmcobm9kZS5pbmRleCkpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9vcCAoZXJyLCBub2RlKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIGlmIChub2RlKSB7XG4gICAgICBpZiAobm9kZS5zaXplID4gb2Zmc2V0KSB7XG4gICAgICAgIG5lYXJlc3RSb290ID0gbm9kZS5pbmRleFxuICAgICAgICByZXR1cm4gb25yb290KG5vZGUuaW5kZXgpXG4gICAgICB9XG4gICAgICBvZmZzZXQgLT0gbm9kZS5zaXplXG4gICAgfVxuXG4gICAgaWYgKCFyb290cy5sZW5ndGgpIHJldHVybiBjYihuZXcgRXJyb3IoJ091dCBvZiBib3VuZHMnKSlcbiAgICBzZWxmLl9zdG9yYWdlLmdldE5vZGUocm9vdHMuc2hpZnQoKSwgbG9vcClcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fcmVhZHlBbmRTZWVrID0gZnVuY3Rpb24gKGJ5dGVzLCBvcHRzLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5zZWVrKGJ5dGVzLCBvcHRzLCBjYilcbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUuX2dldEJ1ZmZlciA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgdGhpcy5fc3RvcmFnZS5nZXREYXRhKGluZGV4LCBjYilcbn1cblxuRmVlZC5wcm90b3R5cGUuX3B1dEJ1ZmZlciA9IGZ1bmN0aW9uIChpbmRleCwgZGF0YSwgcHJvb2YsIGZyb20sIGNiKSB7XG4gIC8vIFRPRE86IHRoaXMgbm9kZXMgaW4gcHJvb2YgYXJlIG5vdCBpbnN0YW5jZXMgb2Ygb3VyIE5vZGUgcHJvdG90eXBlXG4gIC8vIGJ1dCBqdXN0IHNpbWlsYXIuIENoZWNrIGlmIHRoaXMgaGFzIGFueSB2OCBwZXJmIGltcGxpY2F0aW9ucy5cblxuICAvLyBUT0RPOiBpZiB0aGUgcHJvb2YgY29udGFpbnMgYSB2YWxpZCBzaWduYXR1cmUgQlVUIGZhaWxzLCBlbWl0IGEgY3JpdGljYWwgZXJyb3JcbiAgLy8gLS0+IGZlZWQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgZGVhZFxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgdHJ1c3RlZCA9IC0xXG4gIHZhciBtaXNzaW5nID0gW11cbiAgdmFyIG5leHQgPSAyICogaW5kZXhcbiAgdmFyIGkgPSBkYXRhID8gMCA6IDFcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh0aGlzLnRyZWUuZ2V0KG5leHQpKSB7XG4gICAgICB0cnVzdGVkID0gbmV4dFxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB2YXIgc2liID0gZmxhdC5zaWJsaW5nKG5leHQpXG4gICAgbmV4dCA9IGZsYXQucGFyZW50KG5leHQpXG5cbiAgICBpZiAoaSA8IHByb29mLm5vZGVzLmxlbmd0aCAmJiBwcm9vZi5ub2Rlc1tpXS5pbmRleCA9PT0gc2liKSB7XG4gICAgICBpKytcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRyZWUuZ2V0KHNpYikpIGJyZWFrXG4gICAgbWlzc2luZy5wdXNoKHNpYilcbiAgfVxuXG4gIGlmICh0cnVzdGVkID09PSAtMSAmJiB0aGlzLnRyZWUuZ2V0KG5leHQpKSB0cnVzdGVkID0gbmV4dFxuXG4gIHZhciBlcnJvciA9IG51bGxcbiAgdmFyIHRydXN0ZWROb2RlID0gbnVsbFxuICB2YXIgbWlzc2luZ05vZGVzID0gbmV3IEFycmF5KG1pc3NpbmcubGVuZ3RoKVxuICB2YXIgcGVuZGluZyA9IG1pc3NpbmcubGVuZ3RoICsgKHRydXN0ZWQgPiAtMSA/IDEgOiAwKVxuXG4gIGZvciAoaSA9IDA7IGkgPCBtaXNzaW5nLmxlbmd0aDsgaSsrKSB0aGlzLl9zdG9yYWdlLmdldE5vZGUobWlzc2luZ1tpXSwgb25taXNzaW5nKVxuICBpZiAodHJ1c3RlZCA+IC0xKSB0aGlzLl9zdG9yYWdlLmdldE5vZGUodHJ1c3RlZCwgb250cnVzdGVkKVxuICBpZiAoIW1pc3NpbmcubGVuZ3RoICYmIHRydXN0ZWQgPT09IC0xKSBvbm1pc3Npbmdsb2FkZWQobnVsbClcblxuICBmdW5jdGlvbiBvbnRydXN0ZWQgKGVyciwgbm9kZSkge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKG5vZGUpIHRydXN0ZWROb2RlID0gbm9kZVxuICAgIGlmICghLS1wZW5kaW5nKSBvbm1pc3Npbmdsb2FkZWQoZXJyb3IpXG4gIH1cblxuICBmdW5jdGlvbiBvbm1pc3NpbmcgKGVyciwgbm9kZSkge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKG5vZGUpIG1pc3NpbmdOb2Rlc1ttaXNzaW5nLmluZGV4T2Yobm9kZS5pbmRleCldID0gbm9kZVxuICAgIGlmICghLS1wZW5kaW5nKSBvbm1pc3Npbmdsb2FkZWQoZXJyb3IpXG4gIH1cblxuICBmdW5jdGlvbiBvbm1pc3Npbmdsb2FkZWQgKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5fdmVyaWZ5QW5kV3JpdGUoaW5kZXgsIGRhdGEsIHByb29mLCBtaXNzaW5nTm9kZXMsIHRydXN0ZWROb2RlLCBmcm9tLCBjYilcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fcmVhZHlBbmRQdXQgPSBmdW5jdGlvbiAoaW5kZXgsIGRhdGEsIHByb29mLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5wdXQoaW5kZXgsIGRhdGEsIHByb29mLCBjYilcbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhLCBub2Rlcywgc2lnLCBmcm9tLCBjYikge1xuICBpZiAoIXRoaXMuX29ud3JpdGUpIHJldHVybiB0aGlzLl93cml0ZUFmdGVySG9vayhpbmRleCwgZGF0YSwgbm9kZXMsIHNpZywgZnJvbSwgY2IpXG4gIHRoaXMuX29ud3JpdGUoaW5kZXgsIGRhdGEsIGZyb20sIHdyaXRlSG9va0RvbmUodGhpcywgaW5kZXgsIGRhdGEsIG5vZGVzLCBzaWcsIGZyb20sIGNiKSlcbn1cblxuZnVuY3Rpb24gd3JpdGVIb29rRG9uZSAoc2VsZiwgaW5kZXgsIGRhdGEsIG5vZGVzLCBzaWcsIGZyb20sIGNiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBzZWxmLl93cml0ZUFmdGVySG9vayhpbmRleCwgZGF0YSwgbm9kZXMsIHNpZywgZnJvbSwgY2IpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3dyaXRlQWZ0ZXJIb29rID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhLCBub2Rlcywgc2lnLCBmcm9tLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHBlbmRpbmcgPSBub2Rlcy5sZW5ndGggKyAxICsgKHNpZyA/IDEgOiAwKVxuICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykgdGhpcy5fc3RvcmFnZS5wdXROb2RlKG5vZGVzW2ldLmluZGV4LCBub2Rlc1tpXSwgb25kb25lKVxuICBpZiAoZGF0YSkgdGhpcy5fc3RvcmFnZS5wdXREYXRhKGluZGV4LCBkYXRhLCBub2Rlcywgb25kb25lKVxuICBlbHNlIG9uZG9uZSgpXG4gIGlmIChzaWcpIHRoaXMuX3N0b3JhZ2UucHV0U2lnbmF0dXJlKHNpZy5pbmRleCwgc2lnLnNpZ25hdHVyZSwgb25kb25lKVxuXG4gIGZ1bmN0aW9uIG9uZG9uZSAoZXJyKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAoLS1wZW5kaW5nKSByZXR1cm5cbiAgICBpZiAoZXJyb3IpIHJldHVybiBjYihlcnJvcilcbiAgICBzZWxmLl93cml0ZURvbmUoaW5kZXgsIGRhdGEsIG5vZGVzLCBmcm9tLCBjYilcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fd3JpdGVEb25lID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhLCBub2RlcywgZnJvbSwgY2IpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykgdGhpcy50cmVlLnNldChub2Rlc1tpXS5pbmRleClcbiAgdGhpcy50cmVlLnNldCgyICogaW5kZXgpXG5cbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAodGhpcy5iaXRmaWVsZC5zZXQoaW5kZXgsIHRydWUpKSB0aGlzLmVtaXQoJ2Rvd25sb2FkJywgaW5kZXgsIGRhdGEsIGZyb20pXG4gICAgaWYgKHRoaXMucGVlcnMubGVuZ3RoKSB0aGlzLl9hbm5vdW5jZSh7c3RhcnQ6IGluZGV4fSwgZnJvbSlcblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgaWYgKCF0aGlzLl9zeW5jZWQpIHRoaXMuX3N5bmNlZCA9IHRoaXMuYml0ZmllbGQuaXRlcmF0b3IoMCwgdGhpcy5sZW5ndGgpXG4gICAgICBpZiAodGhpcy5fc3luY2VkLm5leHQoKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5fc3luY2VkLnJhbmdlKDAsIHRoaXMubGVuZ3RoKVxuICAgICAgICB0aGlzLl9zeW5jZWQuc2VlaygwKVxuICAgICAgICBpZiAodGhpcy5fc3luY2VkLm5leHQoKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3N5bmMnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fc3luYyhudWxsLCBjYilcbn1cblxuRmVlZC5wcm90b3R5cGUuX3ZlcmlmeUFuZFdyaXRlID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhLCBwcm9vZiwgbG9jYWxOb2RlcywgdHJ1c3RlZE5vZGUsIGZyb20sIGNiKSB7XG4gIHZhciB2aXNpdGVkID0gW11cbiAgdmFyIHJlbW90ZU5vZGVzID0gcHJvb2Yubm9kZXNcbiAgdmFyIHRvcCA9IGRhdGEgPyBuZXcgc3RvcmFnZS5Ob2RlKDIgKiBpbmRleCwgY3J5cHRvLmRhdGEoZGF0YSksIGRhdGEubGVuZ3RoKSA6IHJlbW90ZU5vZGVzLnNoaWZ0KClcblxuICAvLyBjaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIGhhc2ggZm9yIHRoaXMgbm9kZVxuICBpZiAodmVyaWZ5Tm9kZSh0cnVzdGVkTm9kZSwgdG9wKSkge1xuICAgIHRoaXMuX3dyaXRlKGluZGV4LCBkYXRhLCB2aXNpdGVkLCBudWxsLCBmcm9tLCBjYilcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGtlZXAgaGFzaGluZyB3aXRoIHNpYmxpbmdzIHVudGlsIHdlIHJlYWNoIG9yIHRydXN0ZWQgbm9kZVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBub2RlID0gbnVsbFxuICAgIHZhciBuZXh0ID0gZmxhdC5zaWJsaW5nKHRvcC5pbmRleClcblxuICAgIGlmIChyZW1vdGVOb2Rlcy5sZW5ndGggJiYgcmVtb3RlTm9kZXNbMF0uaW5kZXggPT09IG5leHQpIHtcbiAgICAgIG5vZGUgPSByZW1vdGVOb2Rlcy5zaGlmdCgpXG4gICAgICB2aXNpdGVkLnB1c2gobm9kZSlcbiAgICB9IGVsc2UgaWYgKGxvY2FsTm9kZXMubGVuZ3RoICYmIGxvY2FsTm9kZXNbMF0uaW5kZXggPT09IG5leHQpIHtcbiAgICAgIG5vZGUgPSBsb2NhbE5vZGVzLnNoaWZ0KClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgY2Fubm90IGNyZWF0ZSBhbm90aGVyIHBhcmVudCwgaS5lLiB0aGVzZSBub2RlcyBtdXN0IGJlIHJvb3RzIGluIHRoZSB0cmVlXG4gICAgICB0aGlzLl92ZXJpZnlSb290c0FuZFdyaXRlKGluZGV4LCBkYXRhLCB0b3AsIHByb29mLCB2aXNpdGVkLCBmcm9tLCBjYilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZpc2l0ZWQucHVzaCh0b3ApXG4gICAgdG9wID0gbmV3IHN0b3JhZ2UuTm9kZShmbGF0LnBhcmVudCh0b3AuaW5kZXgpLCBjcnlwdG8ucGFyZW50KHRvcCwgbm9kZSksIHRvcC5zaXplICsgbm9kZS5zaXplKVxuXG4gICAgLy8gdGhlIHRyZWUgY2hlY2tzIG91dCwgd3JpdGUgdGhlIGRhdGEgYW5kIHRoZSB2aXNpdGVkIG5vZGVzXG4gICAgaWYgKHZlcmlmeU5vZGUodHJ1c3RlZE5vZGUsIHRvcCkpIHtcbiAgICAgIHRoaXMuX3dyaXRlKGluZGV4LCBkYXRhLCB2aXNpdGVkLCBudWxsLCBmcm9tLCBjYilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fdmVyaWZ5Um9vdHNBbmRXcml0ZSA9IGZ1bmN0aW9uIChpbmRleCwgZGF0YSwgdG9wLCBwcm9vZiwgbm9kZXMsIGZyb20sIGNiKSB7XG4gIHZhciByZW1vdGVOb2RlcyA9IHByb29mLm5vZGVzXG4gIHZhciBsYXN0Tm9kZSA9IHJlbW90ZU5vZGVzLmxlbmd0aCA/IHJlbW90ZU5vZGVzW3JlbW90ZU5vZGVzLmxlbmd0aCAtIDFdLmluZGV4IDogdG9wLmluZGV4XG4gIHZhciB2ZXJpZmllZEJ5ID0gTWF0aC5tYXgoZmxhdC5yaWdodFNwYW4odG9wLmluZGV4KSwgZmxhdC5yaWdodFNwYW4obGFzdE5vZGUpKSArIDJcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5fZ2V0Um9vdHNUb1ZlcmlmeSh2ZXJpZmllZEJ5LCB0b3AsIHJlbW90ZU5vZGVzLCBmdW5jdGlvbiAoZXJyLCByb290cywgZXh0cmFOb2Rlcykge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICB2YXIgY2hlY2tzdW0gPSBjcnlwdG8udHJlZShyb290cylcbiAgICB2YXIgc2lnbmF0dXJlID0gbnVsbFxuXG4gICAgaWYgKHNlbGYubGVuZ3RoICYmIHNlbGYubGl2ZSAmJiAhcHJvb2Yuc2lnbmF0dXJlKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdSZW1vdGUgZGlkIG5vdCBpbmNsdWRlIGEgc2lnbmF0dXJlJykpXG4gICAgfVxuXG4gICAgaWYgKHByb29mLnNpZ25hdHVyZSkgeyAvLyBjaGVjayBzaWduYXR1cmV4XG4gICAgICBpZiAoIWNyeXB0by52ZXJpZnkoY2hlY2tzdW0sIHByb29mLnNpZ25hdHVyZSwgc2VsZi5rZXkpKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1JlbW90ZSBzaWduYXR1cmUgY291bGQgbm90IGJlIHZlcmlmaWVkJykpXG4gICAgICB9XG5cbiAgICAgIHNpZ25hdHVyZSA9IHtpbmRleDogdmVyaWZpZWRCeSAvIDIgLSAxLCBzaWduYXR1cmU6IHByb29mLnNpZ25hdHVyZX1cbiAgICB9IGVsc2UgeyAvLyBjaGVjayB0cmVlIHJvb3RcbiAgICAgIGlmICghZXF1YWxzKGNoZWNrc3VtLCBzZWxmLmtleSkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignUmVtb3RlIGNoZWNrc3VtIGZhaWxlZCcpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYubGl2ZSA9ICEhc2lnbmF0dXJlXG5cbiAgICB2YXIgbGVuZ3RoID0gdmVyaWZpZWRCeSAvIDJcbiAgICBpZiAobGVuZ3RoID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgIC8vIFRPRE86IG9ubHkgZW1pdCB0aGlzIGFmdGVyIHRoZSBpbmZvIGhhcyBiZWVuIGZsdXNoZWQgdG8gc3RvcmFnZVxuICAgICAgc2VsZi5sZW5ndGggPSBsZW5ndGhcbiAgICAgIHNlbGYuYnl0ZUxlbmd0aCA9IHJvb3RzLnJlZHVjZShhZGRTaXplLCAwKVxuICAgICAgaWYgKHNlbGYuX3N5bmNlZCkgc2VsZi5fc3luY2VkLnNlZWsoMCwgc2VsZi5sZW5ndGgpXG4gICAgICBzZWxmLmVtaXQoJ2FwcGVuZCcpXG4gICAgfVxuXG4gICAgc2VsZi5fd3JpdGUoaW5kZXgsIGRhdGEsIG5vZGVzLmNvbmNhdChleHRyYU5vZGVzKSwgc2lnbmF0dXJlLCBmcm9tLCBjYilcbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUuX2dldFJvb3RzVG9WZXJpZnkgPSBmdW5jdGlvbiAodmVyaWZpZWRCeSwgdG9wLCByZW1vdGVOb2RlcywgY2IpIHtcbiAgdmFyIGluZGV4ZXMgPSBmbGF0LmZ1bGxSb290cyh2ZXJpZmllZEJ5KVxuICB2YXIgcm9vdHMgPSBuZXcgQXJyYXkoaW5kZXhlcy5sZW5ndGgpXG4gIHZhciBub2RlcyA9IFtdXG4gIHZhciBlcnJvciA9IG51bGxcbiAgdmFyIHBlbmRpbmcgPSByb290cy5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaW5kZXhlc1tpXSA9PT0gdG9wLmluZGV4KSB7XG4gICAgICBub2Rlcy5wdXNoKHRvcClcbiAgICAgIG9ubm9kZShudWxsLCB0b3ApXG4gICAgfSBlbHNlIGlmIChyZW1vdGVOb2Rlcy5sZW5ndGggJiYgaW5kZXhlc1tpXSA9PT0gcmVtb3RlTm9kZXNbMF0uaW5kZXgpIHtcbiAgICAgIG5vZGVzLnB1c2gocmVtb3RlTm9kZXNbMF0pXG4gICAgICBvbm5vZGUobnVsbCwgcmVtb3RlTm9kZXMuc2hpZnQoKSlcbiAgICB9IGVsc2UgaWYgKHRoaXMudHJlZS5nZXQoaW5kZXhlc1tpXSkpIHtcbiAgICAgIHRoaXMuX3N0b3JhZ2UuZ2V0Tm9kZShpbmRleGVzW2ldLCBvbm5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9ubm9kZShuZXcgRXJyb3IoJ01pc3NpbmcgdHJlZSByb290cyBuZWVkZWQgZm9yIHZlcmlmeScpKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubm9kZSAoZXJyLCBub2RlKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAobm9kZSkgcm9vdHNbaW5kZXhlcy5pbmRleE9mKG5vZGUuaW5kZXgpXSA9IG5vZGVcbiAgICBpZiAoIS0tcGVuZGluZykgZG9uZShlcnJvcilcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBjYihudWxsLCByb290cywgbm9kZXMpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX2Fubm91bmNlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGZyb20pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBlZXIgPSB0aGlzLnBlZXJzW2ldXG4gICAgaWYgKHBlZXIgIT09IGZyb20pIHBlZXIuaGF2ZShtZXNzYWdlKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl91bmFubm91bmNlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlZXJzLmxlbmd0aDsgaSsrKSB0aGlzLnBlZXJzW2ldLnVuaGF2ZShtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS5kb3dubG9hZGVkID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMuYml0ZmllbGQudG90YWwoc3RhcnQsIGVuZClcbn1cblxuRmVlZC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5iaXRmaWVsZC5nZXQoc3RhcnQpXG4gIHZhciB0b3RhbCA9IGVuZCAtIHN0YXJ0XG4gIHJldHVybiB0b3RhbCA9PT0gdGhpcy5iaXRmaWVsZC50b3RhbChzdGFydCwgZW5kKVxufVxuXG5GZWVkLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuaGVhZCh7fSwgb3B0cylcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkgY2IobmV3IEVycm9yKCdmZWVkIGlzIGVtcHR5JykpXG4gICAgZWxzZSBzZWxmLmdldChzZWxmLmxlbmd0aCAtIDEsIGNiKVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZ2V0KGluZGV4LCBudWxsLCBvcHRzKVxuICBpZiAoIXRoaXMub3BlbmVkKSByZXR1cm4gdGhpcy5fcmVhZHlBbmRHZXQoaW5kZXgsIG9wdHMsIGNiKVxuXG4gIGlmIChvcHRzICYmIG9wdHMudGltZW91dCkgY2IgPSB0aW1lb3V0Q2FsbGJhY2soY2IsIG9wdHMudGltZW91dClcblxuICBpZiAoIXRoaXMuYml0ZmllbGQuZ2V0KGluZGV4KSkge1xuICAgIGlmIChvcHRzICYmIG9wdHMud2FpdCA9PT0gZmFsc2UpIHJldHVybiBjYihuZXcgRXJyb3IoJ0Jsb2NrIG5vdCBkb3dubG9hZGVkJykpXG5cbiAgICB0aGlzLl93YWl0aW5nLnB1c2goe2J5dGVzOiAwLCBoYXNoOiBmYWxzZSwgaW5kZXg6IGluZGV4LCBvcHRpb25zOiBvcHRzLCBjYWxsYmFjazogY2J9KVxuICAgIHRoaXMuX3VwZGF0ZVBlZXJzKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChvcHRzICYmIG9wdHMudmFsdWVFbmNvZGluZykgY2IgPSB3cmFwQ29kZWModG9Db2RlYyhvcHRzLnZhbHVlRW5jb2RpbmcpLCBjYilcbiAgZWxzZSBpZiAodGhpcy5fY29kZWMgIT09IGNvZGVjcy5iaW5hcnkpIGNiID0gd3JhcENvZGVjKHRoaXMuX2NvZGVjLCBjYilcblxuICB0aGlzLl9nZXRCdWZmZXIoaW5kZXgsIGNiKVxufVxuXG5GZWVkLnByb3RvdHlwZS5fcmVhZHlBbmRHZXQgPSBmdW5jdGlvbiAoaW5kZXgsIG9wdHMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBzZWxmLmdldChpbmRleCwgb3B0cywgY2IpXG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLl91cGRhdGVQZWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlZXJzLmxlbmd0aDsgaSsrKSB0aGlzLnBlZXJzW2ldLnVwZGF0ZSgpXG59XG5cbkZlZWQucHJvdG90eXBlLmNyZWF0ZVdyaXRlU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIGJ1bGsub2JqKHdyaXRlKVxuXG4gIGZ1bmN0aW9uIHdyaXRlIChiYXRjaCwgY2IpIHtcbiAgICBzZWxmLl9iYXRjaChiYXRjaCwgY2IpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuY3JlYXRlUmVhZFN0cmVhbSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBzdGFydCA9IG9wdHMuc3RhcnQgfHwgMFxuICB2YXIgZW5kID0gdHlwZW9mIG9wdHMuZW5kID09PSAnbnVtYmVyJyA/IG9wdHMuZW5kIDogLTFcbiAgdmFyIGxpdmUgPSAhIW9wdHMubGl2ZVxuICB2YXIgc25hcHNob3QgPSBvcHRzLnNuYXBzaG90ICE9PSBmYWxzZVxuICB2YXIgZmlyc3QgPSB0cnVlXG4gIHZhciByYW5nZSA9IHRoaXMuZG93bmxvYWQoe3N0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGxpbmVhcjogdHJ1ZX0pXG5cbiAgcmV0dXJuIGZyb20ub2JqKHJlYWQpLm9uKCdlbmQnLCBjbGVhbnVwKS5vbignY2xvc2UnLCBjbGVhbnVwKVxuXG4gIGZ1bmN0aW9uIHJlYWQgKHNpemUsIGNiKSB7XG4gICAgaWYgKCFzZWxmLm9wZW5lZCkgcmV0dXJuIG9wZW4oc2l6ZSwgY2IpXG5cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIGlmIChsaXZlKSBlbmQgPSBJbmZpbml0eVxuICAgICAgICBlbHNlIGlmIChzbmFwc2hvdCkgZW5kID0gc2VsZi5sZW5ndGhcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnRhaWwpIHN0YXJ0ID0gc2VsZi5sZW5ndGhcbiAgICAgIGZpcnN0ID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAoZW5kID09PSAtMSAmJiBzdGFydCA9PT0gc2VsZi5sZW5ndGgpKSByZXR1cm4gY2IobnVsbCwgbnVsbClcbiAgICBzZWxmLmdldChzdGFydCsrLCBvcHRzLCBjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIGlmICghcmFuZ2UpIHJldHVyblxuICAgIHNlbGYudW5kb3dubG9hZChyYW5nZSlcbiAgICByYW5nZSA9IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW4gKHNpemUsIGNiKSB7XG4gICAgc2VsZi5fcmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJlYWQoc2l6ZSwgY2IpXG4gICAgfSlcbiAgfVxufVxuXG4vLyBUT0RPOiB3aGVuIGNhbGxpbmcgZmluYWxpemUgb24gYSBsaXZlIGZlZWQgd3JpdGUgYW4gRU5EX09GX0ZFRUQgYmxvY2sgKGxlbmd0aCA9PT0gMD8pXG5GZWVkLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAoIXRoaXMua2V5KSB7XG4gICAgdGhpcy5rZXkgPSBjcnlwdG8udHJlZSh0aGlzLl9tZXJrbGUucm9vdHMpXG4gICAgdGhpcy5kaXNjb3ZlcnlLZXkgPSBjcnlwdG8uZGlzY292ZXJ5S2V5KHRoaXMua2V5KVxuICB9XG4gIHRoaXMuX3N0b3JhZ2Uua2V5LndyaXRlKDAsIHRoaXMua2V5LCBjYilcbn1cblxuRmVlZC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGJhdGNoLCBjYikge1xuICB0aGlzLl9iYXRjaChBcnJheS5pc0FycmF5KGJhdGNoKSA/IGJhdGNoIDogW2JhdGNoXSwgY2IgfHwgbm9vcClcbn1cblxuRmVlZC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgdGhpcy5fYmF0Y2goW10sIGNiKVxufVxuXG5GZWVkLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLl9yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IGZhbHNlXG4gICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlXG4gICAgc2VsZi5fc3RvcmFnZS5jbG9zZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIXNlbGYuY2xvc2VkICYmICFlcnIpIHtcbiAgICAgICAgc2VsZi5jbG9zZWQgPSB0cnVlXG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICAgICAgfVxuICAgICAgaWYgKGNiKSBjYihlcnIpXG4gICAgfSlcbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUuX2FwcGVuZEhvb2sgPSBmdW5jdGlvbiAoYmF0Y2gsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgbWlzc2luZyA9IGJhdGNoLmxlbmd0aFxuICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgaWYgKCFtaXNzaW5nKSByZXR1cm4gdGhpcy5fYXBwZW5kKGJhdGNoLCBjYilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaC5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX29ud3JpdGUoaSArIHRoaXMubGVuZ3RoLCBiYXRjaFtpXSwgbnVsbCwgZG9uZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKC0tbWlzc2luZykgcmV0dXJuXG4gICAgaWYgKGVycm9yKSByZXR1cm4gY2IoZXJyb3IpXG4gICAgc2VsZi5fYXBwZW5kKGJhdGNoLCBjYilcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fYXBwZW5kID0gZnVuY3Rpb24gKGJhdGNoLCBjYikge1xuICBpZiAoIXRoaXMub3BlbmVkKSByZXR1cm4gdGhpcy5fcmVhZHlBbmRBcHBlbmQoYmF0Y2gsIGNiKVxuICBpZiAoIXRoaXMud3JpdGFibGUpIHJldHVybiBjYihuZXcgRXJyb3IoJ1RoaXMgZmVlZCBpcyBub3Qgd3JpdGFibGUuIERpZCB5b3UgY3JlYXRlIGl0PycpKVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcGVuZGluZyA9IHRoaXMubGl2ZSAmJiBiYXRjaC5sZW5ndGggPyAxICsgYmF0Y2gubGVuZ3RoIDogYmF0Y2gubGVuZ3RoXG4gIHZhciBvZmZzZXQgPSAwXG4gIHZhciBlcnJvciA9IG51bGxcblxuICBpZiAoIXBlbmRpbmcpIHJldHVybiBjYigpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkYXRhID0gdGhpcy5fY29kZWMuZW5jb2RlKGJhdGNoW2ldKVxuICAgIHZhciBub2RlcyA9IHRoaXMuX21lcmtsZS5uZXh0KGRhdGEpXG5cbiAgICBpZiAodGhpcy5faW5kZXhpbmcpIGRvbmUobnVsbClcbiAgICBlbHNlIHRoaXMuX3N0b3JhZ2UuZGF0YS53cml0ZSh0aGlzLmJ5dGVMZW5ndGggKyBvZmZzZXQsIGRhdGEsIGRvbmUpXG5cbiAgICBpZiAodGhpcy5saXZlICYmIGkgPT09IGJhdGNoLmxlbmd0aCAtIDEpIHtcbiAgICAgIHZhciBzaWcgPSBjcnlwdG8uc2lnbihjcnlwdG8udHJlZSh0aGlzLl9tZXJrbGUucm9vdHMpLCB0aGlzLnNlY3JldEtleSlcbiAgICAgIHRoaXMuX3N0b3JhZ2UucHV0U2lnbmF0dXJlKHRoaXMubGVuZ3RoICsgaSwgc2lnLCBkb25lKVxuICAgIH1cblxuICAgIHBlbmRpbmcgKz0gbm9kZXMubGVuZ3RoXG4gICAgb2Zmc2V0ICs9IGRhdGEubGVuZ3RoXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2pdXG4gICAgICB0aGlzLl9zdG9yYWdlLnB1dE5vZGUobm9kZS5pbmRleCwgbm9kZSwgZG9uZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmICgtLXBlbmRpbmcpIHJldHVyblxuICAgIGlmIChlcnJvcikgcmV0dXJuIGNiKGVycm9yKVxuXG4gICAgdmFyIHN0YXJ0ID0gc2VsZi5sZW5ndGhcblxuICAgIC8vIFRPRE86IG9ubHkgZW1pdCBhcHBlbmQgYW5kIHVwZGF0ZSBsZW5ndGggLyBieXRlTGVuZ3RoIGFmdGVyIHRoZSBpbmZvIGhhcyBiZWVuIGZsdXNoZWQgdG8gc3RvcmFnZVxuICAgIHNlbGYuYnl0ZUxlbmd0aCArPSBvZmZzZXRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxmLmJpdGZpZWxkLnNldChzZWxmLmxlbmd0aCwgdHJ1ZSlcbiAgICAgIHNlbGYudHJlZS5zZXQoMiAqIHNlbGYubGVuZ3RoKyspXG4gICAgfVxuICAgIHNlbGYuZW1pdCgnYXBwZW5kJylcblxuICAgIHZhciBtZXNzYWdlID0gc2VsZi5sZW5ndGggLSBzdGFydCA+IDEgPyB7c3RhcnQ6IHN0YXJ0LCBsZW5ndGg6IHNlbGYubGVuZ3RoIC0gc3RhcnR9IDoge3N0YXJ0OiBzdGFydH1cbiAgICBpZiAoc2VsZi5wZWVycy5sZW5ndGgpIHNlbGYuX2Fubm91bmNlKG1lc3NhZ2UpXG5cbiAgICBzZWxmLl9zeW5jKG51bGwsIGNiKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9yZWFkeUFuZEFwcGVuZCA9IGZ1bmN0aW9uIChiYXRjaCwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHNlbGYuX2FwcGVuZChiYXRjaCwgY2IpXG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLl9yZWFkeUFuZENhbmNlbCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9jYW5jZWwoc3RhcnQsIGVuZClcbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUuX3BvbGxXYWl0aW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuID0gdGhpcy5fd2FpdGluZy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBuZXh0ID0gdGhpcy5fd2FpdGluZ1tpXVxuICAgIGlmICghbmV4dC5ieXRlcyAmJiAhdGhpcy5iaXRmaWVsZC5nZXQobmV4dC5pbmRleCkpIGNvbnRpbnVlXG5cbiAgICByZW1vdmUodGhpcy5fd2FpdGluZywgaS0tKVxuICAgIGxlbi0tXG5cbiAgICBpZiAobmV4dC5ieXRlcykgdGhpcy5zZWVrKG5leHQuYnl0ZXMsIG5leHQsIG5leHQuY2FsbGJhY2spXG4gICAgZWxzZSBpZiAobmV4dC51cGRhdGUpIHRoaXMudXBkYXRlKG5leHQuaW5kZXggKyAxLCBuZXh0LmNhbGxiYWNrKVxuICAgIGVsc2UgdGhpcy5nZXQobmV4dC5pbmRleCwgbmV4dC5vcHRpb25zLCBuZXh0LmNhbGxiYWNrKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9zeW5jQml0ZmllbGQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIG1pc3NpbmcgPSB0aGlzLmJpdGZpZWxkLnBhZ2VzLnVwZGF0ZXMubGVuZ3RoXG4gIHZhciBuZXh0ID0gbnVsbFxuICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgLy8gQWxsIGRhdGEgLyBub2RlcyBoYXZlIGJlZW4gd3JpdHRlbiBub3cuIFdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIHRoZSBiaXRmaWVsZHMgdGhvdWdoXG5cbiAgLy8gVE9ETyAxOiBpZiB0aGUgcHJvZ3JhbSBmYWlscyBkdXJpbmcgdGhpcyB3cml0ZSB0aGUgYml0ZmllbGQgbWlnaHQgbm90IGhhdmUgYmVlbiBmdWxseSB3cml0dGVuXG4gIC8vIEhPV0VWRVIsIHdlIGNhbiBlYXNpbHkgcmVjb3ZlciBmcm9tIHRoaXMgYnkgdHJhdmVyc2luZyB0aGUgdHJlZSBhbmQgY2hlY2tpbmcgaWYgdGhlIG5vZGVzIGV4aXN0c1xuICAvLyBvbiBkaXNrLiBTbyBpZiBhIGdldCBmYWlscywgaXQgc2hvdWxkIHRyeSBhbmQgcmVjb3ZlciBvbmNlLlxuXG4gIC8vIFRPRE8gMjogaWYgLndyaXRhYmxlIGFwcGVuZCBiaXRmaWVsZCB1cGRhdGVzIGludG8gYSBzaW5nbGUgYnVmZmVyIGZvciBleHRyYSBwZXJmXG4gIC8vIEFkZGVkIGJlbmVmaXQgaXMgdGhhdCBpZiB0aGUgcHJvZ3JhbSBleGl0cyB3aGlsZSBmbHVzaGluZyB0aGUgYml0ZmllbGQgdGhlIGZlZWQgd2lsbCBvbmx5IGdldFxuICAvLyB0cnVuY2F0ZWQgYW5kIG5vdCBoYXZlIG1pc3NpbmcgY2h1bmtzIHdoaWNoIGlzIHdoYXQgeW91IGV4cGVjdC5cblxuICBpZiAoIW1pc3NpbmcpIHtcbiAgICB0aGlzLl9wb2xsV2FpdGluZygpXG4gICAgcmV0dXJuIGNiKG51bGwpXG4gIH1cblxuICB3aGlsZSAoKG5leHQgPSB0aGlzLmJpdGZpZWxkLnBhZ2VzLmxhc3RVcGRhdGUoKSkgIT09IG51bGwpIHtcbiAgICB0aGlzLl9zdG9yYWdlLnB1dEJpdGZpZWxkKG5leHQub2Zmc2V0LCBuZXh0LmJ1ZmZlciwgb25kb25lKVxuICB9XG5cbiAgdGhpcy5fcG9sbFdhaXRpbmcoKVxuXG4gIGZ1bmN0aW9uIG9uZG9uZSAoZXJyKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAoLS1taXNzaW5nKSByZXR1cm5cbiAgICBjYihlcnJvcilcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fcm9vdHMgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIHZhciByb290cyA9IGZsYXQuZnVsbFJvb3RzKDIgKiBpbmRleClcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShyb290cy5sZW5ndGgpXG4gIHZhciBwZW5kaW5nID0gcm9vdHMubGVuZ3RoXG4gIHZhciBlcnJvciA9IG51bGxcblxuICBpZiAoIXBlbmRpbmcpIHJldHVybiBjYihudWxsLCByZXN1bHQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290cy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX3N0b3JhZ2UuZ2V0Tm9kZShyb290c1tpXSwgb25ub2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gb25ub2RlIChlcnIsIG5vZGUpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmIChub2RlKSByZXN1bHRbcm9vdHMuaW5kZXhPZihub2RlLmluZGV4KV0gPSBub2RlXG4gICAgaWYgKC0tcGVuZGluZykgcmV0dXJuXG4gICAgaWYgKGVycm9yKSByZXR1cm4gY2IoZXJyb3IpXG4gICAgY2IobnVsbCwgcmVzdWx0KVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gdmVyaWZ5Tm9kZSAodHJ1c3RlZCwgbm9kZSkge1xuICByZXR1cm4gdHJ1c3RlZCAmJiB0cnVzdGVkLmluZGV4ID09PSBub2RlLmluZGV4ICYmIGVxdWFscyh0cnVzdGVkLmhhc2gsIG5vZGUuaGFzaClcbn1cblxuZnVuY3Rpb24gYWRkU2l6ZSAoc2l6ZSwgbm9kZSkge1xuICByZXR1cm4gc2l6ZSArIG5vZGUuc2l6ZVxufVxuXG5mdW5jdGlvbiBpc0Jsb2NrIChpbmRleCkge1xuICByZXR1cm4gKGluZGV4ICYgMSkgPT09IDBcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFN0b3JhZ2UgKGRpcikge1xuICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gcmFmKG5hbWUsIHtkaXJlY3Rvcnk6IGRpcn0pXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9Db2RlYyAoZW5jKSB7XG4gIC8vIFN3aXRjaCB0byBuZGpzb24gZW5jb2RpbmcgaWYgSlNPTiBpcyB1c2VkLiBUaGF0IHdheSBkYXRhIGZpbGVzIHBhcnNlIGxpa2UgbmRqc29uIFxcby9cbiAgcmV0dXJuIGNvZGVjcyhlbmMgPT09ICdqc29uJyA/ICduZGpzb24nIDogZW5jKVxufVxuXG5mdW5jdGlvbiB3cmFwQ29kZWMgKGVuYywgY2IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGJ1Zikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgdHJ5IHtcbiAgICAgIGJ1ZiA9IGVuYy5kZWNvZGUoYnVmKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycilcbiAgICB9XG4gICAgY2IobnVsbCwgYnVmKVxuICB9XG59XG5cbmZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjayAoY2IsIHRpbWVvdXQpIHtcbiAgdmFyIGZhaWxlZCA9IGZhbHNlXG4gIHZhciBpZCA9IHNldFRpbWVvdXQob250aW1lb3V0LCB0aW1lb3V0KVxuICByZXR1cm4gZG9uZVxuXG4gIGZ1bmN0aW9uIG9udGltZW91dCAoKSB7XG4gICAgZmFpbGVkID0gdHJ1ZVxuICAgIC8vIFRPRE86IG1ha2UgbGlicy9lcnJvcnMgZm9yIGFsbCB0aGlzIHN0dWZmXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignRVRJTUVET1VUJylcbiAgICBlcnIuY29kZSA9ICdFVElNRURPVVQnXG4gICAgY2IoZXJyKVxuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyLCB2YWwpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm5cbiAgICBjbGVhclRpbWVvdXQoaWQpXG4gICAgY2IoZXJyLCB2YWwpXG4gIH1cbn1cblxuLy8gYnVmZmVyLWVxdWFscywgYnV0IGhhbmRsZSAnbnVsbCcgYnVmZmVyIHBhcmFtZXRlcnMuXG5mdW5jdGlvbiBzYWZlQnVmZmVyRXF1YWxzIChhLCBiKSB7XG4gIGlmICghYSkgcmV0dXJuICFiXG4gIGlmICghYikgcmV0dXJuICFhXG4gIHJldHVybiBlcXVhbHMoYSwgYilcbn1cbiIsInZhciBmbGF0ID0gcmVxdWlyZSgnZmxhdC10cmVlJylcbnZhciBybGUgPSByZXF1aXJlKCdiaXRmaWVsZC1ybGUnKVxudmFyIHBhZ2VyID0gcmVxdWlyZSgnbWVtb3J5LXBhZ2VyJylcbnZhciBiaXRmaWVsZCA9IHJlcXVpcmUoJ3NwYXJzZS1iaXRmaWVsZCcpXG5cbnZhciBJTkRFWF9VUERBVEVfTUFTSyA9IFs2MywgMjA3LCAyNDMsIDI1Ml1cbnZhciBJTkRFWF9JVEVSQVRFX01BU0sgPSBbMCwgMTkyLCAyNDAsIDI1Ml1cbnZhciBEQVRBX0lURVJBVEVfTUFTSyA9IFsxMjgsIDE5MiwgMjI0LCAyNDAsIDI0OCwgMjUyLCAyNTQsIDI1NV1cbnZhciBEQVRBX1VQREFURV9NQVNLID0gWzEyNywgMTkxLCAyMjMsIDIzOSwgMjQ3LCAyNTEsIDI1MywgMjU0XVxudmFyIE1BUF9QQVJFTlRfUklHSFQgPSBuZXcgQXJyYXkoMjU2KVxudmFyIE1BUF9QQVJFTlRfTEVGVCA9IG5ldyBBcnJheSgyNTYpXG52YXIgTkVYVF9EQVRBXzBfQklUID0gbmV3IEFycmF5KDI1NilcbnZhciBORVhUX0lOREVYXzBfQklUID0gbmV3IEFycmF5KDI1NilcbnZhciBUT1RBTF8xX0JJVFMgPSBuZXcgQXJyYXkoMjU2KVxuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIHZhciBhID0gKGkgJiAoMTUgPDwgNCkpID4+IDRcbiAgdmFyIGIgPSBpICYgMTVcbiAgdmFyIG5pYmJsZSA9IFswLCAxLCAxLCAyLCAxLCAyLCAyLCAzLCAxLCAyLCAyLCAzLCAyLCAzLCAzLCA0XVxuICBNQVBfUEFSRU5UX1JJR0hUW2ldID0gKChhID09PSAxNSA/IDMgOiBhID09PSAwID8gMCA6IDEpIDw8IDIpIHwgKGIgPT09IDE1ID8gMyA6IGIgPT09IDAgPyAwIDogMSlcbiAgTUFQX1BBUkVOVF9MRUZUW2ldID0gTUFQX1BBUkVOVF9SSUdIVFtpXSA8PCA0XG4gIE5FWFRfREFUQV8wX0JJVFtpXSA9IGkgPT09IDI1NSA/IC0xIDogKDggLSBNYXRoLmNlaWwoTWF0aC5sb2coMjU2IC0gaSkgLyBNYXRoLmxvZygyKSkpXG4gIE5FWFRfSU5ERVhfMF9CSVRbaV0gPSBpID09PSAyNTUgPyAtMSA6IE1hdGguZmxvb3IoTkVYVF9EQVRBXzBfQklUW2ldIC8gMilcbiAgVE9UQUxfMV9CSVRTW2ldID0gbmliYmxlW2kgPj4gNF0gKyBuaWJibGVbaSAmIDB4MEZdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQml0ZmllbGRcblxuZnVuY3Rpb24gQml0ZmllbGQgKGJ1ZmZlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQml0ZmllbGQpKSByZXR1cm4gbmV3IEJpdGZpZWxkKGJ1ZmZlcilcblxuICB0aGlzLnBhZ2VzID0gcGFnZXIoMzMyOClcblxuICBpZiAoYnVmZmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDMzMjgpIHtcbiAgICAgIHRoaXMucGFnZXMuc2V0KGkgLyAzMzI4LCBidWZmZXIuc2xpY2UoaSwgaSArIDMzMjgpKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZGF0YSA9IGJpdGZpZWxkKHtcbiAgICBwYWdlU2l6ZTogMTAyNCxcbiAgICBwYWdlT2Zmc2V0OiAwLFxuICAgIHBhZ2VzOiB0aGlzLnBhZ2VzLFxuICAgIHRyYWNrVXBkYXRlczogdHJ1ZVxuICB9KVxuXG4gIHRoaXMudHJlZSA9IGJpdGZpZWxkKHtcbiAgICBwYWdlU2l6ZTogMjA0OCxcbiAgICBwYWdlT2Zmc2V0OiAxMDI0LFxuICAgIHBhZ2VzOiB0aGlzLnBhZ2VzLFxuICAgIHRyYWNrVXBkYXRlczogdHJ1ZVxuICB9KVxuXG4gIHRoaXMuaW5kZXggPSBiaXRmaWVsZCh7XG4gICAgcGFnZVNpemU6IDI1NixcbiAgICBwYWdlT2Zmc2V0OiAxMDI0ICsgMjA0OCxcbiAgICBwYWdlczogdGhpcy5wYWdlcyxcbiAgICB0cmFja1VwZGF0ZXM6IHRydWVcbiAgfSlcblxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGhcbiAgdGhpcy5faXRlcmF0b3IgPSBmbGF0Lml0ZXJhdG9yKDApXG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaSwgdmFsdWUpIHtcbiAgdmFyIG8gPSBpICYgN1xuICBpID0gKGkgLSBvKSAvIDhcbiAgdmFyIHYgPSB2YWx1ZSA/IHRoaXMuZGF0YS5nZXRCeXRlKGkpIHwgKDEyOCA+PiBvKSA6IHRoaXMuZGF0YS5nZXRCeXRlKGkpICYgREFUQV9VUERBVEVfTUFTS1tvXVxuXG4gIGlmICghdGhpcy5kYXRhLnNldEJ5dGUoaSwgdikpIHJldHVybiBmYWxzZVxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGhcbiAgdGhpcy5fc2V0SW5kZXgoaSwgdilcbiAgcmV0dXJuIHRydWVcbn1cblxuQml0ZmllbGQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuZ2V0KGkpXG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS50b3RhbCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMuZGF0YS5sZW5ndGhcbiAgaWYgKGVuZCA8IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAoZW5kID4gdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgIHRoaXMuX2V4cGFuZChlbmQpXG4gIH1cbiAgdmFyIG8gPSBzdGFydCAmIDdcbiAgdmFyIGUgPSBlbmQgJiA3XG4gIHZhciBwb3MgPSAoc3RhcnQgLSBvKSAvIDhcbiAgdmFyIGxhc3QgPSAoZW5kIC0gZSkgLyA4XG4gIHZhciBsZWZ0TWFzayA9ICgyNTUgLSAobyA/IERBVEFfSVRFUkFURV9NQVNLW28gLSAxXSA6IDApKVxuICB2YXIgcmlnaHRNYXNrID0gKGUgPyBEQVRBX0lURVJBVEVfTUFTS1tlIC0gMV0gOiAwKVxuICB2YXIgYnl0ZSA9IHRoaXMuZGF0YS5nZXRCeXRlKHBvcylcbiAgaWYgKHBvcyA9PT0gbGFzdCkge1xuICAgIHJldHVybiBUT1RBTF8xX0JJVFNbYnl0ZSAmIGxlZnRNYXNrICYgcmlnaHRNYXNrXVxuICB9XG4gIHZhciB0b3RhbCA9IFRPVEFMXzFfQklUU1tieXRlICYgbGVmdE1hc2tdXG4gIGZvciAodmFyIGkgPSBwb3MgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgdG90YWwgKz0gVE9UQUxfMV9CSVRTW3RoaXMuZGF0YS5nZXRCeXRlKGkpXVxuICB9XG4gIHRvdGFsICs9IFRPVEFMXzFfQklUU1t0aGlzLmRhdGEuZ2V0Qnl0ZShsYXN0KSAmIHJpZ2h0TWFza11cbiAgcmV0dXJuIHRvdGFsXG59XG5cbi8vIFRPRE86IHVzZSB0aGUgaW5kZXggdG8gc3BlZWQgdGhpcyB1cCAqYSBsb3QqXG5CaXRmaWVsZC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBybGUuZW5jb2RlKHRoaXMuZGF0YS50b0J1ZmZlcigpKVxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUuX3NldEluZGV4ID0gZnVuY3Rpb24gKGksIHZhbHVlKSB7XG4gIC8vICAgICAgICAgICAgICAgICAgICAoYSArIGIgfCBjICsgZCB8IGUgKyBmIHwgZyArIGgpXG4gIC8vIC0+IChhIHwgYiB8IGMgfCBkKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUgfCBmIHwgZyB8IGgpXG4gIC8vXG5cbiAgdmFyIG8gPSBpICYgM1xuICBpID0gKGkgLSBvKSAvIDRcblxuICB2YXIgYml0ZmllbGQgPSB0aGlzLmluZGV4XG4gIHZhciBpdGUgPSB0aGlzLl9pdGVyYXRvclxuICB2YXIgc3RhcnQgPSAyICogaVxuICB2YXIgYnl0ZSA9IChiaXRmaWVsZC5nZXRCeXRlKHN0YXJ0KSAmIElOREVYX1VQREFURV9NQVNLW29dKSB8IChnZXRJbmRleFZhbHVlKHZhbHVlKSA+PiAoMiAqIG8pKVxuICB2YXIgbGVuID0gYml0ZmllbGQubGVuZ3RoXG4gIHZhciBtYXhMZW5ndGggPSB0aGlzLnBhZ2VzLmxlbmd0aCAqIDI1NlxuXG4gIGl0ZS5zZWVrKHN0YXJ0KVxuXG4gIHdoaWxlIChpdGUuaW5kZXggPCBtYXhMZW5ndGggJiYgYml0ZmllbGQuc2V0Qnl0ZShpdGUuaW5kZXgsIGJ5dGUpKSB7XG4gICAgaWYgKGl0ZS5pc0xlZnQoKSkge1xuICAgICAgYnl0ZSA9IE1BUF9QQVJFTlRfTEVGVFtieXRlXSB8IE1BUF9QQVJFTlRfUklHSFRbYml0ZmllbGQuZ2V0Qnl0ZShpdGUuc2libGluZygpKV1cbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZSA9IE1BUF9QQVJFTlRfUklHSFRbYnl0ZV0gfCBNQVBfUEFSRU5UX0xFRlRbYml0ZmllbGQuZ2V0Qnl0ZShpdGUuc2libGluZygpKV1cbiAgICB9XG4gICAgaXRlLnBhcmVudCgpXG4gIH1cblxuICBpZiAobGVuICE9PSBiaXRmaWVsZC5sZW5ndGgpIHRoaXMuX2V4cGFuZChsZW4pXG5cbiAgcmV0dXJuIGl0ZS5pbmRleCAhPT0gc3RhcnRcbn1cblxuQml0ZmllbGQucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiAobGVuKSB7XG4gIHZhciByb290cyA9IGZsYXQuZnVsbFJvb3RzKDIgKiBsZW4pXG4gIHZhciBiaXRmaWVsZCA9IHRoaXMuaW5kZXhcbiAgdmFyIGl0ZSA9IHRoaXMuX2l0ZXJhdG9yXG4gIHZhciBieXRlID0gMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICBpdGUuc2Vlayhyb290c1tpXSlcbiAgICBieXRlID0gYml0ZmllbGQuZ2V0Qnl0ZShpdGUuaW5kZXgpXG5cbiAgICBkbyB7XG4gICAgICBpZiAoaXRlLmlzTGVmdCgpKSB7XG4gICAgICAgIGJ5dGUgPSBNQVBfUEFSRU5UX0xFRlRbYnl0ZV0gfCBNQVBfUEFSRU5UX1JJR0hUW2JpdGZpZWxkLmdldEJ5dGUoaXRlLnNpYmxpbmcoKSldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBieXRlID0gTUFQX1BBUkVOVF9SSUdIVFtieXRlXSB8IE1BUF9QQVJFTlRfTEVGVFtiaXRmaWVsZC5nZXRCeXRlKGl0ZS5zaWJsaW5nKCkpXVxuICAgICAgfVxuICAgIH0gd2hpbGUgKHNldEJ5dGVOb0FsbG9jKGJpdGZpZWxkLCBpdGUucGFyZW50KCksIGJ5dGUpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEJ5dGVOb0FsbG9jIChiaXRmaWVsZCwgaSwgYikge1xuICBpZiAoOCAqIGkgPj0gYml0ZmllbGQubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGJpdGZpZWxkLnNldEJ5dGUoaSwgYilcbn1cblxuQml0ZmllbGQucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGl0ZSA9IG5ldyBJdGVyYXRvcih0aGlzKVxuXG4gIGl0ZS5yYW5nZShzdGFydCB8fCAwLCBlbmQgfHwgdGhpcy5sZW5ndGgpXG4gIGl0ZS5zZWVrKDApXG5cbiAgcmV0dXJuIGl0ZVxufVxuXG5mdW5jdGlvbiBJdGVyYXRvciAoYml0ZmllbGQpIHtcbiAgdGhpcy5zdGFydCA9IDBcbiAgdGhpcy5lbmQgPSAwXG5cbiAgdGhpcy5faW5kZXhFbmQgPSAwXG4gIHRoaXMuX3BvcyA9IDBcbiAgdGhpcy5fYnl0ZSA9IDBcbiAgdGhpcy5fYml0ZmllbGQgPSBiaXRmaWVsZFxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB0aGlzLnN0YXJ0ID0gc3RhcnRcbiAgdGhpcy5lbmQgPSBlbmRcbiAgdGhpcy5faW5kZXhFbmQgPSAyICogTWF0aC5jZWlsKGVuZCAvIDMyKVxuXG4gIGlmICh0aGlzLmVuZCA+IHRoaXMuX2JpdGZpZWxkLmxlbmd0aCkge1xuICAgIHRoaXMuX2JpdGZpZWxkLl9leHBhbmQodGhpcy5lbmQpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgb2Zmc2V0ICs9IHRoaXMuc3RhcnRcbiAgaWYgKG9mZnNldCA8IHRoaXMuc3RhcnQpIG9mZnNldCA9IHRoaXMuc3RhcnRcblxuICBpZiAob2Zmc2V0ID49IHRoaXMuZW5kKSB7XG4gICAgdGhpcy5fcG9zID0gLTFcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG8gPSBvZmZzZXQgJiA3XG5cbiAgdGhpcy5fcG9zID0gKG9mZnNldCAtIG8pIC8gOFxuICB0aGlzLl9ieXRlID0gdGhpcy5fYml0ZmllbGQuZGF0YS5nZXRCeXRlKHRoaXMuX3BvcykgfCAobyA/IERBVEFfSVRFUkFURV9NQVNLW28gLSAxXSA6IDApXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLnJhbmRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSB0aGlzLnNlZWsoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkpKS5uZXh0KClcbiAgcmV0dXJuIGkgPT09IC0xID8gdGhpcy5zZWVrKDApLm5leHQoKSA6IGlcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9wb3MgPT09IC0xKSByZXR1cm4gLTFcblxuICB2YXIgZGF0YUJpdGZpZWxkID0gdGhpcy5fYml0ZmllbGQuZGF0YVxuICB2YXIgZnJlZSA9IE5FWFRfREFUQV8wX0JJVFt0aGlzLl9ieXRlXVxuXG4gIHdoaWxlIChmcmVlID09PSAtMSkge1xuICAgIHRoaXMuX2J5dGUgPSBkYXRhQml0ZmllbGQuZ2V0Qnl0ZSgrK3RoaXMuX3BvcylcbiAgICBmcmVlID0gTkVYVF9EQVRBXzBfQklUW3RoaXMuX2J5dGVdXG5cbiAgICBpZiAoZnJlZSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX3BvcyA9IHRoaXMuX3NraXBBaGVhZCh0aGlzLl9wb3MpXG4gICAgICBpZiAodGhpcy5fcG9zID09PSAtMSkgcmV0dXJuIC0xXG5cbiAgICAgIHRoaXMuX2J5dGUgPSBkYXRhQml0ZmllbGQuZ2V0Qnl0ZSh0aGlzLl9wb3MpXG4gICAgICBmcmVlID0gTkVYVF9EQVRBXzBfQklUW3RoaXMuX2J5dGVdXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fYnl0ZSB8PSBEQVRBX0lURVJBVEVfTUFTS1tmcmVlXVxuXG4gIHZhciBuID0gOCAqIHRoaXMuX3BvcyArIGZyZWVcbiAgcmV0dXJuIG4gPCB0aGlzLmVuZCA/IG4gOiAtMVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3BvcyA9PT0gLTEpIHJldHVybiAtMVxuXG4gIHZhciBmcmVlID0gTkVYVF9EQVRBXzBfQklUW3RoaXMuX2J5dGVdXG4gIHZhciBuID0gOCAqIHRoaXMuX3BvcyArIGZyZWVcbiAgcmV0dXJuIG4gPCB0aGlzLmVuZCA/IG4gOiAtMVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUuX3NraXBBaGVhZCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICB2YXIgaW5kZXhCaXRmaWVsZCA9IHRoaXMuX2JpdGZpZWxkLmluZGV4XG4gIHZhciB0cmVlRW5kID0gdGhpcy5faW5kZXhFbmRcbiAgdmFyIGl0ZSA9IHRoaXMuX2JpdGZpZWxkLl9pdGVyYXRvclxuICB2YXIgbyA9IHN0YXJ0ICYgM1xuXG4gIGl0ZS5zZWVrKDIgKiAoKHN0YXJ0IC0gbykgLyA0KSlcblxuICB2YXIgdHJlZUJ5dGUgPSBpbmRleEJpdGZpZWxkLmdldEJ5dGUoaXRlLmluZGV4KSB8IElOREVYX0lURVJBVEVfTUFTS1tvXVxuXG4gIHdoaWxlIChORVhUX0lOREVYXzBfQklUW3RyZWVCeXRlXSA9PT0gLTEpIHtcbiAgICBpZiAoaXRlLmlzTGVmdCgpKSB7XG4gICAgICBpdGUubmV4dCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZS5uZXh0KClcbiAgICAgIGl0ZS5wYXJlbnQoKVxuICAgIH1cblxuICAgIGlmIChyaWdodFNwYW4oaXRlKSA+PSB0cmVlRW5kKSB7XG4gICAgICB3aGlsZSAocmlnaHRTcGFuKGl0ZSkgPj0gdHJlZUVuZCAmJiBpc1BhcmVudChpdGUpKSBpdGUubGVmdENoaWxkKClcbiAgICAgIGlmIChyaWdodFNwYW4oaXRlKSA+PSB0cmVlRW5kKSByZXR1cm4gLTFcbiAgICB9XG5cbiAgICB0cmVlQnl0ZSA9IGluZGV4Qml0ZmllbGQuZ2V0Qnl0ZShpdGUuaW5kZXgpXG4gIH1cblxuICB3aGlsZSAoaXRlLmZhY3RvciA+IDIpIHtcbiAgICBpZiAoTkVYVF9JTkRFWF8wX0JJVFt0cmVlQnl0ZV0gPCAyKSBpdGUubGVmdENoaWxkKClcbiAgICBlbHNlIGl0ZS5yaWdodENoaWxkKClcblxuICAgIHRyZWVCeXRlID0gaW5kZXhCaXRmaWVsZC5nZXRCeXRlKGl0ZS5pbmRleClcbiAgfVxuXG4gIHZhciBmcmVlID0gTkVYVF9JTkRFWF8wX0JJVFt0cmVlQnl0ZV1cbiAgaWYgKGZyZWUgPT09IC0xKSBmcmVlID0gNFxuXG4gIHZhciBuZXh0ID0gaXRlLmluZGV4ICogMiArIGZyZWVcblxuICByZXR1cm4gbmV4dCA8PSBzdGFydCA/IHN0YXJ0ICsgMSA6IG5leHRcbn1cblxuZnVuY3Rpb24gcmlnaHRTcGFuIChpdGUpIHtcbiAgcmV0dXJuIGl0ZS5pbmRleCArIGl0ZS5mYWN0b3IgLyAyIC0gMVxufVxuXG5mdW5jdGlvbiBpc1BhcmVudCAoaXRlKSB7XG4gIHJldHVybiBpdGUuaW5kZXggJiAxXG59XG5cbmZ1bmN0aW9uIGdldEluZGV4VmFsdWUgKG4pIHtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAyNTU6IHJldHVybiAxOTJcbiAgICBjYXNlIDA6IHJldHVybiAwXG4gICAgZGVmYXVsdDogcmV0dXJuIDY0XG4gIH1cbn1cbiIsInZhciBzb2RpdW0gPSByZXF1aXJlKCdzb2RpdW0tdW5pdmVyc2FsJylcbnZhciB1aW50NjRiZSA9IHJlcXVpcmUoJ3VpbnQ2NGJlJylcbnZhciBidWZmZXJGcm9tID0gcmVxdWlyZSgnYnVmZmVyLWZyb20nKVxudmFyIGJ1ZmZlckFsbG9jID0gcmVxdWlyZSgnYnVmZmVyLWFsbG9jLXVuc2FmZScpXG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lcmtsZV90cmVlI1NlY29uZF9wcmVpbWFnZV9hdHRhY2tcbnZhciBMRUFGX1RZUEUgPSBidWZmZXJGcm9tKFswXSlcbnZhciBQQVJFTlRfVFlQRSA9IGJ1ZmZlckZyb20oWzFdKVxudmFyIFJPT1RfVFlQRSA9IGJ1ZmZlckZyb20oWzJdKVxudmFyIEhZUEVSQ09SRSA9IGJ1ZmZlckZyb20oJ2h5cGVyY29yZScpXG5cbmV4cG9ydHMua2V5UGFpciA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gIHZhciBwdWJsaWNLZXkgPSBidWZmZXJBbGxvYyhzb2RpdW0uY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpXG4gIHZhciBzZWNyZXRLZXkgPSBidWZmZXJBbGxvYyhzb2RpdW0uY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG5cbiAgaWYgKHNlZWQpIHNvZGl1bS5jcnlwdG9fc2lnbl9zZWVkX2tleXBhaXIocHVibGljS2V5LCBzZWNyZXRLZXksIHNlZWQpXG4gIGVsc2Ugc29kaXVtLmNyeXB0b19zaWduX2tleXBhaXIocHVibGljS2V5LCBzZWNyZXRLZXkpXG5cbiAgcmV0dXJuIHtcbiAgICBwdWJsaWNLZXk6IHB1YmxpY0tleSxcbiAgICBzZWNyZXRLZXk6IHNlY3JldEtleVxuICB9XG59XG5cbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzZWNyZXRLZXkpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IGJ1ZmZlckFsbG9jKHNvZGl1bS5jcnlwdG9fc2lnbl9CWVRFUylcbiAgc29kaXVtLmNyeXB0b19zaWduX2RldGFjaGVkKHNpZ25hdHVyZSwgbWVzc2FnZSwgc2VjcmV0S2V5KVxuICByZXR1cm4gc2lnbmF0dXJlXG59XG5cbmV4cG9ydHMudmVyaWZ5ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gIHJldHVybiBzb2RpdW0uY3J5cHRvX3NpZ25fdmVyaWZ5X2RldGFjaGVkKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KVxufVxuXG5leHBvcnRzLmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gYmxha2UyYihbXG4gICAgTEVBRl9UWVBFLFxuICAgIGVuY29kZVVJbnQ2NChkYXRhLmxlbmd0aCksXG4gICAgZGF0YVxuICBdKVxufVxuXG5leHBvcnRzLmxlYWYgPSBmdW5jdGlvbiAobGVhZikge1xuICByZXR1cm4gZXhwb3J0cy5kYXRhKGxlYWYuZGF0YSlcbn1cblxuZXhwb3J0cy5wYXJlbnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICBpZiAoYS5pbmRleCA+IGIuaW5kZXgpIHtcbiAgICB2YXIgdG1wID0gYVxuICAgIGEgPSBiXG4gICAgYiA9IHRtcFxuICB9XG5cbiAgcmV0dXJuIGJsYWtlMmIoW1xuICAgIFBBUkVOVF9UWVBFLFxuICAgIGVuY29kZVVJbnQ2NChhLnNpemUgKyBiLnNpemUpLFxuICAgIGEuaGFzaCxcbiAgICBiLmhhc2hcbiAgXSlcbn1cblxuZXhwb3J0cy50cmVlID0gZnVuY3Rpb24gKHJvb3RzKSB7XG4gIHZhciBidWZmZXJzID0gbmV3IEFycmF5KDMgKiByb290cy5sZW5ndGggKyAxKVxuICB2YXIgaiA9IDBcblxuICBidWZmZXJzW2orK10gPSBST09UX1RZUEVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHIgPSByb290c1tpXVxuICAgIGJ1ZmZlcnNbaisrXSA9IHIuaGFzaFxuICAgIGJ1ZmZlcnNbaisrXSA9IGVuY29kZVVJbnQ2NChyLmluZGV4KVxuICAgIGJ1ZmZlcnNbaisrXSA9IGVuY29kZVVJbnQ2NChyLnNpemUpXG4gIH1cblxuICByZXR1cm4gYmxha2UyYihidWZmZXJzKVxufVxuXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIGJ1ZiA9IGJ1ZmZlckFsbG9jKG4pXG4gIHNvZGl1bS5yYW5kb21ieXRlc19idWYoYnVmKVxuICByZXR1cm4gYnVmXG59XG5cbmV4cG9ydHMuZGlzY292ZXJ5S2V5ID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgdmFyIGRpZ2VzdCA9IGJ1ZmZlckFsbG9jKDMyKVxuICBzb2RpdW0uY3J5cHRvX2dlbmVyaWNoYXNoKGRpZ2VzdCwgSFlQRVJDT1JFLCB0cmVlKVxuICByZXR1cm4gZGlnZXN0XG59XG5cbmZ1bmN0aW9uIGVuY29kZVVJbnQ2NCAobikge1xuICByZXR1cm4gdWludDY0YmUuZW5jb2RlKG4sIGJ1ZmZlckFsbG9jKDgpKVxufVxuXG5mdW5jdGlvbiBibGFrZTJiIChidWZmZXJzKSB7XG4gIHZhciBkaWdlc3QgPSBidWZmZXJBbGxvYygzMilcbiAgc29kaXVtLmNyeXB0b19nZW5lcmljaGFzaF9iYXRjaChkaWdlc3QsIGJ1ZmZlcnMpXG4gIHJldHVybiBkaWdlc3Rcbn1cbiIsInZhciBwcm90b2NvbCA9IHJlcXVpcmUoJ2h5cGVyY29yZS1wcm90b2NvbCcpXG52YXIgYml0ZmllbGQgPSByZXF1aXJlKCdzcGFyc2UtYml0ZmllbGQnKVxudmFyIHNldCA9IHJlcXVpcmUoJ3Vub3JkZXJlZC1zZXQnKVxudmFyIHJsZSA9IHJlcXVpcmUoJ2JpdGZpZWxkLXJsZScpXG5cbm1vZHVsZS5leHBvcnRzID0gcmVwbGljYXRlXG5cbmZ1bmN0aW9uIHJlcGxpY2F0ZSAoZmVlZCwgb3B0cykge1xuICB2YXIgc3RyZWFtID0gb3B0cy5zdHJlYW1cblxuICBpZiAoIXN0cmVhbSkge1xuICAgIGlmICghb3B0cy5leHBlY3RlZEZlZWRzKSBvcHRzLmV4cGVjdGVkRmVlZHMgPSAxXG4gICAgaWYgKCFvcHRzLmlkKSBvcHRzLmlkID0gZmVlZC5pZFxuICAgIHN0cmVhbSA9IHByb3RvY29sKG9wdHMpXG4gIH1cblxuICBmZWVkLnJlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koZXJyKVxuICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSByZXR1cm5cblxuICAgIHZhciBwZWVyID0gbmV3IFBlZXIoZmVlZCwgb3B0cylcbiAgICBwZWVyLmZlZWQgPSBmZWVkXG4gICAgcGVlci5zdHJlYW0gPSBzdHJlYW0uZmVlZChmZWVkLmtleSwge3BlZXI6IHBlZXJ9KVxuXG4gICAgcGVlci5yZW1vdGVJZCA9IHN0cmVhbS5yZW1vdGVJZFxuICAgIHN0cmVhbS5zZXRNYXhMaXN0ZW5lcnMoMClcbiAgICBzdHJlYW0ub24oJ2hhbmRzaGFrZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHBlZXIucmVtb3RlSWQgPSBzdHJlYW0ucmVtb3RlSWRcbiAgICB9KVxuXG4gICAgLy8gc3RyZWFtIG1pZ2h0IGdldCBkZXN0cm95ZWQgb24gZmVlZCBpbml0IGluIGNhc2Ugb2YgY29uZiBlcnJvcnNcbiAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICBwZWVyLnJlYWR5KClcbiAgfSlcblxuICByZXR1cm4gc3RyZWFtXG59XG5cbmZ1bmN0aW9uIFBlZXIgKGZlZWQsIG9wdHMpIHtcbiAgdGhpcy5mZWVkID0gZmVlZFxuICB0aGlzLnN0cmVhbSA9IG51bGwgLy8gc2V0IGJ5IHJlcGxpY2F0ZSBqdXN0IGFmdGVyIGNyZWF0aW9uXG4gIHRoaXMucmVtb3RlSWQgPSBudWxsXG4gIHRoaXMucmVtb3RlQml0ZmllbGQgPSBudWxsXG4gIHRoaXMucmVtb3RlTGVuZ3RoID0gMFxuICB0aGlzLnJlbW90ZVdhbnQgPSBmYWxzZVxuICB0aGlzLmxpdmUgPSAhIW9wdHMubGl2ZVxuICB0aGlzLnNwYXJzZSA9IGZlZWQuc3BhcnNlXG5cbiAgdGhpcy5yZW1vdGVEb3dubG9hZGluZyA9IHRydWVcbiAgdGhpcy5kb3dubG9hZGluZyA9IHR5cGVvZiBvcHRzLmRvd25sb2FkID09PSAnYm9vbGVhbicgPyBvcHRzLmRvd25sb2FkIDogIWZlZWQud3JpdGFibGVcbiAgdGhpcy51cGxvYWRpbmcgPSB0cnVlXG5cbiAgdGhpcy5tYXhSZXF1ZXN0cyA9IG9wdHMubWF4UmVxdWVzdHMgfHwgZmVlZC5tYXhSZXF1ZXN0cyB8fCAxNlxuICB0aGlzLmluZmxpZ2h0UmVxdWVzdHMgPSBbXVxuXG4gIHRoaXMuX2luZGV4ID0gLTFcbiAgdGhpcy5fbGFzdEJ5dGVzID0gMFxuICB0aGlzLl9maXJzdCA9IHRydWVcbiAgdGhpcy5fY2xvc2VkID0gZmFsc2VcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2VcbiAgdGhpcy5fZGVmYXVsdERvd25sb2FkaW5nID0gdGhpcy5kb3dubG9hZGluZ1xufVxuXG5QZWVyLnByb3RvdHlwZS5vbndhbnQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRPRE86IHJlcGx5IHRvIHRoZSBhY3R1YWwgd2FudCBjb250ZXh0XG4gIHRoaXMucmVtb3RlV2FudCA9IHRydWVcbiAgdmFyIHJsZSA9IHRoaXMuZmVlZC5iaXRmaWVsZC5jb21wcmVzcygpXG4gIHRoaXMuc3RyZWFtLmhhdmUoe3N0YXJ0OiAwLCBiaXRmaWVsZDogcmxlfSlcbn1cblxuUGVlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgLy8gSWdub3JlIHVucmVxdWVzdGVkIG1lc3NhZ2VzIHVubGVzcyB3ZSBhbGxvdyBwdXNoXG4gIC8vIFRPRE86IHdvdWxkIGJlIGJldHRlciB0byBjaGVjayBpZiB0aGUgYnl0ZSByYW5nZSB3YXMgcmVxdWVzdGVkIGluc3RlYWQsIGJ1dCB0aGlzIHdvcmtzIGZpbmVcbiAgdmFyIGFsbG93UHVzaCA9IHRoaXMuZmVlZC5hbGxvd1B1c2ggfHwgIWRhdGEudmFsdWVcbiAgaWYgKCFhbGxvd1B1c2ggJiYgIXRoaXMuZmVlZC5fcmVzZXJ2ZWQuZ2V0KGRhdGEuaW5kZXgpKSB7XG4gICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgdGhpcyBibG9jaywgc2VuZCBiYWNrIHVuaGF2ZSBtZXNzYWdlIGZvciB0aGlzIGluZGV4LFxuICAgIC8vIHRvIGxldCB0aGUgcmVtb3RlIGtub3cgd2UgcmVqZWN0ZWQgaXQuXG4gICAgLy8gVE9ETzogd2UgbWlnaHQgd2FudCB0byBoYXZlIHNvbWUgXCJ1bndhbnRlZCBwdXNoXCIgdGhyZXNob2xkIHRvIHB1bmlzaCBzcGFtbWVyc1xuICAgIGlmICghc2VsZi5mZWVkLmJpdGZpZWxkLmdldChkYXRhLmluZGV4KSkgc2VsZi51bmhhdmUoe3N0YXJ0OiBkYXRhLmluZGV4fSlcbiAgICBzZWxmLl9jbGVhcihkYXRhLmluZGV4LCAhZGF0YS52YWx1ZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuZmVlZC5fcHV0QnVmZmVyKGRhdGEuaW5kZXgsIGRhdGEudmFsdWUsIGRhdGEsIHRoaXMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5kZXN0cm95KGVycilcbiAgICBzZWxmLl9jbGVhcihkYXRhLmluZGV4LCAhZGF0YS52YWx1ZSlcbiAgfSlcbn1cblxuUGVlci5wcm90b3R5cGUuX2NsZWFyID0gZnVuY3Rpb24gKGluZGV4LCBoYXNoKSB7XG4gIC8vIFRPRE86IG9wdGltaXplIG1lIChubyBzcGxpY2UgYW5kIGRvIG5vdCBydW4gdGhyb3VnaCBhbGwgLi4uKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmluZmxpZ2h0UmVxdWVzdHNbaV0uaW5kZXggPT09IGluZGV4KSB7XG4gICAgICB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuc3BsaWNlKGksIDEpXG4gICAgICBpLS1cbiAgICB9XG4gIH1cblxuICB0aGlzLmZlZWQuX3Jlc2VydmVkLnNldChpbmRleCwgZmFsc2UpXG4gIC8vIFRPRE86IG9ubHkgdXBkYXRlIGFsbCBpZiB3ZSBoYXZlIG92ZXJsYXBwaW5nIHNlbGVjdGlvbnNcbiAgdGhpcy5mZWVkLl91cGRhdGVQZWVycygpXG59XG5cblBlZXIucHJvdG90eXBlLm9ucmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LmJ5dGVzKSByZXR1cm4gdGhpcy5fb25ieXRlcyhyZXF1ZXN0KVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgb3B0cyA9IHtkaWdlc3Q6IHJlcXVlc3Qubm9kZXMsIGhhc2g6IHJlcXVlc3QuaGFzaH1cblxuICB0aGlzLmZlZWQucHJvb2YocmVxdWVzdC5pbmRleCwgb3B0cywgb25wcm9vZilcblxuICBmdW5jdGlvbiBvbnByb29mIChlcnIsIHByb29mKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZGVzdHJveShlcnIpXG4gICAgaWYgKHJlcXVlc3QuaGFzaCkgb252YWx1ZShudWxsLCBudWxsKVxuICAgIGVsc2UgaWYgKHNlbGYuZmVlZC5iaXRmaWVsZC5nZXQocmVxdWVzdC5pbmRleCkpIHNlbGYuZmVlZC5fZ2V0QnVmZmVyKHJlcXVlc3QuaW5kZXgsIG9udmFsdWUpXG5cbiAgICBmdW5jdGlvbiBvbnZhbHVlIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5kZXN0cm95KGVycilcblxuICAgICAgaWYgKCFzZWxmLnJlbW90ZUJpdGZpZWxkKSBzZWxmLnJlbW90ZUJpdGZpZWxkID0gYml0ZmllbGQoKVxuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnJlbW90ZUJpdGZpZWxkLnNldChyZXF1ZXN0LmluZGV4LCB0cnVlKSkgcmV0dXJuXG4gICAgICAgIHNlbGYuZmVlZC5lbWl0KCd1cGxvYWQnLCByZXF1ZXN0LmluZGV4LCB2YWx1ZSwgc2VsZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzZWxmLnJlbW90ZUJpdGZpZWxkLmdldChyZXF1ZXN0LmluZGV4KSkgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXF1ZXN0LmluZGV4ICsgMSA+IHNlbGYucmVtb3RlTGVuZ3RoKSB7XG4gICAgICAgIHNlbGYucmVtb3RlTGVuZ3RoID0gcmVxdWVzdC5pbmRleCArIDFcbiAgICAgICAgc2VsZi5fdXBkYXRlRW5kKClcbiAgICAgIH1cblxuICAgICAgc2VsZi5zdHJlYW0uZGF0YSh7XG4gICAgICAgIGluZGV4OiByZXF1ZXN0LmluZGV4LFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG5vZGVzOiBwcm9vZi5ub2RlcyxcbiAgICAgICAgc2lnbmF0dXJlOiBwcm9vZi5zaWduYXR1cmVcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9vbmJ5dGVzID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5mZWVkLnNlZWsocmVxdWVzdC5ieXRlcywge3dhaXQ6IGZhbHNlfSwgZnVuY3Rpb24gKGVyciwgaW5kZXgpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXF1ZXN0LmJ5dGVzID0gMFxuICAgICAgc2VsZi5vbnJlcXVlc3QocmVxdWVzdClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHF1aWNrJ24nZGlydHkgZmlsdGVyIGZvciBwYXJhbGxlbCBieXRlcyByZXF1ZXN0c1xuICAgIC8vIGl0IGRvZXMgbm90IG1hdHRlciB0aGF0IHRoaXMgZG9lc24ndCBjYXRjaCBBTEwgcGFyYWxsZWwgcmVxdWVzdHMgLSBqdXN0IGEgYmFuZHdpZHRoIG9wdGltaXphdGlvblxuICAgIGlmIChzZWxmLl9sYXN0Qnl0ZXMgPT09IHJlcXVlc3QuYnl0ZXMpIHJldHVyblxuICAgIHNlbGYuX2xhc3RCeXRlcyA9IHJlcXVlc3QuYnl0ZXNcblxuICAgIHJlcXVlc3QuYnl0ZXMgPSAwXG4gICAgcmVxdWVzdC5pbmRleCA9IGluZGV4XG4gICAgcmVxdWVzdC5ub2RlcyA9IDBcblxuICAgIHNlbGYub25yZXF1ZXN0KHJlcXVlc3QpXG4gIH0pXG59XG5cblBlZXIucHJvdG90eXBlLm9udGljayA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoKSByZXR1cm5cblxuICB2YXIgZmlyc3QgPSB0aGlzLmluZmxpZ2h0UmVxdWVzdHNbMF1cbiAgaWYgKC0tZmlyc3QudGljaykgcmV0dXJuXG5cbiAgaWYgKGZpcnN0Lmhhc2ggPyB0aGlzLmZlZWQudHJlZS5nZXQoMiAqIGZpcnN0LmluZGV4KSA6IHRoaXMuZmVlZC5iaXRmaWVsZC5nZXQoZmlyc3QuaW5kZXgpKSB7XG4gICAgLy8gcHJvYiBhIGJ5dGVzIHJlc3BvbnNlXG4gICAgdGhpcy5pbmZsaWdodFJlcXVlc3RzLnNoaWZ0KClcbiAgICB0aGlzLmZlZWQuX3Jlc2VydmVkLnNldChmaXJzdC5pbmRleCwgZmFsc2UpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnKSlcbn1cblxuUGVlci5wcm90b3R5cGUub25oYXZlID0gZnVuY3Rpb24gKGhhdmUpIHtcbiAgdmFyIHVwZGF0ZWQgPSB0aGlzLl9maXJzdFxuICBpZiAodGhpcy5fZmlyc3QpIHRoaXMuX2ZpcnN0ID0gZmFsc2VcblxuICBpZiAoaGF2ZS5iaXRmaWVsZCkgeyAvLyBUT0RPOiBoYW5kbGUgc3RhcnQgIT09IDBcbiAgICB0aGlzLnJlbW90ZUJpdGZpZWxkID0gYml0ZmllbGQocmxlLmRlY29kZShoYXZlLmJpdGZpZWxkKSlcbiAgICBpZiAodGhpcy5yZW1vdGVCaXRmaWVsZC5sZW5ndGggPiB0aGlzLnJlbW90ZUxlbmd0aCkge1xuICAgICAgdGhpcy5yZW1vdGVMZW5ndGggPSB0aGlzLnJlbW90ZUJpdGZpZWxkLmxlbmd0aFxuICAgICAgd2hpbGUgKHRoaXMucmVtb3RlTGVuZ3RoICYmICF0aGlzLnJlbW90ZUJpdGZpZWxkLmdldCh0aGlzLnJlbW90ZUxlbmd0aCAtIDEpKSB0aGlzLnJlbW90ZUxlbmd0aC0tXG4gICAgICB1cGRhdGVkID0gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIXRoaXMucmVtb3RlQml0ZmllbGQpIHRoaXMucmVtb3RlQml0ZmllbGQgPSBiaXRmaWVsZCgpXG4gICAgLy8gVE9ETzogaWYgbGVuID4gc29tZXRoaW5nIHNpbXBseSBjb3B5IGEgMGIxMTExLi4uIGJ1ZmZlciB0byB0aGUgYml0ZmllbGRcblxuICAgIHZhciBzdGFydCA9IGhhdmUuc3RhcnRcbiAgICB2YXIgbGVuID0gaGF2ZS5sZW5ndGggfHwgMVxuXG4gICAgd2hpbGUgKGxlbi0tKSB0aGlzLnJlbW90ZUJpdGZpZWxkLnNldChzdGFydCsrLCB0cnVlKVxuICAgIGlmIChzdGFydCA+IHRoaXMucmVtb3RlTGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlbW90ZUxlbmd0aCA9IHN0YXJ0XG4gICAgICB1cGRhdGVkID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGlmICh1cGRhdGVkKSB7XG4gICAgdGhpcy5mZWVkLmVtaXQoJ3JlbW90ZS11cGRhdGUnLCB0aGlzKVxuICB9XG5cbiAgdGhpcy5fdXBkYXRlRW5kKClcbiAgdGhpcy51cGRhdGUoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fdXBkYXRlRW5kID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5saXZlIHx8IHRoaXMuZmVlZC5zcGFyc2UgfHwgIXRoaXMuZmVlZC5fc2VsZWN0aW9ucy5sZW5ndGgpIHJldHVyblxuXG4gIHZhciBzZWwgPSB0aGlzLmZlZWQuX3NlbGVjdGlvbnNbMF1cbiAgdmFyIHJlbW90ZUxlbmd0aCA9IHRoaXMuZmVlZC5sZW5ndGggfHwgLTFcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmVlZC5wZWVycy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmZlZWQucGVlcnNbaV0ucmVtb3RlTGVuZ3RoID4gcmVtb3RlTGVuZ3RoKSB7XG4gICAgICByZW1vdGVMZW5ndGggPSB0aGlzLmZlZWQucGVlcnNbaV0ucmVtb3RlTGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgc2VsLmVuZCA9IHJlbW90ZUxlbmd0aFxufVxuXG5QZWVyLnByb3RvdHlwZS5vbmluZm8gPSBmdW5jdGlvbiAoaW5mbykge1xuICB0aGlzLnJlbW90ZURvd25sb2FkaW5nID0gaW5mby5kb3dubG9hZGluZ1xuICBpZiAoaW5mby5kb3dubG9hZGluZyB8fCB0aGlzLmxpdmUpIHJldHVyblxuICB0aGlzLnVwZGF0ZSgpXG4gIGlmICh0aGlzLmZlZWQuX3NlbGVjdGlvbnMubGVuZ3RoICYmIHRoaXMuZG93bmxvYWRpbmcpIHJldHVyblxuICB0aGlzLmVuZCgpXG59XG5cblBlZXIucHJvdG90eXBlLm9udW5oYXZlID0gZnVuY3Rpb24gKHVuaGF2ZSkge1xuICBpZiAoIXRoaXMucmVtb3RlQml0ZmllbGQpIHJldHVyblxuXG4gIHZhciBzdGFydCA9IHVuaGF2ZS5zdGFydFxuICB2YXIgbGVuID0gdW5oYXZlLmxlbmd0aCB8fCAxXG5cbiAgd2hpbGUgKGxlbi0tKSB0aGlzLnJlbW90ZUJpdGZpZWxkLnNldChzdGFydCsrLCBmYWxzZSlcbn1cblxuUGVlci5wcm90b3R5cGUub251bndhbnQgPVxuUGVlci5wcm90b3R5cGUub25jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRPRE86IGltcGwgYWxsIG9mIG1lXG59XG5cblBlZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVzdHJveSgpXG59XG5cblBlZXIucHJvdG90eXBlLmhhdmUgPSBmdW5jdGlvbiAoaGF2ZSkgeyAvLyBjYWxsZWQgYnkgZmVlZFxuICBpZiAodGhpcy5zdHJlYW0gJiYgdGhpcy5yZW1vdGVXYW50KSB0aGlzLnN0cmVhbS5oYXZlKGhhdmUpXG59XG5cblBlZXIucHJvdG90eXBlLnVuaGF2ZSA9IGZ1bmN0aW9uICh1bmhhdmUpIHsgLy8gY2FsbGVkIGJ5IGZlZWRcbiAgaWYgKHRoaXMuc3RyZWFtICYmIHRoaXMucmVtb3RlV2FudCkgdGhpcy5zdHJlYW0udW5oYXZlKHVuaGF2ZSlcbn1cblxuUGVlci5wcm90b3R5cGUuaGF2ZUJ5dGVzID0gZnVuY3Rpb24gKGJ5dGVzKSB7IC8vIGNhbGxlZCBieSBmZWVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuaW5mbGlnaHRSZXF1ZXN0c1tpXS5ieXRlcyA9PT0gYnl0ZXMpIHtcbiAgICAgIHRoaXMuZmVlZC5fcmVzZXJ2ZWQuc2V0KHRoaXMuaW5mbGlnaHRSZXF1ZXN0c1tpXS5pbmRleCwgZmFsc2UpXG4gICAgICB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuc3BsaWNlKGksIDEpXG4gICAgICBpLS1cbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZSgpXG59XG5cblBlZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZG8gbm90aGluZ1xuICB3aGlsZSAodGhpcy5fdXBkYXRlKCkpIHt9XG59XG5cblBlZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiBtdXRhdGVkIGZhbHNlIGlmIG5vdFxuICBpZiAoIXRoaXMuZG93bmxvYWRpbmcgfHwgIXRoaXMucmVtb3RlQml0ZmllbGQpIHJldHVybiBmYWxzZVxuXG4gIHZhciBzZWxlY3Rpb25zID0gdGhpcy5mZWVkLl9zZWxlY3Rpb25zXG4gIHZhciB3YWl0aW5nID0gdGhpcy5mZWVkLl93YWl0aW5nXG4gIHZhciB3bGVuID0gd2FpdGluZy5sZW5ndGhcbiAgdmFyIHNsZW4gPSBzZWxlY3Rpb25zLmxlbmd0aFxuICB2YXIgaW5mbGlnaHQgPSB0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoXG4gIHZhciBvZmZzZXQgPSAwXG4gIHZhciBpID0gMFxuXG4gIC8vIFRPRE86IGxlc3MgZHVwbGljYXRlIGNvZGUgaGVyZVxuICAvLyBUT0RPOiByZS1hZGQgcHJpb3JpdHkgbGV2ZWxzXG5cbiAgd2hpbGUgKGluZmxpZ2h0IDwgdGhpcy5tYXhSZXF1ZXN0cykge1xuICAgIG9mZnNldCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHdhaXRpbmcubGVuZ3RoKVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHdhaXRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gd2FpdGluZ1tvZmZzZXQrK11cbiAgICAgIGlmIChvZmZzZXQgPT09IHdhaXRpbmcubGVuZ3RoKSBvZmZzZXQgPSAwXG5cbiAgICAgIHRoaXMuX2Rvd25sb2FkV2FpdGluZyh3KVxuICAgICAgaWYgKHdhaXRpbmcubGVuZ3RoICE9PSB3bGVuKSByZXR1cm4gdHJ1ZSAvLyBtdXRhdGVkXG4gICAgICBpZiAodGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aCA+PSB0aGlzLm1heFJlcXVlc3RzKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGluZmxpZ2h0ID09PSB0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoKSBicmVha1xuICAgIGluZmxpZ2h0ID0gdGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aFxuICB9XG5cbiAgd2hpbGUgKGluZmxpZ2h0IDwgdGhpcy5tYXhSZXF1ZXN0cykge1xuICAgIG9mZnNldCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNlbGVjdGlvbnMubGVuZ3RoKVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzID0gc2VsZWN0aW9uc1tvZmZzZXQrK11cbiAgICAgIGlmIChvZmZzZXQgPT09IHNlbGVjdGlvbnMubGVuZ3RoKSBvZmZzZXQgPSAwXG5cbiAgICAgIGlmICghcy5pdGVyYXRvcikgcy5pdGVyYXRvciA9IHRoaXMuZmVlZC5iaXRmaWVsZC5pdGVyYXRvcihzLnN0YXJ0LCBzLmVuZClcbiAgICAgIHRoaXMuX2Rvd25sb2FkUmFuZ2UocylcbiAgICAgIGlmIChzZWxlY3Rpb25zLmxlbmd0aCAhPT0gc2xlbikgcmV0dXJuIHRydWUgLy8gbXV0YXRlZFxuICAgICAgaWYgKHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGggPj0gdGhpcy5tYXhSZXF1ZXN0cykgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGluZmxpZ2h0ID09PSB0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgICBpbmZsaWdodCA9IHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5QZWVyLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgc2V0LmFkZCh0aGlzLmZlZWQucGVlcnMsIHRoaXMpXG4gIHRoaXMuc3RyZWFtLndhbnQoe3N0YXJ0OiAwfSkgLy8gVE9ETzogZG9uJ3QganVzdCBzdWJzY3JpYmUgdG8gKkVWRVJZVEhJTkcqIGhlaGVcbiAgdGhpcy5mZWVkLmVtaXQoJ3BlZXItYWRkJywgdGhpcylcbn1cblxuUGVlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZG93bmxvYWRpbmcgJiYgIXRoaXMucmVtb3RlRG93bmxvYWRpbmcgJiYgIXRoaXMubGl2ZSkge1xuICAgIGlmICghdGhpcy5fZGVmYXVsdERvd25sb2FkaW5nKSB7XG4gICAgICB0aGlzLnN0cmVhbS5pbmZvKHtkb3dubG9hZGluZzogZmFsc2UsIHVwbG9hZGluZzogZmFsc2V9KVxuICAgIH1cbiAgICB0aGlzLl9jbG9zZSgpXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCF0aGlzLl9jbG9zZWQpIHtcbiAgICB0aGlzLl9jbG9zZWQgPSB0cnVlXG4gICAgdGhpcy5kb3dubG9hZGluZyA9IGZhbHNlXG4gICAgdGhpcy5zdHJlYW0uaW5mbyh7ZG93bmxvYWRpbmc6IGZhbHNlLCB1cGxvYWRpbmc6IHRydWV9KVxuICB9IGVsc2Uge1xuICAgIGlmICghdGhpcy5saXZlKSB0aGlzLl9jbG9zZSgpXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5faW5kZXggPT09IC0xKSByZXR1cm5cbiAgaWYgKCF0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICB0aGlzLnN0cmVhbS5jbG9zZSgpXG4gICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuICB9XG4gIHNldC5yZW1vdmUodGhpcy5mZWVkLnBlZXJzLCB0aGlzKVxuICB0aGlzLl9pbmRleCA9IC0xXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5mZWVkLl9yZXNlcnZlZC5zZXQodGhpcy5pbmZsaWdodFJlcXVlc3RzW2ldLmluZGV4LCBmYWxzZSlcbiAgfVxuICB0aGlzLl91cGRhdGVFbmQoKVxuICB0aGlzLnJlbW90ZVdhbnQgPSBmYWxzZVxuICB0aGlzLmZlZWQuX3VwZGF0ZVBlZXJzKClcbiAgdGhpcy5mZWVkLmVtaXQoJ3BlZXItcmVtb3ZlJywgdGhpcylcbn1cblxuUGVlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuX2luZGV4ID09PSAtMSB8fCB0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLnN0cmVhbS5kZXN0cm95KGVycilcbiAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuICB0aGlzLl9jbG9zZSgpXG59XG5cblBlZXIucHJvdG90eXBlLl9kb3dubG9hZFdhaXRpbmcgPSBmdW5jdGlvbiAod2FpdCkge1xuICBpZiAoIXdhaXQuYnl0ZXMpIHtcbiAgICBpZiAoIXRoaXMucmVtb3RlQml0ZmllbGQuZ2V0KHdhaXQuaW5kZXgpIHx8ICF0aGlzLmZlZWQuX3Jlc2VydmVkLnNldCh3YWl0LmluZGV4LCB0cnVlKSkgcmV0dXJuXG4gICAgdGhpcy5fcmVxdWVzdCh3YWl0LmluZGV4LCAwLCBmYWxzZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuX2Rvd25sb2FkUmFuZ2Uod2FpdClcbn1cblxuUGVlci5wcm90b3R5cGUuX2Rvd25sb2FkUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgaWYgKCFyYW5nZS5pdGVyYXRvcikgcmFuZ2UuaXRlcmF0b3IgPSB0aGlzLmZlZWQuYml0ZmllbGQuaXRlcmF0b3IocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZClcblxuICB2YXIgcmVzZXJ2ZWQgPSB0aGlzLmZlZWQuX3Jlc2VydmVkXG4gIHZhciBpdGUgPSByYW5nZS5pdGVyYXRvclxuICB2YXIgd2FudGVkRW5kID0gTWF0aC5taW4ocmFuZ2UuZW5kID09PSAtMSA/IHRoaXMucmVtb3RlTGVuZ3RoIDogcmFuZ2UuZW5kLCB0aGlzLnJlbW90ZUxlbmd0aClcblxuICBpZiAoaXRlLmVuZCAhPT0gd2FudGVkRW5kKSBpdGUucmFuZ2UocmFuZ2Uuc3RhcnQsIHdhbnRlZEVuZClcblxuICB2YXIgaSA9IHJhbmdlLmxpbmVhciA/IGl0ZS5uZXh0KCkgOiBpdGUucmFuZG9tKClcbiAgdmFyIHJlc2V0ID0gZmFsc2VcbiAgdmFyIHN0YXJ0ID0gaVxuXG4gIGlmIChpID09PSAtMSkge1xuICAgIGlmICghcmFuZ2UuYnl0ZXMgJiYgaXRlLnNlZWsoMCkubmV4dCgpID09PSAtMSAmJiAocmFuZ2UuZW5kID4gLTEgJiYgdGhpcy5yZW1vdGVMZW5ndGggPj0gcmFuZ2UuZW5kKSkge1xuICAgICAgc2V0LnJlbW92ZSh0aGlzLmZlZWQuX3NlbGVjdGlvbnMsIHJhbmdlKVxuICAgICAgcmFuZ2UuY2FsbGJhY2sobnVsbClcbiAgICAgIGlmICghdGhpcy5saXZlICYmICF0aGlzLnNwYXJzZSAmJiAhdGhpcy5mZWVkLl9zZWxlY3Rpb25zLmxlbmd0aCkgdGhpcy5lbmQoKVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIHdoaWxlICghdGhpcy5yZW1vdGVCaXRmaWVsZC5nZXQoaSkgfHwgKHJhbmdlLmhhc2ggJiYgdGhpcy5mZWVkLnRyZWUuZ2V0KDIgKiBpKSkgfHwgIXJlc2VydmVkLnNldChpLCB0cnVlKSkge1xuICAgIGkgPSBpdGUubmV4dCgpXG4gICAgcmVzZXQgPSB0cnVlXG5cbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAvLyBjaGVjayB0aGlzIGluZGV4XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICghcmFuZ2UubGluZWFyICYmIHN0YXJ0ICE9PSAwKSB7XG4gICAgICAvLyByZXRyeSBmcm9tIHRoZSBiZWdpbm5pbmcgc2luY2Ugd2UgYXJlIGl0ZXJhdGluZyByYW5kb21seSBhbmQgc3RhcnRlZCAhPT0gMFxuICAgICAgaSA9IGl0ZS5zZWVrKDApLm5leHQoKVxuICAgICAgc3RhcnQgPSAwXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIHdlIGhhdmUgY2hlY2tlZCBhbGwgaW5kZXhlcy5cbiAgICAvLyBpZiB3ZSBhcmUgbG9va2luZyBmb3IgaGFzaGVzIHdlIHNob3VsZCBjaGVjayBpZiB3ZSBoYXZlIGFsbCBub3cgKGZpcnN0IGNoZWNrIG9ubHkgY2hlY2tzIGJsb2NrcylcbiAgICBpZiAocmFuZ2UuaGFzaCkge1xuICAgICAgLy8gcXVpY2snbidkaXJ0eSBjaGVjayBpZiBoYXZlIGFsbCBoYXNoZXMgLSBjYW4gYmUgb3B0aW1pemVkIGJlIGNoZWNraW5nIG9ubHkgdHJlZSByb290c1xuICAgICAgLy8gYnV0IHdlIGRvbid0IHJlYWxseSByZXF1ZXN0IGxvbmcgcmFuZ2VzIG9mIGhhc2hlcyBzbyB5b2xvXG4gICAgICBmb3IgKHZhciBqID0gcmFuZ2Uuc3RhcnQ7IGogPCB3YW50ZWRFbmQ7IGorKykge1xuICAgICAgICBpZiAoIXRoaXMuZmVlZC50cmVlLmdldCgyICogaikpIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKCFyYW5nZS5ieXRlcykge1xuICAgICAgICBzZXQucmVtb3ZlKHRoaXMuZmVlZC5fc2VsZWN0aW9ucywgcmFuZ2UpXG4gICAgICAgIHJhbmdlLmNhbGxiYWNrKG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXhpdCB0aGUgdXBkYXRlIGxvb3AgLSBub3RoaW5nIHRvIGRvXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocmVzZXQpIGl0ZS5zZWVrKDApXG5cbiAgdGhpcy5fcmVxdWVzdChpLCByYW5nZS5ieXRlcyB8fCAwLCByYW5nZS5oYXNoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fcmVxdWVzdCA9IGZ1bmN0aW9uIChpbmRleCwgYnl0ZXMsIGhhc2gpIHtcbiAgdmFyIHJlcXVlc3QgPSB7XG4gICAgdGljazogNixcbiAgICBieXRlczogYnl0ZXMsXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGhhc2g6IGhhc2gsXG4gICAgbm9kZXM6IHRoaXMuZmVlZC5kaWdlc3QoaW5kZXgpXG4gIH1cblxuICB0aGlzLmluZmxpZ2h0UmVxdWVzdHMucHVzaChyZXF1ZXN0KVxuICB0aGlzLnN0cmVhbS5yZXF1ZXN0KHJlcXVlc3QpXG59XG4iLCJ2YXIgdWludDY0YmUgPSByZXF1aXJlKCd1aW50NjRiZScpXG52YXIgZmxhdCA9IHJlcXVpcmUoJ2ZsYXQtdHJlZScpXG52YXIgYWxydSA9IHJlcXVpcmUoJ2FycmF5LWxydScpXG52YXIgYnVmZmVyQWxsb2MgPSByZXF1aXJlKCdidWZmZXItYWxsb2MtdW5zYWZlJylcblxubW9kdWxlLmV4cG9ydHMgPSBTdG9yYWdlXG5cbnZhciBub2FyciA9IFtdXG5cbmZ1bmN0aW9uIFN0b3JhZ2UgKGNyZWF0ZSwgY2FjaGVTaXplKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdG9yYWdlKSkgcmV0dXJuIG5ldyBTdG9yYWdlKGNyZWF0ZSwgY2FjaGVTaXplKVxuICBjYWNoZVNpemUgPSB0eXBlb2YgY2FjaGVTaXplID09PSAndW5kZWZpbmVkJyA/IDY1NTM2IDogY2FjaGVTaXplXG5cbiAgdGhpcy5jYWNoZSA9IGNhY2hlU2l6ZSA+IDAgPyBhbHJ1KGNhY2hlU2l6ZSwge2luZGV4ZWRWYWx1ZXM6IHRydWV9KSA6IG51bGxcbiAgdGhpcy5rZXkgPSBudWxsXG4gIHRoaXMuc2VjcmV0S2V5ID0gbnVsbFxuICB0aGlzLnRyZWUgPSBudWxsXG4gIHRoaXMuZGF0YSA9IG51bGxcbiAgdGhpcy5iaXRmaWVsZCA9IG51bGxcbiAgdGhpcy5zaWduYXR1cmVzID0gbnVsbFxuICB0aGlzLmNyZWF0ZSA9IGNyZWF0ZVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5wdXREYXRhID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhLCBub2RlcywgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBub29wXG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm4gY2IobnVsbClcbiAgdGhpcy5kYXRhT2Zmc2V0KGluZGV4LCBub2RlcywgZnVuY3Rpb24gKGVyciwgb2Zmc2V0LCBzaXplKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoc2l6ZSAhPT0gZGF0YS5sZW5ndGgpIHJldHVybiBjYihuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZGF0YSBzaXplJykpXG4gICAgc2VsZi5kYXRhLndyaXRlKG9mZnNldCwgZGF0YSwgY2IpXG4gIH0pXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLmRhdGFPZmZzZXQoaW5kZXgsIG5vYXJyLCBmdW5jdGlvbiAoZXJyLCBvZmZzZXQsIHNpemUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHNlbGYuZGF0YS5yZWFkKG9mZnNldCwgc2l6ZSwgY2IpXG4gIH0pXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLm5leHRTaWduYXR1cmUgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMuX2dldFNpZ25hdHVyZShpbmRleCwgZnVuY3Rpb24gKGVyciwgc2lnbmF0dXJlKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoaXNCbGFuayhzaWduYXR1cmUpKSByZXR1cm4gc2VsZi5uZXh0U2lnbmF0dXJlKGluZGV4ICsgMSwgY2IpXG4gICAgY2IobnVsbCwgeyBpbmRleDogaW5kZXgsIHNpZ25hdHVyZTogc2lnbmF0dXJlIH0pXG4gIH0pXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLmdldFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgdGhpcy5fZ2V0U2lnbmF0dXJlKGluZGV4LCBmdW5jdGlvbiAoZXJyLCBzaWduYXR1cmUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChpc0JsYW5rKHNpZ25hdHVyZSkpIHJldHVybiBjYihuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZSBmb3VuZCcpKVxuICAgIGNiKG51bGwsIHNpZ25hdHVyZSlcbiAgfSlcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUuX2dldFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgdGhpcy5zaWduYXR1cmVzLnJlYWQoMzIgKyA2NCAqIGluZGV4LCA2NCwgY2IpXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLnB1dFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChpbmRleCwgc2lnbmF0dXJlLCBjYikge1xuICB0aGlzLnNpZ25hdHVyZXMud3JpdGUoMzIgKyA2NCAqIGluZGV4LCBzaWduYXR1cmUsIGNiKVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5kYXRhT2Zmc2V0ID0gZnVuY3Rpb24gKGluZGV4LCBjYWNoZWROb2RlcywgY2IpIHtcbiAgdmFyIHJvb3RzID0gZmxhdC5mdWxsUm9vdHMoMiAqIGluZGV4KVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG9mZnNldCA9IDBcbiAgdmFyIHBlbmRpbmcgPSByb290cy5sZW5ndGhcbiAgdmFyIGVycm9yID0gbnVsbFxuICB2YXIgYmxrID0gMiAqIGluZGV4XG5cbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IDFcbiAgICBvbm5vZGUobnVsbCwgbnVsbClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGZpbmROb2RlKGNhY2hlZE5vZGVzLCByb290c1tpXSlcbiAgICBpZiAobm9kZSkgb25ub2RlKG51bGwsIG5vZGUpXG4gICAgZWxzZSB0aGlzLmdldE5vZGUocm9vdHNbaV0sIG9ubm9kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubGFzdCAoZXJyLCBub2RlKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjYihudWxsLCBvZmZzZXQsIG5vZGUuc2l6ZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubm9kZSAoZXJyLCBub2RlKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAobm9kZSkgb2Zmc2V0ICs9IG5vZGUuc2l6ZVxuICAgIGlmICgtLXBlbmRpbmcpIHJldHVyblxuXG4gICAgaWYgKGVycm9yKSByZXR1cm4gY2IoZXJyb3IpXG5cbiAgICB2YXIgbGFzdCA9IGZpbmROb2RlKGNhY2hlZE5vZGVzLCBibGspXG4gICAgaWYgKGxhc3QpIG9ubGFzdChudWxsLCBsYXN0KVxuICAgIGVsc2Ugc2VsZi5nZXROb2RlKGJsaywgb25sYXN0KVxuICB9XG59XG5cblN0b3JhZ2UucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIGlmICh0aGlzLmNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuY2FjaGUuZ2V0KGluZGV4KVxuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYihudWxsLCBjYWNoZWQpXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLnRyZWUucmVhZCgzMiArIDQwICogaW5kZXgsIDQwLCBmdW5jdGlvbiAoZXJyLCBidWYpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgdmFyIGhhc2ggPSBidWYuc2xpY2UoMCwgMzIpXG4gICAgdmFyIHNpemUgPSB1aW50NjRiZS5kZWNvZGUoYnVmLCAzMilcblxuICAgIGlmICghc2l6ZSAmJiBpc0JsYW5rKGhhc2gpKSByZXR1cm4gY2IobmV3IEVycm9yKCdObyBub2RlIGZvdW5kJykpXG5cbiAgICB2YXIgdmFsID0gbmV3IE5vZGUoaW5kZXgsIGhhc2gsIHNpemUsIG51bGwpXG4gICAgaWYgKHNlbGYuY2FjaGUpIHNlbGYuY2FjaGUuc2V0KGluZGV4LCB2YWwpXG4gICAgY2IobnVsbCwgdmFsKVxuICB9KVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5wdXROb2RlID0gZnVuY3Rpb24gKGluZGV4LCBub2RlLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcblxuICAvLyBUT0RPOiByZS1lbmFibGUgcHV0IGNhY2hlLiBjdXJyZW50bHkgdGhpcyBjYXVzZXMgYSBtZW1sZWFrXG4gIC8vIGJlY2F1c2Ugbm9kZS5oYXNoIGlzIGEgc2xpY2Ugb2YgdGhlIGJpZyBkYXRhIGJ1ZmZlciBvbiByZXBsaWNhdGVcbiAgLy8gaWYgKHRoaXMuY2FjaGUpIHRoaXMuY2FjaGUuc2V0KGluZGV4LCBub2RlKVxuXG4gIHZhciBidWYgPSBidWZmZXJBbGxvYyg0MClcblxuICBub2RlLmhhc2guY29weShidWYsIDApXG4gIHVpbnQ2NGJlLmVuY29kZShub2RlLnNpemUsIGJ1ZiwgMzIpXG4gIHRoaXMudHJlZS53cml0ZSgzMiArIDQwICogaW5kZXgsIGJ1ZiwgY2IpXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLnB1dEJpdGZpZWxkID0gZnVuY3Rpb24gKG9mZnNldCwgZGF0YSwgY2IpIHtcbiAgdGhpcy5iaXRmaWVsZC53cml0ZSgzMiArIG9mZnNldCwgZGF0YSwgY2IpXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICghY2IpIGNiID0gbm9vcFxuICB2YXIgbWlzc2luZyA9IDZcbiAgdmFyIGVycm9yID0gbnVsbFxuXG4gIGNsb3NlKHRoaXMuYml0ZmllbGQsIGRvbmUpXG4gIGNsb3NlKHRoaXMudHJlZSwgZG9uZSlcbiAgY2xvc2UodGhpcy5kYXRhLCBkb25lKVxuICBjbG9zZSh0aGlzLmtleSwgZG9uZSlcbiAgY2xvc2UodGhpcy5zZWNyZXRLZXksIGRvbmUpXG4gIGNsb3NlKHRoaXMuc2lnbmF0dXJlcywgZG9uZSlcblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmICgtLW1pc3NpbmcpIHJldHVyblxuICAgIGNiKGVycm9yKVxuICB9XG59XG5cblN0b3JhZ2UucHJvdG90eXBlLm9wZW5LZXkgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5vcGVuS2V5KHt9LCBvcHRzKVxuICBpZiAoIXRoaXMua2V5KSB0aGlzLmtleSA9IHRoaXMuY3JlYXRlKCdrZXknLCBvcHRzKVxuICB0aGlzLmtleS5yZWFkKDAsIDMyLCBjYilcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLm9wZW4oe30sIG9wdHMpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBlcnJvciA9IG51bGxcbiAgdmFyIG1pc3NpbmcgPSA1XG5cbiAgaWYgKCF0aGlzLmtleSkgdGhpcy5rZXkgPSB0aGlzLmNyZWF0ZSgna2V5Jywgb3B0cylcbiAgaWYgKCF0aGlzLnNlY3JldEtleSkgdGhpcy5zZWNyZXRLZXkgPSB0aGlzLmNyZWF0ZSgnc2VjcmV0X2tleScsIG9wdHMpXG4gIGlmICghdGhpcy50cmVlKSB0aGlzLnRyZWUgPSB0aGlzLmNyZWF0ZSgndHJlZScsIG9wdHMpXG4gIGlmICghdGhpcy5kYXRhKSB0aGlzLmRhdGEgPSB0aGlzLmNyZWF0ZSgnZGF0YScsIG9wdHMpXG4gIGlmICghdGhpcy5iaXRmaWVsZCkgdGhpcy5iaXRmaWVsZCA9IHRoaXMuY3JlYXRlKCdiaXRmaWVsZCcsIG9wdHMpXG4gIGlmICghdGhpcy5zaWduYXR1cmVzKSB0aGlzLnNpZ25hdHVyZXMgPSB0aGlzLmNyZWF0ZSgnc2lnbmF0dXJlcycsIG9wdHMpXG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBiaXRmaWVsZDogYnVmZmVyQWxsb2MoMCksXG4gICAgc2VjcmV0S2V5OiBudWxsLFxuICAgIGtleTogbnVsbFxuICB9XG5cbiAgdGhpcy5iaXRmaWVsZC53cml0ZSgwLCBoZWFkZXIoMCwgMzMyOCwgbnVsbCksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJlYWRBbGwoc2VsZi5iaXRmaWVsZCwgMzIsIDMzMjgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhKSByZXN1bHQuYml0ZmllbGQgPSBkYXRhXG4gICAgICBkb25lKGVycilcbiAgICB9KVxuICB9KVxuXG4gIHRoaXMuc2lnbmF0dXJlcy53cml0ZSgwLCBoZWFkZXIoMSwgNjQsICdFZDI1NTE5JyksIGRvbmUpXG4gIHRoaXMudHJlZS53cml0ZSgwLCBoZWFkZXIoMiwgNDAsICdCTEFLRTJiJyksIGRvbmUpXG5cbiAgLy8gVE9ETzogSW1wcm92ZSB0aGUgZXJyb3IgaGFuZGxpbmcgaGVyZS5cbiAgLy8gSS5lLiBpZiBzZWNyZXRLZXkgbGVuZ3RoID09PSA2NCBhbmQgaXQgZmFpbHMsIGVycm9yXG5cbiAgdGhpcy5zZWNyZXRLZXkucmVhZCgwLCA2NCwgZnVuY3Rpb24gKF8sIGRhdGEpIHtcbiAgICBpZiAoZGF0YSkgcmVzdWx0LnNlY3JldEtleSA9IGRhdGFcbiAgICBkb25lKG51bGwpXG4gIH0pXG5cbiAgdGhpcy5rZXkucmVhZCgwLCAzMiwgZnVuY3Rpb24gKF8sIGRhdGEpIHtcbiAgICBpZiAoZGF0YSkgcmVzdWx0LmtleSA9IGRhdGFcbiAgICBkb25lKG51bGwpXG4gIH0pXG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAoLS1taXNzaW5nKSByZXR1cm5cbiAgICBpZiAoZXJyb3IpIGNiKGVycm9yKVxuICAgIGVsc2UgY2IobnVsbCwgcmVzdWx0KVxuICB9XG59XG5cblN0b3JhZ2UuTm9kZSA9IE5vZGVcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBoZWFkZXIgKHR5cGUsIHNpemUsIG5hbWUpIHtcbiAgdmFyIGJ1ZiA9IGJ1ZmZlckFsbG9jKDMyKVxuICBidWYuZmlsbCgwKVxuXG4gIC8vIG1hZ2ljIG51bWJlclxuICBidWZbMF0gPSA1XG4gIGJ1ZlsxXSA9IDJcbiAgYnVmWzJdID0gODdcbiAgYnVmWzNdID0gdHlwZVxuXG4gIC8vIHZlcnNpb25cbiAgYnVmWzRdID0gMFxuXG4gIC8vIGJsb2NrIHNpemVcbiAgYnVmLndyaXRlVUludDE2QkUoc2l6ZSwgNSlcblxuICBpZiAobmFtZSkge1xuICAgIC8vIGFsZ28gbmFtZVxuICAgIGJ1Zls3XSA9IG5hbWUubGVuZ3RoXG4gICAgYnVmLndyaXRlKG5hbWUsIDgpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIE5vZGUgKGluZGV4LCBoYXNoLCBzaXplKSB7XG4gIHRoaXMuaW5kZXggPSBpbmRleFxuICB0aGlzLmhhc2ggPSBoYXNoXG4gIHRoaXMuc2l6ZSA9IHNpemVcbn1cblxuZnVuY3Rpb24gZmluZE5vZGUgKG5vZGVzLCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldLmluZGV4ID09PSBpbmRleCkgcmV0dXJuIG5vZGVzW2ldXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gaXNCbGFuayAoYnVmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY2xvc2UgKHN0LCBjYikge1xuICBpZiAoc3QuY2xvc2UpIHN0LmNsb3NlKGNiKVxuICBlbHNlIGNiKClcbn1cblxuZnVuY3Rpb24gc3RhdEFuZFJlYWRBbGwgKHN0LCBvZmZzZXQsIGNiKSB7XG4gIHN0LnN0YXQoZnVuY3Rpb24gKGVyciwgc3RhdCkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihudWxsLCBidWZmZXJBbGxvYygwKSlcbiAgICBzdC5yZWFkKG9mZnNldCwgc3RhdC5zaXplIC0gb2Zmc2V0LCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEFsbCAoc3QsIG9mZnNldCwgcGFnZVNpemUsIGNiKSB7XG4gIGlmICh0eXBlb2Ygc3QubGVuZ3RoID09PSAnbnVtYmVyJyAmJiBzdC5sZW5ndGggPiAtMSkgcmV0dXJuIHN0LnJlYWQob2Zmc2V0LCBzdC5sZW5ndGggLSBvZmZzZXQsIGNiKVxuICBpZiAoc3Quc3RhdGFibGUgPT09IHRydWUpIHJldHVybiBzdGF0QW5kUmVhZEFsbChzdCwgb2Zmc2V0LCBjYilcblxuICB2YXIgYnVmcyA9IFtdXG5cbiAgc3QucmVhZChvZmZzZXQsIHBhZ2VTaXplLCBsb29wKVxuXG4gIGZ1bmN0aW9uIGxvb3AgKGVyciwgYnVmKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKG51bGwsIEJ1ZmZlci5jb25jYXQoYnVmcykpXG4gICAgYnVmcy5wdXNoKGJ1ZilcbiAgICBzdC5yZWFkKG9mZnNldCArIGJ1ZnMubGVuZ3RoICogcGFnZVNpemUsIHBhZ2VTaXplLCBsb29wKVxuICB9XG59XG4iLCJ2YXIgZmxhdCA9IHJlcXVpcmUoJ2ZsYXQtdHJlZScpXG52YXIgYml0ZmllbGQgPSByZXF1aXJlKCdzcGFyc2UtYml0ZmllbGQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyZWVJbmRleFxuXG5mdW5jdGlvbiBUcmVlSW5kZXggKGJpdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyZWVJbmRleCkpIHJldHVybiBuZXcgVHJlZUluZGV4KGJpdHMpXG4gIHRoaXMuYml0ZmllbGQgPSBiaXRzIHx8IGJpdGZpZWxkKClcbn1cblxuVHJlZUluZGV4LnByb3RvdHlwZS5wcm9vZiA9IGZ1bmN0aW9uIChpbmRleCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIHZhciBub2RlcyA9IFtdXG4gIHZhciByZW1vdGVUcmVlID0gb3B0cy50cmVlIHx8IG5ldyBUcmVlSW5kZXgoKVxuICB2YXIgZGlnZXN0ID0gb3B0cy5kaWdlc3QgfHwgMFxuXG4gIGlmICghdGhpcy5nZXQoaW5kZXgpKSByZXR1cm4gbnVsbFxuICBpZiAob3B0cy5oYXNoKSBub2Rlcy5wdXNoKGluZGV4KSAvLyBhbHdheXMgcmV0dXJuIGhhc2ggLSBubyBtYXR0ZXIgd2hhdCB0aGUgZGlnZXN0IHNheXNcbiAgaWYgKGRpZ2VzdCA9PT0gMSkgcmV0dXJuIHtub2Rlczogbm9kZXMsIHZlcmlmaWVkQnk6IDB9XG5cbiAgdmFyIHJvb3RzID0gbnVsbFxuICB2YXIgc2libGluZyA9IGluZGV4XG4gIHZhciBuZXh0ID0gaW5kZXhcbiAgdmFyIGhhc1Jvb3QgPSBkaWdlc3QgJiAxXG4gIGRpZ2VzdCA9IHJpZ2h0U2hpZnQoZGlnZXN0KVxuXG4gIHdoaWxlIChkaWdlc3QpIHtcbiAgICBpZiAoZGlnZXN0ID09PSAxICYmIGhhc1Jvb3QpIHtcbiAgICAgIGlmICh0aGlzLmdldChuZXh0KSkgcmVtb3RlVHJlZS5zZXQobmV4dClcblxuICAgICAgLy8gaGF2aW5nIGEgcm9vdCBpbXBsaWVzIGhhdmluZyBwcmV2IHJvb3RzIGFzIHdlbGxcbiAgICAgIC8vIFRPRE86IHRoaXMgY2FuIGJlIG9wdGltaXplZCBhd2F5IGJlIG9ubHkgc2VuZGluZyBcIm5ld2VyXCIgcm9vdHMsXG4gICAgICAvLyB3aGVuIHNlbmRpbmcgcm9vdHNcbiAgICAgIGlmIChmbGF0LnNpYmxpbmcobmV4dCkgPCBuZXh0KSBuZXh0ID0gZmxhdC5zaWJsaW5nKG5leHQpXG4gICAgICByb290cyA9IGZsYXQuZnVsbFJvb3RzKGZsYXQucmlnaHRTcGFuKG5leHQpICsgMilcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0KHJvb3RzW2ldKSkgcmVtb3RlVHJlZS5zZXQocm9vdHNbaV0pXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIHNpYmxpbmcgPSBmbGF0LnNpYmxpbmcobmV4dClcbiAgICBpZiAoZGlnZXN0ICYgMSkge1xuICAgICAgaWYgKHRoaXMuZ2V0KHNpYmxpbmcpKSByZW1vdGVUcmVlLnNldChzaWJsaW5nKVxuICAgIH1cbiAgICBuZXh0ID0gZmxhdC5wYXJlbnQobmV4dClcbiAgICBkaWdlc3QgPSByaWdodFNoaWZ0KGRpZ2VzdClcbiAgfVxuXG4gIG5leHQgPSBpbmRleFxuXG4gIHdoaWxlICghcmVtb3RlVHJlZS5nZXQobmV4dCkpIHtcbiAgICBzaWJsaW5nID0gZmxhdC5zaWJsaW5nKG5leHQpXG4gICAgaWYgKCF0aGlzLmdldChzaWJsaW5nKSkge1xuICAgICAgLy8gbmV4dCBpcyBhIGxvY2FsIHJvb3RcbiAgICAgIHZhciB2ZXJpZmllZEJ5ID0gdGhpcy52ZXJpZmllZEJ5KG5leHQpXG4gICAgICBhZGRGdWxsUm9vdHModmVyaWZpZWRCeSwgbm9kZXMsIG5leHQsIHJlbW90ZVRyZWUpXG4gICAgICByZXR1cm4ge25vZGVzOiBub2RlcywgdmVyaWZpZWRCeTogdmVyaWZpZWRCeX1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFyZW1vdGVUcmVlLmdldChzaWJsaW5nKSkgbm9kZXMucHVzaChzaWJsaW5nKVxuICAgIH1cblxuICAgIG5leHQgPSBmbGF0LnBhcmVudChuZXh0KVxuICB9XG5cbiAgcmV0dXJuIHtub2Rlczogbm9kZXMsIHZlcmlmaWVkQnk6IDB9XG59XG5cblRyZWVJbmRleC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIGlmICh0aGlzLmdldChpbmRleCkpIHJldHVybiAxXG5cbiAgdmFyIGRpZ2VzdCA9IDBcbiAgdmFyIG5leHQgPSBmbGF0LnNpYmxpbmcoaW5kZXgpXG4gIHZhciBtYXggPSBNYXRoLm1heChuZXh0ICsgMiwgdGhpcy5iaXRmaWVsZC5sZW5ndGgpIC8vIFRPRE86IG1ha2UgdGhpcyBsZXNzIC4uLiBoYWNreVxuXG4gIHZhciBiaXQgPSAyXG4gIHZhciBkZXB0aCA9IGZsYXQuZGVwdGgoaW5kZXgpXG4gIHZhciBwYXJlbnQgPSBmbGF0LnBhcmVudChuZXh0LCBkZXB0aCsrKVxuXG4gIHdoaWxlIChmbGF0LnJpZ2h0U3BhbihuZXh0KSA8IG1heCB8fCBmbGF0LmxlZnRTcGFuKHBhcmVudCkgPiAwKSB7XG4gICAgaWYgKHRoaXMuZ2V0KG5leHQpKSB7XG4gICAgICBkaWdlc3QgfD0gYml0XG4gICAgfVxuICAgIGlmICh0aGlzLmdldChwYXJlbnQpKSB7XG4gICAgICBkaWdlc3QgfD0gKDIgKiBiaXQgKyAxKVxuICAgICAgaWYgKGRpZ2VzdCArIDEgPT09IDQgKiBiaXQpIHJldHVybiAxXG4gICAgICByZXR1cm4gZGlnZXN0XG4gICAgfVxuICAgIG5leHQgPSBmbGF0LnNpYmxpbmcocGFyZW50KVxuICAgIHBhcmVudCA9IGZsYXQucGFyZW50KG5leHQsIGRlcHRoKyspXG4gICAgYml0ICo9IDJcbiAgfVxuXG4gIHJldHVybiBkaWdlc3Rcbn1cblxuVHJlZUluZGV4LnByb3RvdHlwZS5ibG9ja3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b3AgPSAwXG4gIHZhciBuZXh0ID0gMFxuICB2YXIgbWF4ID0gdGhpcy5iaXRmaWVsZC5sZW5ndGhcblxuICB3aGlsZSAoZmxhdC5yaWdodFNwYW4obmV4dCkgPCBtYXgpIHtcbiAgICBuZXh0ID0gZmxhdC5wYXJlbnQobmV4dClcbiAgICBpZiAodGhpcy5nZXQobmV4dCkpIHRvcCA9IG5leHRcbiAgfVxuXG4gIHJldHVybiAodGhpcy5nZXQodG9wKSA/IHRoaXMudmVyaWZpZWRCeSh0b3ApIDogMCkgLyAyXG59XG5cblRyZWVJbmRleC5wcm90b3R5cGUucm9vdHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmbGF0LmZ1bGxSb290cygyICogdGhpcy5ibG9ja3MoKSlcbn1cblxuVHJlZUluZGV4LnByb3RvdHlwZS52ZXJpZmllZEJ5ID0gZnVuY3Rpb24gKGluZGV4LCBub2Rlcykge1xuICB2YXIgaGFzSW5kZXggPSB0aGlzLmdldChpbmRleClcbiAgaWYgKCFoYXNJbmRleCkgcmV0dXJuIDBcblxuICAvLyBmaW5kIHJvb3Qgb2YgY3VycmVudCB0cmVlXG5cbiAgdmFyIGRlcHRoID0gZmxhdC5kZXB0aChpbmRleClcbiAgdmFyIHRvcCA9IGluZGV4XG4gIHZhciBwYXJlbnQgPSBmbGF0LnBhcmVudCh0b3AsIGRlcHRoKyspXG4gIHdoaWxlICh0aGlzLmdldChwYXJlbnQpICYmIHRoaXMuZ2V0KGZsYXQuc2libGluZyh0b3ApKSkge1xuICAgIHRvcCA9IHBhcmVudFxuICAgIHBhcmVudCA9IGZsYXQucGFyZW50KHRvcCwgZGVwdGgrKylcbiAgfVxuXG4gIC8vIGV4cGFuZCByaWdodCBkb3duXG5cbiAgZGVwdGgtLVxuICB3aGlsZSAoZGVwdGgpIHtcbiAgICB0b3AgPSBmbGF0LmxlZnRDaGlsZChmbGF0LmluZGV4KGRlcHRoLCBmbGF0Lm9mZnNldCh0b3AsIGRlcHRoKSArIDEpLCBkZXB0aClcbiAgICBkZXB0aC0tXG5cbiAgICB3aGlsZSAoIXRoaXMuZ2V0KHRvcCkgJiYgZGVwdGgpIHRvcCA9IGZsYXQubGVmdENoaWxkKHRvcCwgZGVwdGgtLSlcbiAgICBpZiAobm9kZXMgJiYgdGhpcy5nZXQodG9wKSkgbm9kZXMucHVzaCh0b3ApXG4gIH1cblxuICByZXR1cm4gdGhpcy5nZXQodG9wKSA/IHRvcCArIDIgOiB0b3Bcbn1cblxuVHJlZUluZGV4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuYml0ZmllbGQuZ2V0KGluZGV4KVxufVxuXG5UcmVlSW5kZXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICBpZiAoIXRoaXMuYml0ZmllbGQuc2V0KGluZGV4LCB0cnVlKSkgcmV0dXJuIGZhbHNlXG4gIHdoaWxlICh0aGlzLmJpdGZpZWxkLmdldChmbGF0LnNpYmxpbmcoaW5kZXgpKSkge1xuICAgIGluZGV4ID0gZmxhdC5wYXJlbnQoaW5kZXgpXG4gICAgaWYgKCF0aGlzLmJpdGZpZWxkLnNldChpbmRleCwgdHJ1ZSkpIGJyZWFrXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmlnaHRTaGlmdCAobikge1xuICByZXR1cm4gKG4gLSAobiAmIDEpKSAvIDJcbn1cblxuZnVuY3Rpb24gYWRkRnVsbFJvb3RzICh2ZXJpZmllZEJ5LCBub2Rlcywgcm9vdCwgcmVtb3RlVHJlZSkge1xuICB2YXIgcm9vdHMgPSBmbGF0LmZ1bGxSb290cyh2ZXJpZmllZEJ5KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJvb3RzW2ldICE9PSByb290ICYmICFyZW1vdGVUcmVlLmdldChyb290c1tpXSkpIG5vZGVzLnB1c2gocm9vdHNbaV0pXG4gIH1cbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh3b3JrKSB7XG4gIHZhciBwZW5kaW5nID0gbnVsbFxuICB2YXIgY2FsbGJhY2sgPSBudWxsXG4gIHZhciBjYWxsYmFja3MgPSBudWxsXG4gIHZhciBuZXh0ID0gbnVsbFxuXG4gIHJldHVybiBmdW5jdGlvbiAodmFsLCBjYikge1xuICAgIG5leHQgPSB2YWxcbiAgICB1cGRhdGUoY2IgfHwgbm9vcClcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZSAoY2IpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGlmICghcGVuZGluZykgcGVuZGluZyA9IFtdXG4gICAgICBwZW5kaW5nLnB1c2goY2IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgdmFsID0gbmV4dFxuICAgIG5leHQgPSBudWxsXG4gICAgY2FsbGJhY2sgPSBjYlxuICAgIHdvcmsodmFsLCBkb25lKVxuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgdmFyIGNiID0gY2FsbGJhY2tcbiAgICB2YXIgY2JzID0gY2FsbGJhY2tzXG4gICAgY2FsbGJhY2tzID0gbnVsbFxuICAgIGNhbGxiYWNrID0gbnVsbFxuXG4gICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgIGNhbGxiYWNrcyA9IHBlbmRpbmdcbiAgICAgIHBlbmRpbmcgPSBudWxsXG4gICAgICB1cGRhdGUobm9vcClcbiAgICB9XG5cbiAgICBpZiAoY2JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5sZW5ndGg7IGkrKykgY2JzW2ldKGVycilcbiAgICB9XG4gICAgY2IoZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AgKF8pIHt9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBhZ2VyXG5cbmZ1bmN0aW9uIFBhZ2VyIChwYWdlU2l6ZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFnZXIpKSByZXR1cm4gbmV3IFBhZ2VyKHBhZ2VTaXplKVxuXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnVwZGF0ZXMgPSBbXVxuICB0aGlzLnBhZ2VzID0gbmV3IEFycmF5KDE2KVxuICB0aGlzLnBhZ2VTaXplID0gcGFnZVNpemUgfHwgMTAyNFxufVxuXG5QYWdlci5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uIChwYWdlKSB7XG4gIGlmIChwYWdlLnVwZGF0ZWQgfHwgIXRoaXMudXBkYXRlcykgcmV0dXJuXG4gIHBhZ2UudXBkYXRlZCA9IHRydWVcbiAgdGhpcy51cGRhdGVzLnB1c2gocGFnZSlcbn1cblxuUGFnZXIucHJvdG90eXBlLmxhc3RVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy51cGRhdGVzIHx8ICF0aGlzLnVwZGF0ZXMubGVuZ3RoKSByZXR1cm4gbnVsbFxuICB2YXIgcGFnZSA9IHRoaXMudXBkYXRlcy5wb3AoKVxuICBwYWdlLnVwZGF0ZWQgPSBmYWxzZVxuICByZXR1cm4gcGFnZVxufVxuXG5QYWdlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGksIG5vQWxsb2NhdGUpIHtcbiAgaWYgKGkgPj0gdGhpcy5wYWdlcy5sZW5ndGgpIHtcbiAgICBpZiAobm9BbGxvY2F0ZSkgcmV0dXJuXG4gICAgdGhpcy5wYWdlcyA9IGdyb3codGhpcy5wYWdlcywgaSwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgcGFnZSA9IHRoaXMucGFnZXNbaV1cblxuICBpZiAoIXBhZ2UgJiYgIW5vQWxsb2NhdGUpIHtcbiAgICBwYWdlID0gdGhpcy5wYWdlc1tpXSA9IG5ldyBQYWdlKGksIGFsbG9jKHRoaXMucGFnZVNpemUpKVxuICAgIGlmIChpID49IHRoaXMubGVuZ3RoKSB0aGlzLmxlbmd0aCA9IGkgKyAxXG4gIH1cblxuICByZXR1cm4gcGFnZVxufVxuXG5QYWdlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGksIGJ1Zikge1xuICBpZiAoaSA+PSB0aGlzLnBhZ2VzLmxlbmd0aCkgdGhpcy5wYWdlcyA9IGdyb3codGhpcy5wYWdlcywgaSwgdGhpcy5sZW5ndGgpXG4gIGlmIChpID49IHRoaXMubGVuZ3RoKSB0aGlzLmxlbmd0aCA9IGkgKyAxXG5cbiAgaWYgKCFidWYpIHtcbiAgICB0aGlzLnBhZ2VzW2ldID0gdW5kZWZpbmVkXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgcGFnZSA9IHRoaXMucGFnZXNbaV1cbiAgdmFyIGIgPSB0cnVuY2F0ZShidWYsIHRoaXMucGFnZVNpemUpXG5cbiAgaWYgKHBhZ2UpIHBhZ2UuYnVmZmVyID0gYlxuICBlbHNlIHRoaXMucGFnZXNbaV0gPSBuZXcgUGFnZShpLCBiKVxufVxuXG5QYWdlci5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsaXN0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICB2YXIgZW1wdHkgPSBhbGxvYyh0aGlzLnBhZ2VTaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGxpc3RbaV0gPSB0aGlzLnBhZ2VzW2ldID8gdGhpcy5wYWdlc1tpXS5idWZmZXIgOiBlbXB0eVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQobGlzdClcbn1cblxuZnVuY3Rpb24gZ3JvdyAobGlzdCwgaW5kZXgsIGxlbikge1xuICB2YXIgbmxlbiA9IGxpc3QubGVuZ3RoICogMlxuICB3aGlsZSAobmxlbiA8PSBpbmRleCkgbmxlbiAqPSAyXG5cbiAgdmFyIHR3aWNlID0gbmV3IEFycmF5KG5sZW4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHR3aWNlW2ldID0gbGlzdFtpXVxuICByZXR1cm4gdHdpY2Vcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUgKGJ1ZiwgbGVuKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBsZW4pIHJldHVybiBidWZcbiAgaWYgKGJ1Zi5sZW5ndGggPiBsZW4pIHJldHVybiBidWYuc2xpY2UoMCwgbGVuKVxuICB2YXIgY3B5ID0gYWxsb2MobGVuKVxuICBidWYuY29weShjcHkpXG4gIHJldHVybiBjcHlcbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUpIHtcbiAgaWYgKEJ1ZmZlci5hbGxvYykgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKVxuICBidWYuZmlsbCgwKVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIFBhZ2UgKGksIGJ1Zikge1xuICB0aGlzLm9mZnNldCA9IGkgKiBidWYubGVuZ3RoXG4gIHRoaXMuYnVmZmVyID0gYnVmXG4gIHRoaXMudXBkYXRlZCA9IGZhbHNlXG59XG4iLCIvLyBhIG1vcmUgbG93IGxldmVsIGludGVyZmFjZSB0byB0aGUgbWVya2xlIHRyZWUgc3RyZWFtLlxuLy8gdXNlZnVsIGZvciBjZXJ0YWluIGFwcGxpY2F0aW9ucyB0aGUgcmVxdWlyZSBub24tc3RyZWFteSBhY2Nlc3MgdG8gdGhlIGFsZ29zLlxuLy8gdmVyc2lvbmVkIGJ5IHRoZSBzYW1lIHNlbXZlciBhcyB0aGUgc3RyZWFtIGludGVyZmFjZS5cblxudmFyIGZsYXQgPSByZXF1aXJlKCdmbGF0LXRyZWUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmtsZUdlbmVyYXRvclxuXG5mdW5jdGlvbiBNZXJrbGVHZW5lcmF0b3IgKG9wdHMsIHJvb3RzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNZXJrbGVHZW5lcmF0b3IpKSByZXR1cm4gbmV3IE1lcmtsZUdlbmVyYXRvcihvcHRzLCByb290cylcbiAgaWYgKCFvcHRzIHx8ICFvcHRzLmxlYWYgfHwgIW9wdHMucGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoJ29wdHMubGVhZiBhbmQgb3B0cy5wYXJlbnQgcmVxdWlyZWQnKVxuXG4gIHRoaXMucm9vdHMgPSByb290cyB8fCBvcHRzLnJvb3RzIHx8IFtdXG4gIHRoaXMuYmxvY2tzID0gdGhpcy5yb290cy5sZW5ndGggPyAxICsgZmxhdC5yaWdodFNwYW4odGhpcy5yb290c1t0aGlzLnJvb3RzLmxlbmd0aCAtIDFdLmluZGV4KSAvIDIgOiAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHIgPSB0aGlzLnJvb3RzW2ldXG4gICAgaWYgKHIgJiYgIXIucGFyZW50KSByLnBhcmVudCA9IGZsYXQucGFyZW50KHIuaW5kZXgpXG4gIH1cblxuICB0aGlzLl9sZWFmID0gb3B0cy5sZWFmXG4gIHRoaXMuX3BhcmVudCA9IG9wdHMucGFyZW50XG59XG5cbk1lcmtsZUdlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChkYXRhLCBub2Rlcykge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSlcbiAgaWYgKCFub2Rlcykgbm9kZXMgPSBbXVxuXG4gIHZhciBpbmRleCA9IDIgKiB0aGlzLmJsb2NrcysrXG5cbiAgdmFyIGxlYWYgPSB7XG4gICAgaW5kZXg6IGluZGV4LFxuICAgIHBhcmVudDogZmxhdC5wYXJlbnQoaW5kZXgpLFxuICAgIGhhc2g6IG51bGwsXG4gICAgc2l6ZTogZGF0YS5sZW5ndGgsXG4gICAgZGF0YTogZGF0YVxuICB9XG5cbiAgbGVhZi5oYXNoID0gdGhpcy5fbGVhZihsZWFmLCB0aGlzLnJvb3RzKVxuICB0aGlzLnJvb3RzLnB1c2gobGVhZilcbiAgbm9kZXMucHVzaChsZWFmKVxuXG4gIHdoaWxlICh0aGlzLnJvb3RzLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgbGVmdCA9IHRoaXMucm9vdHNbdGhpcy5yb290cy5sZW5ndGggLSAyXVxuICAgIHZhciByaWdodCA9IHRoaXMucm9vdHNbdGhpcy5yb290cy5sZW5ndGggLSAxXVxuXG4gICAgaWYgKGxlZnQucGFyZW50ICE9PSByaWdodC5wYXJlbnQpIGJyZWFrXG5cbiAgICB0aGlzLnJvb3RzLnBvcCgpXG4gICAgdGhpcy5yb290c1t0aGlzLnJvb3RzLmxlbmd0aCAtIDFdID0gbGVhZiA9IHtcbiAgICAgIGluZGV4OiBsZWZ0LnBhcmVudCxcbiAgICAgIHBhcmVudDogZmxhdC5wYXJlbnQobGVmdC5wYXJlbnQpLFxuICAgICAgaGFzaDogdGhpcy5fcGFyZW50KGxlZnQsIHJpZ2h0KSxcbiAgICAgIHNpemU6IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemUsXG4gICAgICBkYXRhOiBudWxsXG4gICAgfVxuICAgIG5vZGVzLnB1c2gobGVhZilcbiAgfVxuXG4gIHJldHVybiBub2Rlc1xufVxuIiwiYXNzZXJ0Lm5vdEVxdWFsID0gbm90RXF1YWxcbmFzc2VydC5ub3RPayA9IG5vdE9rXG5hc3NlcnQuZXF1YWwgPSBlcXVhbFxuYXNzZXJ0Lm9rID0gYXNzZXJ0XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0XG5cbmZ1bmN0aW9uIGVxdWFsIChhLCBiLCBtKSB7XG4gIGFzc2VydChhID09IGIsIG0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG59XG5cbmZ1bmN0aW9uIG5vdEVxdWFsIChhLCBiLCBtKSB7XG4gIGFzc2VydChhICE9IGIsIG0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG59XG5cbmZ1bmN0aW9uIG5vdE9rICh0LCBtKSB7XG4gIGFzc2VydCghdCwgbSlcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0LCBtKSB7XG4gIGlmICghdCkgdGhyb3cgbmV3IEVycm9yKG0gfHwgJ0Fzc2VydGlvbkVycm9yJylcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljaztcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxudmFyIHN2YXJpbnQgPSByZXF1aXJlKCdzaWduZWQtdmFyaW50JylcblxuZXhwb3J0cy5tYWtlID0gZW5jb2RlclxuXG5leHBvcnRzLm5hbWUgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHNba2V5c1tpXV0gPT09IGVuYykgcmV0dXJuIGtleXNbaV1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnRzLnNraXAgPSBmdW5jdGlvbiAodHlwZSwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAwOlxuICAgICAgdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICAgIHJldHVybiBvZmZzZXQgKyB2YXJpbnQuZGVjb2RlLmJ5dGVzXG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgOFxuXG4gICAgY2FzZSAyOlxuICAgICAgdmFyIGxlbiA9IHZhcmludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpXG4gICAgICByZXR1cm4gb2Zmc2V0ICsgdmFyaW50LmRlY29kZS5ieXRlcyArIGxlblxuXG4gICAgY2FzZSAzOlxuICAgIGNhc2UgNDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignR3JvdXBzIGFyZSBub3Qgc3VwcG9ydGVkJylcblxuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBvZmZzZXQgKyA0XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gd2lyZSB0eXBlOiAnICsgdHlwZSlcbn1cblxuZXhwb3J0cy5ieXRlcyA9IGVuY29kZXIoMixcbiAgZnVuY3Rpb24gZW5jb2RlICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBsZW4gPSBidWZmZXJMZW5ndGgodmFsKVxuXG4gICAgdmFyaW50LmVuY29kZShsZW4sIGJ1ZmZlciwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KVxuICAgIGVsc2UgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBsZW4pXG4gICAgb2Zmc2V0ICs9IGxlblxuXG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuXG4gICAgdmFyIGxlbiA9IHZhcmludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcblxuICAgIHZhciB2YWwgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pXG4gICAgb2Zmc2V0ICs9IHZhbC5sZW5ndGhcblxuICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiB2YWxcbiAgfSxcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKHZhbCkge1xuICAgIHZhciBsZW4gPSBidWZmZXJMZW5ndGgodmFsKVxuICAgIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgobGVuKSArIGxlblxuICB9XG4pXG5cbmV4cG9ydHMuc3RyaW5nID0gZW5jb2RlcigyLFxuICBmdW5jdGlvbiBlbmNvZGUgKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbClcblxuICAgIHZhcmludC5lbmNvZGUobGVuLCBidWZmZXIsIG9mZnNldCwgJ3V0Zi04JylcbiAgICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuXG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBsZW4pXG4gICAgb2Zmc2V0ICs9IGxlblxuXG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuXG4gICAgdmFyIGxlbiA9IHZhcmludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcblxuICAgIHZhciB2YWwgPSBidWZmZXIudG9TdHJpbmcoJ3V0Zi04Jywgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pXG4gICAgb2Zmc2V0ICs9IGxlblxuXG4gICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIHZhbFxuICB9LFxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAodmFsKSB7XG4gICAgdmFyIGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbClcbiAgICByZXR1cm4gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGxlbikgKyBsZW5cbiAgfVxuKVxuXG5leHBvcnRzLmJvb2wgPSBlbmNvZGVyKDAsXG4gIGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gdmFsID8gMSA6IDBcbiAgICBlbmNvZGUuYnl0ZXMgPSAxXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIGJvb2wgPSBidWZmZXJbb2Zmc2V0XSA+IDBcbiAgICBkZWNvZGUuYnl0ZXMgPSAxXG4gICAgcmV0dXJuIGJvb2xcbiAgfSxcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cbilcblxuZXhwb3J0cy5pbnQzMiA9IGVuY29kZXIoMCxcbiAgZnVuY3Rpb24gZW5jb2RlICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyaW50LmVuY29kZSh2YWwgPCAwID8gdmFsICsgNDI5NDk2NzI5NiA6IHZhbCwgYnVmZmVyLCBvZmZzZXQpXG4gICAgZW5jb2RlLmJ5dGVzID0gdmFyaW50LmVuY29kZS5ieXRlc1xuICAgIHJldHVybiBidWZmZXJcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciB2YWwgPSB2YXJpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KVxuICAgIGRlY29kZS5ieXRlcyA9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICByZXR1cm4gdmFsID4gMjE0NzQ4MzY0NyA/IHZhbCAtIDQyOTQ5NjcyOTYgOiB2YWxcbiAgfSxcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKHZhbCkge1xuICAgIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgodmFsIDwgMCA/IHZhbCArIDQyOTQ5NjcyOTYgOiB2YWwpXG4gIH1cbilcblxuZXhwb3J0cy5pbnQ2NCA9IGVuY29kZXIoMCxcbiAgZnVuY3Rpb24gZW5jb2RlICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgIHZhciBsYXN0ID0gb2Zmc2V0ICsgOVxuICAgICAgdmFyaW50LmVuY29kZSh2YWwgKiAtMSwgYnVmZmVyLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlcyAtIDFcbiAgICAgIGJ1ZmZlcltvZmZzZXRdID0gYnVmZmVyW29mZnNldF0gfCAweDgwXG4gICAgICB3aGlsZSAob2Zmc2V0IDwgbGFzdCAtIDEpIHtcbiAgICAgICAgb2Zmc2V0KytcbiAgICAgICAgYnVmZmVyW29mZnNldF0gPSAweGZmXG4gICAgICB9XG4gICAgICBidWZmZXJbbGFzdF0gPSAweDAxXG4gICAgICBlbmNvZGUuYnl0ZXMgPSAxMFxuICAgIH0gZWxzZSB7XG4gICAgICB2YXJpbnQuZW5jb2RlKHZhbCwgYnVmZmVyLCBvZmZzZXQpXG4gICAgICBlbmNvZGUuYnl0ZXMgPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIHJldHVybiBidWZmZXJcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciB2YWwgPSB2YXJpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KVxuICAgIGlmICh2YWwgPj0gTWF0aC5wb3coMiwgNjMpKSB7XG4gICAgICB2YXIgbGltaXQgPSA5XG4gICAgICB3aGlsZSAoYnVmZmVyW29mZnNldCArIGxpbWl0IC0gMV0gPT09IDB4ZmYpIGxpbWl0LS1cbiAgICAgIGxpbWl0ID0gbGltaXQgfHwgOVxuICAgICAgdmFyIHN1YnNldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsaW1pdClcbiAgICAgIGJ1ZmZlci5jb3B5KHN1YnNldCwgMCwgb2Zmc2V0LCBvZmZzZXQgKyBsaW1pdClcbiAgICAgIHN1YnNldFtsaW1pdCAtIDFdID0gc3Vic2V0W2xpbWl0IC0gMV0gJiAweDdmXG4gICAgICB2YWwgPSAtMSAqIHZhcmludC5kZWNvZGUoc3Vic2V0LCAwKVxuICAgICAgZGVjb2RlLmJ5dGVzID0gMTBcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjb2RlLmJ5dGVzID0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgIH1cbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoICh2YWwpIHtcbiAgICByZXR1cm4gdmFsIDwgMCA/IDEwIDogdmFyaW50LmVuY29kaW5nTGVuZ3RoKHZhbClcbiAgfVxuKVxuXG5leHBvcnRzLnNpbnQzMiA9XG5leHBvcnRzLnNpbnQ2NCA9IGVuY29kZXIoMCxcbiAgc3ZhcmludC5lbmNvZGUsXG4gIHN2YXJpbnQuZGVjb2RlLFxuICBzdmFyaW50LmVuY29kaW5nTGVuZ3RoXG4pXG5cbmV4cG9ydHMudWludDMyID1cbmV4cG9ydHMudWludDY0ID1cbmV4cG9ydHMuZW51bSA9XG5leHBvcnRzLnZhcmludCA9IGVuY29kZXIoMCxcbiAgdmFyaW50LmVuY29kZSxcbiAgdmFyaW50LmRlY29kZSxcbiAgdmFyaW50LmVuY29kaW5nTGVuZ3RoXG4pXG5cbi8vIHdlIGNhbm5vdCByZXByZXNlbnQgdGhlc2UgaW4gamF2YXNjcmlwdCBzbyB3ZSBqdXN0IHVzZSBidWZmZXJzXG5leHBvcnRzLmZpeGVkNjQgPVxuZXhwb3J0cy5zZml4ZWQ2NCA9IGVuY29kZXIoMSxcbiAgZnVuY3Rpb24gZW5jb2RlICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpXG4gICAgZW5jb2RlLmJ5dGVzID0gOFxuICAgIHJldHVybiBidWZmZXJcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciB2YWwgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA4KVxuICAgIGRlY29kZS5ieXRlcyA9IDhcbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gOFxuICB9XG4pXG5cbmV4cG9ydHMuZG91YmxlID0gZW5jb2RlcigxLFxuICBmdW5jdGlvbiBlbmNvZGUgKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBidWZmZXIud3JpdGVEb3VibGVMRSh2YWwsIG9mZnNldClcbiAgICBlbmNvZGUuYnl0ZXMgPSA4XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbCA9IGJ1ZmZlci5yZWFkRG91YmxlTEUob2Zmc2V0KVxuICAgIGRlY29kZS5ieXRlcyA9IDhcbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gOFxuICB9XG4pXG5cbmV4cG9ydHMuZml4ZWQzMiA9IGVuY29kZXIoNSxcbiAgZnVuY3Rpb24gZW5jb2RlICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUodmFsLCBvZmZzZXQpXG4gICAgZW5jb2RlLmJ5dGVzID0gNFxuICAgIHJldHVybiBidWZmZXJcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciB2YWwgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldClcbiAgICBkZWNvZGUuYnl0ZXMgPSA0XG4gICAgcmV0dXJuIHZhbFxuICB9LFxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDRcbiAgfVxuKVxuXG5leHBvcnRzLnNmaXhlZDMyID0gZW5jb2Rlcig1LFxuICBmdW5jdGlvbiBlbmNvZGUgKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBidWZmZXIud3JpdGVJbnQzMkxFKHZhbCwgb2Zmc2V0KVxuICAgIGVuY29kZS5ieXRlcyA9IDRcbiAgICByZXR1cm4gYnVmZmVyXG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gYnVmZmVyLnJlYWRJbnQzMkxFKG9mZnNldClcbiAgICBkZWNvZGUuYnl0ZXMgPSA0XG4gICAgcmV0dXJuIHZhbFxuICB9LFxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDRcbiAgfVxuKVxuXG5leHBvcnRzLmZsb2F0ID0gZW5jb2Rlcig1LFxuICBmdW5jdGlvbiBlbmNvZGUgKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBidWZmZXIud3JpdGVGbG9hdExFKHZhbCwgb2Zmc2V0KVxuICAgIGVuY29kZS5ieXRlcyA9IDRcbiAgICByZXR1cm4gYnVmZmVyXG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gYnVmZmVyLnJlYWRGbG9hdExFKG9mZnNldClcbiAgICBkZWNvZGUuYnl0ZXMgPSA0XG4gICAgcmV0dXJuIHZhbFxuICB9LFxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDRcbiAgfVxuKVxuXG5mdW5jdGlvbiBlbmNvZGVyICh0eXBlLCBlbmNvZGUsIGRlY29kZSwgZW5jb2RpbmdMZW5ndGgpIHtcbiAgZW5jb2RlLmJ5dGVzID0gZGVjb2RlLmJ5dGVzID0gMFxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBlbmNvZGluZ0xlbmd0aDogZW5jb2RpbmdMZW5ndGhcbiAgfVxufVxuXG5mdW5jdGlvbiBidWZmZXJMZW5ndGggKHZhbCkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHZhbCkgPyB2YWwubGVuZ3RoIDogQnVmZmVyLmJ5dGVMZW5ndGgodmFsKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigncmFuZG9tLWFjY2Vzcy1maWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXInKVxufVxuIiwidmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbnZhciBOT1RfUkVBREFCTEUgPSBkZWZhdWx0SW1wbChuZXcgRXJyb3IoJ05vdCByZWFkYWJsZScpKVxudmFyIE5PVF9XUklUQUJMRSA9IGRlZmF1bHRJbXBsKG5ldyBFcnJvcignTm90IHdyaXRhYmxlJykpXG52YXIgTk9UX0RFTEVUQUJMRSA9IGRlZmF1bHRJbXBsKG5ldyBFcnJvcignTm90IGRlbGV0YWJsZScpKVxudmFyIE5PVF9TVEFUQUJMRSA9IGRlZmF1bHRJbXBsKG5ldyBFcnJvcignTm90IHN0YXRhYmxlJykpXG52YXIgTk9fT1BFTl9SRUFEQUJMRSA9IGRlZmF1bHRJbXBsKG5ldyBFcnJvcignTm8gcmVhZG9ubHkgb3BlbicpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbUFjY2Vzc1xuXG5mdW5jdGlvbiBSYW5kb21BY2Nlc3MgKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhbmRvbUFjY2VzcykpIHJldHVybiBuZXcgUmFuZG9tQWNjZXNzKG9wdHMpXG4gIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuXG4gIHRoaXMuX3F1ZXVlZCA9IFtdXG4gIHRoaXMuX3BlbmRpbmcgPSAwXG4gIHRoaXMuX25lZWRzT3BlbiA9IHRydWVcblxuICB0aGlzLm9wZW5lZCA9IGZhbHNlXG4gIHRoaXMuY2xvc2VkID0gZmFsc2VcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIGlmIChvcHRzKSB7XG4gICAgaWYgKG9wdHMub3BlblJlYWRvbmx5KSB0aGlzLl9vcGVuUmVhZG9ubHkgPSBvcHRzLm9wZW5SZWFkb25seVxuICAgIGlmIChvcHRzLm9wZW4pIHRoaXMuX29wZW4gPSBvcHRzLm9wZW5cbiAgICBpZiAob3B0cy5yZWFkKSB0aGlzLl9yZWFkID0gb3B0cy5yZWFkXG4gICAgaWYgKG9wdHMud3JpdGUpIHRoaXMuX3dyaXRlID0gb3B0cy53cml0ZVxuICAgIGlmIChvcHRzLmRlbCkgdGhpcy5fZGVsID0gb3B0cy5kZWxcbiAgICBpZiAob3B0cy5zdGF0KSB0aGlzLl9zdGF0ID0gb3B0cy5zdGF0XG4gICAgaWYgKG9wdHMuY2xvc2UpIHRoaXMuX2Nsb3NlID0gb3B0cy5jbG9zZVxuICAgIGlmIChvcHRzLmRlc3Ryb3kpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRzLmRlc3Ryb3lcbiAgfVxuXG4gIHRoaXMucHJlZmVyUmVhZG9ubHkgPSB0aGlzLl9vcGVuUmVhZG9ubHkgIT09IE5PX09QRU5fUkVBREFCTEVcbiAgdGhpcy5yZWFkYWJsZSA9IHRoaXMuX3JlYWQgIT09IE5PVF9SRUFEQUJMRVxuICB0aGlzLndyaXRhYmxlID0gdGhpcy5fd3JpdGUgIT09IE5PVF9XUklUQUJMRVxuICB0aGlzLmRlbGV0YWJsZSA9IHRoaXMuX2RlbCAhPT0gTk9UX0RFTEVUQUJMRVxuICB0aGlzLnN0YXRhYmxlID0gdGhpcy5fc3RhdCAhPT0gTk9UX1NUQVRBQkxFXG59XG5cbmluaGVyaXRzKFJhbmRvbUFjY2VzcywgZXZlbnRzLkV2ZW50RW1pdHRlcilcblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICghY2IpIGNiID0gbm9vcFxuICBpZiAodGhpcy5vcGVuZWQgJiYgIXRoaXMuX25lZWRzT3BlbikgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2IsIG51bGwpXG4gIHF1ZXVlQW5kUnVuKHRoaXMsIG5ldyBSZXF1ZXN0KHRoaXMsIDAsIDAsIDAsIG51bGwsIGNiKSlcbn1cblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5fb3BlbiA9IGRlZmF1bHRJbXBsKG51bGwpXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLl9vcGVuUmVhZG9ubHkgPSBOT19PUEVOX1JFQURBQkxFXG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIHNpemUsIGNiKSB7XG4gIHRoaXMucnVuKG5ldyBSZXF1ZXN0KHRoaXMsIDEsIG9mZnNldCwgc2l6ZSwgbnVsbCwgY2IpKVxufVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLl9yZWFkID0gTk9UX1JFQURBQkxFXG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob2Zmc2V0LCBkYXRhLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgb3BlbldyaXRhYmxlKHRoaXMpXG4gIHRoaXMucnVuKG5ldyBSZXF1ZXN0KHRoaXMsIDIsIG9mZnNldCwgZGF0YS5sZW5ndGgsIGRhdGEsIGNiKSlcbn1cblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5fd3JpdGUgPSBOT1RfV1JJVEFCTEVcblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAob2Zmc2V0LCBzaXplLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgb3BlbldyaXRhYmxlKHRoaXMpXG4gIHRoaXMucnVuKG5ldyBSZXF1ZXN0KHRoaXMsIDMsIG9mZnNldCwgc2l6ZSwgbnVsbCwgY2IpKVxufVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLl9kZWwgPSBOT1RfREVMRVRBQkxFXG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uIChjYikge1xuICB0aGlzLnJ1bihuZXcgUmVxdWVzdCh0aGlzLCA0LCAwLCAwLCBudWxsLCBjYikpXG59XG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuX3N0YXQgPSBOT1RfU1RBVEFCTEVcblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKHRoaXMuY2xvc2VkKSByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYiwgbnVsbClcbiAgcXVldWVBbmRSdW4odGhpcywgbmV3IFJlcXVlc3QodGhpcywgNSwgMCwgMCwgbnVsbCwgY2IpKVxufVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLl9jbG9zZSA9IGRlZmF1bHRJbXBsKG51bGwpXG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKCF0aGlzLmNsb3NlZCkgdGhpcy5jbG9zZShub29wKVxuICBxdWV1ZUFuZFJ1bih0aGlzLCBuZXcgUmVxdWVzdCh0aGlzLCA2LCAwLCAwLCBudWxsLCBjYikpXG59XG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBkZWZhdWx0SW1wbChudWxsKVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgaWYgKHRoaXMuX25lZWRzT3BlbikgdGhpcy5vcGVuKG5vb3ApXG4gIGlmICh0aGlzLl9xdWV1ZWQubGVuZ3RoKSB0aGlzLl9xdWV1ZWQucHVzaChyZXEpXG4gIGVsc2UgcmVxLl9ydW4oKVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIFJlcXVlc3QgKHNlbGYsIHR5cGUsIG9mZnNldCwgc2l6ZSwgZGF0YSwgY2IpIHtcbiAgdGhpcy50eXBlID0gdHlwZVxuICB0aGlzLm9mZnNldCA9IG9mZnNldFxuICB0aGlzLmRhdGEgPSBkYXRhXG4gIHRoaXMuc2l6ZSA9IHNpemVcbiAgdGhpcy5zdG9yYWdlID0gc2VsZlxuXG4gIHRoaXMuX3N5bmMgPSBmYWxzZVxuICB0aGlzLl9jYWxsYmFjayA9IGNiXG59XG5cblJlcXVlc3QucHJvdG90eXBlLl91bnF1ZXVlID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgcmEgPSB0aGlzLnN0b3JhZ2VcbiAgdmFyIHF1ZXVlZCA9IHJhLl9xdWV1ZWRcblxuICBpZiAoIWVycikge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGlmICghcmEub3BlbmVkKSB7XG4gICAgICAgICAgcmEub3BlbmVkID0gdHJ1ZVxuICAgICAgICAgIHJhLmVtaXQoJ29wZW4nKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgaWYgKCFyYS5jbG9zZWQpIHtcbiAgICAgICAgICByYS5jbG9zZWQgPSB0cnVlXG4gICAgICAgICAgcmEuZW1pdCgnY2xvc2UnKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgNjpcbiAgICAgICAgaWYgKCFyYS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByYS5kZXN0cm95ZWQgPSB0cnVlXG4gICAgICAgICAgcmEuZW1pdCgnZGVzdHJveScpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAocXVldWVkLmxlbmd0aCAmJiBxdWV1ZWRbMF0gPT09IHRoaXMpIHF1ZXVlZC5zaGlmdCgpXG4gIGlmICghLS1yYS5fcGVuZGluZyAmJiBxdWV1ZWQubGVuZ3RoKSBxdWV1ZWRbMF0uX3J1bigpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24gKGVyciwgdmFsKSB7XG4gIGlmICh0aGlzLl9zeW5jKSByZXR1cm4gbmV4dFRpY2sodGhpcywgZXJyLCB2YWwpXG4gIHRoaXMuX3VucXVldWUoZXJyKVxuICB0aGlzLl9jYWxsYmFjayhlcnIsIHZhbClcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuX29wZW5BbmROb3RDbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByYSA9IHRoaXMuc3RvcmFnZVxuICBpZiAocmEub3BlbmVkICYmICFyYS5jbG9zZWQpIHJldHVybiB0cnVlXG4gIGlmICghcmEub3BlbmVkKSBuZXh0VGljayh0aGlzLCBuZXcgRXJyb3IoJ05vdCBvcGVuZWQnKSlcbiAgZWxzZSBpZiAocmEuY2xvc2VkKSBuZXh0VGljayh0aGlzLCBuZXcgRXJyb3IoJ0Nsb3NlZCcpKVxuICByZXR1cm4gZmFsc2Vcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByYSA9IHRoaXMuc3RvcmFnZVxuXG4gIGlmIChyYS5vcGVuZWQgJiYgIXJhLl9uZWVkc09wZW4pIHJldHVybiBuZXh0VGljayh0aGlzLCBudWxsKVxuICBpZiAocmEuY2xvc2VkKSByZXR1cm4gbmV4dFRpY2sodGhpcywgbmV3IEVycm9yKCdDbG9zZWQnKSlcblxuICByYS5fbmVlZHNPcGVuID0gZmFsc2VcbiAgaWYgKHJhLnByZWZlclJlYWRvbmx5KSByYS5fb3BlblJlYWRvbmx5KHRoaXMpXG4gIGVsc2UgcmEuX29wZW4odGhpcylcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuX3J1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhID0gdGhpcy5zdG9yYWdlXG4gIHJhLl9wZW5kaW5nKytcblxuICB0aGlzLl9zeW5jID0gdHJ1ZVxuXG4gIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSAwOlxuICAgICAgdGhpcy5fb3BlbigpXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAxOlxuICAgICAgaWYgKHRoaXMuX29wZW5BbmROb3RDbG9zZWQoKSkgcmEuX3JlYWQodGhpcylcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIDI6XG4gICAgICBpZiAodGhpcy5fb3BlbkFuZE5vdENsb3NlZCgpKSByYS5fd3JpdGUodGhpcylcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIDM6XG4gICAgICBpZiAodGhpcy5fb3BlbkFuZE5vdENsb3NlZCgpKSByYS5fZGVsKHRoaXMpXG4gICAgICBicmVha1xuXG4gICAgY2FzZSA0OlxuICAgICAgaWYgKHRoaXMuX29wZW5BbmROb3RDbG9zZWQoKSkgcmEuX3N0YXQodGhpcylcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIDU6XG4gICAgICBpZiAocmEuY2xvc2VkIHx8ICFyYS5vcGVuZWQpIG5leHRUaWNrKHRoaXMsIG51bGwpXG4gICAgICBlbHNlIHJhLl9jbG9zZSh0aGlzKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgNjpcbiAgICAgIGlmIChyYS5kZXN0cm95ZWQpIG5leHRUaWNrKHRoaXMsIG51bGwpXG4gICAgICBlbHNlIHJhLl9kZXN0cm95KHRoaXMpXG4gICAgICBicmVha1xuICB9XG5cbiAgdGhpcy5fc3luYyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIHF1ZXVlQW5kUnVuIChzZWxmLCByZXEpIHtcbiAgc2VsZi5fcXVldWVkLnB1c2gocmVxKVxuICBpZiAoIXNlbGYuX3BlbmRpbmcpIHJlcS5fcnVuKClcbn1cblxuZnVuY3Rpb24gb3BlbldyaXRhYmxlIChzZWxmKSB7XG4gIGlmIChzZWxmLnByZWZlclJlYWRvbmx5KSB7XG4gICAgc2VsZi5fbmVlZHNPcGVuID0gdHJ1ZVxuICAgIHNlbGYucHJlZmVyUmVhZG9ubHkgPSBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRJbXBsIChlcnIpIHtcbiAgcmV0dXJuIG92ZXJyaWRhYmxlXG5cbiAgZnVuY3Rpb24gb3ZlcnJpZGFibGUgKHJlcSkge1xuICAgIG5leHRUaWNrKHJlcSwgZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChyZXEsIGVyciwgdmFsKSB7XG4gIHByb2Nlc3MubmV4dFRpY2sobmV4dFRpY2tDYWxsYmFjaywgcmVxLCBlcnIsIHZhbClcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2tDYWxsYmFjayAocmVxLCBlcnIsIHZhbCkge1xuICByZXEuY2FsbGJhY2soZXJyLCB2YWwpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsInZhciB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUgKHYsIGIsIG8pIHtcbiAgdiA9IHYgPj0gMCA/IHYqMiA6IHYqLTIgLSAxXG4gIHZhciByID0gdmFyaW50LmVuY29kZSh2LCBiLCBvKVxuICBlbmNvZGUuYnl0ZXMgPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG4gIHJldHVybiByXG59XG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZSAoYiwgbykge1xuICB2YXIgdiA9IHZhcmludC5kZWNvZGUoYiwgbylcbiAgZGVjb2RlLmJ5dGVzID0gdmFyaW50LmRlY29kZS5ieXRlc1xuICByZXR1cm4gdiAmIDEgPyAodisxKSAvIC0yIDogdiAvIDJcbn1cblxuZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgodiA+PSAwID8gdioyIDogdiotMiAtIDEpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbGxiYWNrXG5cbmZ1bmN0aW9uIF9hZGQgKGEsIGIpIHtcbiAgdmFyIHJsID0gYS5sICsgYi5sXG4gIHZhciBhMiA9IHtcbiAgICBoOiBhLmggKyBiLmggKyAocmwgLyAyID4+PiAzMSkgPj4+IDAsXG4gICAgbDogcmwgPj4+IDBcbiAgfVxuICBhLmggPSBhMi5oXG4gIGEubCA9IGEyLmxcbn1cblxuZnVuY3Rpb24gX3hvciAoYSwgYikge1xuICBhLmggXj0gYi5oXG4gIGEuaCA+Pj49IDBcbiAgYS5sIF49IGIubFxuICBhLmwgPj4+PSAwXG59XG5cbmZ1bmN0aW9uIF9yb3RsIChhLCBuKSB7XG4gIHZhciBhMiA9IHtcbiAgICBoOiBhLmggPDwgbiB8IGEubCA+Pj4gKDMyIC0gbiksXG4gICAgbDogYS5sIDw8IG4gfCBhLmggPj4+ICgzMiAtIG4pXG4gIH1cbiAgYS5oID0gYTIuaFxuICBhLmwgPSBhMi5sXG59XG5cbmZ1bmN0aW9uIF9yb3RsMzIgKGEpIHtcbiAgdmFyIGFsID0gYS5sXG4gIGEubCA9IGEuaFxuICBhLmggPSBhbFxufVxuXG5mdW5jdGlvbiBfY29tcHJlc3MgKHYwLCB2MSwgdjIsIHYzKSB7XG4gIF9hZGQodjAsIHYxKVxuICBfYWRkKHYyLCB2MylcbiAgX3JvdGwodjEsIDEzKVxuICBfcm90bCh2MywgMTYpXG4gIF94b3IodjEsIHYwKVxuICBfeG9yKHYzLCB2MilcbiAgX3JvdGwzMih2MClcbiAgX2FkZCh2MiwgdjEpXG4gIF9hZGQodjAsIHYzKVxuICBfcm90bCh2MSwgMTcpXG4gIF9yb3RsKHYzLCAyMSlcbiAgX3hvcih2MSwgdjIpXG4gIF94b3IodjMsIHYwKVxuICBfcm90bDMyKHYyKVxufVxuXG5mdW5jdGlvbiBfZ2V0X2ludCAoYSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoYVtvZmZzZXQgKyAzXSA8PCAyNCkgfCAoYVtvZmZzZXQgKyAyXSA8PCAxNikgfCAoYVtvZmZzZXQgKyAxXSA8PCA4KSB8IGFbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBmYWxsYmFjayAob3V0LCBtLCBrZXkpIHsgLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vamVkaXNjdDEvc2lwaGFzaC1qcyB0byB1c2UgdWludDhhcnJheXNcbiAgdmFyIGswID0ge2g6IF9nZXRfaW50KGtleSwgNCksIGw6IF9nZXRfaW50KGtleSwgMCl9XG4gIHZhciBrMSA9IHtoOiBfZ2V0X2ludChrZXksIDEyKSwgbDogX2dldF9pbnQoa2V5LCA4KX1cbiAgdmFyIHYwID0ge2g6IGswLmgsIGw6IGswLmx9XG4gIHZhciB2MiA9IGswXG4gIHZhciB2MSA9IHtoOiBrMS5oLCBsOiBrMS5sfVxuICB2YXIgdjMgPSBrMVxuICB2YXIgbWlcbiAgdmFyIG1wID0gMFxuICB2YXIgbWwgPSBtLmxlbmd0aFxuICB2YXIgbWw3ID0gbWwgLSA3XG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoOCkpXG5cbiAgX3hvcih2MCwge2g6IDB4NzM2ZjZkNjUsIGw6IDB4NzA3MzY1NzV9KVxuICBfeG9yKHYxLCB7aDogMHg2NDZmNzI2MSwgbDogMHg2ZTY0NmY2ZH0pXG4gIF94b3IodjIsIHtoOiAweDZjNzk2NzY1LCBsOiAweDZlNjU3MjYxfSlcbiAgX3hvcih2Mywge2g6IDB4NzQ2NTY0NjIsIGw6IDB4Nzk3NDY1NzN9KVxuXG4gIHdoaWxlIChtcCA8IG1sNykge1xuICAgIG1pID0ge2g6IF9nZXRfaW50KG0sIG1wICsgNCksIGw6IF9nZXRfaW50KG0sIG1wKX1cbiAgICBfeG9yKHYzLCBtaSlcbiAgICBfY29tcHJlc3ModjAsIHYxLCB2MiwgdjMpXG4gICAgX2NvbXByZXNzKHYwLCB2MSwgdjIsIHYzKVxuICAgIF94b3IodjAsIG1pKVxuICAgIG1wICs9IDhcbiAgfVxuXG4gIGJ1Zls3XSA9IG1sXG4gIHZhciBpYyA9IDBcbiAgd2hpbGUgKG1wIDwgbWwpIHtcbiAgICBidWZbaWMrK10gPSBtW21wKytdXG4gIH1cbiAgd2hpbGUgKGljIDwgNykge1xuICAgIGJ1ZltpYysrXSA9IDBcbiAgfVxuXG4gIG1pID0ge1xuICAgIGg6IGJ1Zls3XSA8PCAyNCB8IGJ1Zls2XSA8PCAxNiB8IGJ1Zls1XSA8PCA4IHwgYnVmWzRdLFxuICAgIGw6IGJ1ZlszXSA8PCAyNCB8IGJ1ZlsyXSA8PCAxNiB8IGJ1ZlsxXSA8PCA4IHwgYnVmWzBdXG4gIH1cblxuICBfeG9yKHYzLCBtaSlcbiAgX2NvbXByZXNzKHYwLCB2MSwgdjIsIHYzKVxuICBfY29tcHJlc3ModjAsIHYxLCB2MiwgdjMpXG4gIF94b3IodjAsIG1pKVxuICBfeG9yKHYyLCB7IGg6IDAsIGw6IDB4ZmYgfSlcbiAgX2NvbXByZXNzKHYwLCB2MSwgdjIsIHYzKVxuICBfY29tcHJlc3ModjAsIHYxLCB2MiwgdjMpXG4gIF9jb21wcmVzcyh2MCwgdjEsIHYyLCB2MylcbiAgX2NvbXByZXNzKHYwLCB2MSwgdjIsIHYzKVxuXG4gIHZhciBoID0gdjBcbiAgX3hvcihoLCB2MSlcbiAgX3hvcihoLCB2MilcbiAgX3hvcihoLCB2MylcblxuICBvdXRbMF0gPSBoLmwgJiAweGZmXG4gIG91dFsxXSA9IChoLmwgPj4gOCkgJiAweGZmXG4gIG91dFsyXSA9IChoLmwgPj4gMTYpICYgMHhmZlxuICBvdXRbM10gPSAoaC5sID4+IDI0KSAmIDB4ZmZcbiAgb3V0WzRdID0gaC5oICYgMHhmZlxuICBvdXRbNV0gPSAoaC5oID4+IDgpICYgMHhmZlxuICBvdXRbNl0gPSAoaC5oID4+IDE2KSAmIDB4ZmZcbiAgb3V0WzddID0gKGguaCA+PiAyNCkgJiAweGZmXG59XG4iLCJ2YXIgd2FzbSA9IHJlcXVpcmUoJy4vc2lwaGFzaDI0JylcbnZhciBmYWxsYmFjayA9IHJlcXVpcmUoJy4vZmFsbGJhY2snKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ25hbm9hc3NlcnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpcGhhc2gyNFxuXG52YXIgQllURVMgPSBzaXBoYXNoMjQuQllURVMgPSA4XG52YXIgS0VZQllURVMgPSBzaXBoYXNoMjQuS0VZQllURVMgPSAxNlxudmFyIG1vZCA9IHdhc20oKVxuXG5zaXBoYXNoMjQuV0FTTV9TVVBQT1JURUQgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICd1bmRlZmluZWQnXG5zaXBoYXNoMjQuV0FTTV9MT0FERUQgPSBmYWxzZVxuXG5pZiAobW9kKSB7XG4gIG1vZC5vbmxvYWQoZnVuY3Rpb24gKGVycikge1xuICAgIHNpcGhhc2gyNC5XQVNNX0xPQURFRCA9ICFlcnJcbiAgfSlcbn1cblxuZnVuY3Rpb24gc2lwaGFzaDI0IChkYXRhLCBrZXksIG91dCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFvdXQpIG91dCA9IG5ldyBVaW50OEFycmF5KDgpXG5cbiAgaWYgKG5vQXNzZXJ0ICE9PSB0cnVlKSB7XG4gICAgYXNzZXJ0KG91dC5sZW5ndGggPj0gQllURVMsICdvdXRwdXQgbXVzdCBiZSBhdCBsZWFzdCAnICsgQllURVMpXG4gICAgYXNzZXJ0KGtleS5sZW5ndGggPj0gS0VZQllURVMsICdrZXkgbXVzdCBiZSBhdCBsZWFzdCAnICsgS0VZQllURVMpXG4gIH1cblxuICBpZiAobW9kICYmIG1vZC5leHBvcnRzKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoICsgMjQgPiBtb2QubWVtb3J5Lmxlbmd0aCkgbW9kLnJlYWxsb2MoZGF0YS5sZW5ndGggKyAyNClcbiAgICBtb2QubWVtb3J5LnNldChrZXksIDgpXG4gICAgbW9kLm1lbW9yeS5zZXQoZGF0YSwgMjQpXG4gICAgbW9kLmV4cG9ydHMuc2lwaGFzaCgyNCwgZGF0YS5sZW5ndGgpXG4gICAgb3V0LnNldChtb2QubWVtb3J5LnN1YmFycmF5KDAsIDgpKVxuICB9IGVsc2Uge1xuICAgIGZhbGxiYWNrKG91dCwgZGF0YSwga2V5KVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRXZWJBc3NlbWJseVxuXG5sb2FkV2ViQXNzZW1ibHkuc3VwcG9ydGVkID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSAndW5kZWZpbmVkJ1xuXG5mdW5jdGlvbiBsb2FkV2ViQXNzZW1ibHkgKG9wdHMpIHtcbiAgaWYgKCFsb2FkV2ViQXNzZW1ibHkuc3VwcG9ydGVkKSByZXR1cm4gbnVsbFxuXG4gIHZhciBpbXAgPSBvcHRzICYmIG9wdHMuaW1wb3J0c1xuICB2YXIgd2FzbSA9IHRvVWludDhBcnJheSgnQUdGemJRRUFBQUFCQmdGZ0FuOS9BQU1DQVFBRkJRRUJDcEJPQnhRQ0JtMWxiVzl5ZVFJQUIzTnBjR2hoYzJnQUFBcmRDQUhhQ0FJSWZnSi9RdlhLellQWHJOdTM4d0FoQWtMdDNwSHpsc3pjdCtRQUlRTkM0ZVNWODliczJienNBQ0VFUXZQSzBjdW5qTm15OUFBaEJVRUlLUU1BSVFkQkVDa0RBQ0VJSUFHdFFqaUdJUVlnQVVFSGNTRUxJQUFnQVdvZ0Myc2hDaUFGSUFpRklRVWdCQ0FIaFNFRUlBTWdDSVVoQXlBQ0lBZUZJUUlDUUFOQUlBQWdDa1lOQVNBQUtRTUFJUWtnQlNBSmhTRUZJQUlnQTN3aEFpQURRZzJKSVFNZ0F5QUNoU0VESUFKQ0lJa2hBaUFFSUFWOElRUWdCVUlRaVNFRklBVWdCSVVoQlNBQ0lBVjhJUUlnQlVJVmlTRUZJQVVnQW9VaEJTQUVJQU44SVFRZ0EwSVJpU0VESUFNZ0JJVWhBeUFFUWlDSklRUWdBaUFEZkNFQ0lBTkNEWWtoQXlBRElBS0ZJUU1nQWtJZ2lTRUNJQVFnQlh3aEJDQUZRaENKSVFVZ0JTQUVoU0VGSUFJZ0JYd2hBaUFGUWhXSklRVWdCU0FDaFNFRklBUWdBM3doQkNBRFFoR0pJUU1nQXlBRWhTRURJQVJDSUlraEJDQUNJQW1GSVFJZ0FFRUlhaUVBREFBTEN3SkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0N3NEhCd1lGQkFNQ0FRQUxJQVlnQURFQUJrSXdob1FoQmdzZ0JpQUFNUUFGUWlpR2hDRUdDeUFHSUFBeEFBUkNJSWFFSVFZTElBWWdBREVBQTBJWWhvUWhCZ3NnQmlBQU1RQUNRaENHaENFR0N5QUdJQUF4QUFGQ0NJYUVJUVlMSUFZZ0FERUFBSVFoQmdzZ0JTQUdoU0VGSUFJZ0Ezd2hBaUFEUWcySklRTWdBeUFDaFNFRElBSkNJSWtoQWlBRUlBVjhJUVFnQlVJUWlTRUZJQVVnQklVaEJTQUNJQVY4SVFJZ0JVSVZpU0VGSUFVZ0FvVWhCU0FFSUFOOElRUWdBMElSaVNFRElBTWdCSVVoQXlBRVFpQ0pJUVFnQWlBRGZDRUNJQU5DRFlraEF5QURJQUtGSVFNZ0FrSWdpU0VDSUFRZ0JYd2hCQ0FGUWhDSklRVWdCU0FFaFNFRklBSWdCWHdoQWlBRlFoV0pJUVVnQlNBQ2hTRUZJQVFnQTN3aEJDQURRaEdKSVFNZ0F5QUVoU0VESUFSQ0lJa2hCQ0FDSUFhRklRSWdCRUwvQVlVaEJDQUNJQU44SVFJZ0EwSU5pU0VESUFNZ0FvVWhBeUFDUWlDSklRSWdCQ0FGZkNFRUlBVkNFSWtoQlNBRklBU0ZJUVVnQWlBRmZDRUNJQVZDRllraEJTQUZJQUtGSVFVZ0JDQURmQ0VFSUFOQ0VZa2hBeUFESUFTRklRTWdCRUlnaVNFRUlBSWdBM3doQWlBRFFnMkpJUU1nQXlBQ2hTRURJQUpDSUlraEFpQUVJQVY4SVFRZ0JVSVFpU0VGSUFVZ0JJVWhCU0FDSUFWOElRSWdCVUlWaVNFRklBVWdBb1VoQlNBRUlBTjhJUVFnQTBJUmlTRURJQU1nQklVaEF5QUVRaUNKSVFRZ0FpQURmQ0VDSUFOQ0RZa2hBeUFESUFLRklRTWdBa0lnaVNFQ0lBUWdCWHdoQkNBRlFoQ0pJUVVnQlNBRWhTRUZJQUlnQlh3aEFpQUZRaFdKSVFVZ0JTQUNoU0VGSUFRZ0Ezd2hCQ0FEUWhHSklRTWdBeUFFaFNFRElBUkNJSWtoQkNBQ0lBTjhJUUlnQTBJTmlTRURJQU1nQW9VaEF5QUNRaUNKSVFJZ0JDQUZmQ0VFSUFWQ0VJa2hCU0FGSUFTRklRVWdBaUFGZkNFQ0lBVkNGWWtoQlNBRklBS0ZJUVVnQkNBRGZDRUVJQU5DRVlraEF5QURJQVNGSVFNZ0JFSWdpU0VFUVFBZ0FpQURJQVFnQllXRmhUY0RBQXM9JylcbiAgdmFyIHJlYWR5ID0gbnVsbFxuXG4gIHZhciBtb2QgPSB7XG4gICAgYnVmZmVyOiB3YXNtLFxuICAgIG1lbW9yeTogbnVsbCxcbiAgICBleHBvcnRzOiBudWxsLFxuICAgIHJlYWxsb2M6IHJlYWxsb2MsXG4gICAgb25sb2FkOiBvbmxvYWRcbiAgfVxuXG4gIG9ubG9hZChmdW5jdGlvbiAoKSB7fSlcblxuICByZXR1cm4gbW9kXG5cbiAgZnVuY3Rpb24gcmVhbGxvYyAoc2l6ZSkge1xuICAgIG1vZC5leHBvcnRzLm1lbW9yeS5ncm93KE1hdGgubWF4KDAsIE1hdGguY2VpbChNYXRoLmFicyhzaXplIC0gbW9kLm1lbW9yeS5sZW5ndGgpIC8gNjU1MzYpKSlcbiAgICBtb2QubWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkobW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubG9hZCAoY2IpIHtcbiAgICBpZiAobW9kLmV4cG9ydHMpIHJldHVybiBjYigpXG5cbiAgICBpZiAocmVhZHkpIHtcbiAgICAgIHJlYWR5LnRoZW4oY2IuYmluZChudWxsLCBudWxsKSkuY2F0Y2goY2IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hc3luYykgdGhyb3cgbmV3IEVycm9yKCdhc3luYycpXG4gICAgICBzZXR1cCh7aW5zdGFuY2U6IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKHdhc20pLCBpbXApfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlYWR5ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUod2FzbSwgaW1wKS50aGVuKHNldHVwKVxuICAgIH1cblxuICAgIG9ubG9hZChjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwICh3KSB7XG4gICAgbW9kLmV4cG9ydHMgPSB3Lmluc3RhbmNlLmV4cG9ydHNcbiAgICBtb2QubWVtb3J5ID0gbW9kLmV4cG9ydHMubWVtb3J5ICYmIG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIgJiYgbmV3IFVpbnQ4QXJyYXkobW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcilcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1VpbnQ4QXJyYXkgKHMpIHtcbiAgaWYgKHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXRvYihzKS5zcGxpdCgnJykubWFwKGNoYXJDb2RlQXQpKVxuICByZXR1cm4gbmV3IChyZXF1aXJlKCdidWYnICsgJ2ZlcicpLkJ1ZmZlcikocywgJ2Jhc2U2NCcpXG59XG5cbmZ1bmN0aW9uIGNoYXJDb2RlQXQgKGMpIHtcbiAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKVxufVxuIiwidmFyIGJsYWtlMmIgPSByZXF1aXJlKCdibGFrZTJiJylcblxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX1BSSU1JVElWRSA9ICdibGFrZTJiJ1xubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX0JZVEVTX01JTiA9IGJsYWtlMmIuQllURVNfTUlOXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfQllURVNfTUFYID0gYmxha2UyYi5CWVRFU19NQVhcbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9CWVRFUyA9IGJsYWtlMmIuQllURVNcbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9LRVlCWVRFU19NSU4gPSBibGFrZTJiLktFWUJZVEVTX01JTlxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX0tFWUJZVEVTX01BWCA9IGJsYWtlMmIuS0VZQllURVNfTUFYXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfS0VZQllURVMgPSBibGFrZTJiLktFWUJZVEVTXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfV0FTTV9TVVBQT1JURUQgPSBibGFrZTJiLldBU01fU1VQUE9SVEVEXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfV0FTTV9MT0FERUQgPSBmYWxzZVxuXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2ggPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCwga2V5KSB7XG4gIGJsYWtlMmIob3V0cHV0Lmxlbmd0aCwga2V5KS51cGRhdGUoaW5wdXQpLmZpbmFsKG91dHB1dClcbn1cblxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX3JlYWR5ID0gYmxha2UyYi5yZWFkeVxuXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfYmF0Y2ggPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dEFycmF5LCBrZXkpIHtcbiAgdmFyIGN0eCA9IGJsYWtlMmIob3V0cHV0Lmxlbmd0aCwga2V5KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBjdHgudXBkYXRlKGlucHV0QXJyYXlbaV0pXG4gIH1cbiAgY3R4LmZpbmFsKG91dHB1dClcbn1cblxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX2luc3RhbmNlID0gZnVuY3Rpb24gKGtleSwgb3V0bGVuKSB7XG4gIGlmIChvdXRsZW4gPT0gbnVsbCkgb3V0bGVuID0gbW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX0JZVEVTXG4gIHJldHVybiBibGFrZTJiKG91dGxlbiwga2V5KVxufVxuXG5ibGFrZTJiLnJlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgbW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX1dBU01fTE9BREVEID0gYmxha2UyYi5XQVNNX0xPQURFRFxufSlcbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCduYW5vYXNzZXJ0JylcbnZhciByYW5kb21ieXRlc19idWYgPSByZXF1aXJlKCcuL3JhbmRvbWJ5dGVzJykucmFuZG9tYnl0ZXNfYnVmXG52YXIgYmxha2UyYiA9IHJlcXVpcmUoJ2JsYWtlMmInKVxuXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX1BSSU1JVElWRSA9ICdibGFrZTJiJ1xubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9CWVRFU19NSU4gPSAxNlxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9CWVRFU19NQVggPSA2NFxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9DT05URVhUQllURVMgPSA4XG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0tFWUJZVEVTID0gMzJcblxuZnVuY3Rpb24gU1RPUkU2NF9MRShkZXN0LCBpbnQpIHtcbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIGRlc3RbMF0gPSBpbnQgJiAweEZGXG4gIHdoaWxlICgrK2kgPCA4ICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgZGVzdFtpXSA9IChpbnQgLyBtdWwpICYgMHhGRlxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfZGVyaXZlX2Zyb21fa2V5ID0gZnVuY3Rpb24gY3J5cHRvX2tkZl9kZXJpdmVfZnJvbV9rZXkgKHN1YmtleSwgc3Via2V5X2lkLCBjdHgsIGtleSkge1xuICBhc3NlcnQoc3Via2V5Lmxlbmd0aCA+PSBtb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0JZVEVTX01JTiwgJ3N1YmtleSBtdXN0IGJlIGF0IGxlYXN0IGNyeXB0b19rZGZfQllURVNfTUlOJylcbiAgYXNzZXJ0KHN1YmtleV9pZCA+PSAwICYmIHN1YmtleV9pZCA8PSAweDFmZmZmZmZmZmZmZmZmLCAnc3Via2V5X2lkIG11c3QgYmUgc2FmZSBpbnRlZ2VyJylcbiAgYXNzZXJ0KGN0eC5sZW5ndGggPj0gbW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9DT05URVhUQllURVMsICdjb250ZXh0IG11c3QgYmUgYXQgbGVhc3QgY3J5cHRvX2tkZl9DT05URVhUQllURVMnKVxuXG4gIHZhciBjdHhfcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoYmxha2UyYi5QRVJTT05BTEJZVEVTKVxuICB2YXIgc2FsdCA9IG5ldyBVaW50OEFycmF5KGJsYWtlMmIuU0FMVEJZVEVTKVxuXG4gIGN0eF9wYWRkZWQuc2V0KGN0eCwgMCwgbW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9DT05URVhUQllURVMpXG4gIFNUT1JFNjRfTEUoc2FsdCwgc3Via2V5X2lkKVxuXG4gIHZhciBvdXRsZW4gPSBNYXRoLm1pbihzdWJrZXkubGVuZ3RoLCBtb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0JZVEVTX01BWClcbiAgYmxha2UyYihvdXRsZW4sIGtleS5zdWJhcnJheSgwLCBtb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0tFWUJZVEVTKSwgc2FsdCwgY3R4X3BhZGRlZCwgdHJ1ZSlcbiAgICAuZmluYWwoc3Via2V5KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX2tleWdlbiA9IGZ1bmN0aW9uIGNyeXB0b19rZGZfa2V5Z2VuIChvdXQpIHtcbiAgYXNzZXJ0KG91dC5sZW5ndGggPj0gbW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9LRVlCWVRFUywgJ291dC5sZW5ndGggbXVzdCBiZSBjcnlwdG9fa2RmX0tFWUJZVEVTJylcbiAgcmFuZG9tYnl0ZXNfYnVmKG91dC5zdWJhcnJheSgwLCBtb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0tFWUJZVEVTKSlcbn1cbiIsInZhciBzaXBoYXNoID0gcmVxdWlyZSgnc2lwaGFzaDI0JylcblxuZXhwb3J0cy5jcnlwdG9fc2hvcnRoYXNoX1BSSU1JVElWRSA9ICdzaXBoYXNoMjQnXG5leHBvcnRzLmNyeXB0b19zaG9ydGhhc2hfQllURVMgPSBzaXBoYXNoLkJZVEVTXG5leHBvcnRzLmNyeXB0b19zaG9ydGhhc2hfS0VZQllURVMgPSBzaXBoYXNoLktFWUJZVEVTXG5leHBvcnRzLmNyeXB0b19zaG9ydGhhc2hfV0FTTV9TVVBQT1JURUQgPSBzaXBoYXNoLldBU01fU1VQUE9SVEVEXG5leHBvcnRzLmNyeXB0b19zaG9ydGhhc2hfV0FTTV9MT0FERUQgPSBzaXBoYXNoLldBU01fTE9BREVEXG5leHBvcnRzLmNyeXB0b19zaG9ydGhhc2ggPSBzaG9ydGhhc2hcblxuZnVuY3Rpb24gc2hvcnRoYXNoIChvdXQsIGRhdGEsIGtleSwgbm9Bc3NlcnQpIHtcbiAgc2lwaGFzaChkYXRhLCBrZXksIG91dCwgbm9Bc3NlcnQpXG59XG4iLCJ2YXIgeHNhbHNhMjAgPSByZXF1aXJlKCd4c2Fsc2EyMCcpXG5cbmV4cG9ydHMuY3J5cHRvX3N0cmVhbV9LRVlCWVRFUyA9IDMyXG5leHBvcnRzLmNyeXB0b19zdHJlYW1fTk9OQ0VCWVRFUyA9IDI0XG5leHBvcnRzLmNyeXB0b19zdHJlYW1fUFJJTUlUSVZFID0gJ3hzYWxzYTIwJ1xuXG5leHBvcnRzLmNyeXB0b19zdHJlYW0gPSBmdW5jdGlvbiAob3V0LCBub25jZSwga2V5KSB7XG4gIG91dC5maWxsKDApXG4gIGV4cG9ydHMuY3J5cHRvX3N0cmVhbV94b3Iob3V0LCBvdXQsIG5vbmNlLCBrZXkpXG59XG5cbmV4cG9ydHMuY3J5cHRvX3N0cmVhbV94b3IgPSBmdW5jdGlvbiAob3V0LCBpbnAsIG5vbmNlLCBrZXkpIHtcbiAgdmFyIHhvciA9IHhzYWxzYTIwKG5vbmNlLCBrZXkpXG4gIHhvci51cGRhdGUoaW5wLCBvdXQpXG4gIHhvci5maW5hbCgpXG59XG5cbmV4cG9ydHMuY3J5cHRvX3N0cmVhbV94b3JfaW5zdGFuY2UgPSBmdW5jdGlvbiAobm9uY2UsIGtleSkge1xuICByZXR1cm4gbmV3IFhPUihub25jZSwga2V5KVxufVxuXG5mdW5jdGlvbiBYT1IgKG5vbmNlLCBrZXkpIHtcbiAgdGhpcy5faW5zdGFuY2UgPSB4c2Fsc2EyMChub25jZSwga2V5KVxufVxuXG5YT1IucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGlucCkge1xuICB0aGlzLl9pbnN0YW5jZS51cGRhdGUoaW5wLCBvdXQpXG59XG5cblhPUi5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2luc3RhbmNlLmZpbmFsaXplKClcbiAgdGhpcy5faW5zdGFuY2UgPSBudWxsXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9kY2hlc3QvdHdlZXRuYWNsLWpzL2Jsb2IvNmRjYmNhZjVmNWNiZmQzMTNmMmRjZmU3NjNkYjM1YzgyOGM4ZmY1Yi9uYWNsLWZhc3QuanMuXG5cbnZhciBzb2RpdW0gPSBtb2R1bGUuZXhwb3J0c1xudmFyIGNzID0gcmVxdWlyZSgnLi9jcnlwdG9fc3RyZWFtJylcblxuLy8gUG9ydGVkIGluIDIwMTQgYnkgRG1pdHJ5IENoZXN0bnlraCBhbmQgRGV2aSBNYW5kaXJpLlxuLy8gUHVibGljIGRvbWFpbi5cbi8vXG4vLyBJbXBsZW1lbnRhdGlvbiBkZXJpdmVkIGZyb20gVHdlZXROYUNsIHZlcnNpb24gMjAxNDA0MjcuXG4vLyBTZWUgZm9yIGRldGFpbHM6IGh0dHA6Ly90d2VldG5hY2wuY3IueXAudG8vXG5cbnZhciBnZiA9IGZ1bmN0aW9uKGluaXQpIHtcbiAgdmFyIGksIHIgPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgaWYgKGluaXQpIGZvciAoaSA9IDA7IGkgPCBpbml0Lmxlbmd0aDsgaSsrKSByW2ldID0gaW5pdFtpXTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBhbHNvIGZvcndhcmRlZCBhdCB0aGUgYm90dG9tIGJ1dCByYW5kb21ieXRlcyBpcyBub24tZW51bWVyYWJsZVxudmFyIHJhbmRvbWJ5dGVzID0gcmVxdWlyZSgnLi9yYW5kb21ieXRlcycpLnJhbmRvbWJ5dGVzXG5cbnZhciBfMCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbnZhciBfOSA9IG5ldyBVaW50OEFycmF5KDMyKTsgXzlbMF0gPSA5O1xuXG52YXIgZ2YwID0gZ2YoKSxcbiAgICBnZjEgPSBnZihbMV0pLFxuICAgIF8xMjE2NjUgPSBnZihbMHhkYjQxLCAxXSksXG4gICAgRCA9IGdmKFsweDc4YTMsIDB4MTM1OSwgMHg0ZGNhLCAweDc1ZWIsIDB4ZDhhYiwgMHg0MTQxLCAweDBhNGQsIDB4MDA3MCwgMHhlODk4LCAweDc3NzksIDB4NDA3OSwgMHg4Y2M3LCAweGZlNzMsIDB4MmI2ZiwgMHg2Y2VlLCAweDUyMDNdKSxcbiAgICBEMiA9IGdmKFsweGYxNTksIDB4MjZiMiwgMHg5Yjk0LCAweGViZDYsIDB4YjE1NiwgMHg4MjgzLCAweDE0OWEsIDB4MDBlMCwgMHhkMTMwLCAweGVlZjMsIDB4ODBmMiwgMHgxOThlLCAweGZjZTcsIDB4NTZkZiwgMHhkOWRjLCAweDI0MDZdKSxcbiAgICBYID0gZ2YoWzB4ZDUxYSwgMHg4ZjI1LCAweDJkNjAsIDB4Yzk1NiwgMHhhN2IyLCAweDk1MjUsIDB4Yzc2MCwgMHg2OTJjLCAweGRjNWMsIDB4ZmRkNiwgMHhlMjMxLCAweGMwYTQsIDB4NTNmZSwgMHhjZDZlLCAweDM2ZDMsIDB4MjE2OV0pLFxuICAgIFkgPSBnZihbMHg2NjU4LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2XSksXG4gICAgSSA9IGdmKFsweGEwYjAsIDB4NGEwZSwgMHgxYjI3LCAweGM0ZWUsIDB4ZTQ3OCwgMHhhZDJmLCAweDE4MDYsIDB4MmY0MywgMHhkN2E3LCAweDNkZmIsIDB4MDA5OSwgMHgyYjRkLCAweGRmMGIsIDB4NGZjMSwgMHgyNDgwLCAweDJiODNdKTtcblxuZnVuY3Rpb24gdHM2NCh4LCBpLCBoLCBsKSB7XG4gIHhbaV0gICA9IChoID4+IDI0KSAmIDB4ZmY7XG4gIHhbaSsxXSA9IChoID4+IDE2KSAmIDB4ZmY7XG4gIHhbaSsyXSA9IChoID4+ICA4KSAmIDB4ZmY7XG4gIHhbaSszXSA9IGggJiAweGZmO1xuICB4W2krNF0gPSAobCA+PiAyNCkgICYgMHhmZjtcbiAgeFtpKzVdID0gKGwgPj4gMTYpICAmIDB4ZmY7XG4gIHhbaSs2XSA9IChsID4+ICA4KSAgJiAweGZmO1xuICB4W2krN10gPSBsICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gdm4oeCwgeGksIHksIHlpLCBuKSB7XG4gIHZhciBpLGQgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBkIHw9IHhbeGkraV1eeVt5aStpXTtcbiAgcmV0dXJuICgxICYgKChkIC0gMSkgPj4+IDgpKSAtIDE7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMTYoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMTYpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzMyKHgsIHhpLCB5LCB5aSkge1xuICByZXR1cm4gdm4oeCx4aSx5LHlpLDMyKTtcbn1cblxuLypcbiogUG9ydCBvZiBBbmRyZXcgTW9vbidzIFBvbHkxMzA1LWRvbm5hLTE2LiBQdWJsaWMgZG9tYWluLlxuKiBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmFcbiovXG5cbnZhciBwb2x5MTMwNSA9IGZ1bmN0aW9uKGtleSkge1xuICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgdGhpcy5yID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdGhpcy5oID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdGhpcy5wYWQgPSBuZXcgVWludDE2QXJyYXkoOCk7XG4gIHRoaXMubGVmdG92ZXIgPSAwO1xuICB0aGlzLmZpbiA9IDA7XG5cbiAgdmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDUsIHQ2LCB0NztcblxuICB0MCA9IGtleVsgMF0gJiAweGZmIHwgKGtleVsgMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMF0gPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgdDEgPSBrZXlbIDJdICYgMHhmZiB8IChrZXlbIDNdICYgMHhmZikgPDwgODsgdGhpcy5yWzFdID0gKCh0MCA+Pj4gMTMpIHwgKHQxIDw8ICAzKSkgJiAweDFmZmY7XG4gIHQyID0ga2V5WyA0XSAmIDB4ZmYgfCAoa2V5WyA1XSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsyXSA9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCAgNikpICYgMHgxZjAzO1xuICB0MyA9IGtleVsgNl0gJiAweGZmIHwgKGtleVsgN10gJiAweGZmKSA8PCA4OyB0aGlzLnJbM10gPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgdDQgPSBrZXlbIDhdICYgMHhmZiB8IChrZXlbIDldICYgMHhmZikgPDwgODsgdGhpcy5yWzRdID0gKCh0MyA+Pj4gIDQpIHwgKHQ0IDw8IDEyKSkgJiAweDAwZmY7XG4gIHRoaXMucls1XSA9ICgodDQgPj4+ICAxKSkgJiAweDFmZmU7XG4gIHQ1ID0ga2V5WzEwXSAmIDB4ZmYgfCAoa2V5WzExXSAmIDB4ZmYpIDw8IDg7IHRoaXMucls2XSA9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICB0NiA9IGtleVsxMl0gJiAweGZmIHwgKGtleVsxM10gJiAweGZmKSA8PCA4OyB0aGlzLnJbN10gPSAoKHQ1ID4+PiAxMSkgfCAodDYgPDwgIDUpKSAmIDB4MWY4MTtcbiAgdDcgPSBrZXlbMTRdICYgMHhmZiB8IChrZXlbMTVdICYgMHhmZikgPDwgODsgdGhpcy5yWzhdID0gKCh0NiA+Pj4gIDgpIHwgKHQ3IDw8ICA4KSkgJiAweDFmZmY7XG4gIHRoaXMucls5XSA9ICgodDcgPj4+ICA1KSkgJiAweDAwN2Y7XG5cbiAgdGhpcy5wYWRbMF0gPSBrZXlbMTZdICYgMHhmZiB8IChrZXlbMTddICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbMV0gPSBrZXlbMThdICYgMHhmZiB8IChrZXlbMTldICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbMl0gPSBrZXlbMjBdICYgMHhmZiB8IChrZXlbMjFdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbM10gPSBrZXlbMjJdICYgMHhmZiB8IChrZXlbMjNdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNF0gPSBrZXlbMjRdICYgMHhmZiB8IChrZXlbMjVdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNV0gPSBrZXlbMjZdICYgMHhmZiB8IChrZXlbMjddICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNl0gPSBrZXlbMjhdICYgMHhmZiB8IChrZXlbMjldICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbN10gPSBrZXlbMzBdICYgMHhmZiB8IChrZXlbMzFdICYgMHhmZikgPDwgODtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS5ibG9ja3MgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaGliaXQgPSB0aGlzLmZpbiA/IDAgOiAoMSA8PCAxMSk7XG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDcsIGM7XG4gIHZhciBkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOTtcblxuICB2YXIgaDAgPSB0aGlzLmhbMF0sXG4gICAgICBoMSA9IHRoaXMuaFsxXSxcbiAgICAgIGgyID0gdGhpcy5oWzJdLFxuICAgICAgaDMgPSB0aGlzLmhbM10sXG4gICAgICBoNCA9IHRoaXMuaFs0XSxcbiAgICAgIGg1ID0gdGhpcy5oWzVdLFxuICAgICAgaDYgPSB0aGlzLmhbNl0sXG4gICAgICBoNyA9IHRoaXMuaFs3XSxcbiAgICAgIGg4ID0gdGhpcy5oWzhdLFxuICAgICAgaDkgPSB0aGlzLmhbOV07XG5cbiAgdmFyIHIwID0gdGhpcy5yWzBdLFxuICAgICAgcjEgPSB0aGlzLnJbMV0sXG4gICAgICByMiA9IHRoaXMuclsyXSxcbiAgICAgIHIzID0gdGhpcy5yWzNdLFxuICAgICAgcjQgPSB0aGlzLnJbNF0sXG4gICAgICByNSA9IHRoaXMucls1XSxcbiAgICAgIHI2ID0gdGhpcy5yWzZdLFxuICAgICAgcjcgPSB0aGlzLnJbN10sXG4gICAgICByOCA9IHRoaXMucls4XSxcbiAgICAgIHI5ID0gdGhpcy5yWzldO1xuXG4gIHdoaWxlIChieXRlcyA+PSAxNikge1xuICAgIHQwID0gbVttcG9zKyAwXSAmIDB4ZmYgfCAobVttcG9zKyAxXSAmIDB4ZmYpIDw8IDg7IGgwICs9ICggdDAgICAgICAgICAgICAgICAgICAgICApICYgMHgxZmZmO1xuICAgIHQxID0gbVttcG9zKyAyXSAmIDB4ZmYgfCAobVttcG9zKyAzXSAmIDB4ZmYpIDw8IDg7IGgxICs9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICAgIHQyID0gbVttcG9zKyA0XSAmIDB4ZmYgfCAobVttcG9zKyA1XSAmIDB4ZmYpIDw8IDg7IGgyICs9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCAgNikpICYgMHgxZmZmO1xuICAgIHQzID0gbVttcG9zKyA2XSAmIDB4ZmYgfCAobVttcG9zKyA3XSAmIDB4ZmYpIDw8IDg7IGgzICs9ICgodDIgPj4+ICA3KSB8ICh0MyA8PCAgOSkpICYgMHgxZmZmO1xuICAgIHQ0ID0gbVttcG9zKyA4XSAmIDB4ZmYgfCAobVttcG9zKyA5XSAmIDB4ZmYpIDw8IDg7IGg0ICs9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgxZmZmO1xuICAgIGg1ICs9ICgodDQgPj4+ICAxKSkgJiAweDFmZmY7XG4gICAgdDUgPSBtW21wb3MrMTBdICYgMHhmZiB8IChtW21wb3MrMTFdICYgMHhmZikgPDwgODsgaDYgKz0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8ICAyKSkgJiAweDFmZmY7XG4gICAgdDYgPSBtW21wb3MrMTJdICYgMHhmZiB8IChtW21wb3MrMTNdICYgMHhmZikgPDwgODsgaDcgKz0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmZmY7XG4gICAgdDcgPSBtW21wb3MrMTRdICYgMHhmZiB8IChtW21wb3MrMTVdICYgMHhmZikgPDwgODsgaDggKz0gKCh0NiA+Pj4gIDgpIHwgKHQ3IDw8ICA4KSkgJiAweDFmZmY7XG4gICAgaDkgKz0gKCh0NyA+Pj4gNSkpIHwgaGliaXQ7XG5cbiAgICBjID0gMDtcblxuICAgIGQwID0gYztcbiAgICBkMCArPSBoMCAqIHIwO1xuICAgIGQwICs9IGgxICogKDUgKiByOSk7XG4gICAgZDAgKz0gaDIgKiAoNSAqIHI4KTtcbiAgICBkMCArPSBoMyAqICg1ICogcjcpO1xuICAgIGQwICs9IGg0ICogKDUgKiByNik7XG4gICAgYyA9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG4gICAgZDAgKz0gaDUgKiAoNSAqIHI1KTtcbiAgICBkMCArPSBoNiAqICg1ICogcjQpO1xuICAgIGQwICs9IGg3ICogKDUgKiByMyk7XG4gICAgZDAgKz0gaDggKiAoNSAqIHIyKTtcbiAgICBkMCArPSBoOSAqICg1ICogcjEpO1xuICAgIGMgKz0gKGQwID4+PiAxMyk7IGQwICY9IDB4MWZmZjtcblxuICAgIGQxID0gYztcbiAgICBkMSArPSBoMCAqIHIxO1xuICAgIGQxICs9IGgxICogcjA7XG4gICAgZDEgKz0gaDIgKiAoNSAqIHI5KTtcbiAgICBkMSArPSBoMyAqICg1ICogcjgpO1xuICAgIGQxICs9IGg0ICogKDUgKiByNyk7XG4gICAgYyA9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG4gICAgZDEgKz0gaDUgKiAoNSAqIHI2KTtcbiAgICBkMSArPSBoNiAqICg1ICogcjUpO1xuICAgIGQxICs9IGg3ICogKDUgKiByNCk7XG4gICAgZDEgKz0gaDggKiAoNSAqIHIzKTtcbiAgICBkMSArPSBoOSAqICg1ICogcjIpO1xuICAgIGMgKz0gKGQxID4+PiAxMyk7IGQxICY9IDB4MWZmZjtcblxuICAgIGQyID0gYztcbiAgICBkMiArPSBoMCAqIHIyO1xuICAgIGQyICs9IGgxICogcjE7XG4gICAgZDIgKz0gaDIgKiByMDtcbiAgICBkMiArPSBoMyAqICg1ICogcjkpO1xuICAgIGQyICs9IGg0ICogKDUgKiByOCk7XG4gICAgYyA9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG4gICAgZDIgKz0gaDUgKiAoNSAqIHI3KTtcbiAgICBkMiArPSBoNiAqICg1ICogcjYpO1xuICAgIGQyICs9IGg3ICogKDUgKiByNSk7XG4gICAgZDIgKz0gaDggKiAoNSAqIHI0KTtcbiAgICBkMiArPSBoOSAqICg1ICogcjMpO1xuICAgIGMgKz0gKGQyID4+PiAxMyk7IGQyICY9IDB4MWZmZjtcblxuICAgIGQzID0gYztcbiAgICBkMyArPSBoMCAqIHIzO1xuICAgIGQzICs9IGgxICogcjI7XG4gICAgZDMgKz0gaDIgKiByMTtcbiAgICBkMyArPSBoMyAqIHIwO1xuICAgIGQzICs9IGg0ICogKDUgKiByOSk7XG4gICAgYyA9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG4gICAgZDMgKz0gaDUgKiAoNSAqIHI4KTtcbiAgICBkMyArPSBoNiAqICg1ICogcjcpO1xuICAgIGQzICs9IGg3ICogKDUgKiByNik7XG4gICAgZDMgKz0gaDggKiAoNSAqIHI1KTtcbiAgICBkMyArPSBoOSAqICg1ICogcjQpO1xuICAgIGMgKz0gKGQzID4+PiAxMyk7IGQzICY9IDB4MWZmZjtcblxuICAgIGQ0ID0gYztcbiAgICBkNCArPSBoMCAqIHI0O1xuICAgIGQ0ICs9IGgxICogcjM7XG4gICAgZDQgKz0gaDIgKiByMjtcbiAgICBkNCArPSBoMyAqIHIxO1xuICAgIGQ0ICs9IGg0ICogcjA7XG4gICAgYyA9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG4gICAgZDQgKz0gaDUgKiAoNSAqIHI5KTtcbiAgICBkNCArPSBoNiAqICg1ICogcjgpO1xuICAgIGQ0ICs9IGg3ICogKDUgKiByNyk7XG4gICAgZDQgKz0gaDggKiAoNSAqIHI2KTtcbiAgICBkNCArPSBoOSAqICg1ICogcjUpO1xuICAgIGMgKz0gKGQ0ID4+PiAxMyk7IGQ0ICY9IDB4MWZmZjtcblxuICAgIGQ1ID0gYztcbiAgICBkNSArPSBoMCAqIHI1O1xuICAgIGQ1ICs9IGgxICogcjQ7XG4gICAgZDUgKz0gaDIgKiByMztcbiAgICBkNSArPSBoMyAqIHIyO1xuICAgIGQ1ICs9IGg0ICogcjE7XG4gICAgYyA9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG4gICAgZDUgKz0gaDUgKiByMDtcbiAgICBkNSArPSBoNiAqICg1ICogcjkpO1xuICAgIGQ1ICs9IGg3ICogKDUgKiByOCk7XG4gICAgZDUgKz0gaDggKiAoNSAqIHI3KTtcbiAgICBkNSArPSBoOSAqICg1ICogcjYpO1xuICAgIGMgKz0gKGQ1ID4+PiAxMyk7IGQ1ICY9IDB4MWZmZjtcblxuICAgIGQ2ID0gYztcbiAgICBkNiArPSBoMCAqIHI2O1xuICAgIGQ2ICs9IGgxICogcjU7XG4gICAgZDYgKz0gaDIgKiByNDtcbiAgICBkNiArPSBoMyAqIHIzO1xuICAgIGQ2ICs9IGg0ICogcjI7XG4gICAgYyA9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG4gICAgZDYgKz0gaDUgKiByMTtcbiAgICBkNiArPSBoNiAqIHIwO1xuICAgIGQ2ICs9IGg3ICogKDUgKiByOSk7XG4gICAgZDYgKz0gaDggKiAoNSAqIHI4KTtcbiAgICBkNiArPSBoOSAqICg1ICogcjcpO1xuICAgIGMgKz0gKGQ2ID4+PiAxMyk7IGQ2ICY9IDB4MWZmZjtcblxuICAgIGQ3ID0gYztcbiAgICBkNyArPSBoMCAqIHI3O1xuICAgIGQ3ICs9IGgxICogcjY7XG4gICAgZDcgKz0gaDIgKiByNTtcbiAgICBkNyArPSBoMyAqIHI0O1xuICAgIGQ3ICs9IGg0ICogcjM7XG4gICAgYyA9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG4gICAgZDcgKz0gaDUgKiByMjtcbiAgICBkNyArPSBoNiAqIHIxO1xuICAgIGQ3ICs9IGg3ICogcjA7XG4gICAgZDcgKz0gaDggKiAoNSAqIHI5KTtcbiAgICBkNyArPSBoOSAqICg1ICogcjgpO1xuICAgIGMgKz0gKGQ3ID4+PiAxMyk7IGQ3ICY9IDB4MWZmZjtcblxuICAgIGQ4ID0gYztcbiAgICBkOCArPSBoMCAqIHI4O1xuICAgIGQ4ICs9IGgxICogcjc7XG4gICAgZDggKz0gaDIgKiByNjtcbiAgICBkOCArPSBoMyAqIHI1O1xuICAgIGQ4ICs9IGg0ICogcjQ7XG4gICAgYyA9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG4gICAgZDggKz0gaDUgKiByMztcbiAgICBkOCArPSBoNiAqIHIyO1xuICAgIGQ4ICs9IGg3ICogcjE7XG4gICAgZDggKz0gaDggKiByMDtcbiAgICBkOCArPSBoOSAqICg1ICogcjkpO1xuICAgIGMgKz0gKGQ4ID4+PiAxMyk7IGQ4ICY9IDB4MWZmZjtcblxuICAgIGQ5ID0gYztcbiAgICBkOSArPSBoMCAqIHI5O1xuICAgIGQ5ICs9IGgxICogcjg7XG4gICAgZDkgKz0gaDIgKiByNztcbiAgICBkOSArPSBoMyAqIHI2O1xuICAgIGQ5ICs9IGg0ICogcjU7XG4gICAgYyA9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG4gICAgZDkgKz0gaDUgKiByNDtcbiAgICBkOSArPSBoNiAqIHIzO1xuICAgIGQ5ICs9IGg3ICogcjI7XG4gICAgZDkgKz0gaDggKiByMTtcbiAgICBkOSArPSBoOSAqIHIwO1xuICAgIGMgKz0gKGQ5ID4+PiAxMyk7IGQ5ICY9IDB4MWZmZjtcblxuICAgIGMgPSAoKChjIDw8IDIpICsgYykpIHwgMDtcbiAgICBjID0gKGMgKyBkMCkgfCAwO1xuICAgIGQwID0gYyAmIDB4MWZmZjtcbiAgICBjID0gKGMgPj4+IDEzKTtcbiAgICBkMSArPSBjO1xuXG4gICAgaDAgPSBkMDtcbiAgICBoMSA9IGQxO1xuICAgIGgyID0gZDI7XG4gICAgaDMgPSBkMztcbiAgICBoNCA9IGQ0O1xuICAgIGg1ID0gZDU7XG4gICAgaDYgPSBkNjtcbiAgICBoNyA9IGQ3O1xuICAgIGg4ID0gZDg7XG4gICAgaDkgPSBkOTtcblxuICAgIG1wb3MgKz0gMTY7XG4gICAgYnl0ZXMgLT0gMTY7XG4gIH1cbiAgdGhpcy5oWzBdID0gaDA7XG4gIHRoaXMuaFsxXSA9IGgxO1xuICB0aGlzLmhbMl0gPSBoMjtcbiAgdGhpcy5oWzNdID0gaDM7XG4gIHRoaXMuaFs0XSA9IGg0O1xuICB0aGlzLmhbNV0gPSBoNTtcbiAgdGhpcy5oWzZdID0gaDY7XG4gIHRoaXMuaFs3XSA9IGg3O1xuICB0aGlzLmhbOF0gPSBoODtcbiAgdGhpcy5oWzldID0gaDk7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24obWFjLCBtYWNwb3MpIHtcbiAgdmFyIGcgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB2YXIgYywgbWFzaywgZiwgaTtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIGkgPSB0aGlzLmxlZnRvdmVyO1xuICAgIHRoaXMuYnVmZmVyW2krK10gPSAxO1xuICAgIGZvciAoOyBpIDwgMTY7IGkrKykgdGhpcy5idWZmZXJbaV0gPSAwO1xuICAgIHRoaXMuZmluID0gMTtcbiAgICB0aGlzLmJsb2Nrcyh0aGlzLmJ1ZmZlciwgMCwgMTYpO1xuICB9XG5cbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIGZvciAoaSA9IDI7IGkgPCAxMDsgaSsrKSB7XG4gICAgdGhpcy5oW2ldICs9IGM7XG4gICAgYyA9IHRoaXMuaFtpXSA+Pj4gMTM7XG4gICAgdGhpcy5oW2ldICY9IDB4MWZmZjtcbiAgfVxuICB0aGlzLmhbMF0gKz0gKGMgKiA1KTtcbiAgYyA9IHRoaXMuaFswXSA+Pj4gMTM7XG4gIHRoaXMuaFswXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsxXSArPSBjO1xuICBjID0gdGhpcy5oWzFdID4+PiAxMztcbiAgdGhpcy5oWzFdICY9IDB4MWZmZjtcbiAgdGhpcy5oWzJdICs9IGM7XG5cbiAgZ1swXSA9IHRoaXMuaFswXSArIDU7XG4gIGMgPSBnWzBdID4+PiAxMztcbiAgZ1swXSAmPSAweDFmZmY7XG4gIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgZ1tpXSA9IHRoaXMuaFtpXSArIGM7XG4gICAgYyA9IGdbaV0gPj4+IDEzO1xuICAgIGdbaV0gJj0gMHgxZmZmO1xuICB9XG4gIGdbOV0gLT0gKDEgPDwgMTMpO1xuXG4gIG1hc2sgPSAoYyBeIDEpIC0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIGdbaV0gJj0gbWFzaztcbiAgbWFzayA9IH5tYXNrO1xuICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykgdGhpcy5oW2ldID0gKHRoaXMuaFtpXSAmIG1hc2spIHwgZ1tpXTtcblxuICB0aGlzLmhbMF0gPSAoKHRoaXMuaFswXSAgICAgICApIHwgKHRoaXMuaFsxXSA8PCAxMykgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsxXSA9ICgodGhpcy5oWzFdID4+PiAgMykgfCAodGhpcy5oWzJdIDw8IDEwKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzJdID0gKCh0aGlzLmhbMl0gPj4+ICA2KSB8ICh0aGlzLmhbM10gPDwgIDcpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbM10gPSAoKHRoaXMuaFszXSA+Pj4gIDkpIHwgKHRoaXMuaFs0XSA8PCAgNCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs0XSA9ICgodGhpcy5oWzRdID4+PiAxMikgfCAodGhpcy5oWzVdIDw8ICAxKSB8ICh0aGlzLmhbNl0gPDwgMTQpKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzVdID0gKCh0aGlzLmhbNl0gPj4+ICAyKSB8ICh0aGlzLmhbN10gPDwgMTEpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNl0gPSAoKHRoaXMuaFs3XSA+Pj4gIDUpIHwgKHRoaXMuaFs4XSA8PCAgOCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs3XSA9ICgodGhpcy5oWzhdID4+PiAgOCkgfCAodGhpcy5oWzldIDw8ICA1KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcblxuICBmID0gdGhpcy5oWzBdICsgdGhpcy5wYWRbMF07XG4gIHRoaXMuaFswXSA9IGYgJiAweGZmZmY7XG4gIGZvciAoaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICBmID0gKCgodGhpcy5oW2ldICsgdGhpcy5wYWRbaV0pIHwgMCkgKyAoZiA+Pj4gMTYpKSB8IDA7XG4gICAgdGhpcy5oW2ldID0gZiAmIDB4ZmZmZjtcbiAgfVxuXG4gIG1hY1ttYWNwb3MrIDBdID0gKHRoaXMuaFswXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAxXSA9ICh0aGlzLmhbMF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMl0gPSAodGhpcy5oWzFdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDNdID0gKHRoaXMuaFsxXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA0XSA9ICh0aGlzLmhbMl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNV0gPSAodGhpcy5oWzJdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDZdID0gKHRoaXMuaFszXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA3XSA9ICh0aGlzLmhbM10gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgOF0gPSAodGhpcy5oWzRdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDldID0gKHRoaXMuaFs0XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEwXSA9ICh0aGlzLmhbNV0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMV0gPSAodGhpcy5oWzVdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTJdID0gKHRoaXMuaFs2XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEzXSA9ICh0aGlzLmhbNl0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxNF0gPSAodGhpcy5oWzddID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTVdID0gKHRoaXMuaFs3XSA+Pj4gOCkgJiAweGZmO1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG0sIG1wb3MsIGJ5dGVzKSB7XG4gIHZhciBpLCB3YW50O1xuXG4gIGlmICh0aGlzLmxlZnRvdmVyKSB7XG4gICAgd2FudCA9ICgxNiAtIHRoaXMubGVmdG92ZXIpO1xuICAgIGlmICh3YW50ID4gYnl0ZXMpXG4gICAgICB3YW50ID0gYnl0ZXM7XG4gICAgZm9yIChpID0gMDsgaSA8IHdhbnQ7IGkrKylcbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMubGVmdG92ZXIgKyBpXSA9IG1bbXBvcytpXTtcbiAgICBieXRlcyAtPSB3YW50O1xuICAgIG1wb3MgKz0gd2FudDtcbiAgICB0aGlzLmxlZnRvdmVyICs9IHdhbnQ7XG4gICAgaWYgKHRoaXMubGVmdG92ZXIgPCAxNilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJsb2Nrcyh0aGlzLmJ1ZmZlciwgMCwgMTYpO1xuICAgIHRoaXMubGVmdG92ZXIgPSAwO1xuICB9XG5cbiAgaWYgKGJ5dGVzID49IDE2KSB7XG4gICAgd2FudCA9IGJ5dGVzIC0gKGJ5dGVzICUgMTYpO1xuICAgIHRoaXMuYmxvY2tzKG0sIG1wb3MsIHdhbnQpO1xuICAgIG1wb3MgKz0gd2FudDtcbiAgICBieXRlcyAtPSB3YW50O1xuICB9XG5cbiAgaWYgKGJ5dGVzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzOyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgdGhpcy5sZWZ0b3ZlciArPSBieXRlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV94b3IgKGMsIGNwb3MsIG0sIG1wb3MsIGNsZW4sIG4sIGspIHtcbiAgY3MuY3J5cHRvX3N0cmVhbV94b3IoYywgbSwgbiwgaylcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbSAoYywgY3BvcywgY2xlbiwgbiwgaykge1xuICBjcy5jcnlwdG9fc3RyZWFtKGMsIG4sIGspXG59XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aChvdXQsIG91dHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgcyA9IG5ldyBwb2x5MTMwNShrKTtcbiAgcy51cGRhdGUobSwgbXBvcywgbik7XG4gIHMuZmluaXNoKG91dCwgb3V0cG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoaCwgaHBvcywgbSwgbXBvcywgbiwgaykge1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKHgsMCxtLG1wb3MsbixrKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMTYoaCxocG9zLHgsMCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3goYyxtLGQsbixrKSB7XG4gIHZhciBpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKGMsMCxtLDAsZCxuLGspO1xuICBjcnlwdG9fb25ldGltZWF1dGgoYywgMTYsIGMsIDMyLCBkIC0gMzIsIGMpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgY1tpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X29wZW4obSxjLGQsbixrKSB7XG4gIHZhciBpO1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtKHgsMCwzMixuLGspO1xuICBpZiAoY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShjLCAxNixjLCAzMixkIC0gMzIseCkgIT09IDApIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IobSwwLGMsMCxkLG4sayk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHNldDI1NTE5KHIsIGEpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSByW2ldID0gYVtpXXwwO1xufVxuXG5mdW5jdGlvbiBjYXIyNTUxOShvKSB7XG4gIHZhciBpLCB2LCBjID0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2ID0gb1tpXSArIGMgKyA2NTUzNTtcbiAgICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpO1xuICAgIG9baV0gPSB2IC0gYyAqIDY1NTM2O1xuICB9XG4gIG9bMF0gKz0gYy0xICsgMzcgKiAoYy0xKTtcbn1cblxuZnVuY3Rpb24gc2VsMjU1MTkocCwgcSwgYikge1xuICB2YXIgdCwgYyA9IH4oYi0xKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdCA9IGMgJiAocFtpXSBeIHFbaV0pO1xuICAgIHBbaV0gXj0gdDtcbiAgICBxW2ldIF49IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGksIGosIGI7XG4gIHZhciBtID0gZ2YoKSwgdCA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB0W2ldID0gbltpXTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgZm9yIChqID0gMDsgaiA8IDI7IGorKykge1xuICAgIG1bMF0gPSB0WzBdIC0gMHhmZmVkO1xuICAgIGZvciAoaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICBtW2ldID0gdFtpXSAtIDB4ZmZmZiAtICgobVtpLTFdPj4xNikgJiAxKTtcbiAgICAgIG1baS0xXSAmPSAweGZmZmY7XG4gICAgfVxuICAgIG1bMTVdID0gdFsxNV0gLSAweDdmZmYgLSAoKG1bMTRdPj4xNikgJiAxKTtcbiAgICBiID0gKG1bMTVdPj4xNikgJiAxO1xuICAgIG1bMTRdICY9IDB4ZmZmZjtcbiAgICBzZWwyNTUxOSh0LCBtLCAxLWIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgb1syKmldID0gdFtpXSAmIDB4ZmY7XG4gICAgb1syKmkrMV0gPSB0W2ldPj44O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lcTI1NTE5KGEsIGIpIHtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheSgzMiksIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShjLCBhKTtcbiAgcGFjazI1NTE5KGQsIGIpO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8zMihjLCAwLCBkLCAwKTtcbn1cblxuZnVuY3Rpb24gcGFyMjU1MTkoYSkge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGQsIGEpO1xuICByZXR1cm4gZFswXSAmIDE7XG59XG5cbmZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gblsyKmldICsgKG5bMippKzFdIDw8IDgpO1xuICBvWzE1XSAmPSAweDdmZmY7XG59XG5cbmZ1bmN0aW9uIEEobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldICsgYltpXTtcbn1cblxuZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gLSBiW2ldO1xufVxuXG5mdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgdmFyIHYsIGMsXG4gICAgIHQwID0gMCwgIHQxID0gMCwgIHQyID0gMCwgIHQzID0gMCwgIHQ0ID0gMCwgIHQ1ID0gMCwgIHQ2ID0gMCwgIHQ3ID0gMCxcbiAgICAgdDggPSAwLCAgdDkgPSAwLCB0MTAgPSAwLCB0MTEgPSAwLCB0MTIgPSAwLCB0MTMgPSAwLCB0MTQgPSAwLCB0MTUgPSAwLFxuICAgIHQxNiA9IDAsIHQxNyA9IDAsIHQxOCA9IDAsIHQxOSA9IDAsIHQyMCA9IDAsIHQyMSA9IDAsIHQyMiA9IDAsIHQyMyA9IDAsXG4gICAgdDI0ID0gMCwgdDI1ID0gMCwgdDI2ID0gMCwgdDI3ID0gMCwgdDI4ID0gMCwgdDI5ID0gMCwgdDMwID0gMCxcbiAgICBiMCA9IGJbMF0sXG4gICAgYjEgPSBiWzFdLFxuICAgIGIyID0gYlsyXSxcbiAgICBiMyA9IGJbM10sXG4gICAgYjQgPSBiWzRdLFxuICAgIGI1ID0gYls1XSxcbiAgICBiNiA9IGJbNl0sXG4gICAgYjcgPSBiWzddLFxuICAgIGI4ID0gYls4XSxcbiAgICBiOSA9IGJbOV0sXG4gICAgYjEwID0gYlsxMF0sXG4gICAgYjExID0gYlsxMV0sXG4gICAgYjEyID0gYlsxMl0sXG4gICAgYjEzID0gYlsxM10sXG4gICAgYjE0ID0gYlsxNF0sXG4gICAgYjE1ID0gYlsxNV07XG5cbiAgdiA9IGFbMF07XG4gIHQwICs9IHYgKiBiMDtcbiAgdDEgKz0gdiAqIGIxO1xuICB0MiArPSB2ICogYjI7XG4gIHQzICs9IHYgKiBiMztcbiAgdDQgKz0gdiAqIGI0O1xuICB0NSArPSB2ICogYjU7XG4gIHQ2ICs9IHYgKiBiNjtcbiAgdDcgKz0gdiAqIGI3O1xuICB0OCArPSB2ICogYjg7XG4gIHQ5ICs9IHYgKiBiOTtcbiAgdDEwICs9IHYgKiBiMTA7XG4gIHQxMSArPSB2ICogYjExO1xuICB0MTIgKz0gdiAqIGIxMjtcbiAgdDEzICs9IHYgKiBiMTM7XG4gIHQxNCArPSB2ICogYjE0O1xuICB0MTUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMV07XG4gIHQxICs9IHYgKiBiMDtcbiAgdDIgKz0gdiAqIGIxO1xuICB0MyArPSB2ICogYjI7XG4gIHQ0ICs9IHYgKiBiMztcbiAgdDUgKz0gdiAqIGI0O1xuICB0NiArPSB2ICogYjU7XG4gIHQ3ICs9IHYgKiBiNjtcbiAgdDggKz0gdiAqIGI3O1xuICB0OSArPSB2ICogYjg7XG4gIHQxMCArPSB2ICogYjk7XG4gIHQxMSArPSB2ICogYjEwO1xuICB0MTIgKz0gdiAqIGIxMTtcbiAgdDEzICs9IHYgKiBiMTI7XG4gIHQxNCArPSB2ICogYjEzO1xuICB0MTUgKz0gdiAqIGIxNDtcbiAgdDE2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzJdO1xuICB0MiArPSB2ICogYjA7XG4gIHQzICs9IHYgKiBiMTtcbiAgdDQgKz0gdiAqIGIyO1xuICB0NSArPSB2ICogYjM7XG4gIHQ2ICs9IHYgKiBiNDtcbiAgdDcgKz0gdiAqIGI1O1xuICB0OCArPSB2ICogYjY7XG4gIHQ5ICs9IHYgKiBiNztcbiAgdDEwICs9IHYgKiBiODtcbiAgdDExICs9IHYgKiBiOTtcbiAgdDEyICs9IHYgKiBiMTA7XG4gIHQxMyArPSB2ICogYjExO1xuICB0MTQgKz0gdiAqIGIxMjtcbiAgdDE1ICs9IHYgKiBiMTM7XG4gIHQxNiArPSB2ICogYjE0O1xuICB0MTcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbM107XG4gIHQzICs9IHYgKiBiMDtcbiAgdDQgKz0gdiAqIGIxO1xuICB0NSArPSB2ICogYjI7XG4gIHQ2ICs9IHYgKiBiMztcbiAgdDcgKz0gdiAqIGI0O1xuICB0OCArPSB2ICogYjU7XG4gIHQ5ICs9IHYgKiBiNjtcbiAgdDEwICs9IHYgKiBiNztcbiAgdDExICs9IHYgKiBiODtcbiAgdDEyICs9IHYgKiBiOTtcbiAgdDEzICs9IHYgKiBiMTA7XG4gIHQxNCArPSB2ICogYjExO1xuICB0MTUgKz0gdiAqIGIxMjtcbiAgdDE2ICs9IHYgKiBiMTM7XG4gIHQxNyArPSB2ICogYjE0O1xuICB0MTggKz0gdiAqIGIxNTtcbiAgdiA9IGFbNF07XG4gIHQ0ICs9IHYgKiBiMDtcbiAgdDUgKz0gdiAqIGIxO1xuICB0NiArPSB2ICogYjI7XG4gIHQ3ICs9IHYgKiBiMztcbiAgdDggKz0gdiAqIGI0O1xuICB0OSArPSB2ICogYjU7XG4gIHQxMCArPSB2ICogYjY7XG4gIHQxMSArPSB2ICogYjc7XG4gIHQxMiArPSB2ICogYjg7XG4gIHQxMyArPSB2ICogYjk7XG4gIHQxNCArPSB2ICogYjEwO1xuICB0MTUgKz0gdiAqIGIxMTtcbiAgdDE2ICs9IHYgKiBiMTI7XG4gIHQxNyArPSB2ICogYjEzO1xuICB0MTggKz0gdiAqIGIxNDtcbiAgdDE5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzVdO1xuICB0NSArPSB2ICogYjA7XG4gIHQ2ICs9IHYgKiBiMTtcbiAgdDcgKz0gdiAqIGIyO1xuICB0OCArPSB2ICogYjM7XG4gIHQ5ICs9IHYgKiBiNDtcbiAgdDEwICs9IHYgKiBiNTtcbiAgdDExICs9IHYgKiBiNjtcbiAgdDEyICs9IHYgKiBiNztcbiAgdDEzICs9IHYgKiBiODtcbiAgdDE0ICs9IHYgKiBiOTtcbiAgdDE1ICs9IHYgKiBiMTA7XG4gIHQxNiArPSB2ICogYjExO1xuICB0MTcgKz0gdiAqIGIxMjtcbiAgdDE4ICs9IHYgKiBiMTM7XG4gIHQxOSArPSB2ICogYjE0O1xuICB0MjAgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNl07XG4gIHQ2ICs9IHYgKiBiMDtcbiAgdDcgKz0gdiAqIGIxO1xuICB0OCArPSB2ICogYjI7XG4gIHQ5ICs9IHYgKiBiMztcbiAgdDEwICs9IHYgKiBiNDtcbiAgdDExICs9IHYgKiBiNTtcbiAgdDEyICs9IHYgKiBiNjtcbiAgdDEzICs9IHYgKiBiNztcbiAgdDE0ICs9IHYgKiBiODtcbiAgdDE1ICs9IHYgKiBiOTtcbiAgdDE2ICs9IHYgKiBiMTA7XG4gIHQxNyArPSB2ICogYjExO1xuICB0MTggKz0gdiAqIGIxMjtcbiAgdDE5ICs9IHYgKiBiMTM7XG4gIHQyMCArPSB2ICogYjE0O1xuICB0MjEgKz0gdiAqIGIxNTtcbiAgdiA9IGFbN107XG4gIHQ3ICs9IHYgKiBiMDtcbiAgdDggKz0gdiAqIGIxO1xuICB0OSArPSB2ICogYjI7XG4gIHQxMCArPSB2ICogYjM7XG4gIHQxMSArPSB2ICogYjQ7XG4gIHQxMiArPSB2ICogYjU7XG4gIHQxMyArPSB2ICogYjY7XG4gIHQxNCArPSB2ICogYjc7XG4gIHQxNSArPSB2ICogYjg7XG4gIHQxNiArPSB2ICogYjk7XG4gIHQxNyArPSB2ICogYjEwO1xuICB0MTggKz0gdiAqIGIxMTtcbiAgdDE5ICs9IHYgKiBiMTI7XG4gIHQyMCArPSB2ICogYjEzO1xuICB0MjEgKz0gdiAqIGIxNDtcbiAgdDIyICs9IHYgKiBiMTU7XG4gIHYgPSBhWzhdO1xuICB0OCArPSB2ICogYjA7XG4gIHQ5ICs9IHYgKiBiMTtcbiAgdDEwICs9IHYgKiBiMjtcbiAgdDExICs9IHYgKiBiMztcbiAgdDEyICs9IHYgKiBiNDtcbiAgdDEzICs9IHYgKiBiNTtcbiAgdDE0ICs9IHYgKiBiNjtcbiAgdDE1ICs9IHYgKiBiNztcbiAgdDE2ICs9IHYgKiBiODtcbiAgdDE3ICs9IHYgKiBiOTtcbiAgdDE4ICs9IHYgKiBiMTA7XG4gIHQxOSArPSB2ICogYjExO1xuICB0MjAgKz0gdiAqIGIxMjtcbiAgdDIxICs9IHYgKiBiMTM7XG4gIHQyMiArPSB2ICogYjE0O1xuICB0MjMgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOV07XG4gIHQ5ICs9IHYgKiBiMDtcbiAgdDEwICs9IHYgKiBiMTtcbiAgdDExICs9IHYgKiBiMjtcbiAgdDEyICs9IHYgKiBiMztcbiAgdDEzICs9IHYgKiBiNDtcbiAgdDE0ICs9IHYgKiBiNTtcbiAgdDE1ICs9IHYgKiBiNjtcbiAgdDE2ICs9IHYgKiBiNztcbiAgdDE3ICs9IHYgKiBiODtcbiAgdDE4ICs9IHYgKiBiOTtcbiAgdDE5ICs9IHYgKiBiMTA7XG4gIHQyMCArPSB2ICogYjExO1xuICB0MjEgKz0gdiAqIGIxMjtcbiAgdDIyICs9IHYgKiBiMTM7XG4gIHQyMyArPSB2ICogYjE0O1xuICB0MjQgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTBdO1xuICB0MTAgKz0gdiAqIGIwO1xuICB0MTEgKz0gdiAqIGIxO1xuICB0MTIgKz0gdiAqIGIyO1xuICB0MTMgKz0gdiAqIGIzO1xuICB0MTQgKz0gdiAqIGI0O1xuICB0MTUgKz0gdiAqIGI1O1xuICB0MTYgKz0gdiAqIGI2O1xuICB0MTcgKz0gdiAqIGI3O1xuICB0MTggKz0gdiAqIGI4O1xuICB0MTkgKz0gdiAqIGI5O1xuICB0MjAgKz0gdiAqIGIxMDtcbiAgdDIxICs9IHYgKiBiMTE7XG4gIHQyMiArPSB2ICogYjEyO1xuICB0MjMgKz0gdiAqIGIxMztcbiAgdDI0ICs9IHYgKiBiMTQ7XG4gIHQyNSArPSB2ICogYjE1O1xuICB2ID0gYVsxMV07XG4gIHQxMSArPSB2ICogYjA7XG4gIHQxMiArPSB2ICogYjE7XG4gIHQxMyArPSB2ICogYjI7XG4gIHQxNCArPSB2ICogYjM7XG4gIHQxNSArPSB2ICogYjQ7XG4gIHQxNiArPSB2ICogYjU7XG4gIHQxNyArPSB2ICogYjY7XG4gIHQxOCArPSB2ICogYjc7XG4gIHQxOSArPSB2ICogYjg7XG4gIHQyMCArPSB2ICogYjk7XG4gIHQyMSArPSB2ICogYjEwO1xuICB0MjIgKz0gdiAqIGIxMTtcbiAgdDIzICs9IHYgKiBiMTI7XG4gIHQyNCArPSB2ICogYjEzO1xuICB0MjUgKz0gdiAqIGIxNDtcbiAgdDI2ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEyXTtcbiAgdDEyICs9IHYgKiBiMDtcbiAgdDEzICs9IHYgKiBiMTtcbiAgdDE0ICs9IHYgKiBiMjtcbiAgdDE1ICs9IHYgKiBiMztcbiAgdDE2ICs9IHYgKiBiNDtcbiAgdDE3ICs9IHYgKiBiNTtcbiAgdDE4ICs9IHYgKiBiNjtcbiAgdDE5ICs9IHYgKiBiNztcbiAgdDIwICs9IHYgKiBiODtcbiAgdDIxICs9IHYgKiBiOTtcbiAgdDIyICs9IHYgKiBiMTA7XG4gIHQyMyArPSB2ICogYjExO1xuICB0MjQgKz0gdiAqIGIxMjtcbiAgdDI1ICs9IHYgKiBiMTM7XG4gIHQyNiArPSB2ICogYjE0O1xuICB0MjcgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTNdO1xuICB0MTMgKz0gdiAqIGIwO1xuICB0MTQgKz0gdiAqIGIxO1xuICB0MTUgKz0gdiAqIGIyO1xuICB0MTYgKz0gdiAqIGIzO1xuICB0MTcgKz0gdiAqIGI0O1xuICB0MTggKz0gdiAqIGI1O1xuICB0MTkgKz0gdiAqIGI2O1xuICB0MjAgKz0gdiAqIGI3O1xuICB0MjEgKz0gdiAqIGI4O1xuICB0MjIgKz0gdiAqIGI5O1xuICB0MjMgKz0gdiAqIGIxMDtcbiAgdDI0ICs9IHYgKiBiMTE7XG4gIHQyNSArPSB2ICogYjEyO1xuICB0MjYgKz0gdiAqIGIxMztcbiAgdDI3ICs9IHYgKiBiMTQ7XG4gIHQyOCArPSB2ICogYjE1O1xuICB2ID0gYVsxNF07XG4gIHQxNCArPSB2ICogYjA7XG4gIHQxNSArPSB2ICogYjE7XG4gIHQxNiArPSB2ICogYjI7XG4gIHQxNyArPSB2ICogYjM7XG4gIHQxOCArPSB2ICogYjQ7XG4gIHQxOSArPSB2ICogYjU7XG4gIHQyMCArPSB2ICogYjY7XG4gIHQyMSArPSB2ICogYjc7XG4gIHQyMiArPSB2ICogYjg7XG4gIHQyMyArPSB2ICogYjk7XG4gIHQyNCArPSB2ICogYjEwO1xuICB0MjUgKz0gdiAqIGIxMTtcbiAgdDI2ICs9IHYgKiBiMTI7XG4gIHQyNyArPSB2ICogYjEzO1xuICB0MjggKz0gdiAqIGIxNDtcbiAgdDI5ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE1XTtcbiAgdDE1ICs9IHYgKiBiMDtcbiAgdDE2ICs9IHYgKiBiMTtcbiAgdDE3ICs9IHYgKiBiMjtcbiAgdDE4ICs9IHYgKiBiMztcbiAgdDE5ICs9IHYgKiBiNDtcbiAgdDIwICs9IHYgKiBiNTtcbiAgdDIxICs9IHYgKiBiNjtcbiAgdDIyICs9IHYgKiBiNztcbiAgdDIzICs9IHYgKiBiODtcbiAgdDI0ICs9IHYgKiBiOTtcbiAgdDI1ICs9IHYgKiBiMTA7XG4gIHQyNiArPSB2ICogYjExO1xuICB0MjcgKz0gdiAqIGIxMjtcbiAgdDI4ICs9IHYgKiBiMTM7XG4gIHQyOSArPSB2ICogYjE0O1xuICB0MzAgKz0gdiAqIGIxNTtcblxuICB0MCAgKz0gMzggKiB0MTY7XG4gIHQxICArPSAzOCAqIHQxNztcbiAgdDIgICs9IDM4ICogdDE4O1xuICB0MyAgKz0gMzggKiB0MTk7XG4gIHQ0ICArPSAzOCAqIHQyMDtcbiAgdDUgICs9IDM4ICogdDIxO1xuICB0NiAgKz0gMzggKiB0MjI7XG4gIHQ3ICArPSAzOCAqIHQyMztcbiAgdDggICs9IDM4ICogdDI0O1xuICB0OSAgKz0gMzggKiB0MjU7XG4gIHQxMCArPSAzOCAqIHQyNjtcbiAgdDExICs9IDM4ICogdDI3O1xuICB0MTIgKz0gMzggKiB0Mjg7XG4gIHQxMyArPSAzOCAqIHQyOTtcbiAgdDE0ICs9IDM4ICogdDMwO1xuICAvLyB0MTUgbGVmdCBhcyBpc1xuXG4gIC8vIGZpcnN0IGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICAvLyBzZWNvbmQgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIG9bIDBdID0gdDA7XG4gIG9bIDFdID0gdDE7XG4gIG9bIDJdID0gdDI7XG4gIG9bIDNdID0gdDM7XG4gIG9bIDRdID0gdDQ7XG4gIG9bIDVdID0gdDU7XG4gIG9bIDZdID0gdDY7XG4gIG9bIDddID0gdDc7XG4gIG9bIDhdID0gdDg7XG4gIG9bIDldID0gdDk7XG4gIG9bMTBdID0gdDEwO1xuICBvWzExXSA9IHQxMTtcbiAgb1sxMl0gPSB0MTI7XG4gIG9bMTNdID0gdDEzO1xuICBvWzE0XSA9IHQxNDtcbiAgb1sxNV0gPSB0MTU7XG59XG5cbmZ1bmN0aW9uIFMobywgYSkge1xuICBNKG8sIGEsIGEpO1xufVxuXG5mdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUzOyBhID49IDA7IGEtLSkge1xuICAgIFMoYywgYyk7XG4gICAgaWYoYSAhPT0gMiAmJiBhICE9PSA0KSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gIHZhciBjID0gZ2YoKTtcbiAgdmFyIGE7XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBjW2FdID0gaVthXTtcbiAgZm9yIChhID0gMjUwOyBhID49IDA7IGEtLSkge1xuICAgICAgUyhjLCBjKTtcbiAgICAgIGlmKGEgIT09IDEpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKSB7XG4gIGNoZWNrKHEsIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKVxuICBjaGVjayhuLCBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUylcbiAgY2hlY2socCwgY3J5cHRvX3NjYWxhcm11bHRfQllURVMpXG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoODApLCByLCBpO1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCk7XG4gIGZvciAoaSA9IDA7IGkgPCAzMTsgaSsrKSB6W2ldID0gbltpXTtcbiAgelszMV09KG5bMzFdJjEyNyl8NjQ7XG4gIHpbMF0mPTI0ODtcbiAgdW5wYWNrMjU1MTkoeCxwKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBiW2ldPXhbaV07XG4gICAgZFtpXT1hW2ldPWNbaV09MDtcbiAgfVxuICBhWzBdPWRbMF09MTtcbiAgZm9yIChpPTI1NDsgaT49MDsgLS1pKSB7XG4gICAgcj0oeltpPj4+M10+Pj4oaSY3KSkmMTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIEEoYyxiLGQpO1xuICAgIFooYixiLGQpO1xuICAgIFMoZCxlKTtcbiAgICBTKGYsYSk7XG4gICAgTShhLGMsYSk7XG4gICAgTShjLGIsZSk7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgUyhiLGEpO1xuICAgIFooYyxkLGYpO1xuICAgIE0oYSxjLF8xMjE2NjUpO1xuICAgIEEoYSxhLGQpO1xuICAgIE0oYyxjLGEpO1xuICAgIE0oYSxkLGYpO1xuICAgIE0oZCxiLHgpO1xuICAgIFMoYixlKTtcbiAgICBzZWwyNTUxOShhLGIscik7XG4gICAgc2VsMjU1MTkoYyxkLHIpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgeFtpKzE2XT1hW2ldO1xuICAgIHhbaSszMl09Y1tpXTtcbiAgICB4W2krNDhdPWJbaV07XG4gICAgeFtpKzY0XT1kW2ldO1xuICB9XG4gIHZhciB4MzIgPSB4LnN1YmFycmF5KDMyKTtcbiAgdmFyIHgxNiA9IHguc3ViYXJyYXkoMTYpO1xuICBpbnYyNTUxOSh4MzIseDMyKTtcbiAgTSh4MTYseDE2LHgzMik7XG4gIHBhY2syNTUxOShxLHgxNik7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pIHtcbiAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIF85KTtcbn1cblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl07XG5cbmZ1bmN0aW9uIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbikge1xuICB2YXIgd2ggPSBuZXcgSW50MzJBcnJheSgxNiksIHdsID0gbmV3IEludDMyQXJyYXkoMTYpLFxuICAgICAgYmgwLCBiaDEsIGJoMiwgYmgzLCBiaDQsIGJoNSwgYmg2LCBiaDcsXG4gICAgICBibDAsIGJsMSwgYmwyLCBibDMsIGJsNCwgYmw1LCBibDYsIGJsNyxcbiAgICAgIHRoLCB0bCwgaSwgaiwgaCwgbCwgYSwgYiwgYywgZDtcblxuICB2YXIgYWgwID0gaGhbMF0sXG4gICAgICBhaDEgPSBoaFsxXSxcbiAgICAgIGFoMiA9IGhoWzJdLFxuICAgICAgYWgzID0gaGhbM10sXG4gICAgICBhaDQgPSBoaFs0XSxcbiAgICAgIGFoNSA9IGhoWzVdLFxuICAgICAgYWg2ID0gaGhbNl0sXG4gICAgICBhaDcgPSBoaFs3XSxcblxuICAgICAgYWwwID0gaGxbMF0sXG4gICAgICBhbDEgPSBobFsxXSxcbiAgICAgIGFsMiA9IGhsWzJdLFxuICAgICAgYWwzID0gaGxbM10sXG4gICAgICBhbDQgPSBobFs0XSxcbiAgICAgIGFsNSA9IGhsWzVdLFxuICAgICAgYWw2ID0gaGxbNl0sXG4gICAgICBhbDcgPSBobFs3XTtcblxuICB2YXIgcG9zID0gMDtcbiAgd2hpbGUgKG4gPj0gMTI4KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGogPSA4ICogaSArIHBvcztcbiAgICAgIHdoW2ldID0gKG1baiswXSA8PCAyNCkgfCAobVtqKzFdIDw8IDE2KSB8IChtW2orMl0gPDwgOCkgfCBtW2orM107XG4gICAgICB3bFtpXSA9IChtW2orNF0gPDwgMjQpIHwgKG1bais1XSA8PCAxNikgfCAobVtqKzZdIDw8IDgpIHwgbVtqKzddO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgYmgwID0gYWgwO1xuICAgICAgYmgxID0gYWgxO1xuICAgICAgYmgyID0gYWgyO1xuICAgICAgYmgzID0gYWgzO1xuICAgICAgYmg0ID0gYWg0O1xuICAgICAgYmg1ID0gYWg1O1xuICAgICAgYmg2ID0gYWg2O1xuICAgICAgYmg3ID0gYWg3O1xuXG4gICAgICBibDAgPSBhbDA7XG4gICAgICBibDEgPSBhbDE7XG4gICAgICBibDIgPSBhbDI7XG4gICAgICBibDMgPSBhbDM7XG4gICAgICBibDQgPSBhbDQ7XG4gICAgICBibDUgPSBhbDU7XG4gICAgICBibDYgPSBhbDY7XG4gICAgICBibDcgPSBhbDc7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IGFoNztcbiAgICAgIGwgPSBhbDc7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTFcbiAgICAgIGggPSAoKGFoNCA+Pj4gMTQpIHwgKGFsNCA8PCAoMzItMTQpKSkgXiAoKGFoNCA+Pj4gMTgpIHwgKGFsNCA8PCAoMzItMTgpKSkgXiAoKGFsNCA+Pj4gKDQxLTMyKSkgfCAoYWg0IDw8ICgzMi0oNDEtMzIpKSkpO1xuICAgICAgbCA9ICgoYWw0ID4+PiAxNCkgfCAoYWg0IDw8ICgzMi0xNCkpKSBeICgoYWw0ID4+PiAxOCkgfCAoYWg0IDw8ICgzMi0xOCkpKSBeICgoYWg0ID4+PiAoNDEtMzIpKSB8IChhbDQgPDwgKDMyLSg0MS0zMikpKSk7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gQ2hcbiAgICAgIGggPSAoYWg0ICYgYWg1KSBeICh+YWg0ICYgYWg2KTtcbiAgICAgIGwgPSAoYWw0ICYgYWw1KSBeICh+YWw0ICYgYWw2KTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBLXG4gICAgICBoID0gS1tpKjJdO1xuICAgICAgbCA9IEtbaSoyKzFdO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIHdcbiAgICAgIGggPSB3aFtpJTE2XTtcbiAgICAgIGwgPSB3bFtpJTE2XTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIHRoID0gYyAmIDB4ZmZmZiB8IGQgPDwgMTY7XG4gICAgICB0bCA9IGEgJiAweGZmZmYgfCBiIDw8IDE2O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSB0aDtcbiAgICAgIGwgPSB0bDtcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIFNpZ21hMFxuICAgICAgaCA9ICgoYWgwID4+PiAyOCkgfCAoYWwwIDw8ICgzMi0yOCkpKSBeICgoYWwwID4+PiAoMzQtMzIpKSB8IChhaDAgPDwgKDMyLSgzNC0zMikpKSkgXiAoKGFsMCA+Pj4gKDM5LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzktMzIpKSkpO1xuICAgICAgbCA9ICgoYWwwID4+PiAyOCkgfCAoYWgwIDw8ICgzMi0yOCkpKSBeICgoYWgwID4+PiAoMzQtMzIpKSB8IChhbDAgPDwgKDMyLSgzNC0zMikpKSkgXiAoKGFoMCA+Pj4gKDM5LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzktMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIE1halxuICAgICAgaCA9IChhaDAgJiBhaDEpIF4gKGFoMCAmIGFoMikgXiAoYWgxICYgYWgyKTtcbiAgICAgIGwgPSAoYWwwICYgYWwxKSBeIChhbDAgJiBhbDIpIF4gKGFsMSAmIGFsMik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICBiaDcgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICBibDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IGJoMztcbiAgICAgIGwgPSBibDM7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICBiaDMgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICBibDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICAgIGFoMSA9IGJoMDtcbiAgICAgIGFoMiA9IGJoMTtcbiAgICAgIGFoMyA9IGJoMjtcbiAgICAgIGFoNCA9IGJoMztcbiAgICAgIGFoNSA9IGJoNDtcbiAgICAgIGFoNiA9IGJoNTtcbiAgICAgIGFoNyA9IGJoNjtcbiAgICAgIGFoMCA9IGJoNztcblxuICAgICAgYWwxID0gYmwwO1xuICAgICAgYWwyID0gYmwxO1xuICAgICAgYWwzID0gYmwyO1xuICAgICAgYWw0ID0gYmwzO1xuICAgICAgYWw1ID0gYmw0O1xuICAgICAgYWw2ID0gYmw1O1xuICAgICAgYWw3ID0gYmw2O1xuICAgICAgYWwwID0gYmw3O1xuXG4gICAgICBpZiAoaSUxNiA9PT0gMTUpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICBoID0gd2hbal07XG4gICAgICAgICAgbCA9IHdsW2pdO1xuXG4gICAgICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAgICAgaCA9IHdoWyhqKzkpJTE2XTtcbiAgICAgICAgICBsID0gd2xbKGorOSklMTZdO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIC8vIHNpZ21hMFxuICAgICAgICAgIHRoID0gd2hbKGorMSklMTZdO1xuICAgICAgICAgIHRsID0gd2xbKGorMSklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxKSB8ICh0bCA8PCAoMzItMSkpKSBeICgodGggPj4+IDgpIHwgKHRsIDw8ICgzMi04KSkpIF4gKHRoID4+PiA3KTtcbiAgICAgICAgICBsID0gKCh0bCA+Pj4gMSkgfCAodGggPDwgKDMyLTEpKSkgXiAoKHRsID4+PiA4KSB8ICh0aCA8PCAoMzItOCkpKSBeICgodGwgPj4+IDcpIHwgKHRoIDw8ICgzMi03KSkpO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIC8vIHNpZ21hMVxuICAgICAgICAgIHRoID0gd2hbKGorMTQpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzE0KSUxNl07XG4gICAgICAgICAgaCA9ICgodGggPj4+IDE5KSB8ICh0bCA8PCAoMzItMTkpKSkgXiAoKHRsID4+PiAoNjEtMzIpKSB8ICh0aCA8PCAoMzItKDYxLTMyKSkpKSBeICh0aCA+Pj4gNik7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDE5KSB8ICh0aCA8PCAoMzItMTkpKSkgXiAoKHRoID4+PiAoNjEtMzIpKSB8ICh0bCA8PCAoMzItKDYxLTMyKSkpKSBeICgodGwgPj4+IDYpIHwgKHRoIDw8ICgzMi02KSkpO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICAgICAgd2hbal0gPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICAgICAgd2xbal0gPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGRcbiAgICBoID0gYWgwO1xuICAgIGwgPSBhbDA7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMF07XG4gICAgbCA9IGhsWzBdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMF0gPSBhaDAgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMF0gPSBhbDAgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgxO1xuICAgIGwgPSBhbDE7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMV07XG4gICAgbCA9IGhsWzFdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMV0gPSBhaDEgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMV0gPSBhbDEgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgyO1xuICAgIGwgPSBhbDI7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMl07XG4gICAgbCA9IGhsWzJdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMl0gPSBhaDIgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMl0gPSBhbDIgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgzO1xuICAgIGwgPSBhbDM7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbM107XG4gICAgbCA9IGhsWzNdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbM10gPSBhaDMgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbM10gPSBhbDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg0O1xuICAgIGwgPSBhbDQ7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNF07XG4gICAgbCA9IGhsWzRdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNF0gPSBhaDQgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNF0gPSBhbDQgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg1O1xuICAgIGwgPSBhbDU7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNV07XG4gICAgbCA9IGhsWzVdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNV0gPSBhaDUgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNV0gPSBhbDUgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg2O1xuICAgIGwgPSBhbDY7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNl07XG4gICAgbCA9IGhsWzZdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNl0gPSBhaDYgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNl0gPSBhbDYgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg3O1xuICAgIGwgPSBhbDc7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbN107XG4gICAgbCA9IGhsWzddO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbN10gPSBhaDcgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbN10gPSBhbDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBwb3MgKz0gMTI4O1xuICAgIG4gLT0gMTI4O1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19oYXNoKG91dCwgbSwgbikge1xuICB2YXIgaGggPSBuZXcgSW50MzJBcnJheSg4KSxcbiAgICAgIGhsID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICB4ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KSxcbiAgICAgIGksIGIgPSBuO1xuXG4gIGhoWzBdID0gMHg2YTA5ZTY2NztcbiAgaGhbMV0gPSAweGJiNjdhZTg1O1xuICBoaFsyXSA9IDB4M2M2ZWYzNzI7XG4gIGhoWzNdID0gMHhhNTRmZjUzYTtcbiAgaGhbNF0gPSAweDUxMGU1MjdmO1xuICBoaFs1XSA9IDB4OWIwNTY4OGM7XG4gIGhoWzZdID0gMHgxZjgzZDlhYjtcbiAgaGhbN10gPSAweDViZTBjZDE5O1xuXG4gIGhsWzBdID0gMHhmM2JjYzkwODtcbiAgaGxbMV0gPSAweDg0Y2FhNzNiO1xuICBobFsyXSA9IDB4ZmU5NGY4MmI7XG4gIGhsWzNdID0gMHg1ZjFkMzZmMTtcbiAgaGxbNF0gPSAweGFkZTY4MmQxO1xuICBobFs1XSA9IDB4MmIzZTZjMWY7XG4gIGhsWzZdID0gMHhmYjQxYmQ2YjtcbiAgaGxbN10gPSAweDEzN2UyMTc5O1xuXG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbik7XG4gIG4gJT0gMTI4O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSBtW2ItbitpXTtcbiAgeFtuXSA9IDEyODtcblxuICBuID0gMjU2LTEyOCoobjwxMTI/MTowKTtcbiAgeFtuLTldID0gMDtcbiAgdHM2NCh4LCBuLTgsICAoYiAvIDB4MjAwMDAwMDApIHwgMCwgYiA8PCAzKTtcbiAgY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCB4LCBuKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB0czY0KG91dCwgOCppLCBoaFtpXSwgaGxbaV0pO1xuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhZGQocCwgcSkge1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCksXG4gICAgICBnID0gZ2YoKSwgaCA9IGdmKCksIHQgPSBnZigpO1xuXG4gIFooYSwgcFsxXSwgcFswXSk7XG4gIFoodCwgcVsxXSwgcVswXSk7XG4gIE0oYSwgYSwgdCk7XG4gIEEoYiwgcFswXSwgcFsxXSk7XG4gIEEodCwgcVswXSwgcVsxXSk7XG4gIE0oYiwgYiwgdCk7XG4gIE0oYywgcFszXSwgcVszXSk7XG4gIE0oYywgYywgRDIpO1xuICBNKGQsIHBbMl0sIHFbMl0pO1xuICBBKGQsIGQsIGQpO1xuICBaKGUsIGIsIGEpO1xuICBaKGYsIGQsIGMpO1xuICBBKGcsIGQsIGMpO1xuICBBKGgsIGIsIGEpO1xuXG4gIE0ocFswXSwgZSwgZik7XG4gIE0ocFsxXSwgaCwgZyk7XG4gIE0ocFsyXSwgZywgZik7XG4gIE0ocFszXSwgZSwgaCk7XG59XG5cbmZ1bmN0aW9uIGNzd2FwKHAsIHEsIGIpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBzZWwyNTUxOShwW2ldLCBxW2ldLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWNrKHIsIHApIHtcbiAgdmFyIHR4ID0gZ2YoKSwgdHkgPSBnZigpLCB6aSA9IGdmKCk7XG4gIGludjI1NTE5KHppLCBwWzJdKTtcbiAgTSh0eCwgcFswXSwgemkpO1xuICBNKHR5LCBwWzFdLCB6aSk7XG4gIHBhY2syNTUxOShyLCB0eSk7XG4gIHJbMzFdIF49IHBhcjI1NTE5KHR4KSA8PCA3O1xufVxuXG5mdW5jdGlvbiBzY2FsYXJtdWx0KHAsIHEsIHMpIHtcbiAgdmFyIGIsIGk7XG4gIHNldDI1NTE5KHBbMF0sIGdmMCk7XG4gIHNldDI1NTE5KHBbMV0sIGdmMSk7XG4gIHNldDI1NTE5KHBbMl0sIGdmMSk7XG4gIHNldDI1NTE5KHBbM10sIGdmMCk7XG4gIGZvciAoaSA9IDI1NTsgaSA+PSAwOyAtLWkpIHtcbiAgICBiID0gKHNbKGkvOCl8MF0gPj4gKGkmNykpICYgMTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgICBhZGQocSwgcCk7XG4gICAgYWRkKHAsIHApO1xuICAgIGNzd2FwKHAsIHEsIGIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjYWxhcmJhc2UocCwgcykge1xuICB2YXIgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcbiAgc2V0MjU1MTkocVswXSwgWCk7XG4gIHNldDI1NTE5KHFbMV0sIFkpO1xuICBzZXQyNTUxOShxWzJdLCBnZjEpO1xuICBNKHFbM10sIFgsIFkpO1xuICBzY2FsYXJtdWx0KHAsIHEsIHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgc2VlZGVkKSB7XG4gIGNoZWNrKHBrLCBzb2RpdW0uY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpXG4gIGNoZWNrKHNrLCBzb2RpdW0uY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG5cbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuICB2YXIgaTtcblxuICBpZiAoIXNlZWRlZCkgcmFuZG9tYnl0ZXMoc2ssIDMyKTtcbiAgY3J5cHRvX2hhc2goZCwgc2ssIDMyKTtcbiAgZFswXSAmPSAyNDg7XG4gIGRbMzFdICY9IDEyNztcbiAgZFszMV0gfD0gNjQ7XG5cbiAgc2NhbGFyYmFzZShwLCBkKTtcbiAgcGFjayhwaywgcCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHNrW2krMzJdID0gcGtbaV07XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9zZWVkX2tleXBhaXIgKHBrLCBzaywgc2VlZCkge1xuICBjaGVjayhzZWVkLCBzb2RpdW0uY3J5cHRvX3NpZ25fU0VFREJZVEVTKVxuICBzZWVkLmNvcHkoc2spXG4gIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrLCB0cnVlKVxufVxuXG52YXIgTCA9IG5ldyBGbG9hdDY0QXJyYXkoWzB4ZWQsIDB4ZDMsIDB4ZjUsIDB4NWMsIDB4MWEsIDB4NjMsIDB4MTIsIDB4NTgsIDB4ZDYsIDB4OWMsIDB4ZjcsIDB4YTIsIDB4ZGUsIDB4ZjksIDB4ZGUsIDB4MTQsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MTBdKTtcblxuZnVuY3Rpb24gbW9kTChyLCB4KSB7XG4gIHZhciBjYXJyeSwgaSwgaiwgaztcbiAgZm9yIChpID0gNjM7IGkgPj0gMzI7IC0taSkge1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGogPSBpIC0gMzIsIGsgPSBpIC0gMTI7IGogPCBrOyArK2opIHtcbiAgICAgIHhbal0gKz0gY2FycnkgLSAxNiAqIHhbaV0gKiBMW2ogLSAoaSAtIDMyKV07XG4gICAgICBjYXJyeSA9ICh4W2pdICsgMTI4KSA+PiA4O1xuICAgICAgeFtqXSAtPSBjYXJyeSAqIDI1NjtcbiAgICB9XG4gICAgeFtqXSArPSBjYXJyeTtcbiAgICB4W2ldID0gMDtcbiAgfVxuICBjYXJyeSA9IDA7XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgeFtqXSArPSBjYXJyeSAtICh4WzMxXSA+PiA0KSAqIExbal07XG4gICAgY2FycnkgPSB4W2pdID4+IDg7XG4gICAgeFtqXSAmPSAyNTU7XG4gIH1cbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHhbal0gLT0gY2FycnkgKiBMW2pdO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHhbaSsxXSArPSB4W2ldID4+IDg7XG4gICAgcltpXSA9IHhbaV0gJiAyNTU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHIpIHtcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgcltpXSA9IDA7XG4gIG1vZEwociwgeCk7XG59XG5cbi8vIE5vdGU6IGRpZmZlcmVuY2UgZnJvbSBDIC0gc21sZW4gcmV0dXJuZWQsIG5vdCBwYXNzZWQgYXMgYXJndW1lbnQuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbihzbSwgbSwgc2spIHtcbiAgY2hlY2soc20sIGNyeXB0b19zaWduX0JZVEVTICsgbS5sZW5ndGgpXG4gIGNoZWNrKG0sIDApXG4gIGNoZWNrKHNrLCBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUylcbiAgdmFyIG4gPSBtLmxlbmd0aFxuXG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCBoID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCByID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgaSwgaiwgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICB2YXIgc21sZW4gPSBuICsgNjQ7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHNtWzY0ICsgaV0gPSBtW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc21bMzIgKyBpXSA9IGRbMzIgKyBpXTtcblxuICBjcnlwdG9faGFzaChyLCBzbS5zdWJhcnJheSgzMiksIG4rMzIpO1xuICByZWR1Y2Uocik7XG4gIHNjYWxhcmJhc2UocCwgcik7XG4gIHBhY2soc20sIHApO1xuXG4gIGZvciAoaSA9IDMyOyBpIDwgNjQ7IGkrKykgc21baV0gPSBza1tpXTtcbiAgY3J5cHRvX2hhc2goaCwgc20sIG4gKyA2NCk7XG4gIHJlZHVjZShoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeFtpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB4W2ldID0gcltpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgICAgeFtpK2pdICs9IGhbaV0gKiBkW2pdO1xuICAgIH1cbiAgfVxuXG4gIG1vZEwoc20uc3ViYXJyYXkoMzIpLCB4KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fZGV0YWNoZWQoc2lnLCBtLCBzaykge1xuICB2YXIgc20gPSBuZXcgVWludDhBcnJheShtLmxlbmd0aCArIGNyeXB0b19zaWduX0JZVEVTKVxuICBjcnlwdG9fc2lnbihzbSwgbSwgc2spXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3J5cHRvX3NpZ25fQllURVM7IGkrKykgc2lnW2ldID0gc21baV1cbn1cblxuZnVuY3Rpb24gdW5wYWNrbmVnKHIsIHApIHtcbiAgdmFyIHQgPSBnZigpLCBjaGsgPSBnZigpLCBudW0gPSBnZigpLFxuICAgICAgZGVuID0gZ2YoKSwgZGVuMiA9IGdmKCksIGRlbjQgPSBnZigpLFxuICAgICAgZGVuNiA9IGdmKCk7XG5cbiAgc2V0MjU1MTkoclsyXSwgZ2YxKTtcbiAgdW5wYWNrMjU1MTkoclsxXSwgcCk7XG4gIFMobnVtLCByWzFdKTtcbiAgTShkZW4sIG51bSwgRCk7XG4gIFoobnVtLCBudW0sIHJbMl0pO1xuICBBKGRlbiwgclsyXSwgZGVuKTtcblxuICBTKGRlbjIsIGRlbik7XG4gIFMoZGVuNCwgZGVuMik7XG4gIE0oZGVuNiwgZGVuNCwgZGVuMik7XG4gIE0odCwgZGVuNiwgbnVtKTtcbiAgTSh0LCB0LCBkZW4pO1xuXG4gIHBvdzI1MjModCwgdCk7XG4gIE0odCwgdCwgbnVtKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHQsIHQsIGRlbik7XG4gIE0oclswXSwgdCwgZGVuKTtcblxuICBTKGNoaywgclswXSk7XG4gIE0oY2hrLCBjaGssIGRlbik7XG4gIGlmIChuZXEyNTUxOShjaGssIG51bSkpIE0oclswXSwgclswXSwgSSk7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSByZXR1cm4gLTE7XG5cbiAgaWYgKHBhcjI1NTE5KHJbMF0pID09PSAocFszMV0+PjcpKSBaKHJbMF0sIGdmMCwgclswXSk7XG5cbiAgTShyWzNdLCByWzBdLCByWzFdKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX29wZW4obXNnLCBzbSwgcGspIHtcbiAgY2hlY2sobXNnLCBzbS5sZW5ndGggLSBjcnlwdG9fc2lnbl9CWVRFUylcbiAgY2hlY2soc20sIGNyeXB0b19zaWduX0JZVEVTKVxuICBjaGVjayhwaywgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpXG4gIHZhciBuID0gc20ubGVuZ3RoXG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoc20ubGVuZ3RoKVxuXG4gIHZhciBpLCBtbGVuO1xuICB2YXIgdCA9IG5ldyBVaW50OEFycmF5KDMyKSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV0sXG4gICAgICBxID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIG1sZW4gPSAtMTtcbiAgaWYgKG4gPCA2NCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh1bnBhY2tuZWcocSwgcGspKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgbVtpKzMyXSA9IHBrW2ldO1xuICBjcnlwdG9faGFzaChoLCBtLCBuKTtcbiAgcmVkdWNlKGgpO1xuICBzY2FsYXJtdWx0KHAsIHEsIGgpO1xuXG4gIHNjYWxhcmJhc2UocSwgc20uc3ViYXJyYXkoMzIpKTtcbiAgYWRkKHAsIHEpO1xuICBwYWNrKHQsIHApO1xuXG4gIG4gLT0gNjQ7XG4gIGlmIChjcnlwdG9fdmVyaWZ5XzMyKHNtLCAwLCB0LCAwKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1baV0gPSAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1zZ1tpXSA9IHNtW2kgKyA2NF07XG4gIG1sZW4gPSBuO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fdmVyaWZ5X2RldGFjaGVkIChzaWcsIG0sIHBrKSB7XG4gIGNoZWNrKHNpZywgY3J5cHRvX3NpZ25fQllURVMpXG4gIHZhciBzbSA9IG5ldyBVaW50OEFycmF5KG0ubGVuZ3RoICsgY3J5cHRvX3NpZ25fQllURVMpXG4gIHZhciBpID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgY3J5cHRvX3NpZ25fQllURVM7IGkrKykgc21baV0gPSBzaWdbaV1cbiAgZm9yIChpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHNtW2kgKyBjcnlwdG9fc2lnbl9CWVRFU10gPSBtW2ldXG4gIHJldHVybiBjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBwaylcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveF9kZXRhY2hlZCAobywgbWFjLCBtc2csIG4sIGspIHtcbiAgY2hlY2sobWFjLCBzb2RpdW0uY3J5cHRvX3NlY3JldGJveF9NQUNCWVRFUylcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGggKyBtYWMubGVuZ3RoKVxuICBjcnlwdG9fc2VjcmV0Ym94X2Vhc3kodG1wLCBtc2csIG4sIGspXG4gIG8uc2V0KHRtcC5zdWJhcnJheSgwLCBtc2cubGVuZ3RoKSlcbiAgbWFjLnNldCh0bXAuc3ViYXJyYXkobXNnLmxlbmd0aCkpXG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfb3Blbl9kZXRhY2hlZCAobXNnLCBvLCBtYWMsIG4sIGspIHtcbiAgY2hlY2sobWFjLCBzb2RpdW0uY3J5cHRvX3NlY3JldGJveF9NQUNCWVRFUylcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KG8ubGVuZ3RoICsgbWFjLmxlbmd0aClcbiAgdG1wLnNldChvKVxuICB0bXAuc2V0KG1hYywgbXNnLmxlbmd0aClcbiAgcmV0dXJuIGNyeXB0b19zZWNyZXRib3hfb3Blbl9lYXN5KG1zZywgdG1wLCBuLCBrKVxufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X2Vhc3kobywgbXNnLCBuLCBrKSB7XG4gIGNoZWNrKG1zZywgMClcbiAgY2hlY2sobywgbXNnLmxlbmd0aCArIHNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X01BQ0JZVEVTKVxuICBjaGVjayhuLCBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMpXG4gIGNoZWNrKGssIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMpXG5cbiAgdmFyIGlcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KG0ubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgbVtpK2NyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTXSA9IG1zZ1tpXTtcbiAgY3J5cHRvX3NlY3JldGJveChjLCBtLCBtLmxlbmd0aCwgbiwgayk7XG4gIGZvciAoaSA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTOyBpIDwgYy5sZW5ndGg7IGkrKykgb1tpIC0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVNdID0gY1tpXVxufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X29wZW5fZWFzeShtc2csIGJveCwgbiwgaykge1xuICBjaGVjayhib3gsIHNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X01BQ0JZVEVTKVxuICBjaGVjayhtc2csIGJveC5sZW5ndGggLSBzb2RpdW0uY3J5cHRvX3NlY3JldGJveF9NQUNCWVRFUylcbiAgY2hlY2sobiwgY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTKVxuICBjaGVjayhrLCBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTKVxuXG4gIHZhciBpXG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgKyBib3gubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjLmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKyspIGNbaStjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFU10gPSBib3hbaV07XG4gIGlmIChjLmxlbmd0aCA8IDMyKSByZXR1cm4gZmFsc2U7XG4gIGlmIChjcnlwdG9fc2VjcmV0Ym94X29wZW4obSwgYywgYy5sZW5ndGgsIG4sIGspICE9PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChpID0gY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVM7IGkgPCBtLmxlbmd0aDsgaSsrKSBtc2dbaSAtIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTXSA9IG1baV1cbiAgcmV0dXJuIHRydWVcbn1cblxudmFyIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMgPSAyNCxcbiAgICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTID0gMTYsXG4gICAgY3J5cHRvX3NjYWxhcm11bHRfQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9OT05DRUJZVEVTID0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICAgIGNyeXB0b19ib3hfWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gICAgY3J5cHRvX2JveF9CT1haRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgICBjcnlwdG9fc2lnbl9CWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMgPSA2NCxcbiAgICBjcnlwdG9fc2lnbl9TRUVEQllURVMgPSAzMixcbiAgICBjcnlwdG9faGFzaF9CWVRFUyA9IDY0O1xuXG5zb2RpdW0ubWVtemVybyA9IGZ1bmN0aW9uIChsZW4sIG9mZnNldCkge1xuICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgbGVuOyBpKyspIGFycltpXSA9IDA7XG59XG5cbnNvZGl1bS5jcnlwdG9fc2lnbl9CWVRFUyA9IGNyeXB0b19zaWduX0JZVEVTXG5zb2RpdW0uY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMgPSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFU1xuc29kaXVtLmNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTID0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVNcbnNvZGl1bS5jcnlwdG9fc2lnbl9TRUVEQllURVMgPSBjcnlwdG9fc2lnbl9TRUVEQllURVNcbnNvZGl1bS5jcnlwdG9fc2lnbl9rZXlwYWlyID0gY3J5cHRvX3NpZ25fa2V5cGFpclxuc29kaXVtLmNyeXB0b19zaWduX3NlZWRfa2V5cGFpciA9IGNyeXB0b19zaWduX3NlZWRfa2V5cGFpclxuc29kaXVtLmNyeXB0b19zaWduID0gY3J5cHRvX3NpZ25cbnNvZGl1bS5jcnlwdG9fc2lnbl9vcGVuID0gY3J5cHRvX3NpZ25fb3Blblxuc29kaXVtLmNyeXB0b19zaWduX2RldGFjaGVkID0gY3J5cHRvX3NpZ25fZGV0YWNoZWRcbnNvZGl1bS5jcnlwdG9fc2lnbl92ZXJpZnlfZGV0YWNoZWQgPSBjcnlwdG9fc2lnbl92ZXJpZnlfZGV0YWNoZWRcblxuZm9yd2FyZChyZXF1aXJlKCcuL2NyeXB0b19nZW5lcmljaGFzaCcpKVxuZm9yd2FyZChyZXF1aXJlKCcuL2NyeXB0b19rZGYnKSlcbmZvcndhcmQocmVxdWlyZSgnLi9jcnlwdG9fc2hvcnRoYXNoJykpXG5mb3J3YXJkKHJlcXVpcmUoJy4vcmFuZG9tYnl0ZXMnKSlcbmZvcndhcmQocmVxdWlyZSgnLi9jcnlwdG9fc3RyZWFtJykpXG5cbnNvZGl1bS5jcnlwdG9fc2NhbGFybXVsdF9CWVRFUyA9IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTXG5zb2RpdW0uY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMgPSBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFU1xuc29kaXVtLmNyeXB0b19zY2FsYXJtdWx0X2Jhc2UgPSBjcnlwdG9fc2NhbGFybXVsdF9iYXNlXG5zb2RpdW0uY3J5cHRvX3NjYWxhcm11bHQgPSBjcnlwdG9fc2NhbGFybXVsdFxuXG5zb2RpdW0uY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMsXG5zb2RpdW0uY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTID0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuc29kaXVtLmNyeXB0b19zZWNyZXRib3hfTUFDQllURVMgPSAxNlxuc29kaXVtLmNyeXB0b19zZWNyZXRib3hfZWFzeSA9IGNyeXB0b19zZWNyZXRib3hfZWFzeVxuc29kaXVtLmNyeXB0b19zZWNyZXRib3hfb3Blbl9lYXN5ID0gY3J5cHRvX3NlY3JldGJveF9vcGVuX2Vhc3lcbnNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X2RldGFjaGVkID0gY3J5cHRvX3NlY3JldGJveF9kZXRhY2hlZFxuc29kaXVtLmNyeXB0b19zZWNyZXRib3hfb3Blbl9kZXRhY2hlZCA9IGNyeXB0b19zZWNyZXRib3hfb3Blbl9kZXRhY2hlZFxuXG5mdW5jdGlvbiBjbGVhbnVwKGFycikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyW2ldID0gMDtcbn1cblxuZnVuY3Rpb24gY2hlY2sgKGJ1ZiwgbGVuKSB7XG4gIGlmICghYnVmIHx8IChsZW4gJiYgYnVmLmxlbmd0aCA8IGxlbikpIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIGJ1ZmZlcicgKyAobGVuID8gJyBvZiBsZW5ndGggJyArIGxlbiA6ICcnKSlcbn1cblxuZnVuY3Rpb24gZm9yd2FyZCAoc3VibW9kdWxlKSB7XG4gIE9iamVjdC5rZXlzKHN1Ym1vZHVsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIG1vZHVsZS5leHBvcnRzW3Byb3BdID0gc3VibW9kdWxlW3Byb3BdXG4gIH0pXG59XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbmFub2Fzc2VydCcpXG52YXIgcmFuZG9tYnl0ZXMgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgUVVPVEEgPSA2NTUzNiAvLyBsaW1pdCBmb3IgUXVvdGFFeGNlZWRlZEV4Y2VwdGlvblxuICB2YXIgY3J5cHRvID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBjcnlwdG8gPSAoZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG8pIDogbnVsbFxuXG4gIGZ1bmN0aW9uIGJyb3dzZXJCeXRlcyAob3V0LCBuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICs9IFFVT1RBKSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG91dC5zdWJhcnJheShpLCBpICsgTWF0aC5taW4obiAtIGksIFFVT1RBKSkpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm9kZUJ5dGVzIChvdXQsIG4pIHtcbiAgICBvdXQuc2V0KGNyeXB0by5yYW5kb21CeXRlcyhuKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vSW1wbCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgYXZhaWxhYmxlJylcbiAgfVxuXG4gIGlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHJldHVybiBicm93c2VyQnl0ZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOb2RlLmpzLlxuICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG4gICAgaWYgKGNyeXB0byAmJiBjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICAgIHJldHVybiBub2RlQnl0ZXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9JbXBsXG59KSgpXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ3JhbmRvbWJ5dGVzJywge1xuICB2YWx1ZTogcmFuZG9tYnl0ZXNcbn0pXG5cbm1vZHVsZS5leHBvcnRzLnJhbmRvbWJ5dGVzX2J1ZiA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgYXNzZXJ0KG91dCwgJ291dCBtdXN0IGJlIGdpdmVuJylcbiAgcmFuZG9tYnl0ZXMob3V0LCBvdXQubGVuZ3RoKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdzb2RpdW0tamF2YXNjcmlwdCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGluZGV4T2ZcblxuZnVuY3Rpb24gaW5kZXhPZiAobGVmdCwgcmlnaHQpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShyaWdodC5sZW5ndGgpXG4gIHZhciBpID0gMFxuICB2YXIgaiA9IDBcblxuICB3aGlsZSAoaSA8IGxlZnQubGVuZ3RoICYmIGogPCByaWdodC5sZW5ndGgpIHtcbiAgICB2YXIgYSA9IGxlZnRbaV1cbiAgICB2YXIgYiA9IHJpZ2h0W2pdXG5cbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmVzdWx0W2orK10gPSBpXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChhIDwgYikge1xuICAgICAgaSsrXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHJlc3VsdFtqKytdID0gLTFcbiAgICBjb250aW51ZVxuICB9XG5cbiAgZm9yICg7IGogPCByaWdodC5sZW5ndGg7IGorKykgcmVzdWx0W2pdID0gLTFcblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJ2YXIgcGFnZXIgPSByZXF1aXJlKCdtZW1vcnktcGFnZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJpdGZpZWxkXG5cbmZ1bmN0aW9uIEJpdGZpZWxkIChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCaXRmaWVsZCkpIHJldHVybiBuZXcgQml0ZmllbGQob3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvcHRzKSkgb3B0cyA9IHtidWZmZXI6IG9wdHN9XG5cbiAgdGhpcy5wYWdlT2Zmc2V0ID0gb3B0cy5wYWdlT2Zmc2V0IHx8IDBcbiAgdGhpcy5wYWdlU2l6ZSA9IG9wdHMucGFnZVNpemUgfHwgMTAyNFxuICB0aGlzLnBhZ2VzID0gb3B0cy5wYWdlcyB8fCBwYWdlcih0aGlzLnBhZ2VTaXplKVxuXG4gIHRoaXMuYnl0ZUxlbmd0aCA9IHRoaXMucGFnZXMubGVuZ3RoICogdGhpcy5wYWdlU2l6ZVxuICB0aGlzLmxlbmd0aCA9IDggKiB0aGlzLmJ5dGVMZW5ndGhcblxuICBpZiAoIXBvd2VyT2ZUd28odGhpcy5wYWdlU2l6ZSkpIHRocm93IG5ldyBFcnJvcignVGhlIHBhZ2Ugc2l6ZSBzaG91bGQgYmUgYSBwb3dlciBvZiB0d28nKVxuXG4gIHRoaXMuX3RyYWNrVXBkYXRlcyA9ICEhb3B0cy50cmFja1VwZGF0ZXNcbiAgdGhpcy5fcGFnZU1hc2sgPSB0aGlzLnBhZ2VTaXplIC0gMVxuXG4gIGlmIChvcHRzLmJ1ZmZlcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5idWZmZXIubGVuZ3RoOyBpICs9IHRoaXMucGFnZVNpemUpIHtcbiAgICAgIHRoaXMucGFnZXMuc2V0KGkgLyB0aGlzLnBhZ2VTaXplLCBvcHRzLmJ1ZmZlci5zbGljZShpLCBpICsgdGhpcy5wYWdlU2l6ZSkpXG4gICAgfVxuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IG9wdHMuYnVmZmVyLmxlbmd0aFxuICAgIHRoaXMubGVuZ3RoID0gOCAqIHRoaXMuYnl0ZUxlbmd0aFxuICB9XG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSkge1xuICB2YXIgbyA9IGkgJiA3XG4gIHZhciBqID0gKGkgLSBvKSAvIDhcblxuICByZXR1cm4gISEodGhpcy5nZXRCeXRlKGopICYgKDEyOCA+PiBvKSlcbn1cblxuQml0ZmllbGQucHJvdG90eXBlLmdldEJ5dGUgPSBmdW5jdGlvbiAoaSkge1xuICB2YXIgbyA9IGkgJiB0aGlzLl9wYWdlTWFza1xuICB2YXIgaiA9IChpIC0gbykgLyB0aGlzLnBhZ2VTaXplXG4gIHZhciBwYWdlID0gdGhpcy5wYWdlcy5nZXQoaiwgdHJ1ZSlcblxuICByZXR1cm4gcGFnZSA/IHBhZ2UuYnVmZmVyW28gKyB0aGlzLnBhZ2VPZmZzZXRdIDogMFxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGksIHYpIHtcbiAgdmFyIG8gPSBpICYgN1xuICB2YXIgaiA9IChpIC0gbykgLyA4XG4gIHZhciBiID0gdGhpcy5nZXRCeXRlKGopXG5cbiAgcmV0dXJuIHRoaXMuc2V0Qnl0ZShqLCB2ID8gYiB8ICgxMjggPj4gbykgOiBiICYgKDI1NSBeICgxMjggPj4gbykpKVxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhbGwgPSBhbGxvYyh0aGlzLnBhZ2VzLmxlbmd0aCAqIHRoaXMucGFnZVNpemUpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLnBhZ2VzLmdldChpLCB0cnVlKVxuICAgIHZhciBhbGxPZmZzZXQgPSBpICogdGhpcy5wYWdlU2l6ZVxuICAgIGlmIChuZXh0KSBuZXh0LmJ1ZmZlci5jb3B5KGFsbCwgYWxsT2Zmc2V0LCB0aGlzLnBhZ2VPZmZzZXQsIHRoaXMucGFnZU9mZnNldCArIHRoaXMucGFnZVNpemUpXG4gIH1cblxuICByZXR1cm4gYWxsXG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS5zZXRCeXRlID0gZnVuY3Rpb24gKGksIGIpIHtcbiAgdmFyIG8gPSBpICYgdGhpcy5fcGFnZU1hc2tcbiAgdmFyIGogPSAoaSAtIG8pIC8gdGhpcy5wYWdlU2l6ZVxuICB2YXIgcGFnZSA9IHRoaXMucGFnZXMuZ2V0KGosIGZhbHNlKVxuXG4gIG8gKz0gdGhpcy5wYWdlT2Zmc2V0XG5cbiAgaWYgKHBhZ2UuYnVmZmVyW29dID09PSBiKSByZXR1cm4gZmFsc2VcbiAgcGFnZS5idWZmZXJbb10gPSBiXG5cbiAgaWYgKGkgPj0gdGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gaSArIDFcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCAqIDhcbiAgfVxuXG4gIGlmICh0aGlzLl90cmFja1VwZGF0ZXMpIHRoaXMucGFnZXMudXBkYXRlZChwYWdlKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGFsbG9jIChuKSB7XG4gIGlmIChCdWZmZXIuYWxsb2MpIHJldHVybiBCdWZmZXIuYWxsb2MobilcbiAgdmFyIGIgPSBuZXcgQnVmZmVyKG4pXG4gIGIuZmlsbCgwKVxuICByZXR1cm4gYlxufVxuXG5mdW5jdGlvbiBwb3dlck9mVHdvICh4KSB7XG4gIHJldHVybiAhKHggJiAoeCAtIDEpKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBuZXh0VGljayA9IG5leHRUaWNrQXJnc1xucHJvY2Vzcy5uZXh0VGljayh1cGdyYWRlLCA0MikgLy8gcGFzcyA0MiBhbmQgc2VlIGlmIHVwZ3JhZGUgaXMgY2FsbGVkIHdpdGggaXRcblxubW9kdWxlLmV4cG9ydHMgPSB0aHVua3lcblxuZnVuY3Rpb24gdGh1bmt5IChmbikge1xuICB2YXIgc3RhdGUgPSBydW5cbiAgcmV0dXJuIHRodW5rXG5cbiAgZnVuY3Rpb24gdGh1bmsgKGNhbGxiYWNrKSB7XG4gICAgc3RhdGUoY2FsbGJhY2sgfHwgbm9vcClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1biAoY2FsbGJhY2spIHtcbiAgICB2YXIgc3RhY2sgPSBbY2FsbGJhY2tdXG4gICAgc3RhdGUgPSB3YWl0XG4gICAgZm4oZG9uZSlcblxuICAgIGZ1bmN0aW9uIHdhaXQgKGNhbGxiYWNrKSB7XG4gICAgICBzdGFjay5wdXNoKGNhbGxiYWNrKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNcbiAgICAgIHN0YXRlID0gaXNFcnJvcihlcnIpID8gcnVuIDogZmluaXNoZWRcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIGZpbmlzaGVkKHN0YWNrLnNoaWZ0KCkpXG5cbiAgICAgIGZ1bmN0aW9uIGZpbmlzaGVkIChjYWxsYmFjaykge1xuICAgICAgICBuZXh0VGljayhhcHBseSwgY2FsbGJhY2ssIGFyZ3MpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IgKGVycikgeyAvLyBpbmxpbmVkIGZyb20gdXRpbCBzbyB0aGlzIHdvcmtzIGluIHRoZSBicm93c2VyXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKSA9PT0gJ1tvYmplY3QgRXJyb3JdJ1xufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIGFwcGx5IChjYWxsYmFjaywgYXJncykge1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmdzKVxufVxuXG5mdW5jdGlvbiB1cGdyYWRlICh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gNDIpIG5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGlja1xufVxuXG5mdW5jdGlvbiBuZXh0VGlja0FyZ3MgKGZuLCBhLCBiKSB7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIGZuKGEsIGIpXG4gIH0pXG59XG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCJ2YXIgYnVmZmVyQWxsb2MgPSByZXF1aXJlKCdidWZmZXItYWxsb2MnKVxuXG52YXIgVUlOVF8zMl9NQVggPSBNYXRoLnBvdygyLCAzMilcblxuZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDhcbn1cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtLCBidWYsIG9mZnNldCkge1xuICBpZiAoIWJ1ZikgYnVmID0gYnVmZmVyQWxsb2MoOClcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICB2YXIgdG9wID0gTWF0aC5mbG9vcihudW0gLyBVSU5UXzMyX01BWClcbiAgdmFyIHJlbSA9IG51bSAtIHRvcCAqIFVJTlRfMzJfTUFYXG5cbiAgYnVmLndyaXRlVUludDMyQkUodG9wLCBvZmZzZXQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKHJlbSwgb2Zmc2V0ICsgNClcbiAgcmV0dXJuIGJ1ZlxufVxuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuXG4gIHZhciB0b3AgPSBidWYucmVhZFVJbnQzMkJFKG9mZnNldClcbiAgdmFyIHJlbSA9IGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgNClcblxuICByZXR1cm4gdG9wICogVUlOVF8zMl9NQVggKyByZW1cbn1cblxuZXhwb3J0cy5lbmNvZGUuYnl0ZXMgPSA4XG5leHBvcnRzLmRlY29kZS5ieXRlcyA9IDhcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVtb3ZlXG5cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpKSB7XG4gIGlmIChpID49IGFyci5sZW5ndGggfHwgaSA8IDApIHJldHVyblxuICB2YXIgbGFzdCA9IGFyci5wb3AoKVxuICBpZiAoaSA8IGFyci5sZW5ndGgpIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldXG4gICAgYXJyW2ldID0gbGFzdFxuICAgIHJldHVybiB0bXBcbiAgfVxuICByZXR1cm4gbGFzdFxufVxuIiwiZXhwb3J0cy5hZGQgPSBhZGRcbmV4cG9ydHMuaGFzID0gaGFzXG5leHBvcnRzLnJlbW92ZSA9IHJlbW92ZVxuZXhwb3J0cy5zd2FwID0gc3dhcFxuXG5mdW5jdGlvbiBhZGQgKGxpc3QsIGl0ZW0pIHtcbiAgaWYgKGhhcyhsaXN0LCBpdGVtKSkgcmV0dXJuIGl0ZW1cbiAgaXRlbS5faW5kZXggPSBsaXN0Lmxlbmd0aFxuICBsaXN0LnB1c2goaXRlbSlcbiAgcmV0dXJuIGl0ZW1cbn1cblxuZnVuY3Rpb24gaGFzIChsaXN0LCBpdGVtKSB7XG4gIHJldHVybiBpdGVtLl9pbmRleCA8IGxpc3QubGVuZ3RoICYmIGxpc3RbaXRlbS5faW5kZXhdID09PSBpdGVtXG59XG5cbmZ1bmN0aW9uIHJlbW92ZSAobGlzdCwgaXRlbSkge1xuICBpZiAoIWhhcyhsaXN0LCBpdGVtKSkgcmV0dXJuIG51bGxcblxuICB2YXIgbGFzdCA9IGxpc3QucG9wKClcbiAgaWYgKGxhc3QgIT09IGl0ZW0pIHtcbiAgICBsaXN0W2l0ZW0uX2luZGV4XSA9IGxhc3RcbiAgICBsYXN0Ll9pbmRleCA9IGl0ZW0uX2luZGV4XG4gIH1cblxuICByZXR1cm4gaXRlbVxufVxuXG5mdW5jdGlvbiBzd2FwIChsaXN0LCBhLCBiKSB7XG4gIGlmICghaGFzKGxpc3QsIGEpIHx8ICFoYXMobGlzdCwgYikpIHJldHVyblxuICB2YXIgdG1wID0gYS5faW5kZXhcbiAgYS5faW5kZXggPSBiLl9pbmRleFxuICBsaXN0W2EuX2luZGV4XSA9IGFcbiAgYi5faW5kZXggPSB0bXBcbiAgbGlzdFtiLl9pbmRleF0gPSBiXG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCkge1xuICAgICAgcmVhZC5ieXRlcyA9IDBcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb3VsZCBub3QgZGVjb2RlIHZhcmludCcpXG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXVxuICAgIHJlcyArPSBzaGlmdCA8IDI4XG4gICAgICA/IChiICYgUkVTVCkgPDwgc2hpZnRcbiAgICAgIDogKGIgJiBSRVNUKSAqIE1hdGgucG93KDIsIHNoaWZ0KVxuICAgIHNoaWZ0ICs9IDdcbiAgfSB3aGlsZSAoYiA+PSBNU0IpXG5cbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXRcblxuICByZXR1cm4gcmVzXG59XG4iLCJ2YXIgeHNhbHNhMjAgPSByZXF1aXJlKCcuL3hzYWxzYTIwJykoKVxuXG52YXIgU0lHTUEgPSBuZXcgVWludDhBcnJheShbMTAxLCAxMjAsIDExMiwgOTcsIDExMCwgMTAwLCAzMiwgNTEsIDUwLCA0NSwgOTgsIDEyMSwgMTE2LCAxMDEsIDMyLCAxMDddKVxudmFyIGhlYWQgPSAxNDRcbnZhciB0b3AgPSBoZWFkXG52YXIgZnJlZSA9IFtdXG5cbm1vZHVsZS5leHBvcnRzID0gWFNhbHNhMjBcblxuWFNhbHNhMjAuTk9OQ0VCWVRFUyA9IDI0XG5YU2Fsc2EyMC5LRVlCWVRFUyA9IDMyXG5cbmZ1bmN0aW9uIFhTYWxzYTIwIChub25jZSwga2V5KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBYU2Fsc2EyMCkpIHJldHVybiBuZXcgWFNhbHNhMjAobm9uY2UsIGtleSlcbiAgaWYgKCFub25jZSB8fCBub25jZS5sZW5ndGggPCAyNCkgdGhyb3cgbmV3IEVycm9yKCdub25jZSBtdXN0IGJlIGF0IGxlYXN0IDI0IGJ5dGVzJylcbiAgaWYgKCFrZXkgfHwga2V5Lmxlbmd0aCA8IDMyKSB0aHJvdyBuZXcgRXJyb3IoJ2tleSBtdXN0IGJlIGF0IGxlYXN0IDMyIGJ5dGVzJylcbiAgdGhpcy5feG9yID0geHNhbHNhMjAgJiYgeHNhbHNhMjAuZXhwb3J0cyA/IG5ldyBXQVNNKG5vbmNlLCBrZXkpIDogbmV3IEZhbGxiYWNrKG5vbmNlLCBrZXkpXG59XG5cblhTYWxzYTIwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dCkge1xuICBpZiAoIWlucHV0KSB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG11c3QgYmUgVWludDhBcnJheSBvciBCdWZmZXInKVxuICBpZiAoIW91dHB1dCkgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKVxuICBpZiAoaW5wdXQubGVuZ3RoKSB0aGlzLl94b3IudXBkYXRlKGlucHV0LCBvdXRwdXQpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuWFNhbHNhMjAucHJvdG90eXBlLmZpbmFsID1cblhTYWxzYTIwLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5feG9yLmZpbmFsaXplKClcbiAgdGhpcy5feG9yID0gbnVsbFxufVxuXG5mdW5jdGlvbiBXQVNNIChub25jZSwga2V5KSB7XG4gIGlmICghZnJlZS5sZW5ndGgpIHtcbiAgICBmcmVlLnB1c2goaGVhZClcbiAgICBoZWFkICs9IDY0XG4gIH1cblxuICB0aGlzLl9wb2ludGVyID0gZnJlZS5wb3AoKVxuICB0aGlzLl9ub25jZSA9IHRoaXMuX3BvaW50ZXIgKyA4XG4gIHRoaXMuX2tleSA9IHRoaXMuX25vbmNlICsgMjRcbiAgdGhpcy5fb3ZlcmZsb3cgPSAwXG5cbiAgeHNhbHNhMjAubWVtb3J5LmZpbGwoMCwgdGhpcy5fcG9pbnRlciwgdGhpcy5fcG9pbnRlciArIDgpXG4gIHhzYWxzYTIwLm1lbW9yeS5zZXQobm9uY2UsIHRoaXMuX25vbmNlKVxuICB4c2Fsc2EyMC5tZW1vcnkuc2V0KGtleSwgdGhpcy5fa2V5KVxufVxuXG5XQVNNLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dCkge1xuICB2YXIgbGVuID0gdGhpcy5fb3ZlcmZsb3cgKyBpbnB1dC5sZW5ndGhcbiAgdmFyIHN0YXJ0ID0gaGVhZCArIHRoaXMuX292ZXJmbG93XG5cbiAgdG9wID0gaGVhZCArIGxlblxuICBpZiAodG9wID49IHhzYWxzYTIwLm1lbW9yeS5sZW5ndGgpIHhzYWxzYTIwLnJlYWxsb2ModG9wKVxuXG4gIHhzYWxzYTIwLm1lbW9yeS5zZXQoaW5wdXQsIHN0YXJ0KVxuICB4c2Fsc2EyMC5leHBvcnRzLnhzYWxzYTIwX3hvcih0aGlzLl9wb2ludGVyLCBoZWFkLCBoZWFkLCBsZW4sIHRoaXMuX25vbmNlLCB0aGlzLl9rZXkpXG4gIG91dHB1dC5zZXQoeHNhbHNhMjAubWVtb3J5LnN1YmFycmF5KHN0YXJ0LCBoZWFkICsgbGVuKSlcblxuICB0aGlzLl9vdmVyZmxvdyA9IGxlbiAmIDYzXG59XG5cbldBU00ucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICB4c2Fsc2EyMC5tZW1vcnkuZmlsbCgwLCB0aGlzLl9wb2ludGVyLCB0aGlzLl9rZXkgKyAzMilcbiAgaWYgKHRvcCA+IGhlYWQpIHtcbiAgICB4c2Fsc2EyMC5tZW1vcnkuZmlsbCgwLCBoZWFkLCB0b3ApXG4gICAgdG9wID0gMFxuICB9XG4gIGZyZWUucHVzaCh0aGlzLl9wb2ludGVyKVxufVxuXG5mdW5jdGlvbiBGYWxsYmFjayAobm9uY2UsIGtleSkge1xuICB0aGlzLl9zID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gIHRoaXMuX3ogPSBuZXcgVWludDhBcnJheSgxNilcbiAgdGhpcy5fb3ZlcmZsb3cgPSAwXG4gIGNvcmVfaHNhbHNhMjAodGhpcy5fcywgbm9uY2UsIGtleSwgU0lHTUEpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB0aGlzLl96W2ldID0gbm9uY2VbaSArIDE2XVxufVxuXG5GYWxsYmFjay5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQpIHtcbiAgdmFyIHggPSBuZXcgVWludDhBcnJheSg2NClcbiAgdmFyIHUgPSAwXG4gIHZhciBpID0gdGhpcy5fb3ZlcmZsb3dcbiAgdmFyIGIgPSBpbnB1dC5sZW5ndGggKyB0aGlzLl9vdmVyZmxvd1xuICB2YXIgeiA9IHRoaXMuX3pcbiAgdmFyIG1wb3MgPSAtdGhpcy5fb3ZlcmZsb3dcbiAgdmFyIGNwb3MgPSAtdGhpcy5fb3ZlcmZsb3dcblxuICB3aGlsZSAoYiA+PSA2NCkge1xuICAgIGNvcmVfc2Fsc2EyMCh4LCB6LCB0aGlzLl9zLCBTSUdNQSlcbiAgICBmb3IgKDsgaSA8IDY0OyBpKyspIG91dHB1dFtjcG9zICsgaV0gPSBpbnB1dFttcG9zICsgaV0gXiB4W2ldXG4gICAgdSA9IDFcbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrKykge1xuICAgICAgdSArPSAoeltpXSAmIDB4ZmYpIHwgMFxuICAgICAgeltpXSA9IHUgJiAweGZmXG4gICAgICB1ID4+Pj0gOFxuICAgIH1cbiAgICBiIC09IDY0XG4gICAgY3BvcyArPSA2NFxuICAgIG1wb3MgKz0gNjRcbiAgICBpID0gMFxuICB9XG4gIGlmIChiID4gMCkge1xuICAgIGNvcmVfc2Fsc2EyMCh4LCB6LCB0aGlzLl9zLCBTSUdNQSlcbiAgICBmb3IgKDsgaSA8IGI7IGkrKykgb3V0cHV0W2Nwb3MgKyBpXSA9IGlucHV0W21wb3MgKyBpXSBeIHhbaV1cbiAgfVxuXG4gIHRoaXMuX292ZXJmbG93ID0gYiAmIDYzXG59XG5cbkZhbGxiYWNrLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fcy5maWxsKDApXG4gIHRoaXMuX3ouZmlsbCgwKVxufVxuXG4vLyBiZWxvdyBtZXRob2RzIGFyZSBwb3J0ZWQgZnJvbSB0d2VldCBuYWNsXG5cbmZ1bmN0aW9uIGNvcmVfc2Fsc2EyMChvLCBwLCBrLCBjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKSA8PCA4IHwgKGNbIDJdICYgMHhmZikgPDwgMTYgfCAoY1sgM10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpIDw8IDggfCAoa1sgMl0gJiAweGZmKSA8PCAxNiB8IChrWyAzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZikgPDwgOCB8IChrWyA2XSAmIDB4ZmYpIDw8IDE2IHwgKGtbIDddICYgMHhmZikgPDwgMjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKSA8PCA4IHwgKGtbMTBdICYgMHhmZikgPDwgMTYgfCAoa1sxMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpIDw8IDggfCAoa1sxNF0gJiAweGZmKSA8PCAxNiB8IChrWzE1XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZikgPDwgOCB8IChjWyA2XSAmIDB4ZmYpIDw8IDE2IHwgKGNbIDddICYgMHhmZikgPDwgMjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKSA8PCA4IHwgKHBbIDJdICYgMHhmZikgPDwgMTYgfCAocFsgM10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpIDw8IDggfCAocFsgNl0gJiAweGZmKSA8PCAxNiB8IChwWyA3XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZikgPDwgOCB8IChwWzEwXSAmIDB4ZmYpIDw8IDE2IHwgKHBbMTFdICYgMHhmZikgPDwgMjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKSA8PCA4IHwgKHBbMTRdICYgMHhmZikgPDwgMTYgfCAocFsxNV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpIDw8IDggfCAoY1sxMF0gJiAweGZmKSA8PCAxNiB8IChjWzExXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZikgPDwgOCB8IChrWzE4XSAmIDB4ZmYpIDw8IDE2IHwgKGtbMTldICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKSA8PCA4IHwgKGtbMjJdICYgMHhmZikgPDwgMTYgfCAoa1syM10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpIDw8IDggfCAoa1syNl0gJiAweGZmKSA8PCAxNiB8IChrWzI3XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZikgPDwgOCB8IChrWzMwXSAmIDB4ZmYpIDw8IDE2IHwgKGtbMzFdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKSA8PCA4IHwgKGNbMTRdICYgMHhmZikgPDwgMTYgfCAoY1sxNV0gJiAweGZmKSA8PCAyNFxuXG4gIHZhciB4MCA9IGowLCB4MSA9IGoxLCB4MiA9IGoyLCB4MyA9IGozLCB4NCA9IGo0LCB4NSA9IGo1LCB4NiA9IGo2LCB4NyA9IGo3LFxuICAgICAgeDggPSBqOCwgeDkgPSBqOSwgeDEwID0gajEwLCB4MTEgPSBqMTEsIHgxMiA9IGoxMiwgeDEzID0gajEzLCB4MTQgPSBqMTQsXG4gICAgICB4MTUgPSBqMTUsIHVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwXG4gICAgeDQgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDQgKyB4MCB8IDBcbiAgICB4OCBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4OCArIHg0IHwgMFxuICAgIHgxMiBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDEyICsgeDggfCAwXG4gICAgeDAgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDUgKyB4MSB8IDBcbiAgICB4OSBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4OSArIHg1IHwgMFxuICAgIHgxMyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4MTMgKyB4OSB8IDBcbiAgICB4MSBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDEgKyB4MTMgfCAwXG4gICAgeDUgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDEwICsgeDYgfCAwXG4gICAgeDE0IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgxNCArIHgxMCB8IDBcbiAgICB4MiBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4MiArIHgxNCB8IDBcbiAgICB4NiBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDYgKyB4MiB8IDBcbiAgICB4MTAgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMFxuICAgIHgzIF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgzICsgeDE1IHwgMFxuICAgIHg3IF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHg3ICsgeDMgfCAwXG4gICAgeDExIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MTEgKyB4NyB8IDBcbiAgICB4MTUgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDAgKyB4MyB8IDBcbiAgICB4MSBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MSArIHgwIHwgMFxuICAgIHgyIF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHgyICsgeDEgfCAwXG4gICAgeDMgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgzICsgeDIgfCAwXG4gICAgeDAgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDUgKyB4NCB8IDBcbiAgICB4NiBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4NiArIHg1IHwgMFxuICAgIHg3IF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHg3ICsgeDYgfCAwXG4gICAgeDQgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHg0ICsgeDcgfCAwXG4gICAgeDUgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDEwICsgeDkgfCAwXG4gICAgeDExIF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgxMSArIHgxMCB8IDBcbiAgICB4OCBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4OCArIHgxMSB8IDBcbiAgICB4OSBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDkgKyB4OCB8IDBcbiAgICB4MTAgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMFxuICAgIHgxMiBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MTIgKyB4MTUgfCAwXG4gICAgeDEzIF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHgxMyArIHgxMiB8IDBcbiAgICB4MTQgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxNCArIHgxMyB8IDBcbiAgICB4MTUgXj0gdSA8PCAxOCB8IHUgPj4+IDE0XG4gIH1cbiAgIHgwID0gIHgwICsgIGowIHwgMFxuICAgeDEgPSAgeDEgKyAgajEgfCAwXG4gICB4MiA9ICB4MiArICBqMiB8IDBcbiAgIHgzID0gIHgzICsgIGozIHwgMFxuICAgeDQgPSAgeDQgKyAgajQgfCAwXG4gICB4NSA9ICB4NSArICBqNSB8IDBcbiAgIHg2ID0gIHg2ICsgIGo2IHwgMFxuICAgeDcgPSAgeDcgKyAgajcgfCAwXG4gICB4OCA9ICB4OCArICBqOCB8IDBcbiAgIHg5ID0gIHg5ICsgIGo5IHwgMFxuICB4MTAgPSB4MTAgKyBqMTAgfCAwXG4gIHgxMSA9IHgxMSArIGoxMSB8IDBcbiAgeDEyID0geDEyICsgajEyIHwgMFxuICB4MTMgPSB4MTMgKyBqMTMgfCAwXG4gIHgxNCA9IHgxNCArIGoxNCB8IDBcbiAgeDE1ID0geDE1ICsgajE1IHwgMFxuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZlxuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmZcbiAgb1sgMl0gPSB4MCA+Pj4gMTYgJiAweGZmXG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZlxuXG4gIG9bIDRdID0geDEgPj4+ICAwICYgMHhmZlxuICBvWyA1XSA9IHgxID4+PiAgOCAmIDB4ZmZcbiAgb1sgNl0gPSB4MSA+Pj4gMTYgJiAweGZmXG4gIG9bIDddID0geDEgPj4+IDI0ICYgMHhmZlxuXG4gIG9bIDhdID0geDIgPj4+ICAwICYgMHhmZlxuICBvWyA5XSA9IHgyID4+PiAgOCAmIDB4ZmZcbiAgb1sxMF0gPSB4MiA+Pj4gMTYgJiAweGZmXG4gIG9bMTFdID0geDIgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMTJdID0geDMgPj4+ICAwICYgMHhmZlxuICBvWzEzXSA9IHgzID4+PiAgOCAmIDB4ZmZcbiAgb1sxNF0gPSB4MyA+Pj4gMTYgJiAweGZmXG4gIG9bMTVdID0geDMgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMTZdID0geDQgPj4+ICAwICYgMHhmZlxuICBvWzE3XSA9IHg0ID4+PiAgOCAmIDB4ZmZcbiAgb1sxOF0gPSB4NCA+Pj4gMTYgJiAweGZmXG4gIG9bMTldID0geDQgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMjBdID0geDUgPj4+ICAwICYgMHhmZlxuICBvWzIxXSA9IHg1ID4+PiAgOCAmIDB4ZmZcbiAgb1syMl0gPSB4NSA+Pj4gMTYgJiAweGZmXG4gIG9bMjNdID0geDUgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMjRdID0geDYgPj4+ICAwICYgMHhmZlxuICBvWzI1XSA9IHg2ID4+PiAgOCAmIDB4ZmZcbiAgb1syNl0gPSB4NiA+Pj4gMTYgJiAweGZmXG4gIG9bMjddID0geDYgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMjhdID0geDcgPj4+ICAwICYgMHhmZlxuICBvWzI5XSA9IHg3ID4+PiAgOCAmIDB4ZmZcbiAgb1szMF0gPSB4NyA+Pj4gMTYgJiAweGZmXG4gIG9bMzFdID0geDcgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMzJdID0geDggPj4+ICAwICYgMHhmZlxuICBvWzMzXSA9IHg4ID4+PiAgOCAmIDB4ZmZcbiAgb1szNF0gPSB4OCA+Pj4gMTYgJiAweGZmXG4gIG9bMzVdID0geDggPj4+IDI0ICYgMHhmZlxuXG4gIG9bMzZdID0geDkgPj4+ICAwICYgMHhmZlxuICBvWzM3XSA9IHg5ID4+PiAgOCAmIDB4ZmZcbiAgb1szOF0gPSB4OSA+Pj4gMTYgJiAweGZmXG4gIG9bMzldID0geDkgPj4+IDI0ICYgMHhmZlxuXG4gIG9bNDBdID0geDEwID4+PiAgMCAmIDB4ZmZcbiAgb1s0MV0gPSB4MTAgPj4+ICA4ICYgMHhmZlxuICBvWzQyXSA9IHgxMCA+Pj4gMTYgJiAweGZmXG4gIG9bNDNdID0geDEwID4+PiAyNCAmIDB4ZmZcblxuICBvWzQ0XSA9IHgxMSA+Pj4gIDAgJiAweGZmXG4gIG9bNDVdID0geDExID4+PiAgOCAmIDB4ZmZcbiAgb1s0Nl0gPSB4MTEgPj4+IDE2ICYgMHhmZlxuICBvWzQ3XSA9IHgxMSA+Pj4gMjQgJiAweGZmXG5cbiAgb1s0OF0gPSB4MTIgPj4+ICAwICYgMHhmZlxuICBvWzQ5XSA9IHgxMiA+Pj4gIDggJiAweGZmXG4gIG9bNTBdID0geDEyID4+PiAxNiAmIDB4ZmZcbiAgb1s1MV0gPSB4MTIgPj4+IDI0ICYgMHhmZlxuXG4gIG9bNTJdID0geDEzID4+PiAgMCAmIDB4ZmZcbiAgb1s1M10gPSB4MTMgPj4+ICA4ICYgMHhmZlxuICBvWzU0XSA9IHgxMyA+Pj4gMTYgJiAweGZmXG4gIG9bNTVdID0geDEzID4+PiAyNCAmIDB4ZmZcblxuICBvWzU2XSA9IHgxNCA+Pj4gIDAgJiAweGZmXG4gIG9bNTddID0geDE0ID4+PiAgOCAmIDB4ZmZcbiAgb1s1OF0gPSB4MTQgPj4+IDE2ICYgMHhmZlxuICBvWzU5XSA9IHgxNCA+Pj4gMjQgJiAweGZmXG5cbiAgb1s2MF0gPSB4MTUgPj4+ICAwICYgMHhmZlxuICBvWzYxXSA9IHgxNSA+Pj4gIDggJiAweGZmXG4gIG9bNjJdID0geDE1ID4+PiAxNiAmIDB4ZmZcbiAgb1s2M10gPSB4MTUgPj4+IDI0ICYgMHhmZlxufVxuXG5mdW5jdGlvbiBjb3JlX2hzYWxzYTIwKG8scCxrLGMpIHtcbiAgdmFyIGowICA9IGNbIDBdICYgMHhmZiB8IChjWyAxXSAmIDB4ZmYpIDw8IDggfCAoY1sgMl0gJiAweGZmKSA8PCAxNiB8IChjWyAzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEgID0ga1sgMF0gJiAweGZmIHwgKGtbIDFdICYgMHhmZikgPDwgOCB8IChrWyAyXSAmIDB4ZmYpIDw8IDE2IHwgKGtbIDNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMiAgPSBrWyA0XSAmIDB4ZmYgfCAoa1sgNV0gJiAweGZmKSA8PCA4IHwgKGtbIDZdICYgMHhmZikgPDwgMTYgfCAoa1sgN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGozICA9IGtbIDhdICYgMHhmZiB8IChrWyA5XSAmIDB4ZmYpIDw8IDggfCAoa1sxMF0gJiAweGZmKSA8PCAxNiB8IChrWzExXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajQgID0ga1sxMl0gJiAweGZmIHwgKGtbMTNdICYgMHhmZikgPDwgOCB8IChrWzE0XSAmIDB4ZmYpIDw8IDE2IHwgKGtbMTVdICYgMHhmZikgPDwgMjQsXG4gICAgICBqNSAgPSBjWyA0XSAmIDB4ZmYgfCAoY1sgNV0gJiAweGZmKSA8PCA4IHwgKGNbIDZdICYgMHhmZikgPDwgMTYgfCAoY1sgN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo2ICA9IHBbIDBdICYgMHhmZiB8IChwWyAxXSAmIDB4ZmYpIDw8IDggfCAocFsgMl0gJiAweGZmKSA8PCAxNiB8IChwWyAzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajcgID0gcFsgNF0gJiAweGZmIHwgKHBbIDVdICYgMHhmZikgPDwgOCB8IChwWyA2XSAmIDB4ZmYpIDw8IDE2IHwgKHBbIDddICYgMHhmZikgPDwgMjQsXG4gICAgICBqOCAgPSBwWyA4XSAmIDB4ZmYgfCAocFsgOV0gJiAweGZmKSA8PCA4IHwgKHBbMTBdICYgMHhmZikgPDwgMTYgfCAocFsxMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo5ICA9IHBbMTJdICYgMHhmZiB8IChwWzEzXSAmIDB4ZmYpIDw8IDggfCAocFsxNF0gJiAweGZmKSA8PCAxNiB8IChwWzE1XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEwID0gY1sgOF0gJiAweGZmIHwgKGNbIDldICYgMHhmZikgPDwgOCB8IChjWzEwXSAmIDB4ZmYpIDw8IDE2IHwgKGNbMTFdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTEgPSBrWzE2XSAmIDB4ZmYgfCAoa1sxN10gJiAweGZmKSA8PCA4IHwgKGtbMThdICYgMHhmZikgPDwgMTYgfCAoa1sxOV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxMiA9IGtbMjBdICYgMHhmZiB8IChrWzIxXSAmIDB4ZmYpIDw8IDggfCAoa1syMl0gJiAweGZmKSA8PCAxNiB8IChrWzIzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEzID0ga1syNF0gJiAweGZmIHwgKGtbMjVdICYgMHhmZikgPDwgOCB8IChrWzI2XSAmIDB4ZmYpIDw8IDE2IHwgKGtbMjddICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTQgPSBrWzI4XSAmIDB4ZmYgfCAoa1syOV0gJiAweGZmKSA8PCA4IHwgKGtbMzBdICYgMHhmZikgPDwgMTYgfCAoa1szMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxNSA9IGNbMTJdICYgMHhmZiB8IChjWzEzXSAmIDB4ZmYpIDw8IDggfCAoY1sxNF0gJiAweGZmKSA8PCAxNiB8IChjWzE1XSAmIDB4ZmYpIDw8IDI0XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDBcbiAgICB4NCBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4NCArIHgwIHwgMFxuICAgIHg4IF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHg4ICsgeDQgfCAwXG4gICAgeDEyIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MTIgKyB4OCB8IDBcbiAgICB4MCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4NSArIHgxIHwgMFxuICAgIHg5IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHg5ICsgeDUgfCAwXG4gICAgeDEzIF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHgxMyArIHg5IHwgMFxuICAgIHgxIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MSArIHgxMyB8IDBcbiAgICB4NSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTAgKyB4NiB8IDBcbiAgICB4MTQgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDE0ICsgeDEwIHwgMFxuICAgIHgyIF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHgyICsgeDE0IHwgMFxuICAgIHg2IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4NiArIHgyIHwgMFxuICAgIHgxMCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwXG4gICAgeDMgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDMgKyB4MTUgfCAwXG4gICAgeDcgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDcgKyB4MyB8IDBcbiAgICB4MTEgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxMSArIHg3IHwgMFxuICAgIHgxNSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MCArIHgzIHwgMFxuICAgIHgxIF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgxICsgeDAgfCAwXG4gICAgeDIgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDIgKyB4MSB8IDBcbiAgICB4MyBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDMgKyB4MiB8IDBcbiAgICB4MCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4NSArIHg0IHwgMFxuICAgIHg2IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHg2ICsgeDUgfCAwXG4gICAgeDcgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDcgKyB4NiB8IDBcbiAgICB4NCBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDQgKyB4NyB8IDBcbiAgICB4NSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTAgKyB4OSB8IDBcbiAgICB4MTEgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDExICsgeDEwIHwgMFxuICAgIHg4IF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHg4ICsgeDExIHwgMFxuICAgIHg5IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4OSArIHg4IHwgMFxuICAgIHgxMCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTUgKyB4MTQgfCAwXG4gICAgeDEyIF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgxMiArIHgxNSB8IDBcbiAgICB4MTMgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDEzICsgeDEyIHwgMFxuICAgIHgxNCBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDE0ICsgeDEzIHwgMFxuICAgIHgxNSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcbiAgfVxuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZlxuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmZcbiAgb1sgMl0gPSB4MCA+Pj4gMTYgJiAweGZmXG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZlxuXG4gIG9bIDRdID0geDUgPj4+ICAwICYgMHhmZlxuICBvWyA1XSA9IHg1ID4+PiAgOCAmIDB4ZmZcbiAgb1sgNl0gPSB4NSA+Pj4gMTYgJiAweGZmXG4gIG9bIDddID0geDUgPj4+IDI0ICYgMHhmZlxuXG4gIG9bIDhdID0geDEwID4+PiAgMCAmIDB4ZmZcbiAgb1sgOV0gPSB4MTAgPj4+ICA4ICYgMHhmZlxuICBvWzEwXSA9IHgxMCA+Pj4gMTYgJiAweGZmXG4gIG9bMTFdID0geDEwID4+PiAyNCAmIDB4ZmZcblxuICBvWzEyXSA9IHgxNSA+Pj4gIDAgJiAweGZmXG4gIG9bMTNdID0geDE1ID4+PiAgOCAmIDB4ZmZcbiAgb1sxNF0gPSB4MTUgPj4+IDE2ICYgMHhmZlxuICBvWzE1XSA9IHgxNSA+Pj4gMjQgJiAweGZmXG5cbiAgb1sxNl0gPSB4NiA+Pj4gIDAgJiAweGZmXG4gIG9bMTddID0geDYgPj4+ICA4ICYgMHhmZlxuICBvWzE4XSA9IHg2ID4+PiAxNiAmIDB4ZmZcbiAgb1sxOV0gPSB4NiA+Pj4gMjQgJiAweGZmXG5cbiAgb1syMF0gPSB4NyA+Pj4gIDAgJiAweGZmXG4gIG9bMjFdID0geDcgPj4+ICA4ICYgMHhmZlxuICBvWzIyXSA9IHg3ID4+PiAxNiAmIDB4ZmZcbiAgb1syM10gPSB4NyA+Pj4gMjQgJiAweGZmXG5cbiAgb1syNF0gPSB4OCA+Pj4gIDAgJiAweGZmXG4gIG9bMjVdID0geDggPj4+ICA4ICYgMHhmZlxuICBvWzI2XSA9IHg4ID4+PiAxNiAmIDB4ZmZcbiAgb1syN10gPSB4OCA+Pj4gMjQgJiAweGZmXG5cbiAgb1syOF0gPSB4OSA+Pj4gIDAgJiAweGZmXG4gIG9bMjldID0geDkgPj4+ICA4ICYgMHhmZlxuICBvWzMwXSA9IHg5ID4+PiAxNiAmIDB4ZmZcbiAgb1szMV0gPSB4OSA+Pj4gMjQgJiAweGZmXG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gbG9hZFdlYkFzc2VtYmx5XG5cbmxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICd1bmRlZmluZWQnXG5cbmZ1bmN0aW9uIGxvYWRXZWJBc3NlbWJseSAob3B0cykge1xuICBpZiAoIWxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQpIHJldHVybiBudWxsXG5cbiAgdmFyIGltcCA9IG9wdHMgJiYgb3B0cy5pbXBvcnRzXG4gIHZhciB3YXNtID0gdG9VaW50OEFycmF5KCdBR0Z6YlFFQUFBQUJHZ05nQm45L2YzOS9md0JnQm45L2YzOStmd0YrWUFOL2YzOEFBd2NHQUFFQkFnSUNCUVVCQVFyb0J3Y29Bd1p0WlcxdmNua0NBQXg0YzJGc2MyRXlNRjk0YjNJQUFBeGpiM0psWDNOaGJITmhNakFBQkFycUVRWVlBQ0FBSUFFZ0FpQURJQVFnQUNrREFDQUZFQUUzQXdBTFBRQkI4QUFnQXlBRkVBTWdBQ0FCSUFJZ0EwRVFhaUFFUWZBQUVBSkI4QUJDQURjREFFSDRBRUlBTndNQVFZQUJRZ0EzQXdCQmlBRkNBRGNEQUF1SEJRRUJmeUFDUVFCR0JFQkNBQThMUWRBQUlBVXBBd0EzQXdCQjJBQWdCVUVJYWlrREFEY0RBRUhnQUNBRlFSQnFLUU1BTndNQVFlZ0FJQVZCR0dvcEF3QTNBd0JCQUNBREtRTUFOd01BUVFnZ0JEY0RBQUpBQTBBZ0FrSEFBRWtOQVVFUVFRQkIwQUFRQlNBQUlBRXBBd0JCRUNrREFJVTNBd0FnQUVFSWFpQUJRUWhxS1FNQVFSZ3BBd0NGTndNQUlBQkJFR29nQVVFUWFpa0RBRUVnS1FNQWhUY0RBQ0FBUVJocUlBRkJHR29wQXdCQktDa0RBSVUzQXdBZ0FFRWdhaUFCUVNCcUtRTUFRVEFwQXdDRk53TUFJQUJCS0dvZ0FVRW9haWtEQUVFNEtRTUFoVGNEQUNBQVFUQnFJQUZCTUdvcEF3QkJ3QUFwQXdDRk53TUFJQUJCT0dvZ0FVRTRhaWtEQUVISUFDa0RBSVUzQXdCQkNFRUlLUU1BUWdGOE53TUFJQUJCd0FCcUlRQWdBVUhBQUdvaEFTQUNRY0FBYXlFQ0RBQUxDMEVJS1FNQUlRUWdBa0VBU3dSQVFSQkJBRUhRQUJBRkFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQ1FRaHVEZ2NIQmdVRUF3SUJBQXNnQUVFNGFpQUJRVGhxS1FNQVFjZ0FLUU1BaFRjREFBc2dBRUV3YWlBQlFUQnFLUU1BUWNBQUtRTUFoVGNEQUFzZ0FFRW9haUFCUVNocUtRTUFRVGdwQXdDRk53TUFDeUFBUVNCcUlBRkJJR29wQXdCQk1Da0RBSVUzQXdBTElBQkJHR29nQVVFWWFpa0RBRUVvS1FNQWhUY0RBQXNnQUVFUWFpQUJRUkJxS1FNQVFTQXBBd0NGTndNQUN5QUFRUWhxSUFGQkNHb3BBd0JCR0NrREFJVTNBd0FMSUFBZ0FTa0RBRUVRS1FNQWhUY0RBQXRCRUVJQU53TUFRUmhDQURjREFFRWdRZ0EzQXdCQktFSUFOd01BUVRCQ0FEY0RBRUU0UWdBM0F3QkJ3QUJDQURjREFFSElBRUlBTndNQVFkQUFRZ0EzQXdCQjJBQkNBRGNEQUVIZ0FFSUFOd01BUWVnQVFnQTNBd0FnQkE4TG5RVUJFWDlCNWZEQml3WWhBMEh1eUlHWkF5RUlRYkxhaU1zSElRMUI5TXFCMlFZaEVpQUNLQUlBSVFRZ0FrRUVhaWdDQUNFRklBSkJDR29vQWdBaEJpQUNRUXhxS0FJQUlRY2dBa0VRYWlnQ0FDRU9JQUpCRkdvb0FnQWhEeUFDUVJocUtBSUFJUkFnQWtFY2FpZ0NBQ0VSSUFFb0FnQWhDU0FCUVFScUtBSUFJUW9nQVVFSWFpZ0NBQ0VMSUFGQkRHb29BZ0FoREVFVUlSTUNRQU5BSUJOQkFFWU5BU0FISUFNZ0QycEJCM2R6SVFjZ0N5QUhJQU5xUVFsM2N5RUxJQThnQ3lBSGFrRU5kM01oRHlBRElBOGdDMnBCRW5keklRTWdEQ0FJSUFScVFRZDNjeUVNSUJBZ0RDQUlha0VKZDNNaEVDQUVJQkFnREdwQkRYZHpJUVFnQ0NBRUlCQnFRUkozY3lFSUlCRWdEU0FKYWtFSGQzTWhFU0FGSUJFZ0RXcEJDWGR6SVFVZ0NTQUZJQkZxUVExM2N5RUpJQTBnQ1NBRmFrRVNkM01oRFNBR0lCSWdEbXBCQjNkeklRWWdDaUFHSUJKcVFRbDNjeUVLSUE0Z0NpQUdha0VOZDNNaERpQVNJQTRnQ21wQkVuZHpJUklnQkNBRElBWnFRUWQzY3lFRUlBVWdCQ0FEYWtFSmQzTWhCU0FHSUFVZ0JHcEJEWGR6SVFZZ0F5QUdJQVZxUVJKM2N5RURJQWtnQ0NBSGFrRUhkM01oQ1NBS0lBa2dDR3BCQ1hkeklRb2dCeUFLSUFscVFRMTNjeUVISUFnZ0J5QUtha0VTZDNNaENDQU9JQTBnREdwQkIzZHpJUTRnQ3lBT0lBMXFRUWwzY3lFTElBd2dDeUFPYWtFTmQzTWhEQ0FOSUF3Z0MycEJFbmR6SVEwZ0R5QVNJQkZxUVFkM2N5RVBJQkFnRHlBU2FrRUpkM01oRUNBUklCQWdEMnBCRFhkeklSRWdFaUFSSUJCcVFSSjNjeUVTSUJOQkFtc2hFd3dBQ3dzZ0FDQUROZ0lBSUFCQkJHb2dDRFlDQUNBQVFRaHFJQTAyQWdBZ0FFRU1haUFTTmdJQUlBQkJFR29nQ1RZQ0FDQUFRUlJxSUFvMkFnQWdBRUVZYWlBTE5nSUFJQUJCSEdvZ0REWUNBQXNLQUNBQUlBRWdBaEFGQzkwR0FTRi9RZVh3d1lzR0lRTkI3c2lCbVFNaENFR3kyb2pMQnlFTlFmVEtnZGtHSVJJZ0FpZ0NBQ0VFSUFKQkJHb29BZ0FoQlNBQ1FRaHFLQUlBSVFZZ0FrRU1haWdDQUNFSElBSkJFR29vQWdBaERpQUNRUlJxS0FJQUlROGdBa0VZYWlnQ0FDRVFJQUpCSEdvb0FnQWhFU0FCS0FJQUlRa2dBVUVFYWlnQ0FDRUtJQUZCQ0dvb0FnQWhDeUFCUVF4cUtBSUFJUXdnQXlFVElBUWhGQ0FGSVJVZ0JpRVdJQWNoRnlBSUlSZ2dDU0VaSUFvaEdpQUxJUnNnRENFY0lBMGhIU0FPSVI0Z0R5RWZJQkFoSUNBUklTRWdFaUVpUVJRaEl3SkFBMEFnSTBFQVJnMEJJQWNnQXlBUGFrRUhkM01oQnlBTElBY2dBMnBCQ1hkeklRc2dEeUFMSUFkcVFRMTNjeUVQSUFNZ0R5QUxha0VTZDNNaEF5QU1JQWdnQkdwQkIzZHpJUXdnRUNBTUlBaHFRUWwzY3lFUUlBUWdFQ0FNYWtFTmQzTWhCQ0FJSUFRZ0VHcEJFbmR6SVFnZ0VTQU5JQWxxUVFkM2N5RVJJQVVnRVNBTmFrRUpkM01oQlNBSklBVWdFV3BCRFhkeklRa2dEU0FKSUFWcVFSSjNjeUVOSUFZZ0VpQU9ha0VIZDNNaEJpQUtJQVlnRW1wQkNYZHpJUW9nRGlBS0lBWnFRUTEzY3lFT0lCSWdEaUFLYWtFU2QzTWhFaUFFSUFNZ0JtcEJCM2R6SVFRZ0JTQUVJQU5xUVFsM2N5RUZJQVlnQlNBRWFrRU5kM01oQmlBRElBWWdCV3BCRW5keklRTWdDU0FJSUFkcVFRZDNjeUVKSUFvZ0NTQUlha0VKZDNNaENpQUhJQW9nQ1dwQkRYZHpJUWNnQ0NBSElBcHFRUkozY3lFSUlBNGdEU0FNYWtFSGQzTWhEaUFMSUE0Z0RXcEJDWGR6SVFzZ0RDQUxJQTVxUVExM2N5RU1JQTBnRENBTGFrRVNkM01oRFNBUElCSWdFV3BCQjNkeklROGdFQ0FQSUJKcVFRbDNjeUVRSUJFZ0VDQVBha0VOZDNNaEVTQVNJQkVnRUdwQkVuZHpJUklnSTBFQ2F5RWpEQUFMQ3lBQUlBTWdFMm8yQWdBZ0FFRUVhaUFFSUJScU5nSUFJQUJCQ0dvZ0JTQVZhallDQUNBQVFReHFJQVlnRm1vMkFnQWdBRUVRYWlBSElCZHFOZ0lBSUFCQkZHb2dDQ0FZYWpZQ0FDQUFRUmhxSUFrZ0dXbzJBZ0FnQUVFY2FpQUtJQnBxTmdJQUlBQkJJR29nQ3lBYmFqWUNBQ0FBUVNScUlBd2dIR28yQWdBZ0FFRW9haUFOSUIxcU5nSUFJQUJCTEdvZ0RpQWVhallDQUNBQVFUQnFJQThnSDJvMkFnQWdBRUUwYWlBUUlDQnFOZ0lBSUFCQk9Hb2dFU0FoYWpZQ0FDQUFRVHhxSUJJZ0ltbzJBZ0FMJylcbiAgdmFyIHJlYWR5ID0gbnVsbFxuXG4gIHZhciBtb2QgPSB7XG4gICAgYnVmZmVyOiB3YXNtLFxuICAgIG1lbW9yeTogbnVsbCxcbiAgICBleHBvcnRzOiBudWxsLFxuICAgIHJlYWxsb2M6IHJlYWxsb2MsXG4gICAgb25sb2FkOiBvbmxvYWRcbiAgfVxuXG4gIG9ubG9hZChmdW5jdGlvbiAoKSB7fSlcblxuICByZXR1cm4gbW9kXG5cbiAgZnVuY3Rpb24gcmVhbGxvYyAoc2l6ZSkge1xuICAgIG1vZC5leHBvcnRzLm1lbW9yeS5ncm93KE1hdGguY2VpbChNYXRoLmFicyhzaXplIC0gbW9kLm1lbW9yeS5sZW5ndGgpIC8gNjU1MzYpKVxuICAgIG1vZC5tZW1vcnkgPSBuZXcgVWludDhBcnJheShtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25sb2FkIChjYikge1xuICAgIGlmIChtb2QuZXhwb3J0cykgcmV0dXJuIGNiKClcblxuICAgIGlmIChyZWFkeSkge1xuICAgICAgcmVhZHkudGhlbihjYi5iaW5kKG51bGwsIG51bGwpKS5jYXRjaChjYilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLmFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jJylcbiAgICAgIHNldHVwKHtpbnN0YW5jZTogbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUod2FzbSksIGltcCl9KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVhZHkgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3YXNtLCBpbXApLnRoZW4oc2V0dXApXG4gICAgfVxuXG4gICAgb25sb2FkKGNiKVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXAgKHcpIHtcbiAgICBtb2QuZXhwb3J0cyA9IHcuaW5zdGFuY2UuZXhwb3J0c1xuICAgIG1vZC5tZW1vcnkgPSBtb2QuZXhwb3J0cy5tZW1vcnkgJiYgbW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlciAmJiBuZXcgVWludDhBcnJheShtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvVWludDhBcnJheSAocykge1xuICBpZiAodHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicpIHJldHVybiBuZXcgVWludDhBcnJheShhdG9iKHMpLnNwbGl0KCcnKS5tYXAoY2hhckNvZGVBdCkpXG4gIHJldHVybiBuZXcgKHJlcXVpcmUoJ2J1ZicgKyAnZmVyJykuQnVmZmVyKShzLCAnYmFzZTY0Jylcbn1cblxuZnVuY3Rpb24gY2hhckNvZGVBdCAoYykge1xuICByZXR1cm4gYy5jaGFyQ29kZUF0KDApXG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgaHlwZXJjb3JlID0gcmVxdWlyZShcImh5cGVyY29yZVwiKVxudmFyIFJhbmRvbUFjY2Vzc0ZpbGUgPSByZXF1aXJlKFwiLi9yYW5kb20tYWNjZXNzLWZpbGVcIilcblxuY29uc3QgbWFpbiA9IGFzeW5jICgpID0+IHtcbiAgY29uc3Qgdm9sdW1lID0gYXdhaXQgUmFuZG9tQWNjZXNzRmlsZS5tb3VudCgpXG4gIHZhciBmZWVkID0gaHlwZXJjb3JlKHZvbHVtZSwgeyB2YWx1ZUVuY29kaW5nOiBcImpzb25cIiB9KVxuXG4gIGZlZWQuYXBwZW5kKHtcbiAgICBoZWxsbzogXCJ3b3JsZFwiXG4gIH0pXG5cbiAgZmVlZC5hcHBlbmQoe1xuICAgIGhlajogXCJ2ZXJkZW5cIlxuICB9KVxuXG4gIGZlZWQuYXBwZW5kKHtcbiAgICBob2xhOiBcIm11bmRvXCJcbiAgfSlcblxuICBmZWVkLmZsdXNoKGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJBcHBlbmRlZCAzIG1vcmUgYmxvY2tzLCAlZCBpbiB0b3RhbCAoJWQgYnl0ZXMpXFxuXCIsXG4gICAgICBmZWVkLmxlbmd0aCxcbiAgICAgIGZlZWQuYnl0ZUxlbmd0aFxuICAgIClcblxuICAgIGZlZWRcbiAgICAgIC5jcmVhdGVSZWFkU3RyZWFtKClcbiAgICAgIC5vbihcImRhdGFcIiwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKSlcbiAgICAgIC5vbihcImVuZFwiLCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUsIFwiXFxuKGVuZClcIikpXG4gIH0pXG59XG5cbm1haW4oKVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuY29uc3QgUmFuZG9tQWNjZXNzID0gcmVxdWlyZShcInJhbmRvbS1hY2Nlc3Mtc3RvcmFnZVwiKVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoXCJCdWZmZXJcIilcblxuY29uc3QgTUFYX1NJWkUgPSAoMSA8PCAzMCkgKiAyIC0gKDEgPDwgMTIpIC0gMVxuXG5jbGFzcyBSYW5kb21BY2Nlc3NGaWxlIGV4dGVuZHMgUmFuZG9tQWNjZXNzIHtcbiAgY29uc3RydWN0b3Iodm9sdW1lLCBuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLnZvbHVtZSA9IHZvbHVtZVxuICAgIHRoaXMudXJsID0gYCR7dm9sdW1lLnVybH0ke25hbWV9YFxuICAgIHRoaXMuZmlsZSA9IG51bGxcbiAgfVxuICBzdGF0aWMgYXN5bmMgbW91bnQodXJsID0gbnVsbCkge1xuICAgIGNvbnN0IHZvbHVtZSA9IGF3YWl0IGJyb3dzZXIuRmlsZVN5c3RlbS5tb3VudCh7XG4gICAgICB1cmw6IHVybCxcbiAgICAgIHJlYWQ6IHRydWUsXG4gICAgICB3cml0ZTogdHJ1ZVxuICAgIH0pXG5cbiAgICByZXR1cm4gKG5hbWUsIG9wdGlvbnMpID0+IG5ldyBSYW5kb21BY2Nlc3NGaWxlKHZvbHVtZSwgbmFtZSwgb3B0aW9ucylcbiAgfVxuICBzdGF0aWMgYXN5bmMgb3BlbihzZWxmLCBtb2RlKSB7XG4gICAgc2VsZi5maWxlID0gYXdhaXQgYnJvd3Nlci5GaWxlU3lzdGVtLm9wZW4oc2VsZi51cmwsIG1vZGUpXG5cbiAgICByZXR1cm4gc2VsZlxuICB9XG4gIHN0YXRpYyBhc3luYyBkZWxldGUoc2VsZiwgcG9zaXRpb24sIHNpemUpIHtcbiAgICBjb25zdCBzdGF0ID0gYXdhaXQgYnJvd3Nlci5GaWxlLnN0YXQoc2VsZi5maWxlKVxuICAgIGlmIChwb3NpdGlvbiArIHNpemUgPCBzdGF0LnNpemUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRhdGEgPVxuICAgICAgICBwb3NpdGlvbiA+IDBcbiAgICAgICAgICA/IGF3YWl0IGJyb3dzZXIuRmlsZS5yZWFkKGZpbGUsIHsgcG9zaXRpb246IDAsIHNpemU6IHBvc2l0aW9uIH0pXG4gICAgICAgICAgOiBudWxsXG5cbiAgICAgIHNlbGYuZmlsZSA9IGF3YWl0IGJyb3dzZXIuRmlsZVN5c3RlbS5vcGVuKHNlbGYuZmlsZVVSTCwge1xuICAgICAgICB0cnVuY2F0ZTogdHJ1ZSxcbiAgICAgICAgcmVhZDogdHJ1ZSxcbiAgICAgICAgd3JpdGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGF3YWl0IGJyb3dzZXIuRmlsZS53cml0ZShzZWxmLmZpbGUsIGRhdGEsIHsgcG9zaXRpb246IDAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX29wZW4ocmVxdWVzdCkge1xuICAgIGNvbnNvbGUubG9nKFwiX29wZW5cIiwgdGhpcy51cmwsIHJlcXVlc3QpXG4gICAgUmFuZG9tQWNjZXNzRmlsZS5vcGVuKHRoaXMsIHsgcmVhZDogdHJ1ZSwgd3JpdGU6IHRydWUsIGNyZWF0ZTogdHJ1ZSB9KVxuICAgICAgLnRoZW4oc2VsZiA9PiByZXF1ZXN0LmNhbGxiYWNrKG51bGwsIHNlbGYpKVxuICAgICAgLmNhdGNoKGVycm9yID0+IHJlcXVlc3QuY2FsbGJhY2soZXJyb3IpKVxuICB9XG4gIF9vcGVuUmVhZG9ubHkocmVxdWVzdCkge1xuICAgIGNvbnNvbGUubG9nKFwiX29wZW5SZWFkb25seVwiLCB0aGlzLnVybCwgcmVxdWVzdClcbiAgICBSYW5kb21BY2Nlc3NGaWxlLm9wZW4odGhpcywgeyByZWFkOiB0cnVlIH0pXG4gICAgICAudGhlbihzZWxmID0+IHJlcXVlc3QuY2FsbGJhY2sobnVsbCwgc2VsZikpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4gcmVxdWVzdC5jYWxsYmFjayhlcnJvcikpXG4gIH1cbiAgX3dyaXRlKHJlcXVlc3QpIHtcbiAgICBjb25zdCB7IG9mZnNldCwgc2l6ZSwgZGF0YSB9ID0gcmVxdWVzdFxuICAgIGNvbnNvbGUubG9nKFwiX3dyaXRlXCIsIHRoaXMudXJsLCBvZmZzZXQsIHNpemUsIGRhdGEsIHJlcXVlc3QpXG4gICAgYnJvd3Nlci5GaWxlLndyaXRlKHRoaXMuZmlsZSwgZGF0YS5idWZmZXIsIHtcbiAgICAgIHBvc2l0aW9uOiBvZmZzZXQsXG4gICAgICBzaXplXG4gICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHJlcXVlc3QuY2FsbGJhY2sobnVsbCkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4gcmVxdWVzdC5jYWxsYmFjaylcbiAgfVxuICBzdGF0aWMgYXN5bmMgcmVhZChmaWxlLCBidWZmZXIsIHBvc2l0aW9uLCBzaXplKSB7XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IGJyb3dzZXIuRmlsZS5yZWFkKGZpbGUsIHtcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgIHNpemU6IHNpemUgLy9NQVhfU0laRSA8IHNpemUgPyB1bmRlZmluZWQgOiBzaXplXG4gICAgfSlcbiAgICBCdWZmZXIuZnJvbShjb250ZW50KS5jb3B5KGJ1ZmZlcilcbiAgICByZXR1cm4gYnVmZmVyXG5cbiAgICAvLyBpZiAoZGF0YS5ieXRlTGVuZ3RoIDwgb3B0aW9ucy5zaXplKSB7XG4gICAgLy8gICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShvcHRpb25zLnNpemUpXG4gICAgLy8gICByZXN1bHQuc2V0KGRhdGEpXG4gICAgLy8gICByZXR1cm4gcmVzdWx0XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgIHJldHVybiBkYXRhXG4gICAgLy8gfVxuICB9XG4gIF9yZWFkKHJlcXVlc3QpIHtcbiAgICBjb25zdCB7IG9mZnNldCwgc2l6ZSB9ID0gcmVxdWVzdFxuICAgIGNvbnNvbGUubG9nKGBfcmVhZGAsIHRoaXMudXJsLCBvZmZzZXQsIHNpemUsIHJlcXVlc3QpXG4gICAgY29uc3QgYnVmZmVyID0gcmVxdWVzdC5kYXRhIHx8IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuICAgIFJhbmRvbUFjY2Vzc0ZpbGUucmVhZCh0aGlzLmZpbGUsIGJ1ZmZlciwgb2Zmc2V0LCBzaXplKVxuICAgICAgLnRoZW4oZGF0YSA9PiByZXF1ZXN0LmNhbGxiYWNrKG51bGwsIGRhdGEpKVxuICAgICAgLmNhdGNoKGVycm9yID0+IHJlcXVlc3QuY2FsbGJhY2soZXJyb3IpKVxuICB9XG4gIF9kZWwocmVxdWVzdCkge1xuICAgIGNvbnNvbGUubG9nKFwiX2RlbFwiLCB0aGlzLnVybCwgcmVxdWVzdClcbiAgICBSYW5kb21BY2Nlc3NGaWxlLmRlbGV0ZSh0aGlzLCByZXF1ZXN0Lm9mZnNldCwgcmVxdWVzdC5zaXplKVxuICAgICAgLnRoZW4oKCkgPT4gcmVxdWVzdC5jYWxsYmFjayhudWxsKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiByZXF1ZXN0LmNhbGxiYWNrKG51bGwpKVxuICB9XG4gIF9zdGF0KHJlcXVlc3QpIHtcbiAgICBjb25zb2xlLmxvZyhcIl9zdGF0XCIsIHRoaXMudXJsLCByZXF1ZXN0KVxuICAgIGJyb3dzZXIuRmlsZS5zdGF0KHRoaXMuZmlsZSlcbiAgICAgIC50aGVuKHN0YXQgPT4gcmVxdWVzdC5jYWxsYmFjayhudWxsLCBzdGF0KSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiByZXF1ZXN0LmNhbGxiYWNrKGVycm9yKSlcbiAgfVxuICBfY2xvc2UocmVxdWVzdCkge1xuICAgIGNvbnNvbGUubG9nKFwiX2Nsb3NlXCIsIHRoaXMudXJsLCByZXF1ZXN0KVxuICAgIGJyb3dzZXIuRmlsZS5jbG9zZSh0aGlzLmZpbGUpXG4gICAgICAudGhlbigoKSA9PiByZXF1ZXN0LmNhbGxiYWNrKCh0aGlzLmZpbGUgPSBudWxsKSkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4gcmVxdWVzdC5jYWxsYmFjayhlcnJvcikpXG4gIH1cbiAgX2Rlc3Ryb3kocmVxdWVzdCkge1xuICAgIGNvbnNvbGUubG9nKFwiX2Rlc3Ryb3lcIiwgdGhpcy51cmwsIHJlcXVlc3QpXG4gICAgYnJvd3Nlci5GaWxlU3lzdGVtLnJlbW92ZUZpbGUodGhpcy5maWxlVVJMLCB7IGlnbm9yZUFic2VudDogdHJ1ZSB9KVxuICAgICAgLnRoZW4oKCkgPT4gcmVxdWVzdC5jYWxsYmFjayhudWxsKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiByZXF1ZXN0LmNhbGxiYWNrKGVycm9yKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbUFjY2Vzc0ZpbGVcbiJdfQ==
