;(function() {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require
          if (!f && c) return c(i, !0)
          if (u) return u(i, !0)
          var a = new Error("Cannot find module '" + i + "'")
          throw ((a.code = "MODULE_NOT_FOUND"), a)
        }
        var p = (n[i] = { exports: {} })
        e[i][0].call(
          p.exports,
          function(r) {
            var n = e[i][1][r]
            return o(n || r)
          },
          p,
          p.exports,
          r,
          e,
          n,
          t
        )
      }
      return n[i].exports
    }
    for (
      var u = "function" == typeof require && require, i = 0;
      i < t.length;
      i++
    )
      o(t[i])
    return o
  }
  return r
})()(
  {
    1: [
      function(require, module, exports) {
        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
        /* eslint-disable no-proto */

        "use strict"

        var base64 = require("base64-js")
        var ieee754 = require("ieee754")

        exports.Buffer = Buffer
        exports.SlowBuffer = SlowBuffer
        exports.INSPECT_MAX_BYTES = 50

        var K_MAX_LENGTH = 0x7fffffff
        exports.kMaxLength = K_MAX_LENGTH

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Print warning and recommend using `buffer` v4.x which has an Object
         *               implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * We report that the browser does not support typed arrays if the are not subclassable
         * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
         * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
         * for __proto__ and has a buggy typed array implementation.
         */
        Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

        if (
          !Buffer.TYPED_ARRAY_SUPPORT &&
          typeof console !== "undefined" &&
          typeof console.error === "function"
        ) {
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by " +
              "`buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          )
        }

        function typedArraySupport() {
          // Can typed array instances can be augmented?
          try {
            var arr = new Uint8Array(1)
            arr.__proto__ = {
              __proto__: Uint8Array.prototype,
              foo: function() {
                return 42
              }
            }
            return arr.foo() === 42
          } catch (e) {
            return false
          }
        }

        Object.defineProperty(Buffer.prototype, "parent", {
          get: function() {
            if (!(this instanceof Buffer)) {
              return undefined
            }
            return this.buffer
          }
        })

        Object.defineProperty(Buffer.prototype, "offset", {
          get: function() {
            if (!(this instanceof Buffer)) {
              return undefined
            }
            return this.byteOffset
          }
        })

        function createBuffer(length) {
          if (length > K_MAX_LENGTH) {
            throw new RangeError("Invalid typed array length")
          }
          // Return an augmented `Uint8Array` instance
          var buf = new Uint8Array(length)
          buf.__proto__ = Buffer.prototype
          return buf
        }

        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */

        function Buffer(arg, encodingOrOffset, length) {
          // Common case.
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string") {
              throw new Error(
                "If encoding is specified then the first argument must be a string"
              )
            }
            return allocUnsafe(arg)
          }
          return from(arg, encodingOrOffset, length)
        }

        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        if (
          typeof Symbol !== "undefined" &&
          Symbol.species &&
          Buffer[Symbol.species] === Buffer
        ) {
          Object.defineProperty(Buffer, Symbol.species, {
            value: null,
            configurable: true,
            enumerable: false,
            writable: false
          })
        }

        Buffer.poolSize = 8192 // not used by this implementation

        function from(value, encodingOrOffset, length) {
          if (typeof value === "number") {
            throw new TypeError('"value" argument must not be a number')
          }

          if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
            return fromArrayBuffer(value, encodingOrOffset, length)
          }

          if (typeof value === "string") {
            return fromString(value, encodingOrOffset)
          }

          return fromObject(value)
        }

        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/
        Buffer.from = function(value, encodingOrOffset, length) {
          return from(value, encodingOrOffset, length)
        }

        // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
        // https://github.com/feross/buffer/pull/148
        Buffer.prototype.__proto__ = Uint8Array.prototype
        Buffer.__proto__ = Uint8Array

        function assertSize(size) {
          if (typeof size !== "number") {
            throw new TypeError('"size" argument must be of type number')
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative')
          }
        }

        function alloc(size, fill, encoding) {
          assertSize(size)
          if (size <= 0) {
            return createBuffer(size)
          }
          if (fill !== undefined) {
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpretted as a start offset.
            return typeof encoding === "string"
              ? createBuffer(size).fill(fill, encoding)
              : createBuffer(size).fill(fill)
          }
          return createBuffer(size)
        }

        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/
        Buffer.alloc = function(size, fill, encoding) {
          return alloc(size, fill, encoding)
        }

        function allocUnsafe(size) {
          assertSize(size)
          return createBuffer(size < 0 ? 0 : checked(size) | 0)
        }

        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */
        Buffer.allocUnsafe = function(size) {
          return allocUnsafe(size)
        }
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */
        Buffer.allocUnsafeSlow = function(size) {
          return allocUnsafe(size)
        }

        function fromString(string, encoding) {
          if (typeof encoding !== "string" || encoding === "") {
            encoding = "utf8"
          }

          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding)
          }

          var length = byteLength(string, encoding) | 0
          var buf = createBuffer(length)

          var actual = buf.write(string, encoding)

          if (actual !== length) {
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            buf = buf.slice(0, actual)
          }

          return buf
        }

        function fromArrayLike(array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0
          var buf = createBuffer(length)
          for (var i = 0; i < length; i += 1) {
            buf[i] = array[i] & 255
          }
          return buf
        }

        function fromArrayBuffer(array, byteOffset, length) {
          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError('"offset" is outside of buffer bounds')
          }

          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('"length" is outside of buffer bounds')
          }

          var buf
          if (byteOffset === undefined && length === undefined) {
            buf = new Uint8Array(array)
          } else if (length === undefined) {
            buf = new Uint8Array(array, byteOffset)
          } else {
            buf = new Uint8Array(array, byteOffset, length)
          }

          // Return an augmented `Uint8Array` instance
          buf.__proto__ = Buffer.prototype
          return buf
        }

        function fromObject(obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0
            var buf = createBuffer(len)

            if (buf.length === 0) {
              return buf
            }

            obj.copy(buf, 0, 0, len)
            return buf
          }

          if (obj) {
            if (ArrayBuffer.isView(obj) || "length" in obj) {
              if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                return createBuffer(0)
              }
              return fromArrayLike(obj)
            }

            if (obj.type === "Buffer" && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data)
            }
          }

          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object."
          )
        }

        function checked(length) {
          // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= K_MAX_LENGTH) {
            throw new RangeError(
              "Attempt to allocate Buffer larger than maximum " +
                "size: 0x" +
                K_MAX_LENGTH.toString(16) +
                " bytes"
            )
          }
          return length | 0
        }

        function SlowBuffer(length) {
          if (+length != length) {
            // eslint-disable-line eqeqeq
            length = 0
          }
          return Buffer.alloc(+length)
        }

        Buffer.isBuffer = function isBuffer(b) {
          return b != null && b._isBuffer === true
        }

        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError("Arguments must be Buffers")
          }

          if (a === b) return 0

          var x = a.length
          var y = b.length

          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i]
              y = b[i]
              break
            }
          }

          if (x < y) return -1
          if (y < x) return 1
          return 0
        }

        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true
            default:
              return false
          }
        }

        Buffer.concat = function concat(list, length) {
          if (!Array.isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers')
          }

          if (list.length === 0) {
            return Buffer.alloc(0)
          }

          var i
          if (length === undefined) {
            length = 0
            for (i = 0; i < list.length; ++i) {
              length += list[i].length
            }
          }

          var buffer = Buffer.allocUnsafe(length)
          var pos = 0
          for (i = 0; i < list.length; ++i) {
            var buf = list[i]
            if (ArrayBuffer.isView(buf)) {
              buf = Buffer.from(buf)
            }
            if (!Buffer.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers')
            }
            buf.copy(buffer, pos)
            pos += buf.length
          }
          return buffer
        }

        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length
          }
          if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
            return string.byteLength
          }
          if (typeof string !== "string") {
            string = "" + string
          }

          var len = string.length
          if (len === 0) return 0

          // Use a for loop to avoid recursion
          var loweredCase = false
          for (;;) {
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len
              case "utf8":
              case "utf-8":
              case undefined:
                return utf8ToBytes(string).length
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2
              case "hex":
                return len >>> 1
              case "base64":
                return base64ToBytes(string).length
              default:
                if (loweredCase) return utf8ToBytes(string).length // assume utf8
                encoding = ("" + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }
        Buffer.byteLength = byteLength

        function slowToString(encoding, start, end) {
          var loweredCase = false

          // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.

          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
          if (start === undefined || start < 0) {
            start = 0
          }
          // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.
          if (start > this.length) {
            return ""
          }

          if (end === undefined || end > this.length) {
            end = this.length
          }

          if (end <= 0) {
            return ""
          }

          // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
          end >>>= 0
          start >>>= 0

          if (end <= start) {
            return ""
          }

          if (!encoding) encoding = "utf8"

          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end)

              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end)

              case "ascii":
                return asciiSlice(this, start, end)

              case "latin1":
              case "binary":
                return latin1Slice(this, start, end)

              case "base64":
                return base64Slice(this, start, end)

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end)

              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding)
                encoding = (encoding + "").toLowerCase()
                loweredCase = true
            }
          }
        }

        // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
        // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
        // reliably in a browserify context because there could be multiple different
        // copies of the 'buffer' package in use. This method works even for Buffer
        // instances that were created from another copy of the `buffer` package.
        // See: https://github.com/feross/buffer/issues/154
        Buffer.prototype._isBuffer = true

        function swap(b, n, m) {
          var i = b[n]
          b[n] = b[m]
          b[m] = i
        }

        Buffer.prototype.swap16 = function swap16() {
          var len = this.length
          if (len % 2 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 16-bits")
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1)
          }
          return this
        }

        Buffer.prototype.swap32 = function swap32() {
          var len = this.length
          if (len % 4 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 32-bits")
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3)
            swap(this, i + 1, i + 2)
          }
          return this
        }

        Buffer.prototype.swap64 = function swap64() {
          var len = this.length
          if (len % 8 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 64-bits")
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7)
            swap(this, i + 1, i + 6)
            swap(this, i + 2, i + 5)
            swap(this, i + 3, i + 4)
          }
          return this
        }

        Buffer.prototype.toString = function toString() {
          var length = this.length
          if (length === 0) return ""
          if (arguments.length === 0) return utf8Slice(this, 0, length)
          return slowToString.apply(this, arguments)
        }

        Buffer.prototype.toLocaleString = Buffer.prototype.toString

        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b))
            throw new TypeError("Argument must be a Buffer")
          if (this === b) return true
          return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.inspect = function inspect() {
          var str = ""
          var max = exports.INSPECT_MAX_BYTES
          if (this.length > 0) {
            str = this.toString("hex", 0, max)
              .match(/.{2}/g)
              .join(" ")
            if (this.length > max) str += " ... "
          }
          return "<Buffer " + str + ">"
        }

        Buffer.prototype.compare = function compare(
          target,
          start,
          end,
          thisStart,
          thisEnd
        ) {
          if (!Buffer.isBuffer(target)) {
            throw new TypeError("Argument must be a Buffer")
          }

          if (start === undefined) {
            start = 0
          }
          if (end === undefined) {
            end = target ? target.length : 0
          }
          if (thisStart === undefined) {
            thisStart = 0
          }
          if (thisEnd === undefined) {
            thisEnd = this.length
          }

          if (
            start < 0 ||
            end > target.length ||
            thisStart < 0 ||
            thisEnd > this.length
          ) {
            throw new RangeError("out of range index")
          }

          if (thisStart >= thisEnd && start >= end) {
            return 0
          }
          if (thisStart >= thisEnd) {
            return -1
          }
          if (start >= end) {
            return 1
          }

          start >>>= 0
          end >>>= 0
          thisStart >>>= 0
          thisEnd >>>= 0

          if (this === target) return 0

          var x = thisEnd - thisStart
          var y = end - start
          var len = Math.min(x, y)

          var thisCopy = this.slice(thisStart, thisEnd)
          var targetCopy = target.slice(start, end)

          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i]
              y = targetCopy[i]
              break
            }
          }

          if (x < y) return -1
          if (y < x) return 1
          return 0
        }

        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1

          // Normalize byteOffset
          if (typeof byteOffset === "string") {
            encoding = byteOffset
            byteOffset = 0
          } else if (byteOffset > 0x7fffffff) {
            byteOffset = 0x7fffffff
          } else if (byteOffset < -0x80000000) {
            byteOffset = -0x80000000
          }
          byteOffset = +byteOffset // Coerce to Number.
          if (numberIsNaN(byteOffset)) {
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : buffer.length - 1
          }

          // Normalize byteOffset: negative offsets start from the end of the buffer
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset
          if (byteOffset >= buffer.length) {
            if (dir) return -1
            else byteOffset = buffer.length - 1
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0
            else return -1
          }

          // Normalize val
          if (typeof val === "string") {
            val = Buffer.from(val, encoding)
          }

          // Finally, search either indexOf (if dir is true) or lastIndexOf
          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) {
              return -1
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
          } else if (typeof val === "number") {
            val = val & 0xff // Search for a byte value [0-255]
            if (typeof Uint8Array.prototype.indexOf === "function") {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(
                  buffer,
                  val,
                  byteOffset
                )
              } else {
                return Uint8Array.prototype.lastIndexOf.call(
                  buffer,
                  val,
                  byteOffset
                )
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
          }

          throw new TypeError("val must be string, number or Buffer")
        }

        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1
          var arrLength = arr.length
          var valLength = val.length

          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase()
            if (
              encoding === "ucs2" ||
              encoding === "ucs-2" ||
              encoding === "utf16le" ||
              encoding === "utf-16le"
            ) {
              if (arr.length < 2 || val.length < 2) {
                return -1
              }
              indexSize = 2
              arrLength /= 2
              valLength /= 2
              byteOffset /= 2
            }
          }

          function read(buf, i) {
            if (indexSize === 1) {
              return buf[i]
            } else {
              return buf.readUInt16BE(i * indexSize)
            }
          }

          var i
          if (dir) {
            var foundIndex = -1
            for (i = byteOffset; i < arrLength; i++) {
              if (
                read(arr, i) ===
                read(val, foundIndex === -1 ? 0 : i - foundIndex)
              ) {
                if (foundIndex === -1) foundIndex = i
                if (i - foundIndex + 1 === valLength)
                  return foundIndex * indexSize
              } else {
                if (foundIndex !== -1) i -= i - foundIndex
                foundIndex = -1
              }
            }
          } else {
            if (byteOffset + valLength > arrLength)
              byteOffset = arrLength - valLength
            for (i = byteOffset; i >= 0; i--) {
              var found = true
              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false
                  break
                }
              }
              if (found) return i
            }
          }

          return -1
        }

        Buffer.prototype.includes = function includes(
          val,
          byteOffset,
          encoding
        ) {
          return this.indexOf(val, byteOffset, encoding) !== -1
        }

        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
        }

        Buffer.prototype.lastIndexOf = function lastIndexOf(
          val,
          byteOffset,
          encoding
        ) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
        }

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0
          var remaining = buf.length - offset
          if (!length) {
            length = remaining
          } else {
            length = Number(length)
            if (length > remaining) {
              length = remaining
            }
          }

          var strLen = string.length

          if (length > strLen / 2) {
            length = strLen / 2
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16)
            if (numberIsNaN(parsed)) return i
            buf[offset + i] = parsed
          }
          return i
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(
            utf8ToBytes(string, buf.length - offset),
            buf,
            offset,
            length
          )
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length)
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(
            utf16leToBytes(string, buf.length - offset),
            buf,
            offset,
            length
          )
        }

        Buffer.prototype.write = function write(
          string,
          offset,
          length,
          encoding
        ) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = "utf8"
            length = this.length
            offset = 0
            // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === "string") {
            encoding = offset
            length = this.length
            offset = 0
            // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset >>> 0
            if (isFinite(length)) {
              length = length >>> 0
              if (encoding === undefined) encoding = "utf8"
            } else {
              encoding = length
              length = undefined
            }
          } else {
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            )
          }

          var remaining = this.length - offset
          if (length === undefined || length > remaining) length = remaining

          if (
            (string.length > 0 && (length < 0 || offset < 0)) ||
            offset > this.length
          ) {
            throw new RangeError("Attempt to write outside buffer bounds")
          }

          if (!encoding) encoding = "utf8"

          var loweredCase = false
          for (;;) {
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length)

              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length)

              case "ascii":
                return asciiWrite(this, string, offset, length)

              case "latin1":
              case "binary":
                return latin1Write(this, string, offset, length)

              case "base64":
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length)

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length)

              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding)
                encoding = ("" + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }

        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          }
        }

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf)
          } else {
            return base64.fromByteArray(buf.slice(start, end))
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end)
          var res = []

          var i = start
          while (i < end) {
            var firstByte = buf[i]
            var codePoint = null
            var bytesPerSequence =
              firstByte > 0xef
                ? 4
                : firstByte > 0xdf
                  ? 3
                  : firstByte > 0xbf
                    ? 2
                    : 1

            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint

              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte
                  }
                  break
                case 2:
                  secondByte = buf[i + 1]
                  if ((secondByte & 0xc0) === 0x80) {
                    tempCodePoint =
                      ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f)
                    if (tempCodePoint > 0x7f) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 3:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  if (
                    (secondByte & 0xc0) === 0x80 &&
                    (thirdByte & 0xc0) === 0x80
                  ) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0xc) |
                      ((secondByte & 0x3f) << 0x6) |
                      (thirdByte & 0x3f)
                    if (
                      tempCodePoint > 0x7ff &&
                      (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                    ) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 4:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  fourthByte = buf[i + 3]
                  if (
                    (secondByte & 0xc0) === 0x80 &&
                    (thirdByte & 0xc0) === 0x80 &&
                    (fourthByte & 0xc0) === 0x80
                  ) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0x12) |
                      ((secondByte & 0x3f) << 0xc) |
                      ((thirdByte & 0x3f) << 0x6) |
                      (fourthByte & 0x3f)
                    if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint
                    }
                  }
              }
            }

            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xfffd
              bytesPerSequence = 1
            } else if (codePoint > 0xffff) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000
              res.push(((codePoint >>> 10) & 0x3ff) | 0xd800)
              codePoint = 0xdc00 | (codePoint & 0x3ff)
            }

            res.push(codePoint)
            i += bytesPerSequence
          }

          return decodeCodePointsArray(res)
        }

        // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
          }

          // Decode in chunks to avoid "call stack size exceeded".
          var res = ""
          var i = 0
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
            )
          }
          return res
        }

        function asciiSlice(buf, start, end) {
          var ret = ""
          end = Math.min(buf.length, end)

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 0x7f)
          }
          return ret
        }

        function latin1Slice(buf, start, end) {
          var ret = ""
          end = Math.min(buf.length, end)

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i])
          }
          return ret
        }

        function hexSlice(buf, start, end) {
          var len = buf.length

          if (!start || start < 0) start = 0
          if (!end || end < 0 || end > len) end = len

          var out = ""
          for (var i = start; i < end; ++i) {
            out += toHex(buf[i])
          }
          return out
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end)
          var res = ""
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
          }
          return res
        }

        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length
          start = ~~start
          end = end === undefined ? len : ~~end

          if (start < 0) {
            start += len
            if (start < 0) start = 0
          } else if (start > len) {
            start = len
          }

          if (end < 0) {
            end += len
            if (end < 0) end = 0
          } else if (end > len) {
            end = len
          }

          if (end < start) end = start

          var newBuf = this.subarray(start, end)
          // Return an augmented `Uint8Array` instance
          newBuf.__proto__ = Buffer.prototype
          return newBuf
        }

        /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0)
            throw new RangeError("offset is not uint")
          if (offset + ext > length)
            throw new RangeError("Trying to access beyond buffer length")
        }

        Buffer.prototype.readUIntLE = function readUIntLE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }

          return val
        }

        Buffer.prototype.readUIntBE = function readUIntBE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length)
          }

          var val = this[offset + --byteLength]
          var mul = 1
          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul
          }

          return val
        }

        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 1, this.length)
          return this[offset]
        }

        Buffer.prototype.readUInt16LE = function readUInt16LE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          return this[offset] | (this[offset + 1] << 8)
        }

        Buffer.prototype.readUInt16BE = function readUInt16BE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          return (this[offset] << 8) | this[offset + 1]
        }

        Buffer.prototype.readUInt32LE = function readUInt32LE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            (this[offset] |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16)) +
            this[offset + 3] * 0x1000000
          )
        }

        Buffer.prototype.readUInt32BE = function readUInt32BE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            this[offset] * 0x1000000 +
            ((this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3])
          )
        }

        Buffer.prototype.readIntLE = function readIntLE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }
          mul *= 0x80

          if (val >= mul) val -= Math.pow(2, 8 * byteLength)

          return val
        }

        Buffer.prototype.readIntBE = function readIntBE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var i = byteLength
          var mul = 1
          var val = this[offset + --i]
          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul
          }
          mul *= 0x80

          if (val >= mul) val -= Math.pow(2, 8 * byteLength)

          return val
        }

        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 1, this.length)
          if (!(this[offset] & 0x80)) return this[offset]
          return (0xff - this[offset] + 1) * -1
        }

        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset] | (this[offset + 1] << 8)
          return val & 0x8000 ? val | 0xffff0000 : val
        }

        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset + 1] | (this[offset] << 8)
          return val & 0x8000 ? val | 0xffff0000 : val
        }

        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            this[offset] |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16) |
            (this[offset + 3] << 24)
          )
        }

        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (
            (this[offset] << 24) |
            (this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            this[offset + 3]
          )
        }

        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, true, 23, 4)
        }

        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, false, 23, 4)
        }

        Buffer.prototype.readDoubleLE = function readDoubleLE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, true, 52, 8)
        }

        Buffer.prototype.readDoubleBE = function readDoubleBE(
          offset,
          noAssert
        ) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf))
            throw new TypeError('"buffer" argument must be a Buffer instance')
          if (value > max || value < min)
            throw new RangeError('"value" argument is out of bounds')
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range")
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1
            checkInt(this, value, offset, byteLength, maxBytes, 0)
          }

          var mul = 1
          var i = 0
          this[offset] = value & 0xff
          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeUIntBE = function writeUIntBE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1
            checkInt(this, value, offset, byteLength, maxBytes, 0)
          }

          var i = byteLength - 1
          var mul = 1
          this[offset + i] = value & 0xff
          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeUInt8 = function writeUInt8(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
          this[offset] = value & 0xff
          return offset + 1
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          this[offset] = value & 0xff
          this[offset + 1] = value >>> 8
          return offset + 2
        }

        Buffer.prototype.writeUInt16BE = function writeUInt16BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          this[offset] = value >>> 8
          this[offset + 1] = value & 0xff
          return offset + 2
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          this[offset + 3] = value >>> 24
          this[offset + 2] = value >>> 16
          this[offset + 1] = value >>> 8
          this[offset] = value & 0xff
          return offset + 4
        }

        Buffer.prototype.writeUInt32BE = function writeUInt32BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          this[offset] = value >>> 24
          this[offset + 1] = value >>> 16
          this[offset + 2] = value >>> 8
          this[offset + 3] = value & 0xff
          return offset + 4
        }

        Buffer.prototype.writeIntLE = function writeIntLE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1)

            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }

          var i = 0
          var mul = 1
          var sub = 0
          this[offset] = value & 0xff
          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1
            }
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeIntBE = function writeIntBE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1)

            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }

          var i = byteLength - 1
          var mul = 1
          var sub = 0
          this[offset + i] = value & 0xff
          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1
            }
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff
          }

          return offset + byteLength
        }

        Buffer.prototype.writeInt8 = function writeInt8(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
          if (value < 0) value = 0xff + value + 1
          this[offset] = value & 0xff
          return offset + 1
        }

        Buffer.prototype.writeInt16LE = function writeInt16LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          this[offset] = value & 0xff
          this[offset + 1] = value >>> 8
          return offset + 2
        }

        Buffer.prototype.writeInt16BE = function writeInt16BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          this[offset] = value >>> 8
          this[offset + 1] = value & 0xff
          return offset + 2
        }

        Buffer.prototype.writeInt32LE = function writeInt32LE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          this[offset] = value & 0xff
          this[offset + 1] = value >>> 8
          this[offset + 2] = value >>> 16
          this[offset + 3] = value >>> 24
          return offset + 4
        }

        Buffer.prototype.writeInt32BE = function writeInt32BE(
          value,
          offset,
          noAssert
        ) {
          value = +value
          offset = offset >>> 0
          if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          if (value < 0) value = 0xffffffff + value + 1
          this[offset] = value >>> 24
          this[offset + 1] = value >>> 16
          this[offset + 2] = value >>> 8
          this[offset + 3] = value & 0xff
          return offset + 4
        }

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range")
          if (offset < 0) throw new RangeError("Index out of range")
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            checkIEEE754(
              buf,
              value,
              offset,
              4,
              3.4028234663852886e38,
              -3.4028234663852886e38
            )
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4)
          return offset + 4
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE(
          value,
          offset,
          noAssert
        ) {
          return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function writeFloatBE(
          value,
          offset,
          noAssert
        ) {
          return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            checkIEEE754(
              buf,
              value,
              offset,
              8,
              1.7976931348623157e308,
              -1.7976931348623157e308
            )
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8)
          return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE(
          value,
          offset,
          noAssert
        ) {
          return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function writeDoubleBE(
          value,
          offset,
          noAssert
        ) {
          return writeDouble(this, value, offset, false, noAssert)
        }

        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!Buffer.isBuffer(target))
            throw new TypeError("argument should be a Buffer")
          if (!start) start = 0
          if (!end && end !== 0) end = this.length
          if (targetStart >= target.length) targetStart = target.length
          if (!targetStart) targetStart = 0
          if (end > 0 && end < start) end = start

          // Copy 0 bytes; we're done
          if (end === start) return 0
          if (target.length === 0 || this.length === 0) return 0

          // Fatal error conditions
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds")
          }
          if (start < 0 || start >= this.length)
            throw new RangeError("Index out of range")
          if (end < 0) throw new RangeError("sourceEnd out of bounds")

          // Are we oob?
          if (end > this.length) end = this.length
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start
          }

          var len = end - start

          if (
            this === target &&
            typeof Uint8Array.prototype.copyWithin === "function"
          ) {
            // Use built-in when available, missing from IE11
            this.copyWithin(targetStart, start, end)
          } else if (
            this === target &&
            start < targetStart &&
            targetStart < end
          ) {
            // descending copy from end
            for (var i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start]
            }
          } else {
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, end),
              targetStart
            )
          }

          return len
        }

        // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start
              start = 0
              end = this.length
            } else if (typeof end === "string") {
              encoding = end
              end = this.length
            }
            if (encoding !== undefined && typeof encoding !== "string") {
              throw new TypeError("encoding must be a string")
            }
            if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding)
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0)
              if (
                (encoding === "utf8" && code < 128) ||
                encoding === "latin1"
              ) {
                // Fast path: If `val` fits into a single byte, use that numeric value.
                val = code
              }
            }
          } else if (typeof val === "number") {
            val = val & 255
          }

          // Invalid ranges are not set to a default, so can range check early.
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError("Out of range index")
          }

          if (end <= start) {
            return this
          }

          start = start >>> 0
          end = end === undefined ? this.length : end >>> 0

          if (!val) val = 0

          var i
          if (typeof val === "number") {
            for (i = start; i < end; ++i) {
              this[i] = val
            }
          } else {
            var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding)
            var len = bytes.length
            if (len === 0) {
              throw new TypeError(
                'The value "' + val + '" is invalid for argument "value"'
              )
            }
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len]
            }
          }

          return this
        }

        // HELPER FUNCTIONS
        // ================

        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

        function base64clean(str) {
          // Node takes equal signs as end of the Base64 encoding
          str = str.split("=")[0]
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = str.trim().replace(INVALID_BASE64_RE, "")
          // Node converts strings with length < 2 to ''
          if (str.length < 2) return ""
          // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
          while (str.length % 4 !== 0) {
            str = str + "="
          }
          return str
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16)
          return n.toString(16)
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity
          var codePoint
          var length = string.length
          var leadSurrogate = null
          var bytes = []

          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i)

            // is surrogate component
            if (codePoint > 0xd7ff && codePoint < 0xe000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xdbff) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                  continue
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                  continue
                }

                // valid lead
                leadSurrogate = codePoint

                continue
              }

              // 2 leads in a row
              if (codePoint < 0xdc00) {
                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                leadSurrogate = codePoint
                continue
              }

              // valid surrogate pair
              codePoint =
                (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                0x10000
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
            }

            leadSurrogate = null

            // encode utf8
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break
              bytes.push(codePoint)
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break
              bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80)
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break
              bytes.push(
                (codePoint >> 0xc) | 0xe0,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80
              )
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break
              bytes.push(
                (codePoint >> 0x12) | 0xf0,
                ((codePoint >> 0xc) & 0x3f) | 0x80,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80
              )
            } else {
              throw new Error("Invalid code point")
            }
          }

          return bytes
        }

        function asciiToBytes(str) {
          var byteArray = []
          for (var i = 0; i < str.length; ++i) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xff)
          }
          return byteArray
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo
          var byteArray = []
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break

            c = str.charCodeAt(i)
            hi = c >> 8
            lo = c % 256
            byteArray.push(lo)
            byteArray.push(hi)
          }

          return byteArray
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str))
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break
            dst[i + offset] = src[i]
          }
          return i
        }

        // ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
        // but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
        function isArrayBuffer(obj) {
          return (
            obj instanceof ArrayBuffer ||
            (obj != null &&
              obj.constructor != null &&
              obj.constructor.name === "ArrayBuffer" &&
              typeof obj.byteLength === "number")
          )
        }

        function numberIsNaN(obj) {
          return obj !== obj // eslint-disable-line no-self-compare
        }
      },
      { "base64-js": 5, ieee754: 36 }
    ],
    2: [
      function(require, module, exports) {
        // crc16 impl, optimized for numeric inputs

        var TABLE = [
          0x0000,
          0x1021,
          0x2042,
          0x3063,
          0x4084,
          0x50a5,
          0x60c6,
          0x70e7,
          0x8108,
          0x9129,
          0xa14a,
          0xb16b,
          0xc18c,
          0xd1ad,
          0xe1ce,
          0xf1ef,
          0x1231,
          0x0210,
          0x3273,
          0x2252,
          0x52b5,
          0x4294,
          0x72f7,
          0x62d6,
          0x9339,
          0x8318,
          0xb37b,
          0xa35a,
          0xd3bd,
          0xc39c,
          0xf3ff,
          0xe3de,
          0x2462,
          0x3443,
          0x0420,
          0x1401,
          0x64e6,
          0x74c7,
          0x44a4,
          0x5485,
          0xa56a,
          0xb54b,
          0x8528,
          0x9509,
          0xe5ee,
          0xf5cf,
          0xc5ac,
          0xd58d,
          0x3653,
          0x2672,
          0x1611,
          0x0630,
          0x76d7,
          0x66f6,
          0x5695,
          0x46b4,
          0xb75b,
          0xa77a,
          0x9719,
          0x8738,
          0xf7df,
          0xe7fe,
          0xd79d,
          0xc7bc,
          0x48c4,
          0x58e5,
          0x6886,
          0x78a7,
          0x0840,
          0x1861,
          0x2802,
          0x3823,
          0xc9cc,
          0xd9ed,
          0xe98e,
          0xf9af,
          0x8948,
          0x9969,
          0xa90a,
          0xb92b,
          0x5af5,
          0x4ad4,
          0x7ab7,
          0x6a96,
          0x1a71,
          0x0a50,
          0x3a33,
          0x2a12,
          0xdbfd,
          0xcbdc,
          0xfbbf,
          0xeb9e,
          0x9b79,
          0x8b58,
          0xbb3b,
          0xab1a,
          0x6ca6,
          0x7c87,
          0x4ce4,
          0x5cc5,
          0x2c22,
          0x3c03,
          0x0c60,
          0x1c41,
          0xedae,
          0xfd8f,
          0xcdec,
          0xddcd,
          0xad2a,
          0xbd0b,
          0x8d68,
          0x9d49,
          0x7e97,
          0x6eb6,
          0x5ed5,
          0x4ef4,
          0x3e13,
          0x2e32,
          0x1e51,
          0x0e70,
          0xff9f,
          0xefbe,
          0xdfdd,
          0xcffc,
          0xbf1b,
          0xaf3a,
          0x9f59,
          0x8f78,
          0x9188,
          0x81a9,
          0xb1ca,
          0xa1eb,
          0xd10c,
          0xc12d,
          0xf14e,
          0xe16f,
          0x1080,
          0x00a1,
          0x30c2,
          0x20e3,
          0x5004,
          0x4025,
          0x7046,
          0x6067,
          0x83b9,
          0x9398,
          0xa3fb,
          0xb3da,
          0xc33d,
          0xd31c,
          0xe37f,
          0xf35e,
          0x02b1,
          0x1290,
          0x22f3,
          0x32d2,
          0x4235,
          0x5214,
          0x6277,
          0x7256,
          0xb5ea,
          0xa5cb,
          0x95a8,
          0x8589,
          0xf56e,
          0xe54f,
          0xd52c,
          0xc50d,
          0x34e2,
          0x24c3,
          0x14a0,
          0x0481,
          0x7466,
          0x6447,
          0x5424,
          0x4405,
          0xa7db,
          0xb7fa,
          0x8799,
          0x97b8,
          0xe75f,
          0xf77e,
          0xc71d,
          0xd73c,
          0x26d3,
          0x36f2,
          0x0691,
          0x16b0,
          0x6657,
          0x7676,
          0x4615,
          0x5634,
          0xd94c,
          0xc96d,
          0xf90e,
          0xe92f,
          0x99c8,
          0x89e9,
          0xb98a,
          0xa9ab,
          0x5844,
          0x4865,
          0x7806,
          0x6827,
          0x18c0,
          0x08e1,
          0x3882,
          0x28a3,
          0xcb7d,
          0xdb5c,
          0xeb3f,
          0xfb1e,
          0x8bf9,
          0x9bd8,
          0xabbb,
          0xbb9a,
          0x4a75,
          0x5a54,
          0x6a37,
          0x7a16,
          0x0af1,
          0x1ad0,
          0x2ab3,
          0x3a92,
          0xfd2e,
          0xed0f,
          0xdd6c,
          0xcd4d,
          0xbdaa,
          0xad8b,
          0x9de8,
          0x8dc9,
          0x7c26,
          0x6c07,
          0x5c64,
          0x4c45,
          0x3ca2,
          0x2c83,
          0x1ce0,
          0x0cc1,
          0xef1f,
          0xff3e,
          0xcf5d,
          0xdf7c,
          0xaf9b,
          0xbfba,
          0x8fd9,
          0x9ff8,
          0x6e17,
          0x7e36,
          0x4e55,
          0x5e74,
          0x2e93,
          0x3eb2,
          0x0ed1,
          0x1ef0
        ]

        module.exports = crc16

        function crc16(n) {
          var crc = 0
          var r = 0

          for (var i = 0; i < 8; i++) {
            r = n & 0xff
            n = (n - r) / 256
            crc = ((crc << 8) ^ TABLE[((crc >> 8) ^ r) & 0xff]) & 0xffff
          }

          return crc
        }
      },
      {}
    ],
    3: [
      function(require, module, exports) {
        var hash = require("./crc16")

        module.exports = LRU

        function LRU(max, opts) {
          if (!(this instanceof LRU)) return new LRU(max, opts)
          if (!opts) opts = {}

          // how many collisions before evicting (factor of two for fast modulo)
          this.collisions = factorOfTwo(opts.collisions || opts.bucketSize || 4)
          // buckets should be a factor of two for fast modulo as well
          this.buckets = factorOf(max, this.collisions) / this.collisions

          // we use 16bit hashing to bucket index must be <0xffff
          while (this.buckets > 65536) {
            this.buckets >>= 1
            this.collisions <<= 1
          }

          this.size = this.buckets * this.collisions
          this.wrap = !opts.indexedValues
          this.cache = new Array(this.size)
          this.hash =
            this.buckets === 65536 ? hash : maskedHash(this.buckets - 1)
          this.evict = opts.evict || null
        }

        LRU.prototype.set = function(index, val) {
          var pageStart = this.collisions * this.hash(index)
          var pageEnd = pageStart + this.collisions
          var ptr = pageStart
          var page = null

          while (ptr < pageEnd) {
            page = this.cache[ptr]

            if (!page) {
              // no exiting version, but we have space to store it
              page = this.cache[ptr] = this.wrap ? new Node(index, val) : val
              move(this.cache, pageStart, ptr, page)
              return
            }

            if (page.index === index) {
              // update existing version and move to head of bucket
              if (this.wrap) page.value = val
              else this.cache[ptr] = val
              move(this.cache, pageStart, ptr, page)
              return
            }

            ptr++
          }

          // bucket is full, update oldest (last element in bucket)
          if (this.wrap) {
            if (this.evict) this.evict(page.index, page.value)
            page.index = index
            page.value = val
          } else {
            if (this.evict) this.evict(page.index, page)
            this.cache[ptr - 1] = val
          }
          move(this.cache, pageStart, ptr - 1, page)
        }

        LRU.prototype.get = function(index) {
          var pageStart = this.collisions * this.hash(index)
          var pageEnd = pageStart + this.collisions
          var ptr = pageStart

          while (ptr < pageEnd) {
            var page = this.cache[ptr++]

            if (!page) return null
            if (page.index !== index) continue

            // we found it! move to head of bucket and return value
            move(this.cache, pageStart, ptr - 1, page)

            return this.wrap ? page.value : page
          }

          return null
        }

        function move(list, index, itemIndex, item) {
          while (itemIndex > index) list[itemIndex] = list[--itemIndex]
          list[index] = item
        }

        function Node(index, value) {
          this.index = index
          this.value = value
        }

        function factorOf(n, factor) {
          n = factorOfTwo(n)
          while (n & (factor - 1)) n <<= 1
          return n
        }

        function factorOfTwo(n) {
          if (n && !(n & (n - 1))) return n
          var p = 1
          while (p < n) p <<= 1
          return p
        }

        function maskedHash(mask) {
          return function(n) {
            return hash(n) & mask
          }
        }
      },
      { "./crc16": 2 }
    ],
    4: [
      function(require, module, exports) {
        module.exports = batcher

        function batcher(run) {
          var running = false
          var pendingBatch = null
          var pendingCallbacks = null
          var callbacks = null

          return append

          function done(err) {
            if (callbacks) callAll(callbacks, err)

            running = false
            callbacks = pendingCallbacks
            var nextBatch = pendingBatch

            pendingBatch = null
            pendingCallbacks = null

            if (!nextBatch || !nextBatch.length) {
              if (!callbacks || !callbacks.length) {
                callbacks = null
                return
              }
              if (!nextBatch) nextBatch = []
            }

            running = true
            run(nextBatch, done)
          }

          function append(val, cb) {
            if (running) {
              if (!pendingBatch) {
                pendingBatch = []
                pendingCallbacks = []
              }
              pushAll(pendingBatch, val)
              if (cb) pendingCallbacks.push(cb)
            } else {
              if (cb) callbacks = [cb]
              running = true
              run(Array.isArray(val) ? val : [val], done)
            }
          }
        }

        function pushAll(list, val) {
          if (Array.isArray(val)) pushArray(list, val)
          else list.push(val)
        }

        function pushArray(list, val) {
          for (var i = 0; i < val.length; i++) list.push(val[i])
        }

        function callAll(list, err) {
          for (var i = 0; i < list.length; i++) list[i](err)
        }
      },
      {}
    ],
    5: [
      function(require, module, exports) {
        "use strict"

        exports.byteLength = byteLength
        exports.toByteArray = toByteArray
        exports.fromByteArray = fromByteArray

        var lookup = []
        var revLookup = []
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array

        var code =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i]
          revLookup[code.charCodeAt(i)] = i
        }

        // Support decoding URL-safe base64 strings, as Node.js does.
        // See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup["-".charCodeAt(0)] = 62
        revLookup["_".charCodeAt(0)] = 63

        function getLens(b64) {
          var len = b64.length

          if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4")
          }

          // Trim off extra bytes after placeholder bytes are found
          // See: https://github.com/beatgammit/base64-js/issues/42
          var validLen = b64.indexOf("=")
          if (validLen === -1) validLen = len

          var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4)

          return [validLen, placeHoldersLen]
        }

        // base64 is 4/3 + up to two characters of the original data
        function byteLength(b64) {
          var lens = getLens(b64)
          var validLen = lens[0]
          var placeHoldersLen = lens[1]
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
        }

        function _byteLength(b64, validLen, placeHoldersLen) {
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
        }

        function toByteArray(b64) {
          var tmp
          var lens = getLens(b64)
          var validLen = lens[0]
          var placeHoldersLen = lens[1]

          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

          var curByte = 0

          // if there are placeholders, only get up to the last complete 4 chars
          var len = placeHoldersLen > 0 ? validLen - 4 : validLen

          for (var i = 0; i < len; i += 4) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 18) |
              (revLookup[b64.charCodeAt(i + 1)] << 12) |
              (revLookup[b64.charCodeAt(i + 2)] << 6) |
              revLookup[b64.charCodeAt(i + 3)]
            arr[curByte++] = (tmp >> 16) & 0xff
            arr[curByte++] = (tmp >> 8) & 0xff
            arr[curByte++] = tmp & 0xff
          }

          if (placeHoldersLen === 2) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 2) |
              (revLookup[b64.charCodeAt(i + 1)] >> 4)
            arr[curByte++] = tmp & 0xff
          }

          if (placeHoldersLen === 1) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 10) |
              (revLookup[b64.charCodeAt(i + 1)] << 4) |
              (revLookup[b64.charCodeAt(i + 2)] >> 2)
            arr[curByte++] = (tmp >> 8) & 0xff
            arr[curByte++] = tmp & 0xff
          }

          return arr
        }

        function tripletToBase64(num) {
          return (
            lookup[(num >> 18) & 0x3f] +
            lookup[(num >> 12) & 0x3f] +
            lookup[(num >> 6) & 0x3f] +
            lookup[num & 0x3f]
          )
        }

        function encodeChunk(uint8, start, end) {
          var tmp
          var output = []
          for (var i = start; i < end; i += 3) {
            tmp =
              ((uint8[i] << 16) & 0xff0000) +
              ((uint8[i + 1] << 8) & 0xff00) +
              (uint8[i + 2] & 0xff)
            output.push(tripletToBase64(tmp))
          }
          return output.join("")
        }

        function fromByteArray(uint8) {
          var tmp
          var len = uint8.length
          var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
          var parts = []
          var maxChunkLength = 16383 // must be multiple of 3

          // go through the array every three bytes, we'll deal with trailing stuff later
          for (
            var i = 0, len2 = len - extraBytes;
            i < len2;
            i += maxChunkLength
          ) {
            parts.push(
              encodeChunk(
                uint8,
                i,
                i + maxChunkLength > len2 ? len2 : i + maxChunkLength
              )
            )
          }

          // pad the end with zeros, but make sure to not forget the extra bytes
          if (extraBytes === 1) {
            tmp = uint8[len - 1]
            parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==")
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1]
            parts.push(
              lookup[tmp >> 10] +
                lookup[(tmp >> 4) & 0x3f] +
                lookup[(tmp << 2) & 0x3f] +
                "="
            )
          }

          return parts.join("")
        }
      },
      {}
    ],
    6: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var varint = require("varint")

          exports.encode = encode
          exports.encode.bytes = 0
          exports.encodingLength = encodingLength

          exports.decode = decode
          exports.decode.bytes = 0
          exports.decodingLength = decodingLength

          function State(input, output, offset) {
            this.inputOffset = 0
            this.inputLength = input.length
            this.input = input
            this.outputOffset = offset
            this.output = output
          }

          function encode(bitfield, buffer, offset) {
            if (!offset) offset = 0
            if (!buffer) buffer = new Buffer(encodingLength(bitfield))
            var state = new State(bitfield, buffer, offset)
            rle(state)
            encode.bytes = state.outputOffset - offset
            return buffer
          }

          function encodingLength(bitfield) {
            var state = new State(bitfield, null, 0)
            rle(state)
            return state.outputOffset
          }

          function decode(buffer, offset) {
            if (!offset) offset = 0

            var bitfield = new Buffer(decodingLength(buffer, offset))
            var ptr = 0

            while (offset < buffer.length) {
              var next = varint.decode(buffer, offset)
              var repeat = next & 1
              var len = repeat ? (next - (next & 3)) / 4 : next / 2

              offset += varint.decode.bytes

              if (repeat) {
                bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len)
              } else {
                buffer.copy(bitfield, ptr, offset, offset + len)
                offset += len
              }

              ptr += len
            }

            decode.bytes = buffer.length - offset

            return bitfield
          }

          function decodingLength(buffer, offset) {
            if (!offset) offset = 0

            var len = 0

            while (offset < buffer.length) {
              var next = varint.decode(buffer, offset)
              offset += varint.decode.bytes

              var repeat = next & 1
              var slice = repeat ? (next - (next & 3)) / 4 : next / 2

              len += slice
              if (!repeat) offset += slice
            }

            if (offset > buffer.length) throw new Error("Invalid RLE bitfield")

            return len
          }

          function rle(state) {
            var len = 0
            var bits = 0
            var input = state.input

            while (state.inputLength > 0 && !input[state.inputLength - 1])
              state.inputLength--

            for (var i = 0; i < state.inputLength; i++) {
              if (input[i] === bits) {
                len++
                continue
              }

              if (len) encodeUpdate(state, i, len, bits)

              if (input[i] === 0 || input[i] === 255) {
                bits = input[i]
                len = 1
              } else {
                len = 0
              }
            }

            if (len) encodeUpdate(state, state.inputLength, len, bits)
            encodeFinal(state)
          }

          function encodeHead(state, end) {
            var headLength = end - state.inputOffset
            varint.encode(2 * headLength, state.output, state.outputOffset)
            state.outputOffset += varint.encode.bytes
            state.input.copy(
              state.output,
              state.outputOffset,
              state.inputOffset,
              end
            )
            state.outputOffset += headLength
          }

          function encodeFinal(state) {
            var headLength = state.inputLength - state.inputOffset
            if (!headLength) return

            if (!state.output) {
              state.outputOffset +=
                headLength + varint.encodingLength(2 * headLength)
            } else {
              encodeHead(state, state.inputLength)
            }

            state.inputOffset = state.inputLength
          }

          function encodeUpdate(state, i, len, bit) {
            var headLength = i - len - state.inputOffset
            var headCost = headLength
              ? varint.encodingLength(2 * headLength) + headLength
              : 0
            var enc = 4 * len + (bit ? 2 : 0) + 1 // len << 2 | bit << 1 | 1
            var encCost = headCost + varint.encodingLength(enc)
            var baseCost =
              varint.encodingLength(2 * (i - state.inputOffset)) +
              i -
              state.inputOffset

            if (encCost >= baseCost) return

            if (!state.output) {
              state.outputOffset += encCost
              state.inputOffset = i
              return
            }

            if (headLength) encodeHead(state, i - len)

            varint.encode(enc, state.output, state.outputOffset)
            state.outputOffset += varint.encode.bytes
            state.inputOffset = i
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, varint: 9 }
    ],
    7: [
      function(require, module, exports) {
        module.exports = read

        var MSB = 0x80,
          REST = 0x7f

        function read(buf, offset) {
          var res = 0,
            offset = offset || 0,
            shift = 0,
            counter = offset,
            b,
            l = buf.length

          do {
            if (counter >= l) {
              read.bytes = 0
              read.bytesRead = 0 // DEPRECATED
              return undefined
            }
            b = buf[counter++]
            res +=
              shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift)
            shift += 7
          } while (b >= MSB)

          read.bytes = counter - offset

          return res
        }
      },
      {}
    ],
    8: [
      function(require, module, exports) {
        module.exports = encode

        var MSB = 0x80,
          REST = 0x7f,
          MSBALL = ~REST,
          INT = Math.pow(2, 31)

        function encode(num, out, offset) {
          out = out || []
          offset = offset || 0
          var oldOffset = offset

          while (num >= INT) {
            out[offset++] = (num & 0xff) | MSB
            num /= 128
          }
          while (num & MSBALL) {
            out[offset++] = (num & 0xff) | MSB
            num >>>= 7
          }
          out[offset] = num | 0

          encode.bytes = offset - oldOffset + 1

          return out
        }
      },
      {}
    ],
    9: [
      function(require, module, exports) {
        module.exports = {
          encode: require("./encode.js"),
          decode: require("./decode.js"),
          encodingLength: require("./length.js")
        }
      },
      { "./decode.js": 7, "./encode.js": 8, "./length.js": 10 }
    ],
    10: [
      function(require, module, exports) {
        var N1 = Math.pow(2, 7)
        var N2 = Math.pow(2, 14)
        var N3 = Math.pow(2, 21)
        var N4 = Math.pow(2, 28)
        var N5 = Math.pow(2, 35)
        var N6 = Math.pow(2, 42)
        var N7 = Math.pow(2, 49)
        var N8 = Math.pow(2, 56)
        var N9 = Math.pow(2, 63)

        module.exports = function(value) {
          return value < N1
            ? 1
            : value < N2
              ? 2
              : value < N3
                ? 3
                : value < N4
                  ? 4
                  : value < N5
                    ? 5
                    : value < N6
                      ? 6
                      : value < N7
                        ? 7
                        : value < N8
                          ? 8
                          : value < N9
                            ? 9
                            : 10
        }
      },
      {}
    ],
    11: [
      function(require, module, exports) {
        module.exports = loadWebAssembly

        loadWebAssembly.supported = typeof WebAssembly !== "undefined"

        function loadWebAssembly(opts) {
          if (!loadWebAssembly.supported) return null

          var imp = opts && opts.imports
          var wasm = toUint8Array(
            "AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL"
          )
          var ready = null

          var mod = {
            buffer: wasm,
            memory: null,
            exports: null,
            realloc: realloc,
            onload: onload
          }

          onload(function() {})

          return mod

          function realloc(size) {
            mod.exports.memory.grow(
              Math.ceil(Math.abs(size - mod.memory.length) / 65536)
            )
            mod.memory = new Uint8Array(mod.exports.memory.buffer)
          }

          function onload(cb) {
            if (mod.exports) return cb()

            if (ready) {
              ready.then(cb.bind(null, null)).catch(cb)
              return
            }

            try {
              if (opts && opts.async) throw new Error("async")
              setup({
                instance: new WebAssembly.Instance(
                  new WebAssembly.Module(wasm),
                  imp
                )
              })
            } catch (err) {
              ready = WebAssembly.instantiate(wasm, imp).then(setup)
            }

            onload(cb)
          }

          function setup(w) {
            mod.exports = w.instance.exports
            mod.memory =
              mod.exports.memory &&
              mod.exports.memory.buffer &&
              new Uint8Array(mod.exports.memory.buffer)
          }
        }

        function toUint8Array(s) {
          if (typeof atob === "function")
            return new Uint8Array(
              atob(s)
                .split("")
                .map(charCodeAt)
            )
          return new (require("buf" + "fer")).Buffer(s, "base64")
        }

        function charCodeAt(c) {
          return c.charCodeAt(0)
        }
      },
      {}
    ],
    12: [
      function(require, module, exports) {
        var assert = require("nanoassert")
        var wasm = require("./blake2b")()

        var head = 64
        var freeList = []

        module.exports = Blake2b
        var BYTES_MIN = (module.exports.BYTES_MIN = 16)
        var BYTES_MAX = (module.exports.BYTES_MAX = 64)
        var BYTES = (module.exports.BYTES = 32)
        var KEYBYTES_MIN = (module.exports.KEYBYTES_MIN = 16)
        var KEYBYTES_MAX = (module.exports.KEYBYTES_MAX = 64)
        var KEYBYTES = (module.exports.KEYBYTES = 32)
        var SALTBYTES = (module.exports.SALTBYTES = 16)
        var PERSONALBYTES = (module.exports.PERSONALBYTES = 16)

        function Blake2b(digestLength, key, salt, personal, noAssert) {
          if (!(this instanceof Blake2b))
            return new Blake2b(digestLength, key, salt, personal, noAssert)
          if (!(wasm && wasm.exports))
            throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)")
          if (!digestLength) digestLength = 32

          if (noAssert !== true) {
            assert(
              digestLength >= BYTES_MIN,
              "digestLength must be at least " +
                BYTES_MIN +
                ", was given " +
                digestLength
            )
            assert(
              digestLength <= BYTES_MAX,
              "digestLength must be at most " +
                BYTES_MAX +
                ", was given " +
                digestLength
            )
            if (key != null)
              assert(
                key.length >= KEYBYTES_MIN,
                "key must be at least " +
                  KEYBYTES_MIN +
                  ", was given " +
                  key.length
              )
            if (key != null)
              assert(
                key.length <= KEYBYTES_MAX,
                "key must be at least " +
                  KEYBYTES_MAX +
                  ", was given " +
                  key.length
              )
            if (salt != null)
              assert(
                salt.length === SALTBYTES,
                "salt must be exactly " +
                  SALTBYTES +
                  ", was given " +
                  salt.length
              )
            if (personal != null)
              assert(
                personal.length === PERSONALBYTES,
                "personal must be exactly " +
                  PERSONALBYTES +
                  ", was given " +
                  personal.length
              )
          }

          if (!freeList.length) {
            freeList.push(head)
            head += 216
          }

          this.digestLength = digestLength
          this.finalized = false
          this.pointer = freeList.pop()

          wasm.memory.fill(0, 0, 64)
          wasm.memory[0] = this.digestLength
          wasm.memory[1] = key ? key.length : 0
          wasm.memory[2] = 1 // fanout
          wasm.memory[3] = 1 // depth

          if (salt) wasm.memory.set(salt, 32)
          if (personal) wasm.memory.set(personal, 48)

          if (this.pointer + 216 > wasm.memory.length)
            wasm.realloc(this.pointer + 216) // we need 216 bytes for the state
          wasm.exports.blake2b_init(this.pointer, this.digestLength)

          if (key) {
            this.update(key)
            wasm.memory.fill(0, head, head + key.length) // whiteout key
            wasm.memory[this.pointer + 200] = 128
          }
        }

        Blake2b.prototype.update = function(input) {
          assert(this.finalized === false, "Hash instance finalized")
          assert(input, "input must be TypedArray or Buffer")

          if (head + input.length > wasm.memory.length)
            wasm.realloc(head + input.length)
          wasm.memory.set(input, head)
          wasm.exports.blake2b_update(this.pointer, head, head + input.length)
          return this
        }

        Blake2b.prototype.digest = function(enc) {
          assert(this.finalized === false, "Hash instance finalized")
          this.finalized = true

          freeList.push(this.pointer)
          wasm.exports.blake2b_final(this.pointer)

          if (!enc || enc === "binary") {
            return wasm.memory.slice(
              this.pointer + 128,
              this.pointer + 128 + this.digestLength
            )
          }

          if (enc === "hex") {
            return hexSlice(wasm.memory, this.pointer + 128, this.digestLength)
          }

          assert(
            enc.length >= this.digestLength,
            "input must be TypedArray or Buffer"
          )
          for (var i = 0; i < this.digestLength; i++) {
            enc[i] = wasm.memory[this.pointer + 128 + i]
          }

          return enc
        }

        // libsodium compat
        Blake2b.prototype.final = Blake2b.prototype.digest

        Blake2b.WASM = wasm && wasm.buffer
        Blake2b.SUPPORTED = typeof WebAssembly !== "undefined"

        Blake2b.ready = function(cb) {
          if (!cb) cb = noop
          if (!wasm) return cb(new Error("WebAssembly not supported"))

          // backwards compat, can be removed in a new major
          var p = new Promise(function(reject, resolve) {
            wasm.onload(function(err) {
              if (err) resolve()
              else reject()
              cb(err)
            })
          })

          return p
        }

        Blake2b.prototype.ready = Blake2b.ready

        function noop() {}

        function hexSlice(buf, start, len) {
          var str = ""
          for (var i = 0; i < len; i++) str += toHex(buf[start + i])
          return str
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16)
          return n.toString(16)
        }
      },
      { "./blake2b": 11, nanoassert: 42 }
    ],
    13: [
      function(require, module, exports) {
        var assert = require("nanoassert")
        var b2wasm = require("blake2b-wasm")

        // 64-bit unsigned addition
        // Sets v[a,a+1] += v[b,b+1]
        // v should be a Uint32Array
        function ADD64AA(v, a, b) {
          var o0 = v[a] + v[b]
          var o1 = v[a + 1] + v[b + 1]
          if (o0 >= 0x100000000) {
            o1++
          }
          v[a] = o0
          v[a + 1] = o1
        }

        // 64-bit unsigned addition
        // Sets v[a,a+1] += b
        // b0 is the low 32 bits of b, b1 represents the high 32 bits
        function ADD64AC(v, a, b0, b1) {
          var o0 = v[a] + b0
          if (b0 < 0) {
            o0 += 0x100000000
          }
          var o1 = v[a + 1] + b1
          if (o0 >= 0x100000000) {
            o1++
          }
          v[a] = o0
          v[a + 1] = o1
        }

        // Little-endian byte access
        function B2B_GET32(arr, i) {
          return (
            arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)
          )
        }

        // G Mixing function
        // The ROTRs are inlined for speed
        function B2B_G(a, b, c, d, ix, iy) {
          var x0 = m[ix]
          var x1 = m[ix + 1]
          var y0 = m[iy]
          var y1 = m[iy + 1]

          ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
          ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

          // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
          var xor0 = v[d] ^ v[a]
          var xor1 = v[d + 1] ^ v[a + 1]
          v[d] = xor1
          v[d + 1] = xor0

          ADD64AA(v, c, d)

          // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
          xor0 = v[b] ^ v[c]
          xor1 = v[b + 1] ^ v[c + 1]
          v[b] = (xor0 >>> 24) ^ (xor1 << 8)
          v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

          ADD64AA(v, a, b)
          ADD64AC(v, a, y0, y1)

          // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
          xor0 = v[d] ^ v[a]
          xor1 = v[d + 1] ^ v[a + 1]
          v[d] = (xor0 >>> 16) ^ (xor1 << 16)
          v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

          ADD64AA(v, c, d)

          // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
          xor0 = v[b] ^ v[c]
          xor1 = v[b + 1] ^ v[c + 1]
          v[b] = (xor1 >>> 31) ^ (xor0 << 1)
          v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
        }

        // Initialization Vector
        var BLAKE2B_IV32 = new Uint32Array([
          0xf3bcc908,
          0x6a09e667,
          0x84caa73b,
          0xbb67ae85,
          0xfe94f82b,
          0x3c6ef372,
          0x5f1d36f1,
          0xa54ff53a,
          0xade682d1,
          0x510e527f,
          0x2b3e6c1f,
          0x9b05688c,
          0xfb41bd6b,
          0x1f83d9ab,
          0x137e2179,
          0x5be0cd19
        ])

        var SIGMA8 = [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          14,
          10,
          4,
          8,
          9,
          15,
          13,
          6,
          1,
          12,
          0,
          2,
          11,
          7,
          5,
          3,
          11,
          8,
          12,
          0,
          5,
          2,
          15,
          13,
          10,
          14,
          3,
          6,
          7,
          1,
          9,
          4,
          7,
          9,
          3,
          1,
          13,
          12,
          11,
          14,
          2,
          6,
          5,
          10,
          4,
          0,
          15,
          8,
          9,
          0,
          5,
          7,
          2,
          4,
          10,
          15,
          14,
          1,
          11,
          12,
          6,
          8,
          3,
          13,
          2,
          12,
          6,
          10,
          0,
          11,
          8,
          3,
          4,
          13,
          7,
          5,
          15,
          14,
          1,
          9,
          12,
          5,
          1,
          15,
          14,
          13,
          4,
          10,
          0,
          7,
          6,
          3,
          9,
          2,
          8,
          11,
          13,
          11,
          7,
          14,
          12,
          1,
          3,
          9,
          5,
          0,
          15,
          4,
          8,
          6,
          2,
          10,
          6,
          15,
          14,
          9,
          11,
          3,
          0,
          8,
          12,
          2,
          13,
          7,
          1,
          4,
          10,
          5,
          10,
          2,
          8,
          4,
          7,
          6,
          1,
          5,
          15,
          11,
          9,
          14,
          3,
          12,
          13,
          0,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          14,
          10,
          4,
          8,
          9,
          15,
          13,
          6,
          1,
          12,
          0,
          2,
          11,
          7,
          5,
          3
        ]

        // These are offsets into a uint64 buffer.
        // Multiply them all by 2 to make them offsets into a uint32 buffer,
        // because this is Javascript and we don't have uint64s
        var SIGMA82 = new Uint8Array(
          SIGMA8.map(function(x) {
            return x * 2
          })
        )

        // Compression function. 'last' flag indicates last block.
        // Note we're representing 16 uint64s as 32 uint32s
        var v = new Uint32Array(32)
        var m = new Uint32Array(32)
        function blake2bCompress(ctx, last) {
          var i = 0

          // init work variables
          for (i = 0; i < 16; i++) {
            v[i] = ctx.h[i]
            v[i + 16] = BLAKE2B_IV32[i]
          }

          // low 64 bits of offset
          v[24] = v[24] ^ ctx.t
          v[25] = v[25] ^ (ctx.t / 0x100000000)
          // high 64 bits not supported, offset may not be higher than 2**53-1

          // last block flag set ?
          if (last) {
            v[28] = ~v[28]
            v[29] = ~v[29]
          }

          // get little-endian words
          for (i = 0; i < 32; i++) {
            m[i] = B2B_GET32(ctx.b, 4 * i)
          }

          // twelve rounds of mixing
          for (i = 0; i < 12; i++) {
            B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
            B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
            B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
            B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
            B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
            B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
            B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
            B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
          }

          for (i = 0; i < 16; i++) {
            ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
          }
        }

        // reusable parameter_block
        var parameter_block = new Uint8Array([
          0,
          0,
          0,
          0, //  0: outlen, keylen, fanout, depth
          0,
          0,
          0,
          0, //  4: leaf length, sequential mode
          0,
          0,
          0,
          0, //  8: node offset
          0,
          0,
          0,
          0, // 12: node offset
          0,
          0,
          0,
          0, // 16: node depth, inner length, rfu
          0,
          0,
          0,
          0, // 20: rfu
          0,
          0,
          0,
          0, // 24: rfu
          0,
          0,
          0,
          0, // 28: rfu
          0,
          0,
          0,
          0, // 32: salt
          0,
          0,
          0,
          0, // 36: salt
          0,
          0,
          0,
          0, // 40: salt
          0,
          0,
          0,
          0, // 44: salt
          0,
          0,
          0,
          0, // 48: personal
          0,
          0,
          0,
          0, // 52: personal
          0,
          0,
          0,
          0, // 56: personal
          0,
          0,
          0,
          0 // 60: personal
        ])

        // Creates a BLAKE2b hashing context
        // Requires an output length between 1 and 64 bytes
        // Takes an optional Uint8Array key
        function Blake2b(outlen, key, salt, personal) {
          // zero out parameter_block before usage
          parameter_block.fill(0)
          // state, 'param block'

          this.b = new Uint8Array(128)
          this.h = new Uint32Array(16)
          this.t = 0 // input count
          this.c = 0 // pointer within buffer
          this.outlen = outlen // output length in bytes

          parameter_block[0] = outlen
          if (key) parameter_block[1] = key.length
          parameter_block[2] = 1 // fanout
          parameter_block[3] = 1 // depth

          if (salt) parameter_block.set(salt, 32)
          if (personal) parameter_block.set(personal, 48)

          // initialize hash state
          for (var i = 0; i < 16; i++) {
            this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4)
          }

          // key the hash, if applicable
          if (key) {
            blake2bUpdate(this, key)
            // at the end
            this.c = 128
          }
        }

        Blake2b.prototype.update = function(input) {
          assert(input != null, "input must be Uint8Array or Buffer")
          blake2bUpdate(this, input)
          return this
        }

        Blake2b.prototype.digest = function(out) {
          var buf =
            !out || out === "binary" || out === "hex"
              ? new Uint8Array(this.outlen)
              : out
          assert(
            buf.length >= this.outlen,
            "out must have at least outlen bytes of space"
          )
          blake2bFinal(this, buf)
          if (out === "hex") return hexSlice(buf)
          return buf
        }

        Blake2b.prototype.final = Blake2b.prototype.digest

        Blake2b.ready = function(cb) {
          b2wasm.ready(function() {
            cb() // ignore the error
          })
        }

        // Updates a BLAKE2b streaming hash
        // Requires hash context and Uint8Array (byte array)
        function blake2bUpdate(ctx, input) {
          for (var i = 0; i < input.length; i++) {
            if (ctx.c === 128) {
              // buffer full ?
              ctx.t += ctx.c // add counters
              blake2bCompress(ctx, false) // compress (not last)
              ctx.c = 0 // counter to zero
            }
            ctx.b[ctx.c++] = input[i]
          }
        }

        // Completes a BLAKE2b streaming hash
        // Returns a Uint8Array containing the message digest
        function blake2bFinal(ctx, out) {
          ctx.t += ctx.c // mark last block offset

          while (ctx.c < 128) {
            // fill up with zeros
            ctx.b[ctx.c++] = 0
          }
          blake2bCompress(ctx, true) // final block flag = 1

          for (var i = 0; i < ctx.outlen; i++) {
            out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
          }
          return out
        }

        function hexSlice(buf) {
          var str = ""
          for (var i = 0; i < buf.length; i++) str += toHex(buf[i])
          return str
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16)
          return n.toString(16)
        }

        var Proto = Blake2b

        module.exports = function createHash(
          outlen,
          key,
          salt,
          personal,
          noAssert
        ) {
          if (noAssert !== true) {
            assert(
              outlen >= BYTES_MIN,
              "outlen must be at least " + BYTES_MIN + ", was given " + outlen
            )
            assert(
              outlen <= BYTES_MAX,
              "outlen must be at most " + BYTES_MAX + ", was given " + outlen
            )
            if (key != null)
              assert(
                key.length >= KEYBYTES_MIN,
                "key must be at least " +
                  KEYBYTES_MIN +
                  ", was given " +
                  key.length
              )
            if (key != null)
              assert(
                key.length <= KEYBYTES_MAX,
                "key must be at least " +
                  KEYBYTES_MAX +
                  ", was given " +
                  key.length
              )
            if (salt != null)
              assert(
                salt.length === SALTBYTES,
                "salt must be exactly " +
                  SALTBYTES +
                  ", was given " +
                  salt.length
              )
            if (personal != null)
              assert(
                personal.length === PERSONALBYTES,
                "personal must be exactly " +
                  PERSONALBYTES +
                  ", was given " +
                  personal.length
              )
          }

          return new Proto(outlen, key, salt, personal)
        }

        module.exports.ready = function(cb) {
          b2wasm.ready(function() {
            // ignore errors
            cb()
          })
        }

        module.exports.WASM_SUPPORTED = b2wasm.SUPPORTED
        module.exports.WASM_LOADED = false

        var BYTES_MIN = (module.exports.BYTES_MIN = 16)
        var BYTES_MAX = (module.exports.BYTES_MAX = 64)
        var BYTES = (module.exports.BYTES = 32)
        var KEYBYTES_MIN = (module.exports.KEYBYTES_MIN = 16)
        var KEYBYTES_MAX = (module.exports.KEYBYTES_MAX = 64)
        var KEYBYTES = (module.exports.KEYBYTES = 32)
        var SALTBYTES = (module.exports.SALTBYTES = 16)
        var PERSONALBYTES = (module.exports.PERSONALBYTES = 16)

        b2wasm.ready(function(err) {
          if (!err) {
            module.exports.WASM_LOADED = true
            Proto = b2wasm
          }
        })
      },
      { "blake2b-wasm": 12, nanoassert: 42 }
    ],
    14: [function(require, module, exports) {}, {}],
    15: [
      function(require, module, exports) {
        ;(function(Buffer) {
          function allocUnsafe(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be a number')
            }

            if (size < 0) {
              throw new RangeError('"size" argument must not be negative')
            }

            if (Buffer.allocUnsafe) {
              return Buffer.allocUnsafe(size)
            } else {
              return new Buffer(size)
            }
          }

          module.exports = allocUnsafe
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    16: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var bufferFill = require("buffer-fill")
          var allocUnsafe = require("buffer-alloc-unsafe")

          module.exports = function alloc(size, fill, encoding) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be a number')
            }

            if (size < 0) {
              throw new RangeError('"size" argument must not be negative')
            }

            if (Buffer.alloc) {
              return Buffer.alloc(size, fill, encoding)
            }

            var buffer = allocUnsafe(size)

            if (size === 0) {
              return buffer
            }

            if (fill === undefined) {
              return bufferFill(buffer, 0)
            }

            if (typeof encoding !== "string") {
              encoding = undefined
            }

            return bufferFill(buffer, fill, encoding)
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "buffer-alloc-unsafe": 15, "buffer-fill": 18 }
    ],
    17: [
      function(require, module, exports) {
        ;(function(Buffer) {
          "use strict"
          module.exports = function(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError("Arguments must be Buffers")
            }

            if (a === b) {
              return true
            }

            if (typeof a.equals === "function") {
              return a.equals(b)
            }

            if (a.length !== b.length) {
              return false
            }

            for (var i = 0; i < a.length; i++) {
              if (a[i] !== b[i]) {
                return false
              }
            }

            return true
          }
        }.call(this, { isBuffer: require("../is-buffer/index.js") }))
      },
      { "../is-buffer/index.js": 38 }
    ],
    18: [
      function(require, module, exports) {
        ;(function(Buffer) {
          /* Node.js 6.4.0 and up has full support */
          var hasFullSupport = (function() {
            try {
              if (!Buffer.isEncoding("latin1")) {
                return false
              }

              var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4)

              buf.fill("ab", "ucs2")

              return buf.toString("hex") === "61006200"
            } catch (_) {
              return false
            }
          })()

          function isSingleByte(val) {
            return val.length === 1 && val.charCodeAt(0) < 256
          }

          function fillWithNumber(buffer, val, start, end) {
            if (start < 0 || end > buffer.length) {
              throw new RangeError("Out of range index")
            }

            start = start >>> 0
            end = end === undefined ? buffer.length : end >>> 0

            if (end > start) {
              buffer.fill(val, start, end)
            }

            return buffer
          }

          function fillWithBuffer(buffer, val, start, end) {
            if (start < 0 || end > buffer.length) {
              throw new RangeError("Out of range index")
            }

            if (end <= start) {
              return buffer
            }

            start = start >>> 0
            end = end === undefined ? buffer.length : end >>> 0

            var pos = start
            var len = val.length
            while (pos <= end - len) {
              val.copy(buffer, pos)
              pos += len
            }

            if (pos !== end) {
              val.copy(buffer, pos, 0, end - pos)
            }

            return buffer
          }

          function fill(buffer, val, start, end, encoding) {
            if (hasFullSupport) {
              return buffer.fill(val, start, end, encoding)
            }

            if (typeof val === "number") {
              return fillWithNumber(buffer, val, start, end)
            }

            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start
                start = 0
                end = buffer.length
              } else if (typeof end === "string") {
                encoding = end
                end = buffer.length
              }

              if (encoding !== undefined && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string")
              }

              if (encoding === "latin1") {
                encoding = "binary"
              }

              if (
                typeof encoding === "string" &&
                !Buffer.isEncoding(encoding)
              ) {
                throw new TypeError("Unknown encoding: " + encoding)
              }

              if (val === "") {
                return fillWithNumber(buffer, 0, start, end)
              }

              if (isSingleByte(val)) {
                return fillWithNumber(buffer, val.charCodeAt(0), start, end)
              }

              val = new Buffer(val, encoding)
            }

            if (Buffer.isBuffer(val)) {
              return fillWithBuffer(buffer, val, start, end)
            }

            // Other values (e.g. undefined, boolean, object) results in zero-fill
            return fillWithNumber(buffer, 0, start, end)
          }

          module.exports = fill
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    19: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var toString = Object.prototype.toString

          var isModern =
            typeof Buffer.alloc === "function" &&
            typeof Buffer.allocUnsafe === "function" &&
            typeof Buffer.from === "function"

          function isArrayBuffer(input) {
            return toString.call(input).slice(8, -1) === "ArrayBuffer"
          }

          function fromArrayBuffer(obj, byteOffset, length) {
            byteOffset >>>= 0

            var maxLength = obj.byteLength - byteOffset

            if (maxLength < 0) {
              throw new RangeError("'offset' is out of bounds")
            }

            if (length === undefined) {
              length = maxLength
            } else {
              length >>>= 0

              if (length > maxLength) {
                throw new RangeError("'length' is out of bounds")
              }
            }

            return isModern
              ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
              : new Buffer(
                  new Uint8Array(obj.slice(byteOffset, byteOffset + length))
                )
          }

          function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8"
            }

            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding')
            }

            return isModern
              ? Buffer.from(string, encoding)
              : new Buffer(string, encoding)
          }

          function bufferFrom(value, encodingOrOffset, length) {
            if (typeof value === "number") {
              throw new TypeError('"value" argument must not be a number')
            }

            if (isArrayBuffer(value)) {
              return fromArrayBuffer(value, encodingOrOffset, length)
            }

            if (typeof value === "string") {
              return fromString(value, encodingOrOffset)
            }

            return isModern ? Buffer.from(value) : new Buffer(value)
          }

          module.exports = bufferFrom
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    20: [
      function(require, module, exports) {
        arguments[4][1][0].apply(exports, arguments)
      },
      { "base64-js": 5, dup: 1, ieee754: 36 }
    ],
    21: [
      function(require, module, exports) {
        var stream = require("readable-stream")
        var inherits = require("inherits")
        var bufferFrom = require("buffer-from")

        var SIGNAL_FLUSH = bufferFrom([0])

        var Bulk = function(opts, worker, flush) {
          if (!(this instanceof Bulk)) return new Bulk(opts, worker, flush)

          if (typeof opts === "function") {
            flush = worker
            worker = opts
            opts = {}
          }

          stream.Writable.call(this, opts)
          this._worker = worker
          this._flush = flush
          this.destroyed = false
        }

        inherits(Bulk, stream.Writable)

        Bulk.obj = function(opts, worker, flush) {
          if (typeof opts === "function") return Bulk.obj(null, opts, worker)
          if (!opts) opts = {}
          opts.objectMode = true
          return new Bulk(opts, worker, flush)
        }

        Bulk.prototype.end = function(data, enc, cb) {
          if (!this._flush)
            return stream.Writable.prototype.end.apply(this, arguments)
          if (typeof data === "function") return this.end(null, null, data)
          if (typeof enc === "function") return this.end(data, null, enc)
          if (data) this.write(data)
          if (!this._writableState.ending) this.write(SIGNAL_FLUSH)
          return stream.Writable.prototype.end.call(this, cb)
        }

        Bulk.prototype.destroy = function(err) {
          if (this.destroyed) return
          this.destroyed = true
          if (err) this.emit("error")
          this.emit("close")
        }

        Bulk.prototype._write = function(data, enc, cb) {
          if (data === SIGNAL_FLUSH) this._flush(cb)
          else this._worker([data], cb)
        }

        Bulk.prototype._writev = function(batch, cb) {
          var len = batch.length
          if (batch[batch.length - 1].chunk === SIGNAL_FLUSH) {
            cb = this._flusher(cb)
            if (!--len) return cb()
          }
          var arr = new Array(len)
          for (var i = 0; i < len; i++) arr[i] = batch[i].chunk
          this._worker(arr, cb)
        }

        Bulk.prototype._flusher = function(cb) {
          var self = this
          return function(err) {
            if (err) return cb(err)
            self._flush(cb)
          }
        }

        module.exports = Bulk
      },
      { "buffer-from": 19, inherits: 37, "readable-stream": 58 }
    ],
    22: [
      function(require, module, exports) {
        ;(function(Buffer) {
          module.exports = codecs

          var fromBuffer =
            Buffer.from && Buffer.from !== Uint8Array.from
              ? Buffer.from
              : Buffer

          codecs.ascii = createString("ascii")
          codecs.utf8 = createString("utf-8")
          codecs.hex = createString("hex")
          codecs.base64 = createString("base64")
          codecs.ucs2 = createString("ucs2")
          codecs.utf16le = createString("utf16le")
          codecs.ndjson = createJSON(true)
          codecs.json = createJSON(false)
          codecs.binary = {
            encode: function encodeBinary(obj) {
              return typeof obj === "string" ? fromBuffer(obj, "utf-8") : obj
            },
            decode: function decodeBinary(buf) {
              return buf
            }
          }

          function codecs(fmt) {
            if (typeof fmt === "object" && fmt && fmt.encode && fmt.decode)
              return fmt

            switch (fmt) {
              case "ndjson":
                return codecs.ndjson
              case "json":
                return codecs.json
              case "ascii":
                return codecs.ascii
              case "utf-8":
              case "utf8":
                return codecs.utf8
              case "hex":
                return codecs.hex
              case "base64":
                return codecs.base64
              case "ucs-2":
              case "ucs2":
                return codecs.ucs2
              case "utf16-le":
              case "utf16le":
                return codecs.utf16le
            }

            return codecs.binary
          }

          function createJSON(newline) {
            return {
              encode: newline ? encodeNDJSON : encodeJSON,
              decode: function decodeJSON(buf) {
                return JSON.parse(buf.toString())
              }
            }

            function encodeJSON(val) {
              return new Buffer(JSON.stringify(val))
            }

            function encodeNDJSON(val) {
              return new Buffer(JSON.stringify(val) + "\n")
            }
          }

          function createString(type) {
            return {
              encode: function encodeString(val) {
                if (typeof val !== "string") val = val.toString()
                return fromBuffer(val, type)
              },
              decode: function decodeString(buf) {
                return buf.toString(type)
              }
            }
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    23: [
      function(require, module, exports) {
        ;(function(Buffer) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.

          function isArray(arg) {
            if (Array.isArray) {
              return Array.isArray(arg)
            }
            return objectToString(arg) === "[object Array]"
          }
          exports.isArray = isArray

          function isBoolean(arg) {
            return typeof arg === "boolean"
          }
          exports.isBoolean = isBoolean

          function isNull(arg) {
            return arg === null
          }
          exports.isNull = isNull

          function isNullOrUndefined(arg) {
            return arg == null
          }
          exports.isNullOrUndefined = isNullOrUndefined

          function isNumber(arg) {
            return typeof arg === "number"
          }
          exports.isNumber = isNumber

          function isString(arg) {
            return typeof arg === "string"
          }
          exports.isString = isString

          function isSymbol(arg) {
            return typeof arg === "symbol"
          }
          exports.isSymbol = isSymbol

          function isUndefined(arg) {
            return arg === void 0
          }
          exports.isUndefined = isUndefined

          function isRegExp(re) {
            return objectToString(re) === "[object RegExp]"
          }
          exports.isRegExp = isRegExp

          function isObject(arg) {
            return typeof arg === "object" && arg !== null
          }
          exports.isObject = isObject

          function isDate(d) {
            return objectToString(d) === "[object Date]"
          }
          exports.isDate = isDate

          function isError(e) {
            return objectToString(e) === "[object Error]" || e instanceof Error
          }
          exports.isError = isError

          function isFunction(arg) {
            return typeof arg === "function"
          }
          exports.isFunction = isFunction

          function isPrimitive(arg) {
            return (
              arg === null ||
              typeof arg === "boolean" ||
              typeof arg === "number" ||
              typeof arg === "string" ||
              typeof arg === "symbol" || // ES6 symbol
              typeof arg === "undefined"
            )
          }
          exports.isPrimitive = isPrimitive

          exports.isBuffer = Buffer.isBuffer

          function objectToString(o) {
            return Object.prototype.toString.call(o)
          }
        }.call(this, { isBuffer: require("../../is-buffer/index.js") }))
      },
      { "../../is-buffer/index.js": 38 }
    ],
    24: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var objectCreate = Object.create || objectCreatePolyfill
        var objectKeys = Object.keys || objectKeysPolyfill
        var bind = Function.prototype.bind || functionBindPolyfill

        function EventEmitter() {
          if (
            !this._events ||
            !Object.prototype.hasOwnProperty.call(this, "_events")
          ) {
            this._events = objectCreate(null)
            this._eventsCount = 0
          }

          this._maxListeners = this._maxListeners || undefined
        }
        module.exports = EventEmitter

        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter

        EventEmitter.prototype._events = undefined
        EventEmitter.prototype._maxListeners = undefined

        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        var defaultMaxListeners = 10

        var hasDefineProperty
        try {
          var o = {}
          if (Object.defineProperty) Object.defineProperty(o, "x", { value: 0 })
          hasDefineProperty = o.x === 0
        } catch (err) {
          hasDefineProperty = false
        }
        if (hasDefineProperty) {
          Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: true,
            get: function() {
              return defaultMaxListeners
            },
            set: function(arg) {
              // check whether the input is a positive number (whose value is zero or
              // greater and not a NaN).
              if (typeof arg !== "number" || arg < 0 || arg !== arg)
                throw new TypeError(
                  '"defaultMaxListeners" must be a positive number'
                )
              defaultMaxListeners = arg
            }
          })
        } else {
          EventEmitter.defaultMaxListeners = defaultMaxListeners
        }

        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== "number" || n < 0 || isNaN(n))
            throw new TypeError('"n" argument must be a positive number')
          this._maxListeners = n
          return this
        }

        function $getMaxListeners(that) {
          if (that._maxListeners === undefined)
            return EventEmitter.defaultMaxListeners
          return that._maxListeners
        }

        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return $getMaxListeners(this)
        }

        // These standalone emit* functions are used to optimize calling of event
        // handlers for fast cases because emit() itself often has a variable number of
        // arguments and can be deoptimized because of that. These functions always have
        // the same number of arguments and thus do not get deoptimized, so the code
        // inside them can execute faster.
        function emitNone(handler, isFn, self) {
          if (isFn) handler.call(self)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].call(self)
          }
        }
        function emitOne(handler, isFn, self, arg1) {
          if (isFn) handler.call(self, arg1)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1)
          }
        }
        function emitTwo(handler, isFn, self, arg1, arg2) {
          if (isFn) handler.call(self, arg1, arg2)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2)
          }
        }
        function emitThree(handler, isFn, self, arg1, arg2, arg3) {
          if (isFn) handler.call(self, arg1, arg2, arg3)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i)
              listeners[i].call(self, arg1, arg2, arg3)
          }
        }

        function emitMany(handler, isFn, self, args) {
          if (isFn) handler.apply(self, args)
          else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) listeners[i].apply(self, args)
          }
        }

        EventEmitter.prototype.emit = function emit(type) {
          var er, handler, len, args, i, events
          var doError = type === "error"

          events = this._events
          if (events) doError = doError && events.error == null
          else if (!doError) return false

          // If there is no 'error' event listener then throw.
          if (doError) {
            if (arguments.length > 1) er = arguments[1]
            if (er instanceof Error) {
              throw er // Unhandled 'error' event
            } else {
              // At least give some kind of context to the user
              var err = new Error('Unhandled "error" event. (' + er + ")")
              err.context = er
              throw err
            }
            return false
          }

          handler = events[type]

          if (!handler) return false

          var isFn = typeof handler === "function"
          len = arguments.length
          switch (len) {
            // fast cases
            case 1:
              emitNone(handler, isFn, this)
              break
            case 2:
              emitOne(handler, isFn, this, arguments[1])
              break
            case 3:
              emitTwo(handler, isFn, this, arguments[1], arguments[2])
              break
            case 4:
              emitThree(
                handler,
                isFn,
                this,
                arguments[1],
                arguments[2],
                arguments[3]
              )
              break
            // slower
            default:
              args = new Array(len - 1)
              for (i = 1; i < len; i++) args[i - 1] = arguments[i]
              emitMany(handler, isFn, this, args)
          }

          return true
        }

        function _addListener(target, type, listener, prepend) {
          var m
          var events
          var existing

          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')

          events = target._events
          if (!events) {
            events = target._events = objectCreate(null)
            target._eventsCount = 0
          } else {
            // To avoid recursion in the case that type === "newListener"! Before
            // adding it to the listeners, first emit "newListener".
            if (events.newListener) {
              target.emit(
                "newListener",
                type,
                listener.listener ? listener.listener : listener
              )

              // Re-assign `events` because a newListener handler could have caused the
              // this._events to be assigned to a new object
              events = target._events
            }
            existing = events[type]
          }

          if (!existing) {
            // Optimize the case of one listener. Don't need the extra array object.
            existing = events[type] = listener
            ++target._eventsCount
          } else {
            if (typeof existing === "function") {
              // Adding the second element, need to change to array.
              existing = events[type] = prepend
                ? [listener, existing]
                : [existing, listener]
            } else {
              // If we've already got an array, just append.
              if (prepend) {
                existing.unshift(listener)
              } else {
                existing.push(listener)
              }
            }

            // Check for listener leak
            if (!existing.warned) {
              m = $getMaxListeners(target)
              if (m && m > 0 && existing.length > m) {
                existing.warned = true
                var w = new Error(
                  "Possible EventEmitter memory leak detected. " +
                    existing.length +
                    ' "' +
                    String(type) +
                    '" listeners ' +
                    "added. Use emitter.setMaxListeners() to " +
                    "increase limit."
                )
                w.name = "MaxListenersExceededWarning"
                w.emitter = target
                w.type = type
                w.count = existing.length
                if (typeof console === "object" && console.warn) {
                  console.warn("%s: %s", w.name, w.message)
                }
              }
            }
          }

          return target
        }

        EventEmitter.prototype.addListener = function addListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, false)
        }

        EventEmitter.prototype.on = EventEmitter.prototype.addListener

        EventEmitter.prototype.prependListener = function prependListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, true)
        }

        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn)
            this.fired = true
            switch (arguments.length) {
              case 0:
                return this.listener.call(this.target)
              case 1:
                return this.listener.call(this.target, arguments[0])
              case 2:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1]
                )
              case 3:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1],
                  arguments[2]
                )
              default:
                var args = new Array(arguments.length)
                for (var i = 0; i < args.length; ++i) args[i] = arguments[i]
                this.listener.apply(this.target, args)
            }
          }
        }

        function _onceWrap(target, type, listener) {
          var state = {
            fired: false,
            wrapFn: undefined,
            target: target,
            type: type,
            listener: listener
          }
          var wrapped = bind.call(onceWrapper, state)
          wrapped.listener = listener
          state.wrapFn = wrapped
          return wrapped
        }

        EventEmitter.prototype.once = function once(type, listener) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')
          this.on(type, _onceWrap(this, type, listener))
          return this
        }

        EventEmitter.prototype.prependOnceListener = function prependOnceListener(
          type,
          listener
        ) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')
          this.prependListener(type, _onceWrap(this, type, listener))
          return this
        }

        // Emits a 'removeListener' event if and only if the listener was removed.
        EventEmitter.prototype.removeListener = function removeListener(
          type,
          listener
        ) {
          var list, events, position, i, originalListener

          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function')

          events = this._events
          if (!events) return this

          list = events[type]
          if (!list) return this

          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0) this._events = objectCreate(null)
            else {
              delete events[type]
              if (events.removeListener)
                this.emit("removeListener", type, list.listener || listener)
            }
          } else if (typeof list !== "function") {
            position = -1

            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener
                position = i
                break
              }
            }

            if (position < 0) return this

            if (position === 0) list.shift()
            else spliceOne(list, position)

            if (list.length === 1) events[type] = list[0]

            if (events.removeListener)
              this.emit("removeListener", type, originalListener || listener)
          }

          return this
        }

        EventEmitter.prototype.removeAllListeners = function removeAllListeners(
          type
        ) {
          var listeners, events, i

          events = this._events
          if (!events) return this

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = objectCreate(null)
              this._eventsCount = 0
            } else if (events[type]) {
              if (--this._eventsCount === 0) this._events = objectCreate(null)
              else delete events[type]
            }
            return this
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = objectKeys(events)
            var key
            for (i = 0; i < keys.length; ++i) {
              key = keys[i]
              if (key === "removeListener") continue
              this.removeAllListeners(key)
            }
            this.removeAllListeners("removeListener")
            this._events = objectCreate(null)
            this._eventsCount = 0
            return this
          }

          listeners = events[type]

          if (typeof listeners === "function") {
            this.removeListener(type, listeners)
          } else if (listeners) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i])
            }
          }

          return this
        }

        function _listeners(target, type, unwrap) {
          var events = target._events

          if (!events) return []

          var evlistener = events[type]
          if (!evlistener) return []

          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener]

          return unwrap
            ? unwrapListeners(evlistener)
            : arrayClone(evlistener, evlistener.length)
        }

        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true)
        }

        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false)
        }

        EventEmitter.listenerCount = function(emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type)
          } else {
            return listenerCount.call(emitter, type)
          }
        }

        EventEmitter.prototype.listenerCount = listenerCount
        function listenerCount(type) {
          var events = this._events

          if (events) {
            var evlistener = events[type]

            if (typeof evlistener === "function") {
              return 1
            } else if (evlistener) {
              return evlistener.length
            }
          }

          return 0
        }

        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : []
        }

        // About 1.5x faster than the two-arg version of Array#splice().
        function spliceOne(list, index) {
          for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
            list[i] = list[k]
          list.pop()
        }

        function arrayClone(arr, n) {
          var copy = new Array(n)
          for (var i = 0; i < n; ++i) copy[i] = arr[i]
          return copy
        }

        function unwrapListeners(arr) {
          var ret = new Array(arr.length)
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i]
          }
          return ret
        }

        function objectCreatePolyfill(proto) {
          var F = function() {}
          F.prototype = proto
          return new F()
        }
        function objectKeysPolyfill(obj) {
          var keys = []
          for (var k in obj)
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
              keys.push(k)
            }
          return k
        }
        function functionBindPolyfill(context) {
          var fn = this
          return function() {
            return fn.apply(context, arguments)
          }
        }
      },
      {}
    ],
    25: [
      function(require, module, exports) {
        exports.fullRoots = function(index, result) {
          if (index & 1)
            throw new Error("You can only look up roots for depth(0) blocks")
          if (!result) result = []

          index /= 2

          var offset = 0
          var factor = 1

          while (true) {
            if (!index) return result
            while (factor * 2 <= index) factor *= 2
            result.push(offset + factor - 1)
            offset = offset + 2 * factor
            index -= factor
            factor = 1
          }
        }

        exports.depth = function(index) {
          var depth = 0

          index += 1
          while (!(index & 1)) {
            depth++
            index = rightShift(index)
          }

          return depth
        }

        exports.sibling = function(index, depth) {
          if (!depth) depth = exports.depth(index)
          var offset = exports.offset(index, depth)

          return exports.index(depth, offset & 1 ? offset - 1 : offset + 1)
        }

        exports.parent = function(index, depth) {
          if (!depth) depth = exports.depth(index)
          var offset = exports.offset(index, depth)

          return exports.index(depth + 1, rightShift(offset))
        }

        exports.leftChild = function(index, depth) {
          if (!(index & 1)) return -1
          if (!depth) depth = exports.depth(index)
          return exports.index(depth - 1, exports.offset(index, depth) * 2)
        }

        exports.rightChild = function(index, depth) {
          if (!(index & 1)) return -1
          if (!depth) depth = exports.depth(index)
          return exports.index(depth - 1, 1 + exports.offset(index, depth) * 2)
        }

        exports.children = function(index, depth) {
          if (!(index & 1)) return null

          if (!depth) depth = exports.depth(index)
          var offset = exports.offset(index, depth) * 2

          return [
            exports.index(depth - 1, offset),
            exports.index(depth - 1, offset + 1)
          ]
        }

        exports.leftSpan = function(index, depth) {
          if (!(index & 1)) return index
          if (!depth) depth = exports.depth(index)
          return exports.offset(index, depth) * twoPow(depth + 1)
        }

        exports.rightSpan = function(index, depth) {
          if (!(index & 1)) return index
          if (!depth) depth = exports.depth(index)
          return (exports.offset(index, depth) + 1) * twoPow(depth + 1) - 2
        }

        exports.count = function(index, depth) {
          if (!(index & 1)) return 1
          if (!depth) depth = exports.depth(index)
          return twoPow(depth + 1) - 1
        }

        exports.spans = function(index, depth) {
          if (!(index & 1)) return [index, index]
          if (!depth) depth = exports.depth(index)

          var offset = exports.offset(index, depth)
          var width = twoPow(depth + 1)

          return [offset * width, (offset + 1) * width - 2]
        }

        exports.index = function(depth, offset) {
          return (1 + 2 * offset) * twoPow(depth) - 1
        }

        exports.offset = function(index, depth) {
          if (!(index & 1)) return index / 2
          if (!depth) depth = exports.depth(index)

          return ((index + 1) / twoPow(depth) - 1) / 2
        }

        exports.iterator = function(index) {
          var ite = new Iterator()
          ite.seek(index || 0)
          return ite
        }

        function twoPow(n) {
          return n < 31 ? 1 << n : (1 << 30) * (1 << (n - 30))
        }

        function rightShift(n) {
          return (n - (n & 1)) / 2
        }

        function Iterator(index) {
          this.index = 0
          this.offset = 0
          this.factor = 0
        }

        Iterator.prototype.seek = function(index) {
          this.index = index
          if (this.index & 1) {
            this.offset = exports.offset(index)
            this.factor = twoPow(exports.depth(index) + 1)
          } else {
            this.offset = index / 2
            this.factor = 2
          }
        }

        Iterator.prototype.isLeft = function() {
          return !(this.offset & 1)
        }

        Iterator.prototype.isRight = function() {
          return !this.isLeft()
        }

        Iterator.prototype.prev = function() {
          if (!this.offset) return this.index
          this.offset--
          this.index -= this.factor
          return this.index
        }

        Iterator.prototype.next = function() {
          this.offset++
          this.index += this.factor
          return this.index
        }

        Iterator.prototype.sibling = function() {
          return this.isLeft() ? this.next() : this.prev()
        }

        Iterator.prototype.parent = function() {
          if (this.offset & 1) {
            this.index -= this.factor / 2
            this.offset = (this.offset - 1) / 2
          } else {
            this.index += this.factor / 2
            this.offset /= 2
          }
          this.factor *= 2
          return this.index
        }

        Iterator.prototype.leftSpan = function() {
          this.index = this.index - this.factor / 2 + 1
          this.offset = this.index / 2
          this.factor = 2
          return this.index
        }

        Iterator.prototype.rightSpan = function() {
          this.index = this.index + this.factor / 2 - 1
          this.offset = this.index / 2
          this.factor = 2
          return this.index
        }

        Iterator.prototype.leftChild = function() {
          if (this.factor === 2) return this.index
          this.factor /= 2
          this.index -= this.factor / 2
          this.offset *= 2
          return this.index
        }

        Iterator.prototype.rightChild = function() {
          if (this.factor === 2) return this.index
          this.factor /= 2
          this.index += this.factor / 2
          this.offset = 2 * this.offset + 1
          return this.index
        }
      },
      {}
    ],
    26: [
      function(require, module, exports) {
        ;(function(process) {
          var Readable = require("readable-stream").Readable
          var inherits = require("inherits")

          module.exports = from2

          from2.ctor = ctor
          from2.obj = obj

          var Proto = ctor()

          function toFunction(list) {
            list = list.slice()
            return function(_, cb) {
              var err = null
              var item = list.length ? list.shift() : null
              if (item instanceof Error) {
                err = item
                item = null
              }

              cb(err, item)
            }
          }

          function from2(opts, read) {
            if (typeof opts !== "object" || Array.isArray(opts)) {
              read = opts
              opts = {}
            }

            var rs = new Proto(opts)
            rs._from = Array.isArray(read) ? toFunction(read) : read || noop
            return rs
          }

          function ctor(opts, read) {
            if (typeof opts === "function") {
              read = opts
              opts = {}
            }

            opts = defaults(opts)

            inherits(Class, Readable)
            function Class(override) {
              if (!(this instanceof Class)) return new Class(override)
              this._reading = false
              this._callback = check
              this.destroyed = false
              Readable.call(this, override || opts)

              var self = this
              var hwm = this._readableState.highWaterMark

              function check(err, data) {
                if (self.destroyed) return
                if (err) return self.destroy(err)
                if (data === null) return self.push(null)
                self._reading = false
                if (self.push(data)) self._read(hwm)
              }
            }

            Class.prototype._from = read || noop
            Class.prototype._read = function(size) {
              if (this._reading || this.destroyed) return
              this._reading = true
              this._from(size, this._callback)
            }

            Class.prototype.destroy = function(err) {
              if (this.destroyed) return
              this.destroyed = true

              var self = this
              process.nextTick(function() {
                if (err) self.emit("error", err)
                self.emit("close")
              })
            }

            return Class
          }

          function obj(opts, read) {
            if (typeof opts === "function" || Array.isArray(opts)) {
              read = opts
              opts = {}
            }

            opts = defaults(opts)
            opts.objectMode = true
            opts.highWaterMark = 16

            return from2(opts, read)
          }

          function noop() {}

          function defaults(opts) {
            opts = opts || {}
            return opts
          }
        }.call(this, require("_process")))
      },
      { _process: 44, inherits: 37, "readable-stream": 58 }
    ],
    27: [
      function(require, module, exports) {
        ;(function(process) {
          var events = require("events")
          var inherits = require("inherits")
          var varint = require("varint")
          var messages = require("./messages")
          var bufferAlloc = require("buffer-alloc-unsafe")

          module.exports = Feed

          function Feed(stream) {
            if (!(this instanceof Feed)) return new Feed(stream)
            events.EventEmitter.call(this)

            this.key = null
            this.discoveryKey = null
            this.stream = stream
            this.peer = null // support a peer object to avoid event emitter + closures overhead

            this.id = -1
            this.remoteId = -1
            this.header = 0
            this.headerLength = 0
            this.closed = false

            this._buffer = []
          }

          inherits(Feed, events.EventEmitter)

          Feed.prototype.handshake = function(message) {
            return this._send(1, messages.Handshake, message)
          }

          Feed.prototype.info = function(message) {
            return this._send(2, messages.Info, message)
          }

          Feed.prototype.have = function(message) {
            return this._send(3, messages.Have, message)
          }

          Feed.prototype.unhave = function(message) {
            return this._send(4, messages.Unhave, message)
          }

          Feed.prototype.want = function(message) {
            return this._send(5, messages.Want, message)
          }

          Feed.prototype.unwant = function(message) {
            return this._send(6, messages.Unwant, message)
          }

          Feed.prototype.request = function(message) {
            return this._send(7, messages.Request, message)
          }

          Feed.prototype.cancel = function(message) {
            return this._send(8, messages.Cancel, message)
          }

          Feed.prototype.data = function(message) {
            return this._send(9, messages.Data, message)
          }

          Feed.prototype.extension = function(type, message) {
            var id = this.stream.extensions.indexOf(type)
            if (id === -1) return false

            var header = this.header | 15
            var len =
              this.headerLength + varint.encodingLength(id) + message.length
            var box = bufferAlloc(varint.encodingLength(len) + len)
            var offset = 0

            varint.encode(len, box, offset)
            offset += varint.encode.bytes

            varint.encode(header, box, offset)
            offset += varint.encode.bytes

            varint.encode(id, box, offset)
            offset += varint.encode.bytes

            message.copy(box, offset)
            return this.stream._push(box)
          }

          Feed.prototype.remoteSupports = function(name) {
            return this.stream.remoteSupports(name)
          }

          Feed.prototype.destroy = function(err) {
            this.stream.destroy(err)
          }

          Feed.prototype.close = function() {
            var i = this.stream.feeds.indexOf(this)

            if (i > -1) {
              this.stream.feeds[i] = this.stream.feeds[
                this.stream.feeds.length - 1
              ]
              this.stream.feeds.pop()
              this.stream._localFeeds[this.id] = null
              this.id = -1

              if (this.stream.destroyed) return
              if (this.stream.expectedFeeds <= 0 || --this.stream.expectedFeeds)
                return

              this.stream._prefinalize()
            }
          }

          Feed.prototype._onclose = function() {
            if (this.closed) return
            this.closed = true

            if (!this.stream.destroyed) {
              this.close()
              if (this.remoteId > -1)
                this.stream._remoteFeeds[this.remoteId] = null
              var hex = this.discoveryKey.toString("hex")
              if (this.stream._feeds[hex] === this)
                delete this.stream._feeds[hex]
            }

            if (this.peer) this.peer.onclose()
            else this.emit("close")
          }

          Feed.prototype._resume = function() {
            var self = this
            process.nextTick(resume)

            function resume() {
              while (self._buffer.length) {
                var next = self._buffer.shift()
                self._emit(next.type, next.message)
              }
              self._buffer = null
            }
          }

          Feed.prototype._onextension = function(data, start, end) {
            if (end <= start) return

            var id = varint.decode(data, start)
            var r = this.stream.remoteExtensions
            var localId = !r || id >= r.length ? -1 : r[id]

            if (localId === -1) return

            var message = data.slice(start + varint.decode.bytes, end)
            var name = this.stream.extensions[localId]

            if (this.peer && this.peer.onextension)
              this.peer.onextension(name, message)
            else this.emit("extension", name, message)
          }

          Feed.prototype._onmessage = function(type, data, start, end) {
            var message = decodeMessage(type, data, start, end)
            if (!message || this.closed) return

            if (type === 1) return this.stream._onhandshake(message)

            if (!this._buffer) {
              this._emit(type, message)
              return
            }

            if (this._buffer.length > 16) {
              this.destroy(
                new Error("Remote sent too many messages on an unopened feed")
              )
              return
            }

            this._buffer.push({ type: type, message: message })
          }

          Feed.prototype._emit = function(type, message) {
            if (this.peer) {
              switch (type) {
                case 2:
                  return this.peer.oninfo(message)
                case 3:
                  return this.peer.onhave(message)
                case 4:
                  return this.peer.onunhave(message)
                case 5:
                  return this.peer.onwant(message)
                case 6:
                  return this.peer.onunwant(message)
                case 7:
                  return this.peer.onrequest(message)
                case 8:
                  return this.peer.oncancel(message)
                case 9:
                  return this.peer.ondata(message)
              }
            } else {
              switch (type) {
                case 2:
                  return this.emit("info", message)
                case 3:
                  return this.emit("have", message)
                case 4:
                  return this.emit("unhave", message)
                case 5:
                  return this.emit("want", message)
                case 6:
                  return this.emit("unwant", message)
                case 7:
                  return this.emit("request", message)
                case 8:
                  return this.emit("cancel", message)
                case 9:
                  return this.emit("data", message)
              }
            }
          }

          Feed.prototype._send = function(type, enc, message) {
            var header = this.header | type
            var len = this.headerLength + enc.encodingLength(message)
            var box = bufferAlloc(varint.encodingLength(len) + len)
            var offset = 0

            varint.encode(len, box, offset)
            offset += varint.encode.bytes

            varint.encode(header, box, offset)
            offset += varint.encode.bytes

            enc.encode(message, box, offset)

            return this.stream._push(box)
          }

          function decodeMessage(type, data, start, end) {
            switch (type) {
              case 1:
                return decode(messages.Handshake, data, start, end)
              case 2:
                return decode(messages.Info, data, start, end)
              case 3:
                return decode(messages.Have, data, start, end)
              case 4:
                return decode(messages.Unhave, data, start, end)
              case 5:
                return decode(messages.Want, data, start, end)
              case 6:
                return decode(messages.Unwant, data, start, end)
              case 7:
                return decode(messages.Request, data, start, end)
              case 8:
                return decode(messages.Cancel, data, start, end)
              case 9:
                return decode(messages.Data, data, start, end)
            }
          }

          function decode(enc, data, start, end) {
            try {
              return enc.decode(data, start, end)
            } catch (err) {
              return null
            }
          }
        }.call(this, require("_process")))
      },
      {
        "./messages": 29,
        _process: 44,
        "buffer-alloc-unsafe": 15,
        events: 24,
        inherits: 37,
        varint: 82
      }
    ],
    28: [
      function(require, module, exports) {
        ;(function(process) {
          var stream = require("readable-stream")
          var inherits = require("inherits")
          var varint = require("varint")
          var sodium = require("sodium-universal")
          var indexOf = require("sorted-indexof")
          var feed = require("./feed")
          var messages = require("./messages")
          var bufferAlloc = require("buffer-alloc-unsafe")
          var bufferFrom = require("buffer-from")

          module.exports = Protocol

          function Protocol(opts) {
            if (!(this instanceof Protocol)) return new Protocol(opts)
            if (!opts) opts = {}

            stream.Duplex.call(this)
            var self = this

            this.id = opts.id || randomBytes(32)
            this.live = !!opts.live
            this.ack = !!opts.ack
            this.userData = opts.userData || null
            this.remoteId = null
            this.remoteLive = false
            this.remoteUserData = null

            this.destroyed = false
            this.encrypted = opts.encrypt !== false
            this.key = null
            this.discoveryKey = null
            this.remoteDiscoveryKey = null
            this.feeds = []
            this.expectedFeeds = opts.expectedFeeds || 0
            this.extensions = opts.extensions || []
            this.remoteExtensions = null

            this._localFeeds = []
            this._remoteFeeds = []
            this._feeds = {}

            this._nonce = null
            this._remoteNonce = null
            this._xor = null
            this._remoteXor = null
            this._needsKey = false
            this._length = bufferAlloc(varint.encodingLength(8388608))
            this._missing = 0
            this._buf = null
            this._pointer = 0
            this._data = null
            this._start = 0
            this._cb = null
            this._interval = null
            this._keepAlive = 0
            this._remoteKeepAlive = 0
            this._maybeFinalize = maybeFinalize

            if (opts.timeout !== 0 && opts.timeout !== false)
              this.setTimeout(opts.timeout || 5000, this._ontimeout)
            this.on("finish", this.finalize)

            function maybeFinalize(err) {
              if (err) return self.destroy(err)
              if (!self.expectedFeeds) self.finalize()
            }
          }

          inherits(Protocol, stream.Duplex)

          Protocol.prototype._prefinalize = function() {
            if (!this.emit("prefinalize", this._maybeFinalize)) this.finalize()
          }

          Protocol.prototype.setTimeout = function(ms, ontimeout) {
            if (this.destroyed) return
            if (ontimeout) this.once("timeout", ontimeout)

            var self = this

            this._keepAlive = 0
            this._remoteKeepAlive = 0

            clearInterval(this._interval)
            if (!ms) return

            this._interval = setInterval(kick, (ms / 4) | 0)
            if (this._interval.unref) this._interval.unref()

            function kick() {
              self._kick()
            }
          }

          Protocol.prototype.feed = function(key, opts) {
            if (this.destroyed) return null
            if (!opts) opts = {}

            var dk = opts.discoveryKey || discoveryKey(key)
            var ch = this._feed(dk)

            if (ch.id > -1) {
              if (opts.peer) ch.peer = opts.peer
              return ch
            }

            if (this._localFeeds.length >= 128) {
              this._tooManyFeeds()
              return null
            }

            ch.id = this._localFeeds.push(ch) - 1
            ch.header = ch.id << 4
            ch.headerLength = varint.encodingLength(ch.header)
            ch.key = key
            ch.discoveryKey = dk
            if (opts.peer) ch.peer = opts.peer

            this.feeds.push(ch)

            var first = !this.key
            var feed = {
              discoveryKey: dk,
              nonce: null
            }

            if (first) {
              this.key = key
              this.discoveryKey = dk

              if (!this._sameKey()) return null

              if (this.encrypted) {
                feed.nonce = this._nonce = randomBytes(24)
                this._xor = sodium.crypto_stream_xor_instance(
                  this._nonce,
                  this.key
                )
                if (this._remoteNonce) {
                  this._remoteXor = sodium.crypto_stream_xor_instance(
                    this._remoteNonce,
                    this.key
                  )
                }
              }

              if (this._needsKey) {
                this._needsKey = false
                this._resume()
              }
            }

            var box = encodeFeed(feed, ch.id)
            if (!feed.nonce && this.encrypted) this._xor.update(box, box)
            this._keepAlive = 0
            this.push(box)

            if (this.destroyed) return null

            if (first) {
              ch.handshake({
                id: this.id,
                live: this.live,
                userData: this.userData,
                extensions: this.extensions,
                ack: this.ack
              })
            }

            if (ch._buffer.length) ch._resume()
            else ch._buffer = null

            return ch
          }

          Protocol.prototype._resume = function() {
            var self = this
            process.nextTick(resume)

            function resume() {
              if (!self._data) return

              var data = self._data
              var start = self._start
              var cb = self._cb

              self._data = null
              self._start = 0
              self._cb = null
              self._parse(data, start, cb)
            }
          }

          Protocol.prototype._kick = function() {
            if (this._remoteKeepAlive > 4) {
              clearInterval(this._interval)
              this.emit("timeout")
              return
            }

            for (var i = 0; i < this.feeds.length; i++) {
              var ch = this.feeds[i]
              if (ch.peer) ch.peer.ontick()
              else ch.emit("tick")
            }

            this._remoteKeepAlive++

            if (this._keepAlive > 2) {
              this.ping()
              this._keepAlive = 0
            } else {
              this._keepAlive++
            }
          }

          Protocol.prototype.ping = function() {
            if (!this.key) return true
            var ping = bufferFrom([0])
            if (this._xor) this._xor.update(ping, ping)
            return this.push(ping)
          }

          Protocol.prototype.destroy = function(err) {
            if (this.destroyed) return
            this.destroyed = true
            if (err) this.emit("error", err)
            this._close()
            this.emit("close")
          }

          Protocol.prototype.finalize = function() {
            if (this.destroyed) return
            this.destroyed = true
            this._close()
            this.push(null)
          }

          Protocol.prototype._close = function() {
            clearInterval(this._interval)

            var feeds = this.feeds
            this.feeds = []
            for (var i = 0; i < feeds.length; i++) feeds[i]._onclose()

            if (this._xor) {
              this._xor.final()
              this._xor = null
            }
          }

          Protocol.prototype._read = function() {
            // do nothing, user back-pressures
          }

          Protocol.prototype._push = function(data) {
            if (this.destroyed) return
            this._keepAlive = 0
            if (this._xor) this._xor.update(data, data)
            return this.push(data)
          }

          Protocol.prototype._write = function(data, enc, cb) {
            this._remoteKeepAlive = 0
            this._parse(data, 0, cb)
          }

          Protocol.prototype._feed = function(dk) {
            var hex = dk.toString("hex")
            var ch = this._feeds[hex]
            if (ch) return ch
            ch = this._feeds[hex] = feed(this)
            return ch
          }

          Protocol.prototype.remoteSupports = function(name) {
            var i = this.extensions.indexOf(name)
            return (
              i > -1 &&
              !!this.remoteExtensions &&
              this.remoteExtensions.indexOf(i) > -1
            )
          }

          Protocol.prototype._onhandshake = function(handshake) {
            if (this.remoteId) return

            this.remoteId = handshake.id || randomBytes(32)
            this.remoteLive = handshake.live
            this.remoteUserData = handshake.userData
            this.remoteExtensions = indexOf(
              this.extensions,
              handshake.extensions
            )
            this.remoteAck = handshake.ack

            this.emit("handshake")
          }

          Protocol.prototype._onopen = function(id, data, start, end) {
            var feed = decodeFeed(data, start, end)

            if (!feed) return this._badFeed()

            if (!this.remoteDiscoveryKey) {
              this.remoteDiscoveryKey = feed.discoveryKey
              if (!this._sameKey()) return

              if (this.encrypted && !this._remoteNonce) {
                if (!feed.nonce) {
                  this.destroy(new Error("Remote did not include a nonce"))
                  return
                }
                this._remoteNonce = feed.nonce
              }

              if (this.encrypted && this.key && !this._remoteXor) {
                this._remoteXor = sodium.crypto_stream_xor_instance(
                  this._remoteNonce,
                  this.key
                )
              }
            }

            this._remoteFeeds[id] = this._feed(feed.discoveryKey)
            feed.remoteId = id

            this.emit("feed", feed.discoveryKey)
          }

          Protocol.prototype._onmessage = function(data, start, end) {
            if (end - start < 2) return

            var header = decodeHeader(data, start)
            if (header === -1)
              return this.destroy(new Error("Remote sent invalid header"))

            start += varint.decode.bytes

            var id = header >> 4
            var type = header & 15

            if (id >= 128) return this._tooManyFeeds()
            while (this._remoteFeeds.length < id) this._remoteFeeds.push(null)

            var ch = this._remoteFeeds[id]

            if (type === 0) {
              if (ch) ch._onclose()
              return this._onopen(id, data, start, end)
            }

            if (!ch) return this._badFeed()
            if (type === 15) return ch._onextension(data, start, end)
            ch._onmessage(type, data, start, end)
          }

          Protocol.prototype._parse = function(data, start, cb) {
            var decrypted = !!this._remoteXor

            if (start) {
              data = data.slice(start)
              start = 0
            }

            if (this._remoteXor) this._remoteXor.update(data, data)

            while (start < data.length && !this.destroyed) {
              if (this._missing) start = this._parseMessage(data, start)
              else start = this._parseLength(data, start)

              if (this._needsKey) {
                this._data = data
                this._start = start
                this._cb = cb
                return
              }

              if (!decrypted && this._remoteXor) {
                return this._parse(data, start, cb)
              }
            }

            cb()
          }

          Protocol.prototype._parseMessage = function(data, start) {
            var end = start + this._missing

            if (end <= data.length) {
              var ret = end

              if (this._buf) {
                data.copy(this._buf, this._pointer, start)
                data = this._buf
                start = 0
                end = data.length
                this._buf = null
              }

              this._missing = 0
              this._pointer = 0
              if (this.encrypted && !this.key) this._needsKey = true
              this._onmessage(data, start, end)

              return ret
            }

            if (!this._buf) {
              this._buf = bufferAlloc(this._missing)
              this._pointer = 0
            }

            var rem = data.length - start

            data.copy(this._buf, this._pointer, start)
            this._pointer += rem
            this._missing -= rem

            return data.length
          }

          Protocol.prototype._parseLength = function(data, start) {
            while (!this._missing && start < data.length) {
              var byte = (this._length[this._pointer++] = data[start++])

              if (!(byte & 0x80)) {
                this._missing = varint.decode(this._length)
                this._pointer = 0
                if (this._missing > 8388608) return this._tooBig(data.length)
                return start
              }

              if (this._pointer >= this._length.length)
                return this._tooBig(data.length)
            }

            return start
          }

          Protocol.prototype._sameKey = function() {
            if (!this.discoveryKey || !this.remoteDiscoveryKey) return true
            if (
              this.remoteDiscoveryKey.toString("hex") ===
              this.discoveryKey.toString("hex")
            )
              return true
            this.destroy(new Error("First shared hypercore must be the same"))
            return false
          }

          Protocol.prototype._tooManyFeeds = function() {
            this.destroy(
              new Error(
                "Only 128 feeds currently supported. Open a Github issue if you need more"
              )
            )
          }

          Protocol.prototype._tooBig = function(len) {
            this.destroy(
              new Error("Remote message is larger than 8MB (max allowed)")
            )
            return len
          }

          Protocol.prototype._badFeed = function() {
            this.destroy(new Error("Remote sent invalid feed message"))
          }

          Protocol.prototype._ontimeout = function() {
            this.destroy(new Error("Remote timed out"))
          }

          function decodeHeader(data, start) {
            try {
              return varint.decode(data, start)
            } catch (err) {
              return -1
            }
          }

          function decodeFeed(data, start, end) {
            var feed = null

            try {
              feed = messages.Feed.decode(data, start, end)
            } catch (err) {
              return null
            }

            if (feed.discoveryKey.length !== 32) return null
            if (feed.nonce && feed.nonce.length !== 24) return null

            return feed
          }

          function encodeFeed(feed, id) {
            var header = id << 4
            var len =
              varint.encodingLength(header) + messages.Feed.encodingLength(feed)
            var box = bufferAlloc(varint.encodingLength(len) + len)
            var offset = 0

            varint.encode(len, box, offset)
            offset += varint.encode.bytes

            varint.encode(header, box, offset)
            offset += varint.encode.bytes

            messages.Feed.encode(feed, box, offset)
            return box
          }

          function discoveryKey(key) {
            var buf = bufferAlloc(32)
            sodium.crypto_generichash(buf, bufferFrom("hypercore"), key)
            return buf
          }

          function randomBytes(n) {
            var buf = bufferAlloc(n)
            sodium.randombytes_buf(buf)
            return buf
          }
        }.call(this, require("_process")))
      },
      {
        "./feed": 27,
        "./messages": 29,
        _process: 44,
        "buffer-alloc-unsafe": 15,
        "buffer-from": 19,
        inherits: 37,
        "readable-stream": 58,
        "sodium-universal": 70,
        "sorted-indexof": 71,
        varint: 82
      }
    ],
    29: [
      function(require, module, exports) {
        ;(function(Buffer) {
          // This file is auto generated by the protocol-buffers cli tool

          /* eslint-disable quotes */
          /* eslint-disable indent */
          /* eslint-disable no-redeclare */

          // Remember to `npm install --save protocol-buffers-encodings`
          var encodings = require("protocol-buffers-encodings")
          var varint = encodings.varint
          var skip = encodings.skip

          var Feed = (exports.Feed = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Handshake = (exports.Handshake = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Info = (exports.Info = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Have = (exports.Have = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Unhave = (exports.Unhave = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Want = (exports.Want = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Unwant = (exports.Unwant = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Request = (exports.Request = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Cancel = (exports.Cancel = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          var Data = (exports.Data = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          })

          defineFeed()
          defineHandshake()
          defineInfo()
          defineHave()
          defineUnhave()
          defineWant()
          defineUnwant()
          defineRequest()
          defineCancel()
          defineData()

          function defineFeed() {
            var enc = [encodings.bytes]

            Feed.encodingLength = encodingLength
            Feed.encode = encode
            Feed.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.discoveryKey))
                throw new Error("discoveryKey is required")
              var len = enc[0].encodingLength(obj.discoveryKey)
              length += 1 + len
              if (defined(obj.nonce)) {
                var len = enc[0].encodingLength(obj.nonce)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.discoveryKey))
                throw new Error("discoveryKey is required")
              buf[offset++] = 10
              enc[0].encode(obj.discoveryKey, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.nonce)) {
                buf[offset++] = 18
                enc[0].encode(obj.nonce, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                discoveryKey: null,
                nonce: null
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.discoveryKey = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.nonce = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineHandshake() {
            var enc = [encodings.bytes, encodings.bool, encodings.string]

            Handshake.encodingLength = encodingLength
            Handshake.encode = encode
            Handshake.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (defined(obj.id)) {
                var len = enc[0].encodingLength(obj.id)
                length += 1 + len
              }
              if (defined(obj.live)) {
                var len = enc[1].encodingLength(obj.live)
                length += 1 + len
              }
              if (defined(obj.userData)) {
                var len = enc[0].encodingLength(obj.userData)
                length += 1 + len
              }
              if (defined(obj.extensions)) {
                for (var i = 0; i < obj.extensions.length; i++) {
                  if (!defined(obj.extensions[i])) continue
                  var len = enc[2].encodingLength(obj.extensions[i])
                  length += 1 + len
                }
              }
              if (defined(obj.ack)) {
                var len = enc[1].encodingLength(obj.ack)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (defined(obj.id)) {
                buf[offset++] = 10
                enc[0].encode(obj.id, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.live)) {
                buf[offset++] = 16
                enc[1].encode(obj.live, buf, offset)
                offset += enc[1].encode.bytes
              }
              if (defined(obj.userData)) {
                buf[offset++] = 26
                enc[0].encode(obj.userData, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.extensions)) {
                for (var i = 0; i < obj.extensions.length; i++) {
                  if (!defined(obj.extensions[i])) continue
                  buf[offset++] = 34
                  enc[2].encode(obj.extensions[i], buf, offset)
                  offset += enc[2].encode.bytes
                }
              }
              if (defined(obj.ack)) {
                buf[offset++] = 40
                enc[1].encode(obj.ack, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                id: null,
                live: false,
                userData: null,
                extensions: [],
                ack: false
              }
              while (true) {
                if (end <= offset) {
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.id = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 2:
                    obj.live = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  case 3:
                    obj.userData = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 4:
                    obj.extensions.push(enc[2].decode(buf, offset))
                    offset += enc[2].decode.bytes
                    break
                  case 5:
                    obj.ack = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineInfo() {
            var enc = [encodings.bool]

            Info.encodingLength = encodingLength
            Info.encode = encode
            Info.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (defined(obj.uploading)) {
                var len = enc[0].encodingLength(obj.uploading)
                length += 1 + len
              }
              if (defined(obj.downloading)) {
                var len = enc[0].encodingLength(obj.downloading)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (defined(obj.uploading)) {
                buf[offset++] = 8
                enc[0].encode(obj.uploading, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.downloading)) {
                buf[offset++] = 16
                enc[0].encode(obj.downloading, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                uploading: false,
                downloading: false
              }
              while (true) {
                if (end <= offset) {
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.uploading = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 2:
                    obj.downloading = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineHave() {
            var enc = [encodings.varint, encodings.bytes]

            Have.encodingLength = encodingLength
            Have.encode = encode
            Have.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              if (defined(obj.bitfield)) {
                var len = enc[1].encodingLength(obj.bitfield)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.bitfield)) {
                buf[offset++] = 26
                enc[1].encode(obj.bitfield, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 1,
                bitfield: null
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 3:
                    obj.bitfield = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineUnhave() {
            var enc = [encodings.varint]

            Unhave.encodingLength = encodingLength
            Unhave.encode = encode
            Unhave.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 1
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineWant() {
            var enc = [encodings.varint]

            Want.encodingLength = encodingLength
            Want.encode = encode
            Want.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 0
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineUnwant() {
            var enc = [encodings.varint]

            Unwant.encodingLength = encodingLength
            Unwant.encode = encode
            Unwant.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.start)) throw new Error("start is required")
              var len = enc[0].encodingLength(obj.start)
              length += 1 + len
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.start)) throw new Error("start is required")
              buf[offset++] = 8
              enc[0].encode(obj.start, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.length)) {
                buf[offset++] = 16
                enc[0].encode(obj.length, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                start: 0,
                length: 0
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.length = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineRequest() {
            var enc = [encodings.varint, encodings.bool]

            Request.encodingLength = encodingLength
            Request.encode = encode
            Request.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.index)) throw new Error("index is required")
              var len = enc[0].encodingLength(obj.index)
              length += 1 + len
              if (defined(obj.bytes)) {
                var len = enc[0].encodingLength(obj.bytes)
                length += 1 + len
              }
              if (defined(obj.hash)) {
                var len = enc[1].encodingLength(obj.hash)
                length += 1 + len
              }
              if (defined(obj.nodes)) {
                var len = enc[0].encodingLength(obj.nodes)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.index)) throw new Error("index is required")
              buf[offset++] = 8
              enc[0].encode(obj.index, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.bytes)) {
                buf[offset++] = 16
                enc[0].encode(obj.bytes, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.hash)) {
                buf[offset++] = 24
                enc[1].encode(obj.hash, buf, offset)
                offset += enc[1].encode.bytes
              }
              if (defined(obj.nodes)) {
                buf[offset++] = 32
                enc[0].encode(obj.nodes, buf, offset)
                offset += enc[0].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                index: 0,
                bytes: 0,
                hash: false,
                nodes: 0
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.bytes = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 3:
                    obj.hash = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  case 4:
                    obj.nodes = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineCancel() {
            var enc = [encodings.varint, encodings.bool]

            Cancel.encodingLength = encodingLength
            Cancel.encode = encode
            Cancel.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.index)) throw new Error("index is required")
              var len = enc[0].encodingLength(obj.index)
              length += 1 + len
              if (defined(obj.bytes)) {
                var len = enc[0].encodingLength(obj.bytes)
                length += 1 + len
              }
              if (defined(obj.hash)) {
                var len = enc[1].encodingLength(obj.hash)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.index)) throw new Error("index is required")
              buf[offset++] = 8
              enc[0].encode(obj.index, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.bytes)) {
                buf[offset++] = 16
                enc[0].encode(obj.bytes, buf, offset)
                offset += enc[0].encode.bytes
              }
              if (defined(obj.hash)) {
                buf[offset++] = 24
                enc[1].encode(obj.hash, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                index: 0,
                bytes: 0,
                hash: false
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.bytes = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    break
                  case 3:
                    obj.hash = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defineData() {
            var Node = (Data.Node = {
              buffer: true,
              encodingLength: null,
              encode: null,
              decode: null
            })

            defineNode()

            function defineNode() {
              var enc = [encodings.varint, encodings.bytes]

              Node.encodingLength = encodingLength
              Node.encode = encode
              Node.decode = decode

              function encodingLength(obj) {
                var length = 0
                if (!defined(obj.index)) throw new Error("index is required")
                var len = enc[0].encodingLength(obj.index)
                length += 1 + len
                if (!defined(obj.hash)) throw new Error("hash is required")
                var len = enc[1].encodingLength(obj.hash)
                length += 1 + len
                if (!defined(obj.size)) throw new Error("size is required")
                var len = enc[0].encodingLength(obj.size)
                length += 1 + len
                return length
              }

              function encode(obj, buf, offset) {
                if (!offset) offset = 0
                if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
                var oldOffset = offset
                if (!defined(obj.index)) throw new Error("index is required")
                buf[offset++] = 8
                enc[0].encode(obj.index, buf, offset)
                offset += enc[0].encode.bytes
                if (!defined(obj.hash)) throw new Error("hash is required")
                buf[offset++] = 18
                enc[1].encode(obj.hash, buf, offset)
                offset += enc[1].encode.bytes
                if (!defined(obj.size)) throw new Error("size is required")
                buf[offset++] = 24
                enc[0].encode(obj.size, buf, offset)
                offset += enc[0].encode.bytes
                encode.bytes = offset - oldOffset
                return buf
              }

              function decode(buf, offset, end) {
                if (!offset) offset = 0
                if (!end) end = buf.length
                if (!(end <= buf.length && offset <= buf.length))
                  throw new Error("Decoded message is not valid")
                var oldOffset = offset
                var obj = {
                  index: 0,
                  hash: null,
                  size: 0
                }
                var found0 = false
                var found1 = false
                var found2 = false
                while (true) {
                  if (end <= offset) {
                    if (!found0 || !found1 || !found2)
                      throw new Error("Decoded message is not valid")
                    decode.bytes = offset - oldOffset
                    return obj
                  }
                  var prefix = varint.decode(buf, offset)
                  offset += varint.decode.bytes
                  var tag = prefix >> 3
                  switch (tag) {
                    case 1:
                      obj.index = enc[0].decode(buf, offset)
                      offset += enc[0].decode.bytes
                      found0 = true
                      break
                    case 2:
                      obj.hash = enc[1].decode(buf, offset)
                      offset += enc[1].decode.bytes
                      found1 = true
                      break
                    case 3:
                      obj.size = enc[0].decode(buf, offset)
                      offset += enc[0].decode.bytes
                      found2 = true
                      break
                    default:
                      offset = skip(prefix & 7, buf, offset)
                  }
                }
              }
            }

            var enc = [encodings.varint, encodings.bytes, Node]

            Data.encodingLength = encodingLength
            Data.encode = encode
            Data.decode = decode

            function encodingLength(obj) {
              var length = 0
              if (!defined(obj.index)) throw new Error("index is required")
              var len = enc[0].encodingLength(obj.index)
              length += 1 + len
              if (defined(obj.value)) {
                var len = enc[1].encodingLength(obj.value)
                length += 1 + len
              }
              if (defined(obj.nodes)) {
                for (var i = 0; i < obj.nodes.length; i++) {
                  if (!defined(obj.nodes[i])) continue
                  var len = enc[2].encodingLength(obj.nodes[i])
                  length += varint.encodingLength(len)
                  length += 1 + len
                }
              }
              if (defined(obj.signature)) {
                var len = enc[1].encodingLength(obj.signature)
                length += 1 + len
              }
              return length
            }

            function encode(obj, buf, offset) {
              if (!offset) offset = 0
              if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
              var oldOffset = offset
              if (!defined(obj.index)) throw new Error("index is required")
              buf[offset++] = 8
              enc[0].encode(obj.index, buf, offset)
              offset += enc[0].encode.bytes
              if (defined(obj.value)) {
                buf[offset++] = 18
                enc[1].encode(obj.value, buf, offset)
                offset += enc[1].encode.bytes
              }
              if (defined(obj.nodes)) {
                for (var i = 0; i < obj.nodes.length; i++) {
                  if (!defined(obj.nodes[i])) continue
                  buf[offset++] = 26
                  varint.encode(
                    enc[2].encodingLength(obj.nodes[i]),
                    buf,
                    offset
                  )
                  offset += varint.encode.bytes
                  enc[2].encode(obj.nodes[i], buf, offset)
                  offset += enc[2].encode.bytes
                }
              }
              if (defined(obj.signature)) {
                buf[offset++] = 34
                enc[1].encode(obj.signature, buf, offset)
                offset += enc[1].encode.bytes
              }
              encode.bytes = offset - oldOffset
              return buf
            }

            function decode(buf, offset, end) {
              if (!offset) offset = 0
              if (!end) end = buf.length
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid")
              var oldOffset = offset
              var obj = {
                index: 0,
                value: null,
                nodes: [],
                signature: null
              }
              var found0 = false
              while (true) {
                if (end <= offset) {
                  if (!found0) throw new Error("Decoded message is not valid")
                  decode.bytes = offset - oldOffset
                  return obj
                }
                var prefix = varint.decode(buf, offset)
                offset += varint.decode.bytes
                var tag = prefix >> 3
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset)
                    offset += enc[0].decode.bytes
                    found0 = true
                    break
                  case 2:
                    obj.value = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  case 3:
                    var len = varint.decode(buf, offset)
                    offset += varint.decode.bytes
                    obj.nodes.push(enc[2].decode(buf, offset, offset + len))
                    offset += enc[2].decode.bytes
                    break
                  case 4:
                    obj.signature = enc[1].decode(buf, offset)
                    offset += enc[1].decode.bytes
                    break
                  default:
                    offset = skip(prefix & 7, buf, offset)
                }
              }
            }
          }

          function defined(val) {
            return (
              val !== null &&
              val !== undefined &&
              (typeof val !== "number" || !isNaN(val))
            )
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "protocol-buffers-encodings": 45 }
    ],
    30: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var equals = require("buffer-equals")
          var low = require("last-one-wins")
          var remove = require("unordered-array-remove")
          var set = require("unordered-set")
          var merkle = require("merkle-tree-stream/generator")
          var flat = require("flat-tree")
          var bulk = require("bulk-write-stream")
          var from = require("from2")
          var codecs = require("codecs")
          var thunky = require("thunky")
          var batcher = require("atomic-batcher")
          var inherits = require("inherits")
          var events = require("events")
          var raf = require("random-access-file")
          var bitfield = require("./lib/bitfield")
          var sparseBitfield = require("sparse-bitfield")
          var treeIndex = require("./lib/tree-index")
          var storage = require("./lib/storage")
          var crypto = require("./lib/crypto")
          var nextTick = require("process-nextick-args")
          var bufferFrom = require("buffer-from")
          var bufferAlloc = require("buffer-alloc-unsafe")
          var replicate = null

          module.exports = Feed

          function Feed(createStorage, key, opts) {
            if (!(this instanceof Feed))
              return new Feed(createStorage, key, opts)
            events.EventEmitter.call(this)

            if (typeof createStorage === "string")
              createStorage = defaultStorage(createStorage)
            if (typeof createStorage !== "function")
              throw new Error("Storage should be a function or string")

            if (typeof key === "string") key = bufferFrom(key, "hex")

            if (!Buffer.isBuffer(key) && !opts) {
              opts = key
              key = null
            }

            if (!opts) opts = {}

            var self = this

            var secretKey = opts.secretKey || null
            if (typeof secretKey === "string")
              secretKey = bufferFrom(secretKey, "hex")

            this.id = opts.id || crypto.randomBytes(32)
            this.live = opts.live !== false
            this.sparse = !!opts.sparse
            this.length = 0
            this.byteLength = 0
            this.maxRequests = opts.maxRequests || 16
            this.key = key || null
            this.discoveryKey = this.key && crypto.discoveryKey(this.key)
            this.secretKey = secretKey
            this.bitfield = null
            this.tree = null
            this.writable = !!opts.writable
            this.readable = true
            this.opened = false
            this.closed = false
            this.allowPush = !!opts.allowPush
            this.peers = []

            // hooks
            this._onwrite = opts.onwrite || null

            this._ready = thunky(open) // TODO: if open fails, do not reopen next time
            this._indexing = !!opts.indexing
            this._createIfMissing = opts.createIfMissing !== false
            this._overwrite = !!opts.overwrite
            this._storeSecretKey = opts.storeSecretKey !== false
            this._merkle = null
            this._storage = storage(createStorage, opts.storageCacheSize)
            this._batch = batcher(this._onwrite ? workHook : work)

            this._waiting = []
            this._selections = []
            this._reserved = sparseBitfield()
            this._synced = null

            this._codec = toCodec(opts.valueEncoding)
            this._sync = low(sync)
            if (!this.sparse) this.download({ start: 0, end: -1 })

            // open it right away. TODO: do not reopen (i.e, set a flag not to retry)
            this._ready(onerror)

            function onerror(err) {
              if (err) self.emit("error", err)
            }

            function workHook(values, cb) {
              self._appendHook(values, cb)
            }

            function work(values, cb) {
              self._append(values, cb)
            }

            function sync(_, cb) {
              self._syncBitfield(cb)
            }

            function open(cb) {
              self._open(cb)
            }
          }

          inherits(Feed, events.EventEmitter)

          Feed.discoveryKey = crypto.discoveryKey

          // TODO: instead of using a getter, update on remote-update/add/remove
          Object.defineProperty(Feed.prototype, "remoteLength", {
            enumerable: true,
            get: function() {
              var len = 0
              for (var i = 0; i < this.peers.length; i++) {
                var remoteLength = this.peers[i].remoteLength
                if (remoteLength > len) len = remoteLength
              }
              return len
            }
          })

          Feed.prototype.replicate = function(opts) {
            // Lazy load replication deps
            if (!replicate) replicate = require("./lib/replicate")

            if (
              (!this._selections.length || this._selections[0].end !== -1) &&
              !this.sparse &&
              !(opts && opts.live)
            ) {
              // hack!! proper fix is to refactor ./replicate to *not* clear our non-sparse selection
              this.download({ start: 0, end: -1 })
            }

            return replicate(this, opts || {})
          }

          Feed.prototype.ready = function(onready) {
            this._ready(function(err) {
              if (!err) onready()
            })
          }

          Feed.prototype.update = function(len, cb) {
            if (typeof len === "function") return this.update(-1, len)
            if (typeof len !== "number") len = -1
            if (!cb) cb = noop

            var self = this

            this.ready(function(err) {
              if (err) return cb(err)
              if (len === -1) len = self.length + 1
              if (self.length >= len) return cb(null)

              if (self.writable) cb = self._writeStateReloader(cb)

              self._waiting.push({
                hash: true,
                bytes: 0,
                index: len - 1,
                update: true,
                callback: cb
              })

              self._updatePeers()
            })
          }

          // will reload the writable state. used by .update on a writable peer
          Feed.prototype._writeStateReloader = function(cb) {
            var self = this
            return function(err) {
              if (err) return cb(err)

              self._roots(self.length, function(err, roots) {
                if (err) return cb(err)
                self._merkle = merkle(crypto, roots)
                cb(null)
              })
            }
          }

          Feed.prototype._open = function(cb) {
            var self = this
            var generatedKey = false

            // TODO: clean up the duplicate code below ...

            this._storage.openKey(function(_, key) {
              if (key && !self._overwrite && !self.key) self.key = key

              if (!self.key && self.live) {
                var keyPair = crypto.keyPair()
                self.secretKey = keyPair.secretKey
                self.key = keyPair.publicKey
                generatedKey = true
              }

              self.discoveryKey = self.key && crypto.discoveryKey(self.key)
              self._storage.open(
                { key: self.key, discoveryKey: self.discoveryKey },
                onopen
              )
            })

            function onopen(err, state) {
              if (err) return cb(err)

              // if no key but we have data do a bitfield reset since we cannot verify the data.
              if (!state.key && state.bitfield.length) {
                self._overwrite = true
              }

              if (self._overwrite) {
                state.bitfield.fill(0)
                state.key = state.secretKey = null
              }

              self.bitfield = bitfield(state.bitfield)
              self.tree = treeIndex(self.bitfield.tree)
              self.length = self.tree.blocks()

              if (state.key && self.key && !equals(state.key, self.key)) {
                return cb(new Error("Another hypercore is stored here"))
              }

              if (state.key) self.key = state.key
              if (state.secretKey) self.secretKey = state.secretKey

              // verify key and secretKey go together
              if (self.key && self.secretKey) {
                var challenge = bufferAlloc(0)
                if (
                  !crypto.verify(
                    challenge,
                    crypto.sign(challenge, self.secretKey),
                    self.key
                  )
                ) {
                  return cb(new Error("Key and secret do not match"))
                }
              }

              if (!self.length) return onsignature(null, null)
              self._storage.getSignature(self.length - 1, onsignature)

              function onsignature(_, sig) {
                if (self.length) self.live = !!sig

                if ((generatedKey || !self.key) && !self._createIfMissing) {
                  return cb(new Error("No hypercore is stored here"))
                }

                if (!self.key && self.live) {
                  var keyPair = crypto.keyPair()
                  self.secretKey = keyPair.secretKey
                  self.key = keyPair.publicKey
                }

                var writable = !!self.secretKey || self.key === null

                if (!writable && self.writable)
                  return cb(new Error("Feed is not writable"))
                self.writable = writable
                self.discoveryKey = self.key && crypto.discoveryKey(self.key)

                if (self._storeSecretKey && !self.secretKey) {
                  self._storeSecretKey = false
                }

                var shouldWriteKey =
                  generatedKey || !safeBufferEquals(self.key, state.key)
                var shouldWriteSecretKey =
                  self._storeSecretKey &&
                  (generatedKey ||
                    !safeBufferEquals(self.secretKey, state.secretKey))

                var missing =
                  1 +
                  (shouldWriteKey ? 1 : 0) +
                  (shouldWriteSecretKey ? 1 : 0) +
                  (self._overwrite ? 1 : 0)
                var error = null

                if (shouldWriteKey) self._storage.key.write(0, self.key, done)
                if (shouldWriteSecretKey)
                  self._storage.secretKey.write(0, self.secretKey, done)

                if (self._overwrite) {
                  // TODO: support storage.resize for this instead
                  self._storage.putBitfield(0, state.bitfield, done)
                }

                done(null)

                function done(err) {
                  if (err) error = err
                  if (--missing) return
                  if (error) return cb(error)
                  self._roots(self.length, onroots)
                }

                function onroots(err, roots) {
                  if (err) return cb(err)

                  self._merkle = merkle(crypto, roots)
                  self.byteLength = roots.reduce(addSize, 0)
                  self.opened = true
                  self.emit("ready")

                  cb(null)
                }
              }
            }
          }

          Feed.prototype.download = function(range, cb) {
            if (typeof range === "function") return this.download(null, range)
            if (typeof range === "number")
              range = { start: range, end: range + 1 }
            if (!range) range = {}

            // TODO: if no peers, check if range is already satisfied and nextTick(cb) if so
            // this._updatePeers does this for us when there is a peer though, so not critical

            var sel = {
              _index: this._selections.length,
              hash: !!range.hash,
              iterator: null,
              start: range.start || 0,
              end: range.end || -1,
              linear: !!range.linear,
              callback: cb || noop
            }

            this._selections.push(sel)
            this._updatePeers()

            return sel
          }

          Feed.prototype.undownload = function(range) {
            if (typeof range === "number")
              range = { start: range, end: range + 1 }
            if (!range) range = {}

            if (range.callback && range._index > -1) {
              set.remove(this._selections, range)
              nextTick(range.callback, new Error("Download was cancelled"))
              return
            }

            var start = range.start || 0
            var end = range.end || -1
            var hash = !!range.hash
            var linear = !!range.linear

            for (var i = 0; i < this._selections.length; i++) {
              var s = this._selections[i]

              if (
                s.start === start &&
                s.end === end &&
                s.hash === hash &&
                s.linear === linear
              ) {
                set.remove(this._selections, s)
                nextTick(s.callback, new Error("Download was cancelled"))
                return
              }
            }
          }

          Feed.prototype.digest = function(index) {
            return this.tree.digest(2 * index)
          }

          Feed.prototype.proof = function(index, opts, cb) {
            if (typeof opts === "function") return this.proof(index, null, opts)
            if (!this.opened) return this._readyAndProof(index, opts, cb)
            if (!opts) opts = {}

            var proof = this.tree.proof(2 * index, opts)
            if (!proof)
              return cb(new Error("No proof available for this index"))

            var needsSig = this.live && !!proof.verifiedBy
            var pending = proof.nodes.length + (needsSig ? 1 : 0)
            var error = null
            var signature = null
            var nodes = new Array(proof.nodes.length)

            if (!pending) return cb(null, { nodes: nodes, signature: null })

            for (var i = 0; i < proof.nodes.length; i++) {
              this._storage.getNode(proof.nodes[i], onnode)
            }
            if (needsSig) {
              this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature)
            }

            function onsignature(err, sig) {
              if (sig) signature = sig
              onnode(err, null)
            }

            function onnode(err, node) {
              if (err) error = err

              if (node) {
                nodes[proof.nodes.indexOf(node.index)] = node
              }

              if (--pending) return
              if (error) return cb(error)
              cb(null, { nodes: nodes, signature: signature })
            }
          }

          Feed.prototype._readyAndProof = function(index, opts, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.proof(index, opts, cb)
            })
          }

          Feed.prototype.put = function(index, data, proof, cb) {
            if (!this.opened) return this._readyAndPut(index, data, proof, cb)
            this._putBuffer(index, this._codec.encode(data), proof, null, cb)
          }

          Feed.prototype.cancel = function(start, end) {
            // TODO: use same argument scheme as download
            if (!end) end = start + 1

            // cancel these right away as .download does not wait for ready
            for (var i = this._selections.length - 1; i >= 0; i--) {
              var sel = this._selections[i]
              if (start <= sel.start && sel.end <= end) {
                this.undownload(sel)
              }
            }

            // defer the last part until after ready as .get does that as well
            if (this.opened) this._cancel(start, end)
            else this._readyAndCancel(start, end)
          }

          Feed.prototype._cancel = function(start, end) {
            var i = 0

            for (i = start; i < end; i++) {
              this._reserved.set(i, false) // TODO: send cancel message if set returns true
            }

            for (i = this._waiting.length - 1; i >= 0; i--) {
              var w = this._waiting[i]
              if (
                (start <= w.start && w.end <= end) ||
                (start <= w.index && w.index < end)
              ) {
                remove(this._waiting, i)
                if (w.callback)
                  nextTick(w.callback, new Error("Request cancelled"))
              }
            }
          }

          Feed.prototype.clear = function(start, end, opts, cb) {
            // TODO: use same argument scheme as download
            if (typeof end === "function")
              return this.clear(start, start + 1, null, end)
            if (typeof opts === "function")
              return this.clear(start, end, null, opts)
            if (!opts) opts = {}
            if (!end) end = start + 1
            if (!cb) cb = noop

            // TODO: this needs some work. fx we can only calc byte offset for blocks we know about
            // so internally we should make sure to only do that. We should use the merkle tree for this

            var self = this
            var byteOffset =
              start === 0
                ? 0
                : typeof opts.byteOffset === "number"
                  ? opts.byteOffset
                  : -1
            var byteLength =
              typeof opts.byteLength === "number" ? opts.byteLength : -1

            this._ready(function(err) {
              if (err) return cb(err)

              var modified = false

              // TODO: use a buffer.fill thing here to speed this up!

              for (var i = start; i < end; i++) {
                if (self.bitfield.set(i, false)) modified = true
              }

              if (!modified) return nextTick(cb)

              // TODO: write to a tmp/update file that we want to del this incase it crashes will del'ing

              self._unannounce({ start: start, length: end - start })
              if (opts.delete === false || self._indexing) return sync()
              if (byteOffset > -1) return onstartbytes(null, byteOffset)
              self._storage.dataOffset(start, [], onstartbytes)

              function sync() {
                self.emit("clear", start, end)
                self._sync(null, cb)
              }

              function onstartbytes(err, offset) {
                if (err) return cb(err)
                byteOffset = offset
                if (byteLength > -1)
                  return onendbytes(null, byteLength + byteOffset)
                if (end === self.length)
                  return onendbytes(null, self.byteLength)
                self._storage.dataOffset(end, [], onendbytes)
              }

              function onendbytes(err, end) {
                if (err) return cb(err)
                if (!self._storage.data.del) return sync() // Not all data storage impls del
                self._storage.data.del(byteOffset, end - byteOffset, sync)
              }
            })
          }

          Feed.prototype.signature = function(index, cb) {
            if (typeof index === "function")
              return this.signature(this.length - 1, index)

            if (index < 0 || index >= this.length)
              return cb(new Error("No signature available for this index"))

            this._storage.nextSignature(index, cb)
          }

          Feed.prototype.verify = function(index, signature, cb) {
            var self = this

            this.rootHashes(index, function(err, roots) {
              if (err) return cb(err)

              var checksum = crypto.tree(roots)

              if (!crypto.verify(checksum, signature, self.key)) {
                cb(new Error("Signature verification failed"))
              } else {
                cb(null, true)
              }
            })
          }

          Feed.prototype.rootHashes = function(index, cb) {
            this._getRootsToVerify(index * 2 + 2, {}, [], cb)
          }

          Feed.prototype.seek = function(bytes, opts, cb) {
            if (typeof opts === "function") return this.seek(bytes, null, opts)
            if (!opts) opts = {}
            if (!this.opened) return this._readyAndSeek(bytes, opts, cb)

            var self = this

            this._seek(bytes, function(err, index, offset) {
              if (!err && isBlock(index)) return done(index / 2, offset)
              if (opts.wait === false)
                return cb(err || new Error("Unable to seek to this offset"))

              var start = opts.start || 0
              var end = opts.end || -1

              if (!err) {
                var left = flat.leftSpan(index) / 2
                var right = flat.rightSpan(index) / 2 + 1

                if (left > start) start = left
                if (right < end || end === -1) end = right
              }

              if (end > -1 && end <= start)
                return cb(new Error("Unable to seek to this offset"))

              self._waiting.push({
                hash: opts.hash !== false,
                bytes: bytes,
                index: -1,
                start: start,
                end: end,
                callback: cb || noop
              })

              self._updatePeers()
            })

            function done(index, offset) {
              for (var i = 0; i < self.peers.length; i++) {
                self.peers[i].haveBytes(bytes)
              }
              cb(null, index, offset)
            }
          }

          Feed.prototype._seek = function(offset, cb) {
            if (offset === 0) return cb(null, 0, 0)

            var self = this
            var roots = flat.fullRoots(this.length * 2)
            var nearestRoot = 0

            loop(null, null)

            function onroot(top) {
              if (isBlock(top)) return cb(null, top, offset)

              var left = flat.leftChild(top)
              while (!self.tree.get(left)) {
                if (isBlock(left)) return cb(null, nearestRoot, offset)
                left = flat.leftChild(left)
              }

              self._storage.getNode(left, onleftchild)
            }

            function onleftchild(err, node) {
              if (err) return cb(err)

              if (node.size > offset) {
                nearestRoot = node.index
                onroot(node.index)
              } else {
                offset -= node.size
                onroot(flat.sibling(node.index))
              }
            }

            function loop(err, node) {
              if (err) return cb(err)

              if (node) {
                if (node.size > offset) {
                  nearestRoot = node.index
                  return onroot(node.index)
                }
                offset -= node.size
              }

              if (!roots.length) return cb(new Error("Out of bounds"))
              self._storage.getNode(roots.shift(), loop)
            }
          }

          Feed.prototype._readyAndSeek = function(bytes, opts, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.seek(bytes, opts, cb)
            })
          }

          Feed.prototype._getBuffer = function(index, cb) {
            this._storage.getData(index, cb)
          }

          Feed.prototype._putBuffer = function(index, data, proof, from, cb) {
            // TODO: this nodes in proof are not instances of our Node prototype
            // but just similar. Check if this has any v8 perf implications.

            // TODO: if the proof contains a valid signature BUT fails, emit a critical error
            // --> feed should be considered dead

            var self = this
            var trusted = -1
            var missing = []
            var next = 2 * index
            var i = data ? 0 : 1

            while (true) {
              if (this.tree.get(next)) {
                trusted = next
                break
              }

              var sib = flat.sibling(next)
              next = flat.parent(next)

              if (i < proof.nodes.length && proof.nodes[i].index === sib) {
                i++
                continue
              }

              if (!this.tree.get(sib)) break
              missing.push(sib)
            }

            if (trusted === -1 && this.tree.get(next)) trusted = next

            var error = null
            var trustedNode = null
            var missingNodes = new Array(missing.length)
            var pending = missing.length + (trusted > -1 ? 1 : 0)

            for (i = 0; i < missing.length; i++)
              this._storage.getNode(missing[i], onmissing)
            if (trusted > -1) this._storage.getNode(trusted, ontrusted)
            if (!missing.length && trusted === -1) onmissingloaded(null)

            function ontrusted(err, node) {
              if (err) error = err
              if (node) trustedNode = node
              if (!--pending) onmissingloaded(error)
            }

            function onmissing(err, node) {
              if (err) error = err
              if (node) missingNodes[missing.indexOf(node.index)] = node
              if (!--pending) onmissingloaded(error)
            }

            function onmissingloaded(err) {
              if (err) return cb(err)
              self._verifyAndWrite(
                index,
                data,
                proof,
                missingNodes,
                trustedNode,
                from,
                cb
              )
            }
          }

          Feed.prototype._readyAndPut = function(index, data, proof, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.put(index, data, proof, cb)
            })
          }

          Feed.prototype._write = function(index, data, nodes, sig, from, cb) {
            if (!this._onwrite)
              return this._writeAfterHook(index, data, nodes, sig, from, cb)
            this._onwrite(
              index,
              data,
              from,
              writeHookDone(this, index, data, nodes, sig, from, cb)
            )
          }

          function writeHookDone(self, index, data, nodes, sig, from, cb) {
            return function(err) {
              if (err) return cb(err)
              self._writeAfterHook(index, data, nodes, sig, from, cb)
            }
          }

          Feed.prototype._writeAfterHook = function(
            index,
            data,
            nodes,
            sig,
            from,
            cb
          ) {
            var self = this
            var pending = nodes.length + 1 + (sig ? 1 : 0)
            var error = null

            for (var i = 0; i < nodes.length; i++)
              this._storage.putNode(nodes[i].index, nodes[i], ondone)
            if (data) this._storage.putData(index, data, nodes, ondone)
            else ondone()
            if (sig)
              this._storage.putSignature(sig.index, sig.signature, ondone)

            function ondone(err) {
              if (err) error = err
              if (--pending) return
              if (error) return cb(error)
              self._writeDone(index, data, nodes, from, cb)
            }
          }

          Feed.prototype._writeDone = function(index, data, nodes, from, cb) {
            for (var i = 0; i < nodes.length; i++) this.tree.set(nodes[i].index)
            this.tree.set(2 * index)

            if (data) {
              if (this.bitfield.set(index, true))
                this.emit("download", index, data, from)
              if (this.peers.length) this._announce({ start: index }, from)

              if (!this.writable) {
                if (!this._synced)
                  this._synced = this.bitfield.iterator(0, this.length)
                if (this._synced.next() === -1) {
                  this._synced.range(0, this.length)
                  this._synced.seek(0)
                  if (this._synced.next() === -1) {
                    this.emit("sync")
                  }
                }
              }
            }

            this._sync(null, cb)
          }

          Feed.prototype._verifyAndWrite = function(
            index,
            data,
            proof,
            localNodes,
            trustedNode,
            from,
            cb
          ) {
            var visited = []
            var remoteNodes = proof.nodes
            var top = data
              ? new storage.Node(2 * index, crypto.data(data), data.length)
              : remoteNodes.shift()

            // check if we already have the hash for this node
            if (verifyNode(trustedNode, top)) {
              this._write(index, data, visited, null, from, cb)
              return
            }

            // keep hashing with siblings until we reach or trusted node
            while (true) {
              var node = null
              var next = flat.sibling(top.index)

              if (remoteNodes.length && remoteNodes[0].index === next) {
                node = remoteNodes.shift()
                visited.push(node)
              } else if (localNodes.length && localNodes[0].index === next) {
                node = localNodes.shift()
              } else {
                // we cannot create another parent, i.e. these nodes must be roots in the tree
                this._verifyRootsAndWrite(
                  index,
                  data,
                  top,
                  proof,
                  visited,
                  from,
                  cb
                )
                return
              }

              visited.push(top)
              top = new storage.Node(
                flat.parent(top.index),
                crypto.parent(top, node),
                top.size + node.size
              )

              // the tree checks out, write the data and the visited nodes
              if (verifyNode(trustedNode, top)) {
                this._write(index, data, visited, null, from, cb)
                return
              }
            }
          }

          Feed.prototype._verifyRootsAndWrite = function(
            index,
            data,
            top,
            proof,
            nodes,
            from,
            cb
          ) {
            var remoteNodes = proof.nodes
            var lastNode = remoteNodes.length
              ? remoteNodes[remoteNodes.length - 1].index
              : top.index
            var verifiedBy =
              Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2
            var self = this

            this._getRootsToVerify(verifiedBy, top, remoteNodes, function(
              err,
              roots,
              extraNodes
            ) {
              if (err) return cb(err)

              var checksum = crypto.tree(roots)
              var signature = null

              if (self.length && self.live && !proof.signature) {
                return cb(new Error("Remote did not include a signature"))
              }

              if (proof.signature) {
                // check signaturex
                if (!crypto.verify(checksum, proof.signature, self.key)) {
                  return cb(new Error("Remote signature could not be verified"))
                }

                signature = {
                  index: verifiedBy / 2 - 1,
                  signature: proof.signature
                }
              } else {
                // check tree root
                if (!equals(checksum, self.key)) {
                  return cb(new Error("Remote checksum failed"))
                }
              }

              self.live = !!signature

              var length = verifiedBy / 2
              if (length > self.length) {
                // TODO: only emit this after the info has been flushed to storage
                self.length = length
                self.byteLength = roots.reduce(addSize, 0)
                if (self._synced) self._synced.seek(0, self.length)
                self.emit("append")
              }

              self._write(
                index,
                data,
                nodes.concat(extraNodes),
                signature,
                from,
                cb
              )
            })
          }

          Feed.prototype._getRootsToVerify = function(
            verifiedBy,
            top,
            remoteNodes,
            cb
          ) {
            var indexes = flat.fullRoots(verifiedBy)
            var roots = new Array(indexes.length)
            var nodes = []
            var error = null
            var pending = roots.length

            for (var i = 0; i < indexes.length; i++) {
              if (indexes[i] === top.index) {
                nodes.push(top)
                onnode(null, top)
              } else if (
                remoteNodes.length &&
                indexes[i] === remoteNodes[0].index
              ) {
                nodes.push(remoteNodes[0])
                onnode(null, remoteNodes.shift())
              } else if (this.tree.get(indexes[i])) {
                this._storage.getNode(indexes[i], onnode)
              } else {
                onnode(new Error("Missing tree roots needed for verify"))
              }
            }

            function onnode(err, node) {
              if (err) error = err
              if (node) roots[indexes.indexOf(node.index)] = node
              if (!--pending) done(error)
            }

            function done(err) {
              if (err) return cb(err)

              cb(null, roots, nodes)
            }
          }

          Feed.prototype._announce = function(message, from) {
            for (var i = 0; i < this.peers.length; i++) {
              var peer = this.peers[i]
              if (peer !== from) peer.have(message)
            }
          }

          Feed.prototype._unannounce = function(message) {
            for (var i = 0; i < this.peers.length; i++)
              this.peers[i].unhave(message)
          }

          Feed.prototype.downloaded = function(start, end) {
            return this.bitfield.total(start, end)
          }

          Feed.prototype.has = function(start, end) {
            if (end === undefined) return this.bitfield.get(start)
            var total = end - start
            return total === this.bitfield.total(start, end)
          }

          Feed.prototype.head = function(opts, cb) {
            if (typeof opts === "function") return this.head({}, opts)
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              if (self.length === 0) cb(new Error("feed is empty"))
              else self.get(self.length - 1, cb)
            })
          }

          Feed.prototype.get = function(index, opts, cb) {
            if (typeof opts === "function") return this.get(index, null, opts)
            if (!this.opened) return this._readyAndGet(index, opts, cb)

            if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout)

            if (!this.bitfield.get(index)) {
              if (opts && opts.wait === false)
                return cb(new Error("Block not downloaded"))

              this._waiting.push({
                bytes: 0,
                hash: false,
                index: index,
                options: opts,
                callback: cb
              })
              this._updatePeers()
              return
            }

            if (opts && opts.valueEncoding)
              cb = wrapCodec(toCodec(opts.valueEncoding), cb)
            else if (this._codec !== codecs.binary)
              cb = wrapCodec(this._codec, cb)

            this._getBuffer(index, cb)
          }

          Feed.prototype._readyAndGet = function(index, opts, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self.get(index, opts, cb)
            })
          }

          Feed.prototype._updatePeers = function() {
            for (var i = 0; i < this.peers.length; i++) this.peers[i].update()
          }

          Feed.prototype.createWriteStream = function() {
            var self = this
            return bulk.obj(write)

            function write(batch, cb) {
              self._batch(batch, cb)
            }
          }

          Feed.prototype.createReadStream = function(opts) {
            if (!opts) opts = {}

            var self = this
            var start = opts.start || 0
            var end = typeof opts.end === "number" ? opts.end : -1
            var live = !!opts.live
            var snapshot = opts.snapshot !== false
            var first = true
            var range = this.download({ start: start, end: end, linear: true })

            return from
              .obj(read)
              .on("end", cleanup)
              .on("close", cleanup)

            function read(size, cb) {
              if (!self.opened) return open(size, cb)

              if (first) {
                if (end === -1) {
                  if (live) end = Infinity
                  else if (snapshot) end = self.length
                }
                if (opts.tail) start = self.length
                first = false
              }

              if (start === end || (end === -1 && start === self.length))
                return cb(null, null)
              self.get(start++, opts, cb)
            }

            function cleanup() {
              if (!range) return
              self.undownload(range)
              range = null
            }

            function open(size, cb) {
              self._ready(function(err) {
                if (err) return cb(err)
                read(size, cb)
              })
            }
          }

          // TODO: when calling finalize on a live feed write an END_OF_FEED block (length === 0?)
          Feed.prototype.finalize = function(cb) {
            if (!this.key) {
              this.key = crypto.tree(this._merkle.roots)
              this.discoveryKey = crypto.discoveryKey(this.key)
            }
            this._storage.key.write(0, this.key, cb)
          }

          Feed.prototype.append = function(batch, cb) {
            this._batch(Array.isArray(batch) ? batch : [batch], cb || noop)
          }

          Feed.prototype.flush = function(cb) {
            this._batch([], cb)
          }

          Feed.prototype.close = function(cb) {
            var self = this

            this._ready(function() {
              self.writable = false
              self.readable = false
              self._storage.close(function(err) {
                if (!self.closed && !err) {
                  self.closed = true
                  self.emit("close")
                }
                if (cb) cb(err)
              })
            })
          }

          Feed.prototype._appendHook = function(batch, cb) {
            var self = this
            var missing = batch.length
            var error = null

            if (!missing) return this._append(batch, cb)
            for (var i = 0; i < batch.length; i++) {
              this._onwrite(i + this.length, batch[i], null, done)
            }

            function done(err) {
              if (err) error = err
              if (--missing) return
              if (error) return cb(error)
              self._append(batch, cb)
            }
          }

          Feed.prototype._append = function(batch, cb) {
            if (!this.opened) return this._readyAndAppend(batch, cb)
            if (!this.writable)
              return cb(
                new Error("This feed is not writable. Did you create it?")
              )

            var self = this
            var pending =
              this.live && batch.length ? 1 + batch.length : batch.length
            var offset = 0
            var error = null

            if (!pending) return cb()

            for (var i = 0; i < batch.length; i++) {
              var data = this._codec.encode(batch[i])
              var nodes = this._merkle.next(data)

              if (this._indexing) done(null)
              else
                this._storage.data.write(this.byteLength + offset, data, done)

              if (this.live && i === batch.length - 1) {
                var sig = crypto.sign(
                  crypto.tree(this._merkle.roots),
                  this.secretKey
                )
                this._storage.putSignature(this.length + i, sig, done)
              }

              pending += nodes.length
              offset += data.length

              for (var j = 0; j < nodes.length; j++) {
                var node = nodes[j]
                this._storage.putNode(node.index, node, done)
              }
            }

            function done(err) {
              if (err) error = err
              if (--pending) return
              if (error) return cb(error)

              var start = self.length

              // TODO: only emit append and update length / byteLength after the info has been flushed to storage
              self.byteLength += offset
              for (var i = 0; i < batch.length; i++) {
                self.bitfield.set(self.length, true)
                self.tree.set(2 * self.length++)
              }
              self.emit("append")

              var message =
                self.length - start > 1
                  ? { start: start, length: self.length - start }
                  : { start: start }
              if (self.peers.length) self._announce(message)

              self._sync(null, cb)
            }
          }

          Feed.prototype._readyAndAppend = function(batch, cb) {
            var self = this
            this._ready(function(err) {
              if (err) return cb(err)
              self._append(batch, cb)
            })
          }

          Feed.prototype._readyAndCancel = function(start, end) {
            var self = this
            this.ready(function() {
              self._cancel(start, end)
            })
          }

          Feed.prototype._pollWaiting = function() {
            var len = this._waiting.length
            for (var i = 0; i < len; i++) {
              var next = this._waiting[i]
              if (!next.bytes && !this.bitfield.get(next.index)) continue

              remove(this._waiting, i--)
              len--

              if (next.bytes) this.seek(next.bytes, next, next.callback)
              else if (next.update) this.update(next.index + 1, next.callback)
              else this.get(next.index, next.options, next.callback)
            }
          }

          Feed.prototype._syncBitfield = function(cb) {
            var missing = this.bitfield.pages.updates.length
            var next = null
            var error = null

            // All data / nodes have been written now. We still need to update the bitfields though

            // TODO 1: if the program fails during this write the bitfield might not have been fully written
            // HOWEVER, we can easily recover from this by traversing the tree and checking if the nodes exists
            // on disk. So if a get fails, it should try and recover once.

            // TODO 2: if .writable append bitfield updates into a single buffer for extra perf
            // Added benefit is that if the program exits while flushing the bitfield the feed will only get
            // truncated and not have missing chunks which is what you expect.

            if (!missing) {
              this._pollWaiting()
              return cb(null)
            }

            while ((next = this.bitfield.pages.lastUpdate()) !== null) {
              this._storage.putBitfield(next.offset, next.buffer, ondone)
            }

            this._pollWaiting()

            function ondone(err) {
              if (err) error = err
              if (--missing) return
              cb(error)
            }
          }

          Feed.prototype._roots = function(index, cb) {
            var roots = flat.fullRoots(2 * index)
            var result = new Array(roots.length)
            var pending = roots.length
            var error = null

            if (!pending) return cb(null, result)

            for (var i = 0; i < roots.length; i++) {
              this._storage.getNode(roots[i], onnode)
            }

            function onnode(err, node) {
              if (err) error = err
              if (node) result[roots.indexOf(node.index)] = node
              if (--pending) return
              if (error) return cb(error)
              cb(null, result)
            }
          }

          function noop() {}

          function verifyNode(trusted, node) {
            return (
              trusted &&
              trusted.index === node.index &&
              equals(trusted.hash, node.hash)
            )
          }

          function addSize(size, node) {
            return size + node.size
          }

          function isBlock(index) {
            return (index & 1) === 0
          }

          function defaultStorage(dir) {
            return function(name) {
              return raf(name, { directory: dir })
            }
          }

          function toCodec(enc) {
            // Switch to ndjson encoding if JSON is used. That way data files parse like ndjson \o/
            return codecs(enc === "json" ? "ndjson" : enc)
          }

          function wrapCodec(enc, cb) {
            return function(err, buf) {
              if (err) return cb(err)
              try {
                buf = enc.decode(buf)
              } catch (err) {
                return cb(err)
              }
              cb(null, buf)
            }
          }

          function timeoutCallback(cb, timeout) {
            var failed = false
            var id = setTimeout(ontimeout, timeout)
            return done

            function ontimeout() {
              failed = true
              // TODO: make libs/errors for all this stuff
              var err = new Error("ETIMEDOUT")
              err.code = "ETIMEDOUT"
              cb(err)
            }

            function done(err, val) {
              if (failed) return
              clearTimeout(id)
              cb(err, val)
            }
          }

          // buffer-equals, but handle 'null' buffer parameters.
          function safeBufferEquals(a, b) {
            if (!a) return !b
            if (!b) return !a
            return equals(a, b)
          }
        }.call(this, { isBuffer: require("../is-buffer/index.js") }))
      },
      {
        "../is-buffer/index.js": 38,
        "./lib/bitfield": 31,
        "./lib/crypto": 32,
        "./lib/replicate": 33,
        "./lib/storage": 34,
        "./lib/tree-index": 35,
        "atomic-batcher": 4,
        "buffer-alloc-unsafe": 15,
        "buffer-equals": 17,
        "buffer-from": 19,
        "bulk-write-stream": 21,
        codecs: 22,
        events: 24,
        "flat-tree": 25,
        from2: 26,
        inherits: 37,
        "last-one-wins": 39,
        "merkle-tree-stream/generator": 41,
        "process-nextick-args": 43,
        "random-access-file": 46,
        "sparse-bitfield": 72,
        thunky: 74,
        "unordered-array-remove": 77,
        "unordered-set": 78
      }
    ],
    31: [
      function(require, module, exports) {
        var flat = require("flat-tree")
        var rle = require("bitfield-rle")
        var pager = require("memory-pager")
        var bitfield = require("sparse-bitfield")

        var INDEX_UPDATE_MASK = [63, 207, 243, 252]
        var INDEX_ITERATE_MASK = [0, 192, 240, 252]
        var DATA_ITERATE_MASK = [128, 192, 224, 240, 248, 252, 254, 255]
        var DATA_UPDATE_MASK = [127, 191, 223, 239, 247, 251, 253, 254]
        var MAP_PARENT_RIGHT = new Array(256)
        var MAP_PARENT_LEFT = new Array(256)
        var NEXT_DATA_0_BIT = new Array(256)
        var NEXT_INDEX_0_BIT = new Array(256)
        var TOTAL_1_BITS = new Array(256)

        for (var i = 0; i < 256; i++) {
          var a = (i & (15 << 4)) >> 4
          var b = i & 15
          var nibble = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]
          MAP_PARENT_RIGHT[i] =
            ((a === 15 ? 3 : a === 0 ? 0 : 1) << 2) |
            (b === 15 ? 3 : b === 0 ? 0 : 1)
          MAP_PARENT_LEFT[i] = MAP_PARENT_RIGHT[i] << 4
          NEXT_DATA_0_BIT[i] =
            i === 255 ? -1 : 8 - Math.ceil(Math.log(256 - i) / Math.log(2))
          NEXT_INDEX_0_BIT[i] =
            i === 255 ? -1 : Math.floor(NEXT_DATA_0_BIT[i] / 2)
          TOTAL_1_BITS[i] = nibble[i >> 4] + nibble[i & 0x0f]
        }

        module.exports = Bitfield

        function Bitfield(buffer) {
          if (!(this instanceof Bitfield)) return new Bitfield(buffer)

          this.pages = pager(3328)

          if (buffer) {
            for (var i = 0; i < buffer.length; i += 3328) {
              this.pages.set(i / 3328, buffer.slice(i, i + 3328))
            }
          }

          this.data = bitfield({
            pageSize: 1024,
            pageOffset: 0,
            pages: this.pages,
            trackUpdates: true
          })

          this.tree = bitfield({
            pageSize: 2048,
            pageOffset: 1024,
            pages: this.pages,
            trackUpdates: true
          })

          this.index = bitfield({
            pageSize: 256,
            pageOffset: 1024 + 2048,
            pages: this.pages,
            trackUpdates: true
          })

          this.length = this.data.length
          this._iterator = flat.iterator(0)
        }

        Bitfield.prototype.set = function(i, value) {
          var o = i & 7
          i = (i - o) / 8
          var v = value
            ? this.data.getByte(i) | (128 >> o)
            : this.data.getByte(i) & DATA_UPDATE_MASK[o]

          if (!this.data.setByte(i, v)) return false
          this.length = this.data.length
          this._setIndex(i, v)
          return true
        }

        Bitfield.prototype.get = function(i) {
          return this.data.get(i)
        }

        Bitfield.prototype.total = function(start, end) {
          if (!start || start < 0) start = 0
          if (!end) end = this.data.length
          if (end < start) return 0
          if (end > this.data.length) {
            this._expand(end)
          }
          var o = start & 7
          var e = end & 7
          var pos = (start - o) / 8
          var last = (end - e) / 8
          var leftMask = 255 - (o ? DATA_ITERATE_MASK[o - 1] : 0)
          var rightMask = e ? DATA_ITERATE_MASK[e - 1] : 0
          var byte = this.data.getByte(pos)
          if (pos === last) {
            return TOTAL_1_BITS[byte & leftMask & rightMask]
          }
          var total = TOTAL_1_BITS[byte & leftMask]
          for (var i = pos + 1; i < last; i++) {
            total += TOTAL_1_BITS[this.data.getByte(i)]
          }
          total += TOTAL_1_BITS[this.data.getByte(last) & rightMask]
          return total
        }

        // TODO: use the index to speed this up *a lot*
        Bitfield.prototype.compress = function() {
          return rle.encode(this.data.toBuffer())
        }

        Bitfield.prototype._setIndex = function(i, value) {
          //                    (a + b | c + d | e + f | g + h)
          // -> (a | b | c | d)                                (e | f | g | h)
          //

          var o = i & 3
          i = (i - o) / 4

          var bitfield = this.index
          var ite = this._iterator
          var start = 2 * i
          var byte =
            (bitfield.getByte(start) & INDEX_UPDATE_MASK[o]) |
            (getIndexValue(value) >> (2 * o))
          var len = bitfield.length
          var maxLength = this.pages.length * 256

          ite.seek(start)

          while (ite.index < maxLength && bitfield.setByte(ite.index, byte)) {
            if (ite.isLeft()) {
              byte =
                MAP_PARENT_LEFT[byte] |
                MAP_PARENT_RIGHT[bitfield.getByte(ite.sibling())]
            } else {
              byte =
                MAP_PARENT_RIGHT[byte] |
                MAP_PARENT_LEFT[bitfield.getByte(ite.sibling())]
            }
            ite.parent()
          }

          if (len !== bitfield.length) this._expand(len)

          return ite.index !== start
        }

        Bitfield.prototype._expand = function(len) {
          var roots = flat.fullRoots(2 * len)
          var bitfield = this.index
          var ite = this._iterator
          var byte = 0

          for (var i = 0; i < roots.length; i++) {
            ite.seek(roots[i])
            byte = bitfield.getByte(ite.index)

            do {
              if (ite.isLeft()) {
                byte =
                  MAP_PARENT_LEFT[byte] |
                  MAP_PARENT_RIGHT[bitfield.getByte(ite.sibling())]
              } else {
                byte =
                  MAP_PARENT_RIGHT[byte] |
                  MAP_PARENT_LEFT[bitfield.getByte(ite.sibling())]
              }
            } while (setByteNoAlloc(bitfield, ite.parent(), byte))
          }
        }

        function setByteNoAlloc(bitfield, i, b) {
          if (8 * i >= bitfield.length) return false
          return bitfield.setByte(i, b)
        }

        Bitfield.prototype.iterator = function(start, end) {
          var ite = new Iterator(this)

          ite.range(start || 0, end || this.length)
          ite.seek(0)

          return ite
        }

        function Iterator(bitfield) {
          this.start = 0
          this.end = 0

          this._indexEnd = 0
          this._pos = 0
          this._byte = 0
          this._bitfield = bitfield
        }

        Iterator.prototype.range = function(start, end) {
          this.start = start
          this.end = end
          this._indexEnd = 2 * Math.ceil(end / 32)

          if (this.end > this._bitfield.length) {
            this._bitfield._expand(this.end)
          }

          return this
        }

        Iterator.prototype.seek = function(offset) {
          offset += this.start
          if (offset < this.start) offset = this.start

          if (offset >= this.end) {
            this._pos = -1
            return this
          }

          var o = offset & 7

          this._pos = (offset - o) / 8
          this._byte =
            this._bitfield.data.getByte(this._pos) |
            (o ? DATA_ITERATE_MASK[o - 1] : 0)

          return this
        }

        Iterator.prototype.random = function() {
          var i = this.seek(
            Math.floor(Math.random() * (this.end - this.start))
          ).next()
          return i === -1 ? this.seek(0).next() : i
        }

        Iterator.prototype.next = function() {
          if (this._pos === -1) return -1

          var dataBitfield = this._bitfield.data
          var free = NEXT_DATA_0_BIT[this._byte]

          while (free === -1) {
            this._byte = dataBitfield.getByte(++this._pos)
            free = NEXT_DATA_0_BIT[this._byte]

            if (free === -1) {
              this._pos = this._skipAhead(this._pos)
              if (this._pos === -1) return -1

              this._byte = dataBitfield.getByte(this._pos)
              free = NEXT_DATA_0_BIT[this._byte]
            }
          }

          this._byte |= DATA_ITERATE_MASK[free]

          var n = 8 * this._pos + free
          return n < this.end ? n : -1
        }

        Iterator.prototype.peek = function() {
          if (this._pos === -1) return -1

          var free = NEXT_DATA_0_BIT[this._byte]
          var n = 8 * this._pos + free
          return n < this.end ? n : -1
        }

        Iterator.prototype._skipAhead = function(start) {
          var indexBitfield = this._bitfield.index
          var treeEnd = this._indexEnd
          var ite = this._bitfield._iterator
          var o = start & 3

          ite.seek(2 * ((start - o) / 4))

          var treeByte =
            indexBitfield.getByte(ite.index) | INDEX_ITERATE_MASK[o]

          while (NEXT_INDEX_0_BIT[treeByte] === -1) {
            if (ite.isLeft()) {
              ite.next()
            } else {
              ite.next()
              ite.parent()
            }

            if (rightSpan(ite) >= treeEnd) {
              while (rightSpan(ite) >= treeEnd && isParent(ite)) ite.leftChild()
              if (rightSpan(ite) >= treeEnd) return -1
            }

            treeByte = indexBitfield.getByte(ite.index)
          }

          while (ite.factor > 2) {
            if (NEXT_INDEX_0_BIT[treeByte] < 2) ite.leftChild()
            else ite.rightChild()

            treeByte = indexBitfield.getByte(ite.index)
          }

          var free = NEXT_INDEX_0_BIT[treeByte]
          if (free === -1) free = 4

          var next = ite.index * 2 + free

          return next <= start ? start + 1 : next
        }

        function rightSpan(ite) {
          return ite.index + ite.factor / 2 - 1
        }

        function isParent(ite) {
          return ite.index & 1
        }

        function getIndexValue(n) {
          switch (n) {
            case 255:
              return 192
            case 0:
              return 0
            default:
              return 64
          }
        }
      },
      {
        "bitfield-rle": 6,
        "flat-tree": 25,
        "memory-pager": 40,
        "sparse-bitfield": 72
      }
    ],
    32: [
      function(require, module, exports) {
        var sodium = require("sodium-universal")
        var uint64be = require("uint64be")
        var bufferFrom = require("buffer-from")
        var bufferAlloc = require("buffer-alloc-unsafe")

        // https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack
        var LEAF_TYPE = bufferFrom([0])
        var PARENT_TYPE = bufferFrom([1])
        var ROOT_TYPE = bufferFrom([2])
        var HYPERCORE = bufferFrom("hypercore")

        exports.keyPair = function(seed) {
          var publicKey = bufferAlloc(sodium.crypto_sign_PUBLICKEYBYTES)
          var secretKey = bufferAlloc(sodium.crypto_sign_SECRETKEYBYTES)

          if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)
          else sodium.crypto_sign_keypair(publicKey, secretKey)

          return {
            publicKey: publicKey,
            secretKey: secretKey
          }
        }

        exports.sign = function(message, secretKey) {
          var signature = bufferAlloc(sodium.crypto_sign_BYTES)
          sodium.crypto_sign_detached(signature, message, secretKey)
          return signature
        }

        exports.verify = function(message, signature, publicKey) {
          return sodium.crypto_sign_verify_detached(
            signature,
            message,
            publicKey
          )
        }

        exports.data = function(data) {
          return blake2b([LEAF_TYPE, encodeUInt64(data.length), data])
        }

        exports.leaf = function(leaf) {
          return exports.data(leaf.data)
        }

        exports.parent = function(a, b) {
          if (a.index > b.index) {
            var tmp = a
            a = b
            b = tmp
          }

          return blake2b([
            PARENT_TYPE,
            encodeUInt64(a.size + b.size),
            a.hash,
            b.hash
          ])
        }

        exports.tree = function(roots) {
          var buffers = new Array(3 * roots.length + 1)
          var j = 0

          buffers[j++] = ROOT_TYPE

          for (var i = 0; i < roots.length; i++) {
            var r = roots[i]
            buffers[j++] = r.hash
            buffers[j++] = encodeUInt64(r.index)
            buffers[j++] = encodeUInt64(r.size)
          }

          return blake2b(buffers)
        }

        exports.randomBytes = function(n) {
          var buf = bufferAlloc(n)
          sodium.randombytes_buf(buf)
          return buf
        }

        exports.discoveryKey = function(tree) {
          var digest = bufferAlloc(32)
          sodium.crypto_generichash(digest, HYPERCORE, tree)
          return digest
        }

        function encodeUInt64(n) {
          return uint64be.encode(n, bufferAlloc(8))
        }

        function blake2b(buffers) {
          var digest = bufferAlloc(32)
          sodium.crypto_generichash_batch(digest, buffers)
          return digest
        }
      },
      {
        "buffer-alloc-unsafe": 15,
        "buffer-from": 19,
        "sodium-universal": 70,
        uint64be: 76
      }
    ],
    33: [
      function(require, module, exports) {
        var protocol = require("hypercore-protocol")
        var bitfield = require("sparse-bitfield")
        var set = require("unordered-set")
        var rle = require("bitfield-rle")

        module.exports = replicate

        function replicate(feed, opts) {
          var stream = opts.stream

          if (!stream) {
            if (!opts.expectedFeeds) opts.expectedFeeds = 1
            if (!opts.id) opts.id = feed.id
            stream = protocol(opts)
          }

          feed.ready(function(err) {
            if (err) return stream.destroy(err)
            if (stream.destroyed) return

            var peer = new Peer(feed, opts)
            peer.feed = feed
            peer.stream = stream.feed(feed.key, { peer: peer })

            peer.remoteId = stream.remoteId
            stream.setMaxListeners(0)
            stream.on("handshake", function() {
              peer.remoteId = stream.remoteId
            })

            // stream might get destroyed on feed init in case of conf errors
            if (stream.destroyed) return

            peer.ready()
          })

          return stream
        }

        function Peer(feed, opts) {
          this.feed = feed
          this.stream = null // set by replicate just after creation
          this.remoteId = null
          this.remoteBitfield = null
          this.remoteLength = 0
          this.remoteWant = false
          this.live = !!opts.live
          this.sparse = feed.sparse

          this.remoteDownloading = true
          this.downloading =
            typeof opts.download === "boolean" ? opts.download : !feed.writable
          this.uploading = true

          this.maxRequests = opts.maxRequests || feed.maxRequests || 16
          this.inflightRequests = []

          this._index = -1
          this._lastBytes = 0
          this._first = true
          this._closed = false
          this._destroyed = false
          this._defaultDownloading = this.downloading
        }

        Peer.prototype.onwant = function() {
          // TODO: reply to the actual want context
          this.remoteWant = true
          var rle = this.feed.bitfield.compress()
          this.stream.have({ start: 0, bitfield: rle })
        }

        Peer.prototype.ondata = function(data) {
          var self = this

          // Ignore unrequested messages unless we allow push
          // TODO: would be better to check if the byte range was requested instead, but this works fine
          var allowPush = this.feed.allowPush || !data.value
          if (!allowPush && !this.feed._reserved.get(data.index)) {
            // If we do not have this block, send back unhave message for this index,
            // to let the remote know we rejected it.
            // TODO: we might want to have some "unwanted push" threshold to punish spammers
            if (!self.feed.bitfield.get(data.index))
              self.unhave({ start: data.index })
            self._clear(data.index, !data.value)
            return
          }

          this.feed._putBuffer(data.index, data.value, data, this, function(
            err
          ) {
            if (err) return self.destroy(err)
            self._clear(data.index, !data.value)
          })
        }

        Peer.prototype._clear = function(index, hash) {
          // TODO: optimize me (no splice and do not run through all ...)
          for (var i = 0; i < this.inflightRequests.length; i++) {
            if (this.inflightRequests[i].index === index) {
              this.inflightRequests.splice(i, 1)
              i--
            }
          }

          this.feed._reserved.set(index, false)
          // TODO: only update all if we have overlapping selections
          this.feed._updatePeers()
        }

        Peer.prototype.onrequest = function(request) {
          if (request.bytes) return this._onbytes(request)

          var self = this
          var opts = { digest: request.nodes, hash: request.hash }

          this.feed.proof(request.index, opts, onproof)

          function onproof(err, proof) {
            if (err) return self.destroy(err)
            if (request.hash) onvalue(null, null)
            else if (self.feed.bitfield.get(request.index))
              self.feed._getBuffer(request.index, onvalue)

            function onvalue(err, value) {
              if (err) return self.destroy(err)

              if (!self.remoteBitfield) self.remoteBitfield = bitfield()

              if (value) {
                if (!self.remoteBitfield.set(request.index, true)) return
                self.feed.emit("upload", request.index, value, self)
              } else {
                if (self.remoteBitfield.get(request.index)) return
              }

              if (request.index + 1 > self.remoteLength) {
                self.remoteLength = request.index + 1
                self._updateEnd()
              }

              self.stream.data({
                index: request.index,
                value: value,
                nodes: proof.nodes,
                signature: proof.signature
              })
            }
          }
        }

        Peer.prototype._onbytes = function(request) {
          var self = this

          this.feed.seek(request.bytes, { wait: false }, function(err, index) {
            if (err) {
              request.bytes = 0
              self.onrequest(request)
              return
            }

            // quick'n'dirty filter for parallel bytes requests
            // it does not matter that this doesn't catch ALL parallel requests - just a bandwidth optimization
            if (self._lastBytes === request.bytes) return
            self._lastBytes = request.bytes

            request.bytes = 0
            request.index = index
            request.nodes = 0

            self.onrequest(request)
          })
        }

        Peer.prototype.ontick = function() {
          if (!this.inflightRequests.length) return

          var first = this.inflightRequests[0]
          if (--first.tick) return

          if (
            first.hash
              ? this.feed.tree.get(2 * first.index)
              : this.feed.bitfield.get(first.index)
          ) {
            // prob a bytes response
            this.inflightRequests.shift()
            this.feed._reserved.set(first.index, false)
            return
          }

          this.destroy(new Error("Request timeout"))
        }

        Peer.prototype.onhave = function(have) {
          var updated = this._first
          if (this._first) this._first = false

          if (have.bitfield) {
            // TODO: handle start !== 0
            this.remoteBitfield = bitfield(rle.decode(have.bitfield))
            if (this.remoteBitfield.length > this.remoteLength) {
              this.remoteLength = this.remoteBitfield.length
              while (
                this.remoteLength &&
                !this.remoteBitfield.get(this.remoteLength - 1)
              )
                this.remoteLength--
              updated = true
            }
          } else {
            if (!this.remoteBitfield) this.remoteBitfield = bitfield()
            // TODO: if len > something simply copy a 0b1111... buffer to the bitfield

            var start = have.start
            var len = have.length || 1

            while (len--) this.remoteBitfield.set(start++, true)
            if (start > this.remoteLength) {
              this.remoteLength = start
              updated = true
            }
          }

          if (updated) {
            this.feed.emit("remote-update", this)
          }

          this._updateEnd()
          this.update()
        }

        Peer.prototype._updateEnd = function() {
          if (this.live || this.feed.sparse || !this.feed._selections.length)
            return

          var sel = this.feed._selections[0]
          var remoteLength = this.feed.length || -1

          for (var i = 0; i < this.feed.peers.length; i++) {
            if (this.feed.peers[i].remoteLength > remoteLength) {
              remoteLength = this.feed.peers[i].remoteLength
            }
          }

          sel.end = remoteLength
        }

        Peer.prototype.oninfo = function(info) {
          this.remoteDownloading = info.downloading
          if (info.downloading || this.live) return
          this.update()
          if (this.feed._selections.length && this.downloading) return
          this.end()
        }

        Peer.prototype.onunhave = function(unhave) {
          if (!this.remoteBitfield) return

          var start = unhave.start
          var len = unhave.length || 1

          while (len--) this.remoteBitfield.set(start++, false)
        }

        Peer.prototype.onunwant = Peer.prototype.oncancel = function() {
          // TODO: impl all of me
        }

        Peer.prototype.onclose = function() {
          this.destroy()
        }

        Peer.prototype.have = function(have) {
          // called by feed
          if (this.stream && this.remoteWant) this.stream.have(have)
        }

        Peer.prototype.unhave = function(unhave) {
          // called by feed
          if (this.stream && this.remoteWant) this.stream.unhave(unhave)
        }

        Peer.prototype.haveBytes = function(bytes) {
          // called by feed
          for (var i = 0; i < this.inflightRequests.length; i++) {
            if (this.inflightRequests[i].bytes === bytes) {
              this.feed._reserved.set(this.inflightRequests[i].index, false)
              this.inflightRequests.splice(i, 1)
              i--
            }
          }

          this.update()
        }

        Peer.prototype.update = function() {
          // do nothing
          while (this._update()) {}
        }

        Peer.prototype._update = function() {
          // should return true if mutated false if not
          if (!this.downloading || !this.remoteBitfield) return false

          var selections = this.feed._selections
          var waiting = this.feed._waiting
          var wlen = waiting.length
          var slen = selections.length
          var inflight = this.inflightRequests.length
          var offset = 0
          var i = 0

          // TODO: less duplicate code here
          // TODO: re-add priority levels

          while (inflight < this.maxRequests) {
            offset = Math.floor(Math.random() * waiting.length)

            for (i = 0; i < waiting.length; i++) {
              var w = waiting[offset++]
              if (offset === waiting.length) offset = 0

              this._downloadWaiting(w)
              if (waiting.length !== wlen) return true // mutated
              if (this.inflightRequests.length >= this.maxRequests) return false
            }
            if (inflight === this.inflightRequests.length) break
            inflight = this.inflightRequests.length
          }

          while (inflight < this.maxRequests) {
            offset = Math.floor(Math.random() * selections.length)

            for (i = 0; i < selections.length; i++) {
              var s = selections[offset++]
              if (offset === selections.length) offset = 0

              if (!s.iterator)
                s.iterator = this.feed.bitfield.iterator(s.start, s.end)
              this._downloadRange(s)
              if (selections.length !== slen) return true // mutated
              if (this.inflightRequests.length >= this.maxRequests) return false
            }

            if (inflight === this.inflightRequests.length) return false
            inflight = this.inflightRequests.length
          }

          return false
        }

        Peer.prototype.ready = function() {
          set.add(this.feed.peers, this)
          this.stream.want({ start: 0 }) // TODO: don't just subscribe to *EVERYTHING* hehe
          this.feed.emit("peer-add", this)
        }

        Peer.prototype.end = function() {
          if (!this.downloading && !this.remoteDownloading && !this.live) {
            if (!this._defaultDownloading) {
              this.stream.info({ downloading: false, uploading: false })
            }
            this._close()
            return
          }
          if (!this._closed) {
            this._closed = true
            this.downloading = false
            this.stream.info({ downloading: false, uploading: true })
          } else {
            if (!this.live) this._close()
          }
        }

        Peer.prototype._close = function() {
          if (this._index === -1) return
          if (!this._destroyed) {
            this.stream.close()
            this._destroyed = true
          }
          set.remove(this.feed.peers, this)
          this._index = -1
          for (var i = 0; i < this.inflightRequests.length; i++) {
            this.feed._reserved.set(this.inflightRequests[i].index, false)
          }
          this._updateEnd()
          this.remoteWant = false
          this.feed._updatePeers()
          this.feed.emit("peer-remove", this)
        }

        Peer.prototype.destroy = function(err) {
          if (this._index === -1 || this._destroyed) return
          this.stream.destroy(err)
          this._destroyed = true
          this._close()
        }

        Peer.prototype._downloadWaiting = function(wait) {
          if (!wait.bytes) {
            if (
              !this.remoteBitfield.get(wait.index) ||
              !this.feed._reserved.set(wait.index, true)
            )
              return
            this._request(wait.index, 0, false)
            return
          }

          this._downloadRange(wait)
        }

        Peer.prototype._downloadRange = function(range) {
          if (!range.iterator)
            range.iterator = this.feed.bitfield.iterator(range.start, range.end)

          var reserved = this.feed._reserved
          var ite = range.iterator
          var wantedEnd = Math.min(
            range.end === -1 ? this.remoteLength : range.end,
            this.remoteLength
          )

          if (ite.end !== wantedEnd) ite.range(range.start, wantedEnd)

          var i = range.linear ? ite.next() : ite.random()
          var reset = false
          var start = i

          if (i === -1) {
            if (
              !range.bytes &&
              ite.seek(0).next() === -1 &&
              (range.end > -1 && this.remoteLength >= range.end)
            ) {
              set.remove(this.feed._selections, range)
              range.callback(null)
              if (!this.live && !this.sparse && !this.feed._selections.length)
                this.end()
            }
            return
          }

          while (
            !this.remoteBitfield.get(i) ||
            (range.hash && this.feed.tree.get(2 * i)) ||
            !reserved.set(i, true)
          ) {
            i = ite.next()
            reset = true

            if (i > -1) {
              // check this index
              continue
            }

            if (!range.linear && start !== 0) {
              // retry from the beginning since we are iterating randomly and started !== 0
              i = ite.seek(0).next()
              start = 0
              continue
            }

            // we have checked all indexes.
            // if we are looking for hashes we should check if we have all now (first check only checks blocks)
            if (range.hash) {
              // quick'n'dirty check if have all hashes - can be optimized be checking only tree roots
              // but we don't really request long ranges of hashes so yolo
              for (var j = range.start; j < wantedEnd; j++) {
                if (!this.feed.tree.get(2 * j)) return
              }
              if (!range.bytes) {
                set.remove(this.feed._selections, range)
                range.callback(null)
              }
            }

            // exit the update loop - nothing to do
            return
          }

          if (reset) ite.seek(0)

          this._request(i, range.bytes || 0, range.hash)
        }

        Peer.prototype._request = function(index, bytes, hash) {
          var request = {
            tick: 6,
            bytes: bytes,
            index: index,
            hash: hash,
            nodes: this.feed.digest(index)
          }

          this.inflightRequests.push(request)
          this.stream.request(request)
        }
      },
      {
        "bitfield-rle": 6,
        "hypercore-protocol": 28,
        "sparse-bitfield": 72,
        "unordered-set": 78
      }
    ],
    34: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var uint64be = require("uint64be")
          var flat = require("flat-tree")
          var alru = require("array-lru")
          var bufferAlloc = require("buffer-alloc-unsafe")

          module.exports = Storage

          var noarr = []

          function Storage(create, cacheSize) {
            if (!(this instanceof Storage))
              return new Storage(create, cacheSize)
            cacheSize = typeof cacheSize === "undefined" ? 65536 : cacheSize

            this.cache =
              cacheSize > 0 ? alru(cacheSize, { indexedValues: true }) : null
            this.key = null
            this.secretKey = null
            this.tree = null
            this.data = null
            this.bitfield = null
            this.signatures = null
            this.create = create
          }

          Storage.prototype.putData = function(index, data, nodes, cb) {
            if (!cb) cb = noop
            var self = this
            if (!data.length) return cb(null)
            this.dataOffset(index, nodes, function(err, offset, size) {
              if (err) return cb(err)
              if (size !== data.length)
                return cb(new Error("Unexpected data size"))
              self.data.write(offset, data, cb)
            })
          }

          Storage.prototype.getData = function(index, cb) {
            var self = this
            this.dataOffset(index, noarr, function(err, offset, size) {
              if (err) return cb(err)
              self.data.read(offset, size, cb)
            })
          }

          Storage.prototype.nextSignature = function(index, cb) {
            var self = this

            this._getSignature(index, function(err, signature) {
              if (err) return cb(err)
              if (isBlank(signature)) return self.nextSignature(index + 1, cb)
              cb(null, { index: index, signature: signature })
            })
          }

          Storage.prototype.getSignature = function(index, cb) {
            this._getSignature(index, function(err, signature) {
              if (err) return cb(err)
              if (isBlank(signature)) return cb(new Error("No signature found"))
              cb(null, signature)
            })
          }

          Storage.prototype._getSignature = function(index, cb) {
            this.signatures.read(32 + 64 * index, 64, cb)
          }

          Storage.prototype.putSignature = function(index, signature, cb) {
            this.signatures.write(32 + 64 * index, signature, cb)
          }

          Storage.prototype.dataOffset = function(index, cachedNodes, cb) {
            var roots = flat.fullRoots(2 * index)
            var self = this
            var offset = 0
            var pending = roots.length
            var error = null
            var blk = 2 * index

            if (!pending) {
              pending = 1
              onnode(null, null)
              return
            }

            for (var i = 0; i < roots.length; i++) {
              var node = findNode(cachedNodes, roots[i])
              if (node) onnode(null, node)
              else this.getNode(roots[i], onnode)
            }

            function onlast(err, node) {
              if (err) return cb(err)
              cb(null, offset, node.size)
            }

            function onnode(err, node) {
              if (err) error = err
              if (node) offset += node.size
              if (--pending) return

              if (error) return cb(error)

              var last = findNode(cachedNodes, blk)
              if (last) onlast(null, last)
              else self.getNode(blk, onlast)
            }
          }

          Storage.prototype.getNode = function(index, cb) {
            if (this.cache) {
              var cached = this.cache.get(index)
              if (cached) return cb(null, cached)
            }

            var self = this

            this.tree.read(32 + 40 * index, 40, function(err, buf) {
              if (err) return cb(err)

              var hash = buf.slice(0, 32)
              var size = uint64be.decode(buf, 32)

              if (!size && isBlank(hash)) return cb(new Error("No node found"))

              var val = new Node(index, hash, size, null)
              if (self.cache) self.cache.set(index, val)
              cb(null, val)
            })
          }

          Storage.prototype.putNode = function(index, node, cb) {
            if (!cb) cb = noop

            // TODO: re-enable put cache. currently this causes a memleak
            // because node.hash is a slice of the big data buffer on replicate
            // if (this.cache) this.cache.set(index, node)

            var buf = bufferAlloc(40)

            node.hash.copy(buf, 0)
            uint64be.encode(node.size, buf, 32)
            this.tree.write(32 + 40 * index, buf, cb)
          }

          Storage.prototype.putBitfield = function(offset, data, cb) {
            this.bitfield.write(32 + offset, data, cb)
          }

          Storage.prototype.close = function(cb) {
            if (!cb) cb = noop
            var missing = 6
            var error = null

            close(this.bitfield, done)
            close(this.tree, done)
            close(this.data, done)
            close(this.key, done)
            close(this.secretKey, done)
            close(this.signatures, done)

            function done(err) {
              if (err) error = err
              if (--missing) return
              cb(error)
            }
          }

          Storage.prototype.openKey = function(opts, cb) {
            if (typeof opts === "function") return this.openKey({}, opts)
            if (!this.key) this.key = this.create("key", opts)
            this.key.read(0, 32, cb)
          }

          Storage.prototype.open = function(opts, cb) {
            if (typeof opts === "function") return this.open({}, opts)

            var self = this
            var error = null
            var missing = 5

            if (!this.key) this.key = this.create("key", opts)
            if (!this.secretKey)
              this.secretKey = this.create("secret_key", opts)
            if (!this.tree) this.tree = this.create("tree", opts)
            if (!this.data) this.data = this.create("data", opts)
            if (!this.bitfield) this.bitfield = this.create("bitfield", opts)
            if (!this.signatures)
              this.signatures = this.create("signatures", opts)

            var result = {
              bitfield: bufferAlloc(0),
              secretKey: null,
              key: null
            }

            this.bitfield.write(0, header(0, 3328, null), function(err) {
              if (err) return cb(err)
              readAll(self.bitfield, 32, 3328, function(err, data) {
                if (data) result.bitfield = data
                done(err)
              })
            })

            this.signatures.write(0, header(1, 64, "Ed25519"), done)
            this.tree.write(0, header(2, 40, "BLAKE2b"), done)

            // TODO: Improve the error handling here.
            // I.e. if secretKey length === 64 and it fails, error

            this.secretKey.read(0, 64, function(_, data) {
              if (data) result.secretKey = data
              done(null)
            })

            this.key.read(0, 32, function(_, data) {
              if (data) result.key = data
              done(null)
            })

            function done(err) {
              if (err) error = err
              if (--missing) return
              if (error) cb(error)
              else cb(null, result)
            }
          }

          Storage.Node = Node

          function noop() {}

          function header(type, size, name) {
            var buf = bufferAlloc(32)
            buf.fill(0)

            // magic number
            buf[0] = 5
            buf[1] = 2
            buf[2] = 87
            buf[3] = type

            // version
            buf[4] = 0

            // block size
            buf.writeUInt16BE(size, 5)

            if (name) {
              // algo name
              buf[7] = name.length
              buf.write(name, 8)
            }

            return buf
          }

          function Node(index, hash, size) {
            this.index = index
            this.hash = hash
            this.size = size
          }

          function findNode(nodes, index) {
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].index === index) return nodes[i]
            }
            return null
          }

          function isBlank(buf) {
            for (var i = 0; i < buf.length; i++) {
              if (buf[i]) return false
            }
            return true
          }

          function close(st, cb) {
            if (st.close) st.close(cb)
            else cb()
          }

          function statAndReadAll(st, offset, cb) {
            st.stat(function(err, stat) {
              if (err) return cb(null, bufferAlloc(0))
              st.read(offset, stat.size - offset, cb)
            })
          }

          function readAll(st, offset, pageSize, cb) {
            if (typeof st.length === "number" && st.length > -1)
              return st.read(offset, st.length - offset, cb)
            if (st.statable === true) return statAndReadAll(st, offset, cb)

            var bufs = []

            st.read(offset, pageSize, loop)

            function loop(err, buf) {
              if (err) return cb(null, Buffer.concat(bufs))
              bufs.push(buf)
              st.read(offset + bufs.length * pageSize, pageSize, loop)
            }
          }
        }.call(this, require("buffer").Buffer))
      },
      {
        "array-lru": 3,
        buffer: 20,
        "buffer-alloc-unsafe": 15,
        "flat-tree": 25,
        uint64be: 76
      }
    ],
    35: [
      function(require, module, exports) {
        var flat = require("flat-tree")
        var bitfield = require("sparse-bitfield")

        module.exports = TreeIndex

        function TreeIndex(bits) {
          if (!(this instanceof TreeIndex)) return new TreeIndex(bits)
          this.bitfield = bits || bitfield()
        }

        TreeIndex.prototype.proof = function(index, opts) {
          if (!opts) opts = {}

          var nodes = []
          var remoteTree = opts.tree || new TreeIndex()
          var digest = opts.digest || 0

          if (!this.get(index)) return null
          if (opts.hash) nodes.push(index) // always return hash - no matter what the digest says
          if (digest === 1) return { nodes: nodes, verifiedBy: 0 }

          var roots = null
          var sibling = index
          var next = index
          var hasRoot = digest & 1
          digest = rightShift(digest)

          while (digest) {
            if (digest === 1 && hasRoot) {
              if (this.get(next)) remoteTree.set(next)

              // having a root implies having prev roots as well
              // TODO: this can be optimized away be only sending "newer" roots,
              // when sending roots
              if (flat.sibling(next) < next) next = flat.sibling(next)
              roots = flat.fullRoots(flat.rightSpan(next) + 2)
              for (var i = 0; i < roots.length; i++) {
                if (this.get(roots[i])) remoteTree.set(roots[i])
              }
              break
            }

            sibling = flat.sibling(next)
            if (digest & 1) {
              if (this.get(sibling)) remoteTree.set(sibling)
            }
            next = flat.parent(next)
            digest = rightShift(digest)
          }

          next = index

          while (!remoteTree.get(next)) {
            sibling = flat.sibling(next)
            if (!this.get(sibling)) {
              // next is a local root
              var verifiedBy = this.verifiedBy(next)
              addFullRoots(verifiedBy, nodes, next, remoteTree)
              return { nodes: nodes, verifiedBy: verifiedBy }
            } else {
              if (!remoteTree.get(sibling)) nodes.push(sibling)
            }

            next = flat.parent(next)
          }

          return { nodes: nodes, verifiedBy: 0 }
        }

        TreeIndex.prototype.digest = function(index) {
          if (this.get(index)) return 1

          var digest = 0
          var next = flat.sibling(index)
          var max = Math.max(next + 2, this.bitfield.length) // TODO: make this less ... hacky

          var bit = 2
          var depth = flat.depth(index)
          var parent = flat.parent(next, depth++)

          while (flat.rightSpan(next) < max || flat.leftSpan(parent) > 0) {
            if (this.get(next)) {
              digest |= bit
            }
            if (this.get(parent)) {
              digest |= 2 * bit + 1
              if (digest + 1 === 4 * bit) return 1
              return digest
            }
            next = flat.sibling(parent)
            parent = flat.parent(next, depth++)
            bit *= 2
          }

          return digest
        }

        TreeIndex.prototype.blocks = function() {
          var top = 0
          var next = 0
          var max = this.bitfield.length

          while (flat.rightSpan(next) < max) {
            next = flat.parent(next)
            if (this.get(next)) top = next
          }

          return (this.get(top) ? this.verifiedBy(top) : 0) / 2
        }

        TreeIndex.prototype.roots = function() {
          return flat.fullRoots(2 * this.blocks())
        }

        TreeIndex.prototype.verifiedBy = function(index, nodes) {
          var hasIndex = this.get(index)
          if (!hasIndex) return 0

          // find root of current tree

          var depth = flat.depth(index)
          var top = index
          var parent = flat.parent(top, depth++)
          while (this.get(parent) && this.get(flat.sibling(top))) {
            top = parent
            parent = flat.parent(top, depth++)
          }

          // expand right down

          depth--
          while (depth) {
            top = flat.leftChild(
              flat.index(depth, flat.offset(top, depth) + 1),
              depth
            )
            depth--

            while (!this.get(top) && depth) top = flat.leftChild(top, depth--)
            if (nodes && this.get(top)) nodes.push(top)
          }

          return this.get(top) ? top + 2 : top
        }

        TreeIndex.prototype.get = function(index) {
          return this.bitfield.get(index)
        }

        TreeIndex.prototype.set = function(index) {
          if (!this.bitfield.set(index, true)) return false
          while (this.bitfield.get(flat.sibling(index))) {
            index = flat.parent(index)
            if (!this.bitfield.set(index, true)) break
          }
          return true
        }

        function rightShift(n) {
          return (n - (n & 1)) / 2
        }

        function addFullRoots(verifiedBy, nodes, root, remoteTree) {
          var roots = flat.fullRoots(verifiedBy)
          for (var i = 0; i < roots.length; i++) {
            if (roots[i] !== root && !remoteTree.get(roots[i]))
              nodes.push(roots[i])
          }
        }
      },
      { "flat-tree": 25, "sparse-bitfield": 72 }
    ],
    36: [
      function(require, module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m
          var eLen = nBytes * 8 - mLen - 1
          var eMax = (1 << eLen) - 1
          var eBias = eMax >> 1
          var nBits = -7
          var i = isLE ? nBytes - 1 : 0
          var d = isLE ? -1 : 1
          var s = buffer[offset + i]

          i += d

          e = s & ((1 << -nBits) - 1)
          s >>= -nBits
          nBits += eLen
          for (
            ;
            nBits > 0;
            e = e * 256 + buffer[offset + i], i += d, nBits -= 8
          ) {}

          m = e & ((1 << -nBits) - 1)
          e >>= -nBits
          nBits += mLen
          for (
            ;
            nBits > 0;
            m = m * 256 + buffer[offset + i], i += d, nBits -= 8
          ) {}

          if (e === 0) {
            e = 1 - eBias
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity
          } else {
            m = m + Math.pow(2, mLen)
            e = e - eBias
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }

        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c
          var eLen = nBytes * 8 - mLen - 1
          var eMax = (1 << eLen) - 1
          var eBias = eMax >> 1
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0
          var i = isLE ? 0 : nBytes - 1
          var d = isLE ? 1 : -1
          var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

          value = Math.abs(value)

          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0
            e = eMax
          } else {
            e = Math.floor(Math.log(value) / Math.LN2)
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--
              c *= 2
            }
            if (e + eBias >= 1) {
              value += rt / c
            } else {
              value += rt * Math.pow(2, 1 - eBias)
            }
            if (value * c >= 2) {
              e++
              c /= 2
            }

            if (e + eBias >= eMax) {
              m = 0
              e = eMax
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen)
              e = e + eBias
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
              e = 0
            }
          }

          for (
            ;
            mLen >= 8;
            buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
          ) {}

          e = (e << mLen) | m
          eLen += mLen
          for (
            ;
            eLen > 0;
            buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
          ) {}

          buffer[offset + i - d] |= s * 128
        }
      },
      {}
    ],
    37: [
      function(require, module, exports) {
        if (typeof Object.create === "function") {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            })
          }
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function() {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
          }
        }
      },
      {}
    ],
    38: [
      function(require, module, exports) {
        /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

        // The _isBuffer check is for Safari 5-7 support, because it's missing
        // Object.prototype.constructor. Remove this eventually
        module.exports = function(obj) {
          return (
            obj != null &&
            (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
          )
        }

        function isBuffer(obj) {
          return (
            !!obj.constructor &&
            typeof obj.constructor.isBuffer === "function" &&
            obj.constructor.isBuffer(obj)
          )
        }

        // For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
          return (
            typeof obj.readFloatLE === "function" &&
            typeof obj.slice === "function" &&
            isBuffer(obj.slice(0, 0))
          )
        }
      },
      {}
    ],
    39: [
      function(require, module, exports) {
        module.exports = function(work) {
          var pending = null
          var callback = null
          var callbacks = null
          var next = null

          return function(val, cb) {
            next = val
            update(cb || noop)
          }

          function update(cb) {
            if (callback) {
              if (!pending) pending = []
              pending.push(cb)
              return
            }

            var val = next
            next = null
            callback = cb
            work(val, done)
          }

          function done(err) {
            var cb = callback
            var cbs = callbacks
            callbacks = null
            callback = null

            if (pending) {
              callbacks = pending
              pending = null
              update(noop)
            }

            if (cbs) {
              for (var i = 0; i < cbs.length; i++) cbs[i](err)
            }
            cb(err)
          }
        }

        function noop(_) {}
      },
      {}
    ],
    40: [
      function(require, module, exports) {
        ;(function(Buffer) {
          module.exports = Pager

          function Pager(pageSize) {
            if (!(this instanceof Pager)) return new Pager(pageSize)

            this.length = 0
            this.updates = []
            this.pages = new Array(16)
            this.pageSize = pageSize || 1024
          }

          Pager.prototype.updated = function(page) {
            if (page.updated || !this.updates) return
            page.updated = true
            this.updates.push(page)
          }

          Pager.prototype.lastUpdate = function() {
            if (!this.updates || !this.updates.length) return null
            var page = this.updates.pop()
            page.updated = false
            return page
          }

          Pager.prototype.get = function(i, noAllocate) {
            if (i >= this.pages.length) {
              if (noAllocate) return
              this.pages = grow(this.pages, i, this.length)
            }

            var page = this.pages[i]

            if (!page && !noAllocate) {
              page = this.pages[i] = new Page(i, alloc(this.pageSize))
              if (i >= this.length) this.length = i + 1
            }

            return page
          }

          Pager.prototype.set = function(i, buf) {
            if (i >= this.pages.length)
              this.pages = grow(this.pages, i, this.length)
            if (i >= this.length) this.length = i + 1

            if (!buf) {
              this.pages[i] = undefined
              return
            }

            var page = this.pages[i]
            var b = truncate(buf, this.pageSize)

            if (page) page.buffer = b
            else this.pages[i] = new Page(i, b)
          }

          Pager.prototype.toBuffer = function() {
            var list = new Array(this.length)
            var empty = alloc(this.pageSize)

            for (var i = 0; i < list.length; i++) {
              list[i] = this.pages[i] ? this.pages[i].buffer : empty
            }

            return Buffer.concat(list)
          }

          function grow(list, index, len) {
            var nlen = list.length * 2
            while (nlen <= index) nlen *= 2

            var twice = new Array(nlen)
            for (var i = 0; i < len; i++) twice[i] = list[i]
            return twice
          }

          function truncate(buf, len) {
            if (buf.length === len) return buf
            if (buf.length > len) return buf.slice(0, len)
            var cpy = alloc(len)
            buf.copy(cpy)
            return cpy
          }

          function alloc(size) {
            if (Buffer.alloc) return Buffer.alloc(size)
            var buf = new Buffer(size)
            buf.fill(0)
            return buf
          }

          function Page(i, buf) {
            this.offset = i * buf.length
            this.buffer = buf
            this.updated = false
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20 }
    ],
    41: [
      function(require, module, exports) {
        ;(function(Buffer) {
          // a more low level interface to the merkle tree stream.
          // useful for certain applications the require non-streamy access to the algos.
          // versioned by the same semver as the stream interface.

          var flat = require("flat-tree")

          module.exports = MerkleGenerator

          function MerkleGenerator(opts, roots) {
            if (!(this instanceof MerkleGenerator))
              return new MerkleGenerator(opts, roots)
            if (!opts || !opts.leaf || !opts.parent)
              throw new Error("opts.leaf and opts.parent required")

            this.roots = roots || opts.roots || []
            this.blocks = this.roots.length
              ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2
              : 0

            for (var i = 0; i < this.roots.length; i++) {
              var r = this.roots[i]
              if (r && !r.parent) r.parent = flat.parent(r.index)
            }

            this._leaf = opts.leaf
            this._parent = opts.parent
          }

          MerkleGenerator.prototype.next = function(data, nodes) {
            if (!Buffer.isBuffer(data)) data = new Buffer(data)
            if (!nodes) nodes = []

            var index = 2 * this.blocks++

            var leaf = {
              index: index,
              parent: flat.parent(index),
              hash: null,
              size: data.length,
              data: data
            }

            leaf.hash = this._leaf(leaf, this.roots)
            this.roots.push(leaf)
            nodes.push(leaf)

            while (this.roots.length > 1) {
              var left = this.roots[this.roots.length - 2]
              var right = this.roots[this.roots.length - 1]

              if (left.parent !== right.parent) break

              this.roots.pop()
              this.roots[this.roots.length - 1] = leaf = {
                index: left.parent,
                parent: flat.parent(left.parent),
                hash: this._parent(left, right),
                size: left.size + right.size,
                data: null
              }
              nodes.push(leaf)
            }

            return nodes
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "flat-tree": 25 }
    ],
    42: [
      function(require, module, exports) {
        assert.notEqual = notEqual
        assert.notOk = notOk
        assert.equal = equal
        assert.ok = assert

        module.exports = assert

        function equal(a, b, m) {
          assert(a == b, m) // eslint-disable-line eqeqeq
        }

        function notEqual(a, b, m) {
          assert(a != b, m) // eslint-disable-line eqeqeq
        }

        function notOk(t, m) {
          assert(!t, m)
        }

        function assert(t, m) {
          if (!t) throw new Error(m || "AssertionError")
        }
      },
      {}
    ],
    43: [
      function(require, module, exports) {
        ;(function(process) {
          "use strict"

          if (
            !process.version ||
            process.version.indexOf("v0.") === 0 ||
            (process.version.indexOf("v1.") === 0 &&
              process.version.indexOf("v1.8.") !== 0)
          ) {
            module.exports = nextTick
          } else {
            module.exports = process.nextTick
          }

          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
              throw new TypeError('"callback" argument must be a function')
            }
            var len = arguments.length
            var args, i
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn)
              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1)
                })
              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2)
                })
              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3)
                })
              default:
                args = new Array(len - 1)
                i = 0
                while (i < args.length) {
                  args[i++] = arguments[i]
                }
                return process.nextTick(function afterTick() {
                  fn.apply(null, args)
                })
            }
          }
        }.call(this, require("_process")))
      },
      { _process: 44 }
    ],
    44: [
      function(require, module, exports) {
        // shim for using process in browser
        var process = (module.exports = {})

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout
        var cachedClearTimeout

        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined")
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined")
        }
        ;(function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout
            } else {
              cachedSetTimeout = defaultSetTimout
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout
            } else {
              cachedClearTimeout = defaultClearTimeout
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout
          }
        })()
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0)
          }
          // if setTimeout wasn't available but was latter defined
          if (
            (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
            setTimeout
          ) {
            cachedSetTimeout = setTimeout
            return setTimeout(fun, 0)
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0)
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0)
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0)
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker)
          }
          // if clearTimeout wasn't available but was latter defined
          if (
            (cachedClearTimeout === defaultClearTimeout ||
              !cachedClearTimeout) &&
            clearTimeout
          ) {
            cachedClearTimeout = clearTimeout
            return clearTimeout(marker)
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker)
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker)
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker)
            }
          }
        }
        var queue = []
        var draining = false
        var currentQueue
        var queueIndex = -1

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return
          }
          draining = false
          if (currentQueue.length) {
            queue = currentQueue.concat(queue)
          } else {
            queueIndex = -1
          }
          if (queue.length) {
            drainQueue()
          }
        }

        function drainQueue() {
          if (draining) {
            return
          }
          var timeout = runTimeout(cleanUpNextTick)
          draining = true

          var len = queue.length
          while (len) {
            currentQueue = queue
            queue = []
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run()
              }
            }
            queueIndex = -1
            len = queue.length
          }
          currentQueue = null
          draining = false
          runClearTimeout(timeout)
        }

        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1)
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i]
            }
          }
          queue.push(new Item(fun, args))
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue)
          }
        }

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun
          this.array = array
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array)
        }
        process.title = "browser"
        process.browser = true
        process.env = {}
        process.argv = []
        process.version = "" // empty string to avoid regexp issues
        process.versions = {}

        function noop() {}

        process.on = noop
        process.addListener = noop
        process.once = noop
        process.off = noop
        process.removeListener = noop
        process.removeAllListeners = noop
        process.emit = noop
        process.prependListener = noop
        process.prependOnceListener = noop

        process.listeners = function(name) {
          return []
        }

        process.binding = function(name) {
          throw new Error("process.binding is not supported")
        }

        process.cwd = function() {
          return "/"
        }
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported")
        }
        process.umask = function() {
          return 0
        }
      },
      {}
    ],
    45: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var varint = require("varint")
          var svarint = require("signed-varint")

          exports.make = encoder

          exports.name = function(enc) {
            var keys = Object.keys(exports)
            for (var i = 0; i < keys.length; i++) {
              if (exports[keys[i]] === enc) return keys[i]
            }
            return null
          }

          exports.skip = function(type, buffer, offset) {
            switch (type) {
              case 0:
                varint.decode(buffer, offset)
                return offset + varint.decode.bytes

              case 1:
                return offset + 8

              case 2:
                var len = varint.decode(buffer, offset)
                return offset + varint.decode.bytes + len

              case 3:
              case 4:
                throw new Error("Groups are not supported")

              case 5:
                return offset + 4
            }

            throw new Error("Unknown wire type: " + type)
          }

          exports.bytes = encoder(
            2,
            function encode(val, buffer, offset) {
              var oldOffset = offset
              var len = bufferLength(val)

              varint.encode(len, buffer, offset)
              offset += varint.encode.bytes

              if (Buffer.isBuffer(val)) val.copy(buffer, offset)
              else buffer.write(val, offset, len)
              offset += len

              encode.bytes = offset - oldOffset
              return buffer
            },
            function decode(buffer, offset) {
              var oldOffset = offset

              var len = varint.decode(buffer, offset)
              offset += varint.decode.bytes

              var val = buffer.slice(offset, offset + len)
              offset += val.length

              decode.bytes = offset - oldOffset
              return val
            },
            function encodingLength(val) {
              var len = bufferLength(val)
              return varint.encodingLength(len) + len
            }
          )

          exports.string = encoder(
            2,
            function encode(val, buffer, offset) {
              var oldOffset = offset
              var len = Buffer.byteLength(val)

              varint.encode(len, buffer, offset, "utf-8")
              offset += varint.encode.bytes

              buffer.write(val, offset, len)
              offset += len

              encode.bytes = offset - oldOffset
              return buffer
            },
            function decode(buffer, offset) {
              var oldOffset = offset

              var len = varint.decode(buffer, offset)
              offset += varint.decode.bytes

              var val = buffer.toString("utf-8", offset, offset + len)
              offset += len

              decode.bytes = offset - oldOffset
              return val
            },
            function encodingLength(val) {
              var len = Buffer.byteLength(val)
              return varint.encodingLength(len) + len
            }
          )

          exports.bool = encoder(
            0,
            function encode(val, buffer, offset) {
              buffer[offset] = val ? 1 : 0
              encode.bytes = 1
              return buffer
            },
            function decode(buffer, offset) {
              var bool = buffer[offset] > 0
              decode.bytes = 1
              return bool
            },
            function encodingLength() {
              return 1
            }
          )

          exports.int32 = encoder(
            0,
            function encode(val, buffer, offset) {
              varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)
              encode.bytes = varint.encode.bytes
              return buffer
            },
            function decode(buffer, offset) {
              var val = varint.decode(buffer, offset)
              decode.bytes = varint.decode.bytes
              return val > 2147483647 ? val - 4294967296 : val
            },
            function encodingLength(val) {
              return varint.encodingLength(val < 0 ? val + 4294967296 : val)
            }
          )

          exports.int64 = encoder(
            0,
            function encode(val, buffer, offset) {
              if (val < 0) {
                var last = offset + 9
                varint.encode(val * -1, buffer, offset)
                offset += varint.encode.bytes - 1
                buffer[offset] = buffer[offset] | 0x80
                while (offset < last - 1) {
                  offset++
                  buffer[offset] = 0xff
                }
                buffer[last] = 0x01
                encode.bytes = 10
              } else {
                varint.encode(val, buffer, offset)
                encode.bytes = varint.encode.bytes
              }
              return buffer
            },
            function decode(buffer, offset) {
              var val = varint.decode(buffer, offset)
              if (val >= Math.pow(2, 63)) {
                var limit = 9
                while (buffer[offset + limit - 1] === 0xff) limit--
                limit = limit || 9
                var subset = Buffer.allocUnsafe(limit)
                buffer.copy(subset, 0, offset, offset + limit)
                subset[limit - 1] = subset[limit - 1] & 0x7f
                val = -1 * varint.decode(subset, 0)
                decode.bytes = 10
              } else {
                decode.bytes = varint.decode.bytes
              }
              return val
            },
            function encodingLength(val) {
              return val < 0 ? 10 : varint.encodingLength(val)
            }
          )

          exports.sint32 = exports.sint64 = encoder(
            0,
            svarint.encode,
            svarint.decode,
            svarint.encodingLength
          )

          exports.uint32 = exports.uint64 = exports.enum = exports.varint = encoder(
            0,
            varint.encode,
            varint.decode,
            varint.encodingLength
          )

          // we cannot represent these in javascript so we just use buffers
          exports.fixed64 = exports.sfixed64 = encoder(
            1,
            function encode(val, buffer, offset) {
              val.copy(buffer, offset)
              encode.bytes = 8
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.slice(offset, offset + 8)
              decode.bytes = 8
              return val
            },
            function encodingLength() {
              return 8
            }
          )

          exports.double = encoder(
            1,
            function encode(val, buffer, offset) {
              buffer.writeDoubleLE(val, offset)
              encode.bytes = 8
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readDoubleLE(offset)
              decode.bytes = 8
              return val
            },
            function encodingLength() {
              return 8
            }
          )

          exports.fixed32 = encoder(
            5,
            function encode(val, buffer, offset) {
              buffer.writeUInt32LE(val, offset)
              encode.bytes = 4
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readUInt32LE(offset)
              decode.bytes = 4
              return val
            },
            function encodingLength() {
              return 4
            }
          )

          exports.sfixed32 = encoder(
            5,
            function encode(val, buffer, offset) {
              buffer.writeInt32LE(val, offset)
              encode.bytes = 4
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readInt32LE(offset)
              decode.bytes = 4
              return val
            },
            function encodingLength() {
              return 4
            }
          )

          exports.float = encoder(
            5,
            function encode(val, buffer, offset) {
              buffer.writeFloatLE(val, offset)
              encode.bytes = 4
              return buffer
            },
            function decode(buffer, offset) {
              var val = buffer.readFloatLE(offset)
              decode.bytes = 4
              return val
            },
            function encodingLength() {
              return 4
            }
          )

          function encoder(type, encode, decode, encodingLength) {
            encode.bytes = decode.bytes = 0

            return {
              type: type,
              encode: encode,
              decode: decode,
              encodingLength: encodingLength
            }
          }

          function bufferLength(val) {
            return Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val)
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "signed-varint": 60, varint: 82 }
    ],
    46: [
      function(require, module, exports) {
        module.exports = function() {
          throw new Error("random-access-file is not supported in the browser")
        }
      },
      {}
    ],
    47: [
      function(require, module, exports) {
        ;(function(process) {
          var events = require("events")
          var inherits = require("inherits")

          var NOT_READABLE = defaultImpl(new Error("Not readable"))
          var NOT_WRITABLE = defaultImpl(new Error("Not writable"))
          var NOT_DELETABLE = defaultImpl(new Error("Not deletable"))
          var NOT_STATABLE = defaultImpl(new Error("Not statable"))
          var NO_OPEN_READABLE = defaultImpl(new Error("No readonly open"))

          module.exports = RandomAccess

          function RandomAccess(opts) {
            if (!(this instanceof RandomAccess)) return new RandomAccess(opts)
            events.EventEmitter.call(this)

            this._queued = []
            this._pending = 0
            this._needsOpen = true

            this.opened = false
            this.closed = false
            this.destroyed = false

            if (opts) {
              if (opts.openReadonly) this._openReadonly = opts.openReadonly
              if (opts.open) this._open = opts.open
              if (opts.read) this._read = opts.read
              if (opts.write) this._write = opts.write
              if (opts.del) this._del = opts.del
              if (opts.stat) this._stat = opts.stat
              if (opts.close) this._close = opts.close
              if (opts.destroy) this._destroy = opts.destroy
            }

            this.preferReadonly = this._openReadonly !== NO_OPEN_READABLE
            this.readable = this._read !== NOT_READABLE
            this.writable = this._write !== NOT_WRITABLE
            this.deletable = this._del !== NOT_DELETABLE
            this.statable = this._stat !== NOT_STATABLE
          }

          inherits(RandomAccess, events.EventEmitter)

          RandomAccess.prototype.open = function(cb) {
            if (!cb) cb = noop
            if (this.opened && !this._needsOpen)
              return process.nextTick(cb, null)
            queueAndRun(this, new Request(this, 0, 0, 0, null, cb))
          }

          RandomAccess.prototype._open = defaultImpl(null)
          RandomAccess.prototype._openReadonly = NO_OPEN_READABLE

          RandomAccess.prototype.read = function(offset, size, cb) {
            this.run(new Request(this, 1, offset, size, null, cb))
          }

          RandomAccess.prototype._read = NOT_READABLE

          RandomAccess.prototype.write = function(offset, data, cb) {
            if (!cb) cb = noop
            openWritable(this)
            this.run(new Request(this, 2, offset, data.length, data, cb))
          }

          RandomAccess.prototype._write = NOT_WRITABLE

          RandomAccess.prototype.del = function(offset, size, cb) {
            if (!cb) cb = noop
            openWritable(this)
            this.run(new Request(this, 3, offset, size, null, cb))
          }

          RandomAccess.prototype._del = NOT_DELETABLE

          RandomAccess.prototype.stat = function(cb) {
            this.run(new Request(this, 4, 0, 0, null, cb))
          }

          RandomAccess.prototype._stat = NOT_STATABLE

          RandomAccess.prototype.close = function(cb) {
            if (!cb) cb = noop
            if (this.closed) return process.nextTick(cb, null)
            queueAndRun(this, new Request(this, 5, 0, 0, null, cb))
          }

          RandomAccess.prototype._close = defaultImpl(null)

          RandomAccess.prototype.destroy = function(cb) {
            if (!cb) cb = noop
            if (!this.closed) this.close(noop)
            queueAndRun(this, new Request(this, 6, 0, 0, null, cb))
          }

          RandomAccess.prototype._destroy = defaultImpl(null)

          RandomAccess.prototype.run = function(req) {
            if (this._needsOpen) this.open(noop)
            if (this._queued.length) this._queued.push(req)
            else req._run()
          }

          function noop() {}

          function Request(self, type, offset, size, data, cb) {
            this.type = type
            this.offset = offset
            this.data = data
            this.size = size
            this.storage = self

            this._sync = false
            this._callback = cb
          }

          Request.prototype._unqueue = function(err) {
            var ra = this.storage
            var queued = ra._queued

            if (!err) {
              switch (this.type) {
                case 0:
                  if (!ra.opened) {
                    ra.opened = true
                    ra.emit("open")
                  }
                  break

                case 5:
                  if (!ra.closed) {
                    ra.closed = true
                    ra.emit("close")
                  }
                  break

                case 6:
                  if (!ra.destroyed) {
                    ra.destroyed = true
                    ra.emit("destroy")
                  }
                  break
              }
            }

            if (queued.length && queued[0] === this) queued.shift()
            if (!--ra._pending && queued.length) queued[0]._run()
          }

          Request.prototype.callback = function(err, val) {
            if (this._sync) return nextTick(this, err, val)
            this._unqueue(err)
            this._callback(err, val)
          }

          Request.prototype._openAndNotClosed = function() {
            var ra = this.storage
            if (ra.opened && !ra.closed) return true
            if (!ra.opened) nextTick(this, new Error("Not opened"))
            else if (ra.closed) nextTick(this, new Error("Closed"))
            return false
          }

          Request.prototype._open = function() {
            var ra = this.storage

            if (ra.opened && !ra._needsOpen) return nextTick(this, null)
            if (ra.closed) return nextTick(this, new Error("Closed"))

            ra._needsOpen = false
            if (ra.preferReadonly) ra._openReadonly(this)
            else ra._open(this)
          }

          Request.prototype._run = function() {
            var ra = this.storage
            ra._pending++

            this._sync = true

            switch (this.type) {
              case 0:
                this._open()
                break

              case 1:
                if (this._openAndNotClosed()) ra._read(this)
                break

              case 2:
                if (this._openAndNotClosed()) ra._write(this)
                break

              case 3:
                if (this._openAndNotClosed()) ra._del(this)
                break

              case 4:
                if (this._openAndNotClosed()) ra._stat(this)
                break

              case 5:
                if (ra.closed || !ra.opened) nextTick(this, null)
                else ra._close(this)
                break

              case 6:
                if (ra.destroyed) nextTick(this, null)
                else ra._destroy(this)
                break
            }

            this._sync = false
          }

          function queueAndRun(self, req) {
            self._queued.push(req)
            if (!self._pending) req._run()
          }

          function openWritable(self) {
            if (self.preferReadonly) {
              self._needsOpen = true
              self.preferReadonly = false
            }
          }

          function defaultImpl(err) {
            return overridable

            function overridable(req) {
              nextTick(req, err)
            }
          }

          function nextTick(req, err, val) {
            process.nextTick(nextTickCallback, req, err, val)
          }

          function nextTickCallback(req, err, val) {
            req.callback(err, val)
          }
        }.call(this, require("_process")))
      },
      { _process: 44, events: 24, inherits: 37 }
    ],
    48: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a duplex stream is just a stream that is both readable and writable.
        // Since JS doesn't have multiple prototypal inheritance, this class
        // prototypally inherits from Readable, and then parasitically from
        // Writable.

        "use strict"

        /*<replacement>*/

        var pna = require("process-nextick-args")
        /*</replacement>*/

        /*<replacement>*/
        var objectKeys =
          Object.keys ||
          function(obj) {
            var keys = []
            for (var key in obj) {
              keys.push(key)
            }
            return keys
          }
        /*</replacement>*/

        module.exports = Duplex

        /*<replacement>*/
        var util = require("core-util-is")
        util.inherits = require("inherits")
        /*</replacement>*/

        var Readable = require("./_stream_readable")
        var Writable = require("./_stream_writable")

        util.inherits(Duplex, Readable)

        {
          // avoid scope creep, the keys array can then be collected
          var keys = objectKeys(Writable.prototype)
          for (var v = 0; v < keys.length; v++) {
            var method = keys[v]
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method]
          }
        }

        function Duplex(options) {
          if (!(this instanceof Duplex)) return new Duplex(options)

          Readable.call(this, options)
          Writable.call(this, options)

          if (options && options.readable === false) this.readable = false

          if (options && options.writable === false) this.writable = false

          this.allowHalfOpen = true
          if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false

          this.once("end", onend)
        }

        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function() {
            return this._writableState.highWaterMark
          }
        })

        // the no-half-open enforcer
        function onend() {
          // if we allow half-open state, or if the writable side ended,
          // then we're ok.
          if (this.allowHalfOpen || this._writableState.ended) return

          // no more data can be written.
          // But allow more writes to happen in this tick.
          pna.nextTick(onEndNT, this)
        }

        function onEndNT(self) {
          self.end()
        }

        Object.defineProperty(Duplex.prototype, "destroyed", {
          get: function() {
            if (
              this._readableState === undefined ||
              this._writableState === undefined
            ) {
              return false
            }
            return (
              this._readableState.destroyed && this._writableState.destroyed
            )
          },
          set: function(value) {
            // we ignore the value if the stream
            // has not been initialized yet
            if (
              this._readableState === undefined ||
              this._writableState === undefined
            ) {
              return
            }

            // backward compatibility, the user is explicitly
            // managing destroyed
            this._readableState.destroyed = value
            this._writableState.destroyed = value
          }
        })

        Duplex.prototype._destroy = function(err, cb) {
          this.push(null)
          this.end()

          pna.nextTick(cb, err)
        }
      },
      {
        "./_stream_readable": 50,
        "./_stream_writable": 52,
        "core-util-is": 23,
        inherits: 37,
        "process-nextick-args": 57
      }
    ],
    49: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a passthrough stream.
        // basically just the most minimal sort of Transform stream.
        // Every written chunk gets output as-is.

        "use strict"

        module.exports = PassThrough

        var Transform = require("./_stream_transform")

        /*<replacement>*/
        var util = require("core-util-is")
        util.inherits = require("inherits")
        /*</replacement>*/

        util.inherits(PassThrough, Transform)

        function PassThrough(options) {
          if (!(this instanceof PassThrough)) return new PassThrough(options)

          Transform.call(this, options)
        }

        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk)
        }
      },
      { "./_stream_transform": 51, "core-util-is": 23, inherits: 37 }
    ],
    50: [
      function(require, module, exports) {
        ;(function(process, global) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          "use strict"

          /*<replacement>*/

          var pna = require("process-nextick-args")
          /*</replacement>*/

          module.exports = Readable

          /*<replacement>*/
          var isArray = require("isarray")
          /*</replacement>*/

          /*<replacement>*/
          var Duplex
          /*</replacement>*/

          Readable.ReadableState = ReadableState

          /*<replacement>*/
          var EE = require("events").EventEmitter

          var EElistenerCount = function(emitter, type) {
            return emitter.listeners(type).length
          }
          /*</replacement>*/

          /*<replacement>*/
          var Stream = require("./internal/streams/stream")
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = require("safe-buffer").Buffer
          var OurUint8Array = global.Uint8Array || function() {}
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk)
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
          }

          /*</replacement>*/

          /*<replacement>*/
          var util = require("core-util-is")
          util.inherits = require("inherits")
          /*</replacement>*/

          /*<replacement>*/
          var debugUtil = require("util")
          var debug = void 0
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream")
          } else {
            debug = function() {}
          }
          /*</replacement>*/

          var BufferList = require("./internal/streams/BufferList")
          var destroyImpl = require("./internal/streams/destroy")
          var StringDecoder

          util.inherits(Readable, Stream)

          var kProxyEvents = ["error", "close", "destroy", "pause", "resume"]

          function prependListener(emitter, event, fn) {
            // Sadly this is not cacheable as some libraries bundle their own
            // event emitter implementation with them.
            if (typeof emitter.prependListener === "function")
              return emitter.prependListener(event, fn)

            // This is a hack to make sure that our error handler is attached before any
            // userland ones.  NEVER DO THIS. This is here only because this code needs
            // to continue to work with older versions of Node.js that do not include
            // the prependListener() method. The goal is to eventually remove this hack.
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn)
            else if (isArray(emitter._events[event]))
              emitter._events[event].unshift(fn)
            else emitter._events[event] = [fn, emitter._events[event]]
          }

          function ReadableState(options, stream) {
            Duplex = Duplex || require("./_stream_duplex")

            options = options || {}

            // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.
            var isDuplex = stream instanceof Duplex

            // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away
            this.objectMode = !!options.objectMode

            if (isDuplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode

            // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"
            var hwm = options.highWaterMark
            var readableHwm = options.readableHighWaterMark
            var defaultHwm = this.objectMode ? 16 : 16 * 1024

            if (hwm || hwm === 0) this.highWaterMark = hwm
            else if (isDuplex && (readableHwm || readableHwm === 0))
              this.highWaterMark = readableHwm
            else this.highWaterMark = defaultHwm

            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark)

            // A linked list is used to store data chunks instead of an array because the
            // linked list can remove elements from the beginning faster than
            // array.shift()
            this.buffer = new BufferList()
            this.length = 0
            this.pipes = null
            this.pipesCount = 0
            this.flowing = null
            this.ended = false
            this.endEmitted = false
            this.reading = false

            // a flag to be able to tell if the event 'readable'/'data' is emitted
            // immediately, or on a later tick.  We set this to true at first, because
            // any actions that shouldn't happen until "later" should generally also
            // not happen before the first read call.
            this.sync = true

            // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.
            this.needReadable = false
            this.emittedReadable = false
            this.readableListening = false
            this.resumeScheduled = false

            // has it been destroyed
            this.destroyed = false

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || "utf8"

            // the number of writers that are awaiting a drain event in .pipe()s
            this.awaitDrain = 0

            // if true, a maybeReadMore has been scheduled
            this.readingMore = false

            this.decoder = null
            this.encoding = null
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require("string_decoder/").StringDecoder
              this.decoder = new StringDecoder(options.encoding)
              this.encoding = options.encoding
            }
          }

          function Readable(options) {
            Duplex = Duplex || require("./_stream_duplex")

            if (!(this instanceof Readable)) return new Readable(options)

            this._readableState = new ReadableState(options, this)

            // legacy
            this.readable = true

            if (options) {
              if (typeof options.read === "function") this._read = options.read

              if (typeof options.destroy === "function")
                this._destroy = options.destroy
            }

            Stream.call(this)
          }

          Object.defineProperty(Readable.prototype, "destroyed", {
            get: function() {
              if (this._readableState === undefined) {
                return false
              }
              return this._readableState.destroyed
            },
            set: function(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._readableState) {
                return
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._readableState.destroyed = value
            }
          })

          Readable.prototype.destroy = destroyImpl.destroy
          Readable.prototype._undestroy = destroyImpl.undestroy
          Readable.prototype._destroy = function(err, cb) {
            this.push(null)
            cb(err)
          }

          // Manually shove something into the read() buffer.
          // This returns true if the highWaterMark has not been hit yet,
          // similar to how Writable.write() returns true if you should
          // write() some more.
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState
            var skipChunkCheck

            if (!state.objectMode) {
              if (typeof chunk === "string") {
                encoding = encoding || state.defaultEncoding
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding)
                  encoding = ""
                }
                skipChunkCheck = true
              }
            } else {
              skipChunkCheck = true
            }

            return readableAddChunk(
              this,
              chunk,
              encoding,
              false,
              skipChunkCheck
            )
          }

          // Unshift should *always* be something directly out of read()
          Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false)
          }

          function readableAddChunk(
            stream,
            chunk,
            encoding,
            addToFront,
            skipChunkCheck
          ) {
            var state = stream._readableState
            if (chunk === null) {
              state.reading = false
              onEofChunk(stream, state)
            } else {
              var er
              if (!skipChunkCheck) er = chunkInvalid(state, chunk)
              if (er) {
                stream.emit("error", er)
              } else if (state.objectMode || (chunk && chunk.length > 0)) {
                if (
                  typeof chunk !== "string" &&
                  !state.objectMode &&
                  Object.getPrototypeOf(chunk) !== Buffer.prototype
                ) {
                  chunk = _uint8ArrayToBuffer(chunk)
                }

                if (addToFront) {
                  if (state.endEmitted)
                    stream.emit(
                      "error",
                      new Error("stream.unshift() after end event")
                    )
                  else addChunk(stream, state, chunk, true)
                } else if (state.ended) {
                  stream.emit("error", new Error("stream.push() after EOF"))
                } else {
                  state.reading = false
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk)
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false)
                    else maybeReadMore(stream, state)
                  } else {
                    addChunk(stream, state, chunk, false)
                  }
                }
              } else if (!addToFront) {
                state.reading = false
              }
            }

            return needMoreData(state)
          }

          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit("data", chunk)
              stream.read(0)
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length
              if (addToFront) state.buffer.unshift(chunk)
              else state.buffer.push(chunk)

              if (state.needReadable) emitReadable(stream)
            }
            maybeReadMore(stream, state)
          }

          function chunkInvalid(state, chunk) {
            var er
            if (
              !_isUint8Array(chunk) &&
              typeof chunk !== "string" &&
              chunk !== undefined &&
              !state.objectMode
            ) {
              er = new TypeError("Invalid non-string/buffer chunk")
            }
            return er
          }

          // if it's past the high water mark, we can push in some more.
          // Also, if we have no data yet, we can stand some
          // more bytes.  This is to work around cases where hwm=0,
          // such as the repl.  Also, if the push() triggered a
          // readable event, and the user called read(largeNumber) such that
          // needReadable was set, then we ought to push more, so that another
          // 'readable' event will be triggered.
          function needMoreData(state) {
            return (
              !state.ended &&
              (state.needReadable ||
                state.length < state.highWaterMark ||
                state.length === 0)
            )
          }

          Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false
          }

          // backwards compatibility.
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require("string_decoder/").StringDecoder
            this._readableState.decoder = new StringDecoder(enc)
            this._readableState.encoding = enc
            return this
          }

          // Don't raise the hwm > 8MB
          var MAX_HWM = 0x800000
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM
            } else {
              // Get the next highest power of 2 to prevent increasing hwm excessively in
              // tiny amounts
              n--
              n |= n >>> 1
              n |= n >>> 2
              n |= n >>> 4
              n |= n >>> 8
              n |= n >>> 16
              n++
            }
            return n
          }

          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function howMuchToRead(n, state) {
            if (n <= 0 || (state.length === 0 && state.ended)) return 0
            if (state.objectMode) return 1
            if (n !== n) {
              // Only flow one buffer at a time
              if (state.flowing && state.length)
                return state.buffer.head.data.length
              else return state.length
            }
            // If we're asking for more than the current hwm, then raise the hwm.
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n)
            if (n <= state.length) return n
            // Don't have enough
            if (!state.ended) {
              state.needReadable = true
              return 0
            }
            return state.length
          }

          // you can override either this method, or the async _read(n) below.
          Readable.prototype.read = function(n) {
            debug("read", n)
            n = parseInt(n, 10)
            var state = this._readableState
            var nOrig = n

            if (n !== 0) state.emittedReadable = false

            // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.
            if (
              n === 0 &&
              state.needReadable &&
              (state.length >= state.highWaterMark || state.ended)
            ) {
              debug("read: emitReadable", state.length, state.ended)
              if (state.length === 0 && state.ended) endReadable(this)
              else emitReadable(this)
              return null
            }

            n = howMuchToRead(n, state)

            // if we've ended, and we're now clear, then finish it up.
            if (n === 0 && state.ended) {
              if (state.length === 0) endReadable(this)
              return null
            }

            // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.

            // if we need a readable event, then we need to do some reading.
            var doRead = state.needReadable
            debug("need readable", doRead)

            // if we currently have less than the highWaterMark, then also read some
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true
              debug("length less than watermark", doRead)
            }

            // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.
            if (state.ended || state.reading) {
              doRead = false
              debug("reading or ended", doRead)
            } else if (doRead) {
              debug("do read")
              state.reading = true
              state.sync = true
              // if the length is currently zero, then we *need* a readable event.
              if (state.length === 0) state.needReadable = true
              // call internal read method
              this._read(state.highWaterMark)
              state.sync = false
              // If _read pushed data synchronously, then `reading` will be false,
              // and we need to re-evaluate how much data we can return to the user.
              if (!state.reading) n = howMuchToRead(nOrig, state)
            }

            var ret
            if (n > 0) ret = fromList(n, state)
            else ret = null

            if (ret === null) {
              state.needReadable = true
              n = 0
            } else {
              state.length -= n
            }

            if (state.length === 0) {
              // If we have nothing in the buffer, then we want to know
              // as soon as we *do* get something into the buffer.
              if (!state.ended) state.needReadable = true

              // If we tried to read() past the EOF, then emit end on the next tick.
              if (nOrig !== n && state.ended) endReadable(this)
            }

            if (ret !== null) this.emit("data", ret)

            return ret
          }

          function onEofChunk(stream, state) {
            if (state.ended) return
            if (state.decoder) {
              var chunk = state.decoder.end()
              if (chunk && chunk.length) {
                state.buffer.push(chunk)
                state.length += state.objectMode ? 1 : chunk.length
              }
            }
            state.ended = true

            // emit 'readable' now to make sure it gets picked up.
            emitReadable(stream)
          }

          // Don't emit readable right away in sync mode, because this can trigger
          // another read() call => stack overflow.  This way, it might trigger
          // a nextTick recursion warning, but that's not so bad.
          function emitReadable(stream) {
            var state = stream._readableState
            state.needReadable = false
            if (!state.emittedReadable) {
              debug("emitReadable", state.flowing)
              state.emittedReadable = true
              if (state.sync) pna.nextTick(emitReadable_, stream)
              else emitReadable_(stream)
            }
          }

          function emitReadable_(stream) {
            debug("emit readable")
            stream.emit("readable")
            flow(stream)
          }

          // at this point, the user has presumably seen the 'readable' event,
          // and called read() to consume some data.  that may have triggered
          // in turn another _read(n) call, in which case reading = true if
          // it's in progress.
          // However, if we're not ended, or reading, and the length < hwm,
          // then go ahead and try to read some more preemptively.
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true
              pna.nextTick(maybeReadMore_, stream, state)
            }
          }

          function maybeReadMore_(stream, state) {
            var len = state.length
            while (
              !state.reading &&
              !state.flowing &&
              !state.ended &&
              state.length < state.highWaterMark
            ) {
              debug("maybeReadMore read 0")
              stream.read(0)
              if (len === state.length)
                // didn't get any data, stop spinning.
                break
              else len = state.length
            }
            state.readingMore = false
          }

          // abstract method.  to be overridden in specific implementation classes.
          // call cb(er, data) where data is <= n in length.
          // for virtual (non-string, non-buffer) streams, "length" is somewhat
          // arbitrary, and perhaps not very meaningful.
          Readable.prototype._read = function(n) {
            this.emit("error", new Error("_read() is not implemented"))
          }

          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this
            var state = this._readableState

            switch (state.pipesCount) {
              case 0:
                state.pipes = dest
                break
              case 1:
                state.pipes = [state.pipes, dest]
                break
              default:
                state.pipes.push(dest)
                break
            }
            state.pipesCount += 1
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts)

            var doEnd =
              (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr

            var endFn = doEnd ? onend : unpipe
            if (state.endEmitted) pna.nextTick(endFn)
            else src.once("end", endFn)

            dest.on("unpipe", onunpipe)
            function onunpipe(readable, unpipeInfo) {
              debug("onunpipe")
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true
                  cleanup()
                }
              }
            }

            function onend() {
              debug("onend")
              dest.end()
            }

            // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            var ondrain = pipeOnDrain(src)
            dest.on("drain", ondrain)

            var cleanedUp = false
            function cleanup() {
              debug("cleanup")
              // cleanup event handlers once the pipe is broken
              dest.removeListener("close", onclose)
              dest.removeListener("finish", onfinish)
              dest.removeListener("drain", ondrain)
              dest.removeListener("error", onerror)
              dest.removeListener("unpipe", onunpipe)
              src.removeListener("end", onend)
              src.removeListener("end", unpipe)
              src.removeListener("data", ondata)

              cleanedUp = true

              // if the reader is waiting for a drain event from this
              // specific writer, then it would cause it to never start
              // flowing again.
              // So, if this is awaiting a drain, then we just call it now.
              // If we don't know, then assume that we are waiting for one.
              if (
                state.awaitDrain &&
                (!dest._writableState || dest._writableState.needDrain)
              )
                ondrain()
            }

            // If the user pushes more data while we're writing to dest then we'll end up
            // in ondata again. However, we only want to increase awaitDrain once because
            // dest will only emit one 'drain' event for the multiple writes.
            // => Introduce a guard on increasing awaitDrain.
            var increasedAwaitDrain = false
            src.on("data", ondata)
            function ondata(chunk) {
              debug("ondata")
              increasedAwaitDrain = false
              var ret = dest.write(chunk)
              if (false === ret && !increasedAwaitDrain) {
                // If the user unpiped during `dest.write()`, it is possible
                // to get stuck in a permanently paused state if that write
                // also returned false.
                // => Check whether `dest` is still a piping destination.
                if (
                  ((state.pipesCount === 1 && state.pipes === dest) ||
                    (state.pipesCount > 1 &&
                      indexOf(state.pipes, dest) !== -1)) &&
                  !cleanedUp
                ) {
                  debug(
                    "false write response, pause",
                    src._readableState.awaitDrain
                  )
                  src._readableState.awaitDrain++
                  increasedAwaitDrain = true
                }
                src.pause()
              }
            }

            // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.
            function onerror(er) {
              debug("onerror", er)
              unpipe()
              dest.removeListener("error", onerror)
              if (EElistenerCount(dest, "error") === 0) dest.emit("error", er)
            }

            // Make sure our error handler is attached before userland ones.
            prependListener(dest, "error", onerror)

            // Both close and finish should trigger unpipe, but only once.
            function onclose() {
              dest.removeListener("finish", onfinish)
              unpipe()
            }
            dest.once("close", onclose)
            function onfinish() {
              debug("onfinish")
              dest.removeListener("close", onclose)
              unpipe()
            }
            dest.once("finish", onfinish)

            function unpipe() {
              debug("unpipe")
              src.unpipe(dest)
            }

            // tell the dest that it's being piped to
            dest.emit("pipe", src)

            // start the flow if it hasn't been started already.
            if (!state.flowing) {
              debug("pipe resume")
              src.resume()
            }

            return dest
          }

          function pipeOnDrain(src) {
            return function() {
              var state = src._readableState
              debug("pipeOnDrain", state.awaitDrain)
              if (state.awaitDrain) state.awaitDrain--
              if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                state.flowing = true
                flow(src)
              }
            }
          }

          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState
            var unpipeInfo = { hasUnpiped: false }

            // if we're not piping anywhere, then do nothing.
            if (state.pipesCount === 0) return this

            // just one destination.  most common case.
            if (state.pipesCount === 1) {
              // passed in one, but it's not the right one.
              if (dest && dest !== state.pipes) return this

              if (!dest) dest = state.pipes

              // got a match.
              state.pipes = null
              state.pipesCount = 0
              state.flowing = false
              if (dest) dest.emit("unpipe", this, unpipeInfo)
              return this
            }

            // slow case. multiple pipe destinations.

            if (!dest) {
              // remove all.
              var dests = state.pipes
              var len = state.pipesCount
              state.pipes = null
              state.pipesCount = 0
              state.flowing = false

              for (var i = 0; i < len; i++) {
                dests[i].emit("unpipe", this, unpipeInfo)
              }
              return this
            }

            // try to find the right one.
            var index = indexOf(state.pipes, dest)
            if (index === -1) return this

            state.pipes.splice(index, 1)
            state.pipesCount -= 1
            if (state.pipesCount === 1) state.pipes = state.pipes[0]

            dest.emit("unpipe", this, unpipeInfo)

            return this
          }

          // set up data events if they are asked for
          // Ensure readable listeners eventually get something
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn)

            if (ev === "data") {
              // Start flowing on next tick if stream isn't explicitly paused
              if (this._readableState.flowing !== false) this.resume()
            } else if (ev === "readable") {
              var state = this._readableState
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true
                state.emittedReadable = false
                if (!state.reading) {
                  pna.nextTick(nReadingNextTick, this)
                } else if (state.length) {
                  emitReadable(this)
                }
              }
            }

            return res
          }
          Readable.prototype.addListener = Readable.prototype.on

          function nReadingNextTick(self) {
            debug("readable nexttick read 0")
            self.read(0)
          }

          // pause() and resume() are remnants of the legacy readable stream API
          // If the user uses them, then switch into old mode.
          Readable.prototype.resume = function() {
            var state = this._readableState
            if (!state.flowing) {
              debug("resume")
              state.flowing = true
              resume(this, state)
            }
            return this
          }

          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true
              pna.nextTick(resume_, stream, state)
            }
          }

          function resume_(stream, state) {
            if (!state.reading) {
              debug("resume read 0")
              stream.read(0)
            }

            state.resumeScheduled = false
            state.awaitDrain = 0
            stream.emit("resume")
            flow(stream)
            if (state.flowing && !state.reading) stream.read(0)
          }

          Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing)
            if (false !== this._readableState.flowing) {
              debug("pause")
              this._readableState.flowing = false
              this.emit("pause")
            }
            return this
          }

          function flow(stream) {
            var state = stream._readableState
            debug("flow", state.flowing)
            while (state.flowing && stream.read() !== null) {}
          }

          // wrap an old-style stream as the async data source.
          // This is *not* part of the readable stream interface.
          // It is an ugly unfortunate mess of history.
          Readable.prototype.wrap = function(stream) {
            var _this = this

            var state = this._readableState
            var paused = false

            stream.on("end", function() {
              debug("wrapped end")
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end()
                if (chunk && chunk.length) _this.push(chunk)
              }

              _this.push(null)
            })

            stream.on("data", function(chunk) {
              debug("wrapped data")
              if (state.decoder) chunk = state.decoder.write(chunk)

              // don't skip over falsy values in objectMode
              if (state.objectMode && (chunk === null || chunk === undefined))
                return
              else if (!state.objectMode && (!chunk || !chunk.length)) return

              var ret = _this.push(chunk)
              if (!ret) {
                paused = true
                stream.pause()
              }
            })

            // proxy all the other methods.
            // important when wrapping filters and duplexes.
            for (var i in stream) {
              if (this[i] === undefined && typeof stream[i] === "function") {
                this[i] = (function(method) {
                  return function() {
                    return stream[method].apply(stream, arguments)
                  }
                })(i)
              }
            }

            // proxy certain important events.
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]))
            }

            // when we try to consume some more bytes, simply unpause the
            // underlying stream.
            this._read = function(n) {
              debug("wrapped _read", n)
              if (paused) {
                paused = false
                stream.resume()
              }
            }

            return this
          }

          Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function() {
              return this._readableState.highWaterMark
            }
          })

          // exposed for testing purposes only.
          Readable._fromList = fromList

          // Pluck off n bytes from an array of buffers.
          // Length is the combined lengths of all the buffers in the list.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromList(n, state) {
            // nothing buffered
            if (state.length === 0) return null

            var ret
            if (state.objectMode) ret = state.buffer.shift()
            else if (!n || n >= state.length) {
              // read it all, truncate the list
              if (state.decoder) ret = state.buffer.join("")
              else if (state.buffer.length === 1) ret = state.buffer.head.data
              else ret = state.buffer.concat(state.length)
              state.buffer.clear()
            } else {
              // read part of list
              ret = fromListPartial(n, state.buffer, state.decoder)
            }

            return ret
          }

          // Extracts only enough buffered data to satisfy the amount requested.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function fromListPartial(n, list, hasStrings) {
            var ret
            if (n < list.head.data.length) {
              // slice is the same for buffers and strings
              ret = list.head.data.slice(0, n)
              list.head.data = list.head.data.slice(n)
            } else if (n === list.head.data.length) {
              // first chunk is a perfect match
              ret = list.shift()
            } else {
              // result spans more than one buffer
              ret = hasStrings
                ? copyFromBufferString(n, list)
                : copyFromBuffer(n, list)
            }
            return ret
          }

          // Copies a specified amount of characters from the list of buffered data
          // chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBufferString(n, list) {
            var p = list.head
            var c = 1
            var ret = p.data
            n -= ret.length
            while ((p = p.next)) {
              var str = p.data
              var nb = n > str.length ? str.length : n
              if (nb === str.length) ret += str
              else ret += str.slice(0, n)
              n -= nb
              if (n === 0) {
                if (nb === str.length) {
                  ++c
                  if (p.next) list.head = p.next
                  else list.head = list.tail = null
                } else {
                  list.head = p
                  p.data = str.slice(nb)
                }
                break
              }
              ++c
            }
            list.length -= c
            return ret
          }

          // Copies a specified amount of bytes from the list of buffered data chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.
          function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n)
            var p = list.head
            var c = 1
            p.data.copy(ret)
            n -= p.data.length
            while ((p = p.next)) {
              var buf = p.data
              var nb = n > buf.length ? buf.length : n
              buf.copy(ret, ret.length - n, 0, nb)
              n -= nb
              if (n === 0) {
                if (nb === buf.length) {
                  ++c
                  if (p.next) list.head = p.next
                  else list.head = list.tail = null
                } else {
                  list.head = p
                  p.data = buf.slice(nb)
                }
                break
              }
              ++c
            }
            list.length -= c
            return ret
          }

          function endReadable(stream) {
            var state = stream._readableState

            // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.
            if (state.length > 0)
              throw new Error('"endReadable()" called on non-empty stream')

            if (!state.endEmitted) {
              state.ended = true
              pna.nextTick(endReadableNT, state, stream)
            }
          }

          function endReadableNT(state, stream) {
            // Check that we didn't get one last unshift.
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true
              stream.readable = false
              stream.emit("end")
            }
          }

          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x) return i
            }
            return -1
          }
        }.call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {}
        ))
      },
      {
        "./_stream_duplex": 48,
        "./internal/streams/BufferList": 53,
        "./internal/streams/destroy": 54,
        "./internal/streams/stream": 55,
        _process: 44,
        "core-util-is": 23,
        events: 24,
        inherits: 37,
        isarray: 56,
        "process-nextick-args": 57,
        "safe-buffer": 59,
        "string_decoder/": 73,
        util: 14
      }
    ],
    51: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // a transform stream is a readable/writable stream where you do
        // something with the data.  Sometimes it's called a "filter",
        // but that's not a great name for it, since that implies a thing where
        // some bits pass through, and others are simply ignored.  (That would
        // be a valid example of a transform, of course.)
        //
        // While the output is causally related to the input, it's not a
        // necessarily symmetric or synchronous transformation.  For example,
        // a zlib stream might take multiple plain-text writes(), and then
        // emit a single compressed chunk some time in the future.
        //
        // Here's how this works:
        //
        // The Transform stream has all the aspects of the readable and writable
        // stream classes.  When you write(chunk), that calls _write(chunk,cb)
        // internally, and returns false if there's a lot of pending writes
        // buffered up.  When you call read(), that calls _read(n) until
        // there's enough pending readable data buffered up.
        //
        // In a transform stream, the written data is placed in a buffer.  When
        // _read(n) is called, it transforms the queued up data, calling the
        // buffered _write cb's as it consumes chunks.  If consuming a single
        // written chunk would result in multiple output chunks, then the first
        // outputted bit calls the readcb, and subsequent chunks just go into
        // the read buffer, and will cause it to emit 'readable' if necessary.
        //
        // This way, back-pressure is actually determined by the reading side,
        // since _read has to be called to start processing a new chunk.  However,
        // a pathological inflate type of transform can cause excessive buffering
        // here.  For example, imagine a stream where every byte of input is
        // interpreted as an integer from 0-255, and then results in that many
        // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
        // 1kb of data being output.  In this case, you could write a very small
        // amount of input, and end up with a very large amount of output.  In
        // such a pathological inflating mechanism, there'd be no way to tell
        // the system to stop doing the transform.  A single 4MB write could
        // cause the system to run out of memory.
        //
        // However, even in such a pathological case, only a single written chunk
        // would be consumed, and then the rest would wait (un-transformed) until
        // the results of the previous transformed chunk were consumed.

        "use strict"

        module.exports = Transform

        var Duplex = require("./_stream_duplex")

        /*<replacement>*/
        var util = require("core-util-is")
        util.inherits = require("inherits")
        /*</replacement>*/

        util.inherits(Transform, Duplex)

        function afterTransform(er, data) {
          var ts = this._transformState
          ts.transforming = false

          var cb = ts.writecb

          if (!cb) {
            return this.emit(
              "error",
              new Error("write callback called multiple times")
            )
          }

          ts.writechunk = null
          ts.writecb = null

          if (data != null)
            // single equals check for both `null` and `undefined`
            this.push(data)

          cb(er)

          var rs = this._readableState
          rs.reading = false
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark)
          }
        }

        function Transform(options) {
          if (!(this instanceof Transform)) return new Transform(options)

          Duplex.call(this, options)

          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }

          // start out asking for a readable event once data is transformed.
          this._readableState.needReadable = true

          // we have implemented the _read method, and done the other things
          // that Readable wants before the first _read call, so unset the
          // sync guard flag.
          this._readableState.sync = false

          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform

            if (typeof options.flush === "function") this._flush = options.flush
          }

          // When the writable side finishes, then flush out anything remaining.
          this.on("prefinish", prefinish)
        }

        function prefinish() {
          var _this = this

          if (typeof this._flush === "function") {
            this._flush(function(er, data) {
              done(_this, er, data)
            })
          } else {
            done(this, null, null)
          }
        }

        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false
          return Duplex.prototype.push.call(this, chunk, encoding)
        }

        // This is the part where you do stuff!
        // override this function in implementation classes.
        // 'chunk' is an input chunk.
        //
        // Call `push(newChunk)` to pass along transformed output
        // to the readable side.  You may call 'push' zero or more times.
        //
        // Call `cb(err)` when you are done with this chunk.  If you pass
        // an error, then that'll put the hurt on the whole operation.  If you
        // never call cb(), then you'll never get another chunk.
        Transform.prototype._transform = function(chunk, encoding, cb) {
          throw new Error("_transform() is not implemented")
        }

        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState
          ts.writecb = cb
          ts.writechunk = chunk
          ts.writeencoding = encoding
          if (!ts.transforming) {
            var rs = this._readableState
            if (
              ts.needTransform ||
              rs.needReadable ||
              rs.length < rs.highWaterMark
            )
              this._read(rs.highWaterMark)
          }
        }

        // Doesn't matter what the args are here.
        // _transform does all the work.
        // That we got here means that the readable side wants more data.
        Transform.prototype._read = function(n) {
          var ts = this._transformState

          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)
          } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that we've asked for it.
            ts.needTransform = true
          }
        }

        Transform.prototype._destroy = function(err, cb) {
          var _this2 = this

          Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2)
            _this2.emit("close")
          })
        }

        function done(stream, er, data) {
          if (er) return stream.emit("error", er)

          if (data != null)
            // single equals check for both `null` and `undefined`
            stream.push(data)

          // if there's nothing in the write buffer, then that means
          // that nothing more will ever be provided
          if (stream._writableState.length)
            throw new Error("Calling transform done when ws.length != 0")

          if (stream._transformState.transforming)
            throw new Error("Calling transform done when still transforming")

          return stream.push(null)
        }
      },
      { "./_stream_duplex": 48, "core-util-is": 23, inherits: 37 }
    ],
    52: [
      function(require, module, exports) {
        ;(function(process, global, setImmediate) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // A bit simpler than readable streams.
          // Implement an async ._write(chunk, encoding, cb), and it'll handle all
          // the drain event emission and buffering.

          "use strict"

          /*<replacement>*/

          var pna = require("process-nextick-args")
          /*</replacement>*/

          module.exports = Writable

          /* <replacement> */
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk
            this.encoding = encoding
            this.callback = cb
            this.next = null
          }

          // It seems a linked list but it is not
          // there will be only 2 of these for each stream
          function CorkedRequest(state) {
            var _this = this

            this.next = null
            this.entry = null
            this.finish = function() {
              onCorkedFinish(_this, state)
            }
          }
          /* </replacement> */

          /*<replacement>*/
          var asyncWrite =
            !process.browser &&
            ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1
              ? setImmediate
              : pna.nextTick
          /*</replacement>*/

          /*<replacement>*/
          var Duplex
          /*</replacement>*/

          Writable.WritableState = WritableState

          /*<replacement>*/
          var util = require("core-util-is")
          util.inherits = require("inherits")
          /*</replacement>*/

          /*<replacement>*/
          var internalUtil = {
            deprecate: require("util-deprecate")
          }
          /*</replacement>*/

          /*<replacement>*/
          var Stream = require("./internal/streams/stream")
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = require("safe-buffer").Buffer
          var OurUint8Array = global.Uint8Array || function() {}
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk)
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
          }

          /*</replacement>*/

          var destroyImpl = require("./internal/streams/destroy")

          util.inherits(Writable, Stream)

          function nop() {}

          function WritableState(options, stream) {
            Duplex = Duplex || require("./_stream_duplex")

            options = options || {}

            // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.
            var isDuplex = stream instanceof Duplex

            // object stream flag to indicate whether or not this stream
            // contains buffers or objects.
            this.objectMode = !!options.objectMode

            if (isDuplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode

            // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()
            var hwm = options.highWaterMark
            var writableHwm = options.writableHighWaterMark
            var defaultHwm = this.objectMode ? 16 : 16 * 1024

            if (hwm || hwm === 0) this.highWaterMark = hwm
            else if (isDuplex && (writableHwm || writableHwm === 0))
              this.highWaterMark = writableHwm
            else this.highWaterMark = defaultHwm

            // cast to ints.
            this.highWaterMark = Math.floor(this.highWaterMark)

            // if _final has been called
            this.finalCalled = false

            // drain event flag.
            this.needDrain = false
            // at the start of calling end()
            this.ending = false
            // when end() has been called, and returned
            this.ended = false
            // when 'finish' is emitted
            this.finished = false

            // has it been destroyed
            this.destroyed = false

            // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.
            var noDecode = options.decodeStrings === false
            this.decodeStrings = !noDecode

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || "utf8"

            // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.
            this.length = 0

            // a flag to see when we're in the middle of a write.
            this.writing = false

            // when true all writes will be buffered until .uncork() call
            this.corked = 0

            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true

            // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.
            this.bufferProcessing = false

            // the callback that's passed to _write(chunk,cb)
            this.onwrite = function(er) {
              onwrite(stream, er)
            }

            // the callback that the user supplies to write(chunk,encoding,cb)
            this.writecb = null

            // the amount that is being written when _write is called.
            this.writelen = 0

            this.bufferedRequest = null
            this.lastBufferedRequest = null

            // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted
            this.pendingcb = 0

            // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams
            this.prefinished = false

            // True if the error was already emitted and should not be thrown again
            this.errorEmitted = false

            // count buffered requests
            this.bufferedRequestCount = 0

            // allocate the first CorkedRequest, there is always
            // one allocated and free to use, and we maintain at most two
            this.corkedRequestsFree = new CorkedRequest(this)
          }

          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest
            var out = []
            while (current) {
              out.push(current)
              current = current.next
            }
            return out
          }
          ;(function() {
            try {
              Object.defineProperty(WritableState.prototype, "buffer", {
                get: internalUtil.deprecate(
                  function() {
                    return this.getBuffer()
                  },
                  "_writableState.buffer is deprecated. Use _writableState.getBuffer " +
                    "instead.",
                  "DEP0003"
                )
              })
            } catch (_) {}
          })()

          // Test _writableState for inheritance to account for Duplex streams,
          // whose prototype chain only points to Readable.
          var realHasInstance
          if (
            typeof Symbol === "function" &&
            Symbol.hasInstance &&
            typeof Function.prototype[Symbol.hasInstance] === "function"
          ) {
            realHasInstance = Function.prototype[Symbol.hasInstance]
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function(object) {
                if (realHasInstance.call(this, object)) return true
                if (this !== Writable) return false

                return object && object._writableState instanceof WritableState
              }
            })
          } else {
            realHasInstance = function(object) {
              return object instanceof this
            }
          }

          function Writable(options) {
            Duplex = Duplex || require("./_stream_duplex")

            // Writable ctor is applied to Duplexes, too.
            // `realHasInstance` is necessary because using plain `instanceof`
            // would return false, as no `_writableState` property is attached.

            // Trying to use the custom `instanceof` for Writable here will also break the
            // Node.js LazyTransform implementation, which has a non-trivial getter for
            // `_writableState` that would lead to infinite recursion.
            if (
              !realHasInstance.call(Writable, this) &&
              !(this instanceof Duplex)
            ) {
              return new Writable(options)
            }

            this._writableState = new WritableState(options, this)

            // legacy.
            this.writable = true

            if (options) {
              if (typeof options.write === "function")
                this._write = options.write

              if (typeof options.writev === "function")
                this._writev = options.writev

              if (typeof options.destroy === "function")
                this._destroy = options.destroy

              if (typeof options.final === "function")
                this._final = options.final
            }

            Stream.call(this)
          }

          // Otherwise people can pipe Writable streams, which is just wrong.
          Writable.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"))
          }

          function writeAfterEnd(stream, cb) {
            var er = new Error("write after end")
            // TODO: defer error events consistently everywhere, not just the cb
            stream.emit("error", er)
            pna.nextTick(cb, er)
          }

          // Checks that a user-supplied chunk is valid, especially for the particular
          // mode the stream is in. Currently this means that `null` is never accepted
          // and undefined/non-string values are only allowed in object mode.
          function validChunk(stream, state, chunk, cb) {
            var valid = true
            var er = false

            if (chunk === null) {
              er = new TypeError("May not write null values to stream")
            } else if (
              typeof chunk !== "string" &&
              chunk !== undefined &&
              !state.objectMode
            ) {
              er = new TypeError("Invalid non-string/buffer chunk")
            }
            if (er) {
              stream.emit("error", er)
              pna.nextTick(cb, er)
              valid = false
            }
            return valid
          }

          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState
            var ret = false
            var isBuf = !state.objectMode && _isUint8Array(chunk)

            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk)
            }

            if (typeof encoding === "function") {
              cb = encoding
              encoding = null
            }

            if (isBuf) encoding = "buffer"
            else if (!encoding) encoding = state.defaultEncoding

            if (typeof cb !== "function") cb = nop

            if (state.ended) writeAfterEnd(this, cb)
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb)
            }

            return ret
          }

          Writable.prototype.cork = function() {
            var state = this._writableState

            state.corked++
          }

          Writable.prototype.uncork = function() {
            var state = this._writableState

            if (state.corked) {
              state.corked--

              if (
                !state.writing &&
                !state.corked &&
                !state.finished &&
                !state.bufferProcessing &&
                state.bufferedRequest
              )
                clearBuffer(this, state)
            }
          }

          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(
            encoding
          ) {
            // node::ParseEncoding() requires lower case.
            if (typeof encoding === "string") encoding = encoding.toLowerCase()
            if (
              !(
                [
                  "hex",
                  "utf8",
                  "utf-8",
                  "ascii",
                  "binary",
                  "base64",
                  "ucs2",
                  "ucs-2",
                  "utf16le",
                  "utf-16le",
                  "raw"
                ].indexOf((encoding + "").toLowerCase()) > -1
              )
            )
              throw new TypeError("Unknown encoding: " + encoding)
            this._writableState.defaultEncoding = encoding
            return this
          }

          function decodeChunk(state, chunk, encoding) {
            if (
              !state.objectMode &&
              state.decodeStrings !== false &&
              typeof chunk === "string"
            ) {
              chunk = Buffer.from(chunk, encoding)
            }
            return chunk
          }

          Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function() {
              return this._writableState.highWaterMark
            }
          })

          // if we're already writing something, then just put this
          // in the queue, and wait our turn.  Otherwise, call _write
          // If we return false, then we need a drain event, so set that flag.
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding)
              if (chunk !== newChunk) {
                isBuf = true
                encoding = "buffer"
                chunk = newChunk
              }
            }
            var len = state.objectMode ? 1 : chunk.length

            state.length += len

            var ret = state.length < state.highWaterMark
            // we must ensure that previous needDrain will not be reset to false.
            if (!ret) state.needDrain = true

            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest
              state.lastBufferedRequest = {
                chunk: chunk,
                encoding: encoding,
                isBuf: isBuf,
                callback: cb,
                next: null
              }
              if (last) {
                last.next = state.lastBufferedRequest
              } else {
                state.bufferedRequest = state.lastBufferedRequest
              }
              state.bufferedRequestCount += 1
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb)
            }

            return ret
          }

          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len
            state.writecb = cb
            state.writing = true
            state.sync = true
            if (writev) stream._writev(chunk, state.onwrite)
            else stream._write(chunk, encoding, state.onwrite)
            state.sync = false
          }

          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb

            if (sync) {
              // defer the callback if we are being called synchronously
              // to avoid piling up things on the stack
              pna.nextTick(cb, er)
              // this can emit finish, and it will always happen
              // after error
              pna.nextTick(finishMaybe, stream, state)
              stream._writableState.errorEmitted = true
              stream.emit("error", er)
            } else {
              // the caller expect this to happen before if
              // it is async
              cb(er)
              stream._writableState.errorEmitted = true
              stream.emit("error", er)
              // this can emit finish, but finish must
              // always follow error
              finishMaybe(stream, state)
            }
          }

          function onwriteStateUpdate(state) {
            state.writing = false
            state.writecb = null
            state.length -= state.writelen
            state.writelen = 0
          }

          function onwrite(stream, er) {
            var state = stream._writableState
            var sync = state.sync
            var cb = state.writecb

            onwriteStateUpdate(state)

            if (er) onwriteError(stream, state, sync, er, cb)
            else {
              // Check if we're actually ready to finish, but don't emit yet
              var finished = needFinish(state)

              if (
                !finished &&
                !state.corked &&
                !state.bufferProcessing &&
                state.bufferedRequest
              ) {
                clearBuffer(stream, state)
              }

              if (sync) {
                /*<replacement>*/
                asyncWrite(afterWrite, stream, state, finished, cb)
                /*</replacement>*/
              } else {
                afterWrite(stream, state, finished, cb)
              }
            }
          }

          function afterWrite(stream, state, finished, cb) {
            if (!finished) onwriteDrain(stream, state)
            state.pendingcb--
            cb()
            finishMaybe(stream, state)
          }

          // Must force callback to be called on nextTick, so that we don't
          // emit 'drain' before the write() consumer gets the 'false' return
          // value, and has a chance to attach a 'drain' listener.
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false
              stream.emit("drain")
            }
          }

          // if there's something in the buffer waiting, then process it
          function clearBuffer(stream, state) {
            state.bufferProcessing = true
            var entry = state.bufferedRequest

            if (stream._writev && entry && entry.next) {
              // Fast case, write everything using _writev()
              var l = state.bufferedRequestCount
              var buffer = new Array(l)
              var holder = state.corkedRequestsFree
              holder.entry = entry

              var count = 0
              var allBuffers = true
              while (entry) {
                buffer[count] = entry
                if (!entry.isBuf) allBuffers = false
                entry = entry.next
                count += 1
              }
              buffer.allBuffers = allBuffers

              doWrite(
                stream,
                state,
                true,
                state.length,
                buffer,
                "",
                holder.finish
              )

              // doWrite is almost always async, defer these to save a bit of time
              // as the hot path ends with doWrite
              state.pendingcb++
              state.lastBufferedRequest = null
              if (holder.next) {
                state.corkedRequestsFree = holder.next
                holder.next = null
              } else {
                state.corkedRequestsFree = new CorkedRequest(state)
              }
              state.bufferedRequestCount = 0
            } else {
              // Slow case, write chunks one-by-one
              while (entry) {
                var chunk = entry.chunk
                var encoding = entry.encoding
                var cb = entry.callback
                var len = state.objectMode ? 1 : chunk.length

                doWrite(stream, state, false, len, chunk, encoding, cb)
                entry = entry.next
                state.bufferedRequestCount--
                // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.
                if (state.writing) {
                  break
                }
              }

              if (entry === null) state.lastBufferedRequest = null
            }

            state.bufferedRequest = entry
            state.bufferProcessing = false
          }

          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error("_write() is not implemented"))
          }

          Writable.prototype._writev = null

          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState

            if (typeof chunk === "function") {
              cb = chunk
              chunk = null
              encoding = null
            } else if (typeof encoding === "function") {
              cb = encoding
              encoding = null
            }

            if (chunk !== null && chunk !== undefined)
              this.write(chunk, encoding)

            // .end() fully uncorks
            if (state.corked) {
              state.corked = 1
              this.uncork()
            }

            // ignore unnecessary end() calls.
            if (!state.ending && !state.finished) endWritable(this, state, cb)
          }

          function needFinish(state) {
            return (
              state.ending &&
              state.length === 0 &&
              state.bufferedRequest === null &&
              !state.finished &&
              !state.writing
            )
          }
          function callFinal(stream, state) {
            stream._final(function(err) {
              state.pendingcb--
              if (err) {
                stream.emit("error", err)
              }
              state.prefinished = true
              stream.emit("prefinish")
              finishMaybe(stream, state)
            })
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === "function") {
                state.pendingcb++
                state.finalCalled = true
                pna.nextTick(callFinal, stream, state)
              } else {
                state.prefinished = true
                stream.emit("prefinish")
              }
            }
          }

          function finishMaybe(stream, state) {
            var need = needFinish(state)
            if (need) {
              prefinish(stream, state)
              if (state.pendingcb === 0) {
                state.finished = true
                stream.emit("finish")
              }
            }
            return need
          }

          function endWritable(stream, state, cb) {
            state.ending = true
            finishMaybe(stream, state)
            if (cb) {
              if (state.finished) pna.nextTick(cb)
              else stream.once("finish", cb)
            }
            state.ended = true
            stream.writable = false
          }

          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry
            corkReq.entry = null
            while (entry) {
              var cb = entry.callback
              state.pendingcb--
              cb(err)
              entry = entry.next
            }
            if (state.corkedRequestsFree) {
              state.corkedRequestsFree.next = corkReq
            } else {
              state.corkedRequestsFree = corkReq
            }
          }

          Object.defineProperty(Writable.prototype, "destroyed", {
            get: function() {
              if (this._writableState === undefined) {
                return false
              }
              return this._writableState.destroyed
            },
            set: function(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._writableState) {
                return
              }

              // backward compatibility, the user is explicitly
              // managing destroyed
              this._writableState.destroyed = value
            }
          })

          Writable.prototype.destroy = destroyImpl.destroy
          Writable.prototype._undestroy = destroyImpl.undestroy
          Writable.prototype._destroy = function(err, cb) {
            this.end()
            cb(err)
          }
        }.call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {},
          require("timers").setImmediate
        ))
      },
      {
        "./_stream_duplex": 48,
        "./internal/streams/destroy": 54,
        "./internal/streams/stream": 55,
        _process: 44,
        "core-util-is": 23,
        inherits: 37,
        "process-nextick-args": 57,
        "safe-buffer": 59,
        timers: 75,
        "util-deprecate": 79
      }
    ],
    53: [
      function(require, module, exports) {
        "use strict"

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
          }
        }

        var Buffer = require("safe-buffer").Buffer
        var util = require("util")

        function copyBuffer(src, target, offset) {
          src.copy(target, offset)
        }

        module.exports = (function() {
          function BufferList() {
            _classCallCheck(this, BufferList)

            this.head = null
            this.tail = null
            this.length = 0
          }

          BufferList.prototype.push = function push(v) {
            var entry = { data: v, next: null }
            if (this.length > 0) this.tail.next = entry
            else this.head = entry
            this.tail = entry
            ++this.length
          }

          BufferList.prototype.unshift = function unshift(v) {
            var entry = { data: v, next: this.head }
            if (this.length === 0) this.tail = entry
            this.head = entry
            ++this.length
          }

          BufferList.prototype.shift = function shift() {
            if (this.length === 0) return
            var ret = this.head.data
            if (this.length === 1) this.head = this.tail = null
            else this.head = this.head.next
            --this.length
            return ret
          }

          BufferList.prototype.clear = function clear() {
            this.head = this.tail = null
            this.length = 0
          }

          BufferList.prototype.join = function join(s) {
            if (this.length === 0) return ""
            var p = this.head
            var ret = "" + p.data
            while ((p = p.next)) {
              ret += s + p.data
            }
            return ret
          }

          BufferList.prototype.concat = function concat(n) {
            if (this.length === 0) return Buffer.alloc(0)
            if (this.length === 1) return this.head.data
            var ret = Buffer.allocUnsafe(n >>> 0)
            var p = this.head
            var i = 0
            while (p) {
              copyBuffer(p.data, ret, i)
              i += p.data.length
              p = p.next
            }
            return ret
          }

          return BufferList
        })()

        if (util && util.inspect && util.inspect.custom) {
          module.exports.prototype[util.inspect.custom] = function() {
            var obj = util.inspect({ length: this.length })
            return this.constructor.name + " " + obj
          }
        }
      },
      { "safe-buffer": 59, util: 14 }
    ],
    54: [
      function(require, module, exports) {
        "use strict"

        /*<replacement>*/

        var pna = require("process-nextick-args")
        /*</replacement>*/

        // undocumented cb() API, needed for core, not for public API
        function destroy(err, cb) {
          var _this = this

          var readableDestroyed =
            this._readableState && this._readableState.destroyed
          var writableDestroyed =
            this._writableState && this._writableState.destroyed

          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err)
            } else if (
              err &&
              (!this._writableState || !this._writableState.errorEmitted)
            ) {
              pna.nextTick(emitErrorNT, this, err)
            }
            return this
          }

          // we set destroyed to true before firing error callbacks in order
          // to make it re-entrance safe in case destroy() is called within callbacks

          if (this._readableState) {
            this._readableState.destroyed = true
          }

          // if this is a duplex stream mark the writable part as destroyed as well
          if (this._writableState) {
            this._writableState.destroyed = true
          }

          this._destroy(err || null, function(err) {
            if (!cb && err) {
              pna.nextTick(emitErrorNT, _this, err)
              if (_this._writableState) {
                _this._writableState.errorEmitted = true
              }
            } else if (cb) {
              cb(err)
            }
          })

          return this
        }

        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false
            this._readableState.reading = false
            this._readableState.ended = false
            this._readableState.endEmitted = false
          }

          if (this._writableState) {
            this._writableState.destroyed = false
            this._writableState.ended = false
            this._writableState.ending = false
            this._writableState.finished = false
            this._writableState.errorEmitted = false
          }
        }

        function emitErrorNT(self, err) {
          self.emit("error", err)
        }

        module.exports = {
          destroy: destroy,
          undestroy: undestroy
        }
      },
      { "process-nextick-args": 57 }
    ],
    55: [
      function(require, module, exports) {
        module.exports = require("events").EventEmitter
      },
      { events: 24 }
    ],
    56: [
      function(require, module, exports) {
        var toString = {}.toString

        module.exports =
          Array.isArray ||
          function(arr) {
            return toString.call(arr) == "[object Array]"
          }
      },
      {}
    ],
    57: [
      function(require, module, exports) {
        ;(function(process) {
          "use strict"

          if (
            !process.version ||
            process.version.indexOf("v0.") === 0 ||
            (process.version.indexOf("v1.") === 0 &&
              process.version.indexOf("v1.8.") !== 0)
          ) {
            module.exports = { nextTick: nextTick }
          } else {
            module.exports = process
          }

          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
              throw new TypeError('"callback" argument must be a function')
            }
            var len = arguments.length
            var args, i
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn)
              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1)
                })
              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2)
                })
              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3)
                })
              default:
                args = new Array(len - 1)
                i = 0
                while (i < args.length) {
                  args[i++] = arguments[i]
                }
                return process.nextTick(function afterTick() {
                  fn.apply(null, args)
                })
            }
          }
        }.call(this, require("_process")))
      },
      { _process: 44 }
    ],
    58: [
      function(require, module, exports) {
        exports = module.exports = require("./lib/_stream_readable.js")
        exports.Stream = exports
        exports.Readable = exports
        exports.Writable = require("./lib/_stream_writable.js")
        exports.Duplex = require("./lib/_stream_duplex.js")
        exports.Transform = require("./lib/_stream_transform.js")
        exports.PassThrough = require("./lib/_stream_passthrough.js")
      },
      {
        "./lib/_stream_duplex.js": 48,
        "./lib/_stream_passthrough.js": 49,
        "./lib/_stream_readable.js": 50,
        "./lib/_stream_transform.js": 51,
        "./lib/_stream_writable.js": 52
      }
    ],
    59: [
      function(require, module, exports) {
        /* eslint-disable node/no-deprecated-api */
        var buffer = require("buffer")
        var Buffer = buffer.Buffer

        // alternative to using Object.keys for old browsers
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key]
          }
        }
        if (
          Buffer.from &&
          Buffer.alloc &&
          Buffer.allocUnsafe &&
          Buffer.allocUnsafeSlow
        ) {
          module.exports = buffer
        } else {
          // Copy properties from require('buffer')
          copyProps(buffer, exports)
          exports.Buffer = SafeBuffer
        }

        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length)
        }

        // Copy static methods from Buffer
        copyProps(Buffer, SafeBuffer)

        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number")
          }
          return Buffer(arg, encodingOrOffset, length)
        }

        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number")
          }
          var buf = Buffer(size)
          if (fill !== undefined) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding)
            } else {
              buf.fill(fill)
            }
          } else {
            buf.fill(0)
          }
          return buf
        }

        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number")
          }
          return Buffer(size)
        }

        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number")
          }
          return buffer.SlowBuffer(size)
        }
      },
      { buffer: 20 }
    ],
    60: [
      function(require, module, exports) {
        var varint = require("varint")
        exports.encode = function encode(v, b, o) {
          v = v >= 0 ? v * 2 : v * -2 - 1
          var r = varint.encode(v, b, o)
          encode.bytes = varint.encode.bytes
          return r
        }
        exports.decode = function decode(b, o) {
          var v = varint.decode(b, o)
          decode.bytes = varint.decode.bytes
          return v & 1 ? (v + 1) / -2 : v / 2
        }

        exports.encodingLength = function(v) {
          return varint.encodingLength(v >= 0 ? v * 2 : v * -2 - 1)
        }
      },
      { varint: 82 }
    ],
    61: [
      function(require, module, exports) {
        module.exports = fallback

        function _add(a, b) {
          var rl = a.l + b.l
          var a2 = {
            h: (a.h + b.h + ((rl / 2) >>> 31)) >>> 0,
            l: rl >>> 0
          }
          a.h = a2.h
          a.l = a2.l
        }

        function _xor(a, b) {
          a.h ^= b.h
          a.h >>>= 0
          a.l ^= b.l
          a.l >>>= 0
        }

        function _rotl(a, n) {
          var a2 = {
            h: (a.h << n) | (a.l >>> (32 - n)),
            l: (a.l << n) | (a.h >>> (32 - n))
          }
          a.h = a2.h
          a.l = a2.l
        }

        function _rotl32(a) {
          var al = a.l
          a.l = a.h
          a.h = al
        }

        function _compress(v0, v1, v2, v3) {
          _add(v0, v1)
          _add(v2, v3)
          _rotl(v1, 13)
          _rotl(v3, 16)
          _xor(v1, v0)
          _xor(v3, v2)
          _rotl32(v0)
          _add(v2, v1)
          _add(v0, v3)
          _rotl(v1, 17)
          _rotl(v3, 21)
          _xor(v1, v2)
          _xor(v3, v0)
          _rotl32(v2)
        }

        function _get_int(a, offset) {
          return (
            (a[offset + 3] << 24) |
            (a[offset + 2] << 16) |
            (a[offset + 1] << 8) |
            a[offset]
          )
        }

        function fallback(out, m, key) {
          // modified from https://github.com/jedisct1/siphash-js to use uint8arrays
          var k0 = { h: _get_int(key, 4), l: _get_int(key, 0) }
          var k1 = { h: _get_int(key, 12), l: _get_int(key, 8) }
          var v0 = { h: k0.h, l: k0.l }
          var v2 = k0
          var v1 = { h: k1.h, l: k1.l }
          var v3 = k1
          var mi
          var mp = 0
          var ml = m.length
          var ml7 = ml - 7
          var buf = new Uint8Array(new ArrayBuffer(8))

          _xor(v0, { h: 0x736f6d65, l: 0x70736575 })
          _xor(v1, { h: 0x646f7261, l: 0x6e646f6d })
          _xor(v2, { h: 0x6c796765, l: 0x6e657261 })
          _xor(v3, { h: 0x74656462, l: 0x79746573 })

          while (mp < ml7) {
            mi = { h: _get_int(m, mp + 4), l: _get_int(m, mp) }
            _xor(v3, mi)
            _compress(v0, v1, v2, v3)
            _compress(v0, v1, v2, v3)
            _xor(v0, mi)
            mp += 8
          }

          buf[7] = ml
          var ic = 0
          while (mp < ml) {
            buf[ic++] = m[mp++]
          }
          while (ic < 7) {
            buf[ic++] = 0
          }

          mi = {
            h: (buf[7] << 24) | (buf[6] << 16) | (buf[5] << 8) | buf[4],
            l: (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0]
          }

          _xor(v3, mi)
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)
          _xor(v0, mi)
          _xor(v2, { h: 0, l: 0xff })
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)
          _compress(v0, v1, v2, v3)

          var h = v0
          _xor(h, v1)
          _xor(h, v2)
          _xor(h, v3)

          out[0] = h.l & 0xff
          out[1] = (h.l >> 8) & 0xff
          out[2] = (h.l >> 16) & 0xff
          out[3] = (h.l >> 24) & 0xff
          out[4] = h.h & 0xff
          out[5] = (h.h >> 8) & 0xff
          out[6] = (h.h >> 16) & 0xff
          out[7] = (h.h >> 24) & 0xff
        }
      },
      {}
    ],
    62: [
      function(require, module, exports) {
        var wasm = require("./siphash24")
        var fallback = require("./fallback")
        var assert = require("nanoassert")

        module.exports = siphash24

        var BYTES = (siphash24.BYTES = 8)
        var KEYBYTES = (siphash24.KEYBYTES = 16)
        var mod = wasm()

        siphash24.WASM_SUPPORTED = typeof WebAssembly !== "undefined"
        siphash24.WASM_LOADED = false

        if (mod) {
          mod.onload(function(err) {
            siphash24.WASM_LOADED = !err
          })
        }

        function siphash24(data, key, out, noAssert) {
          if (!out) out = new Uint8Array(8)

          if (noAssert !== true) {
            assert(out.length >= BYTES, "output must be at least " + BYTES)
            assert(key.length >= KEYBYTES, "key must be at least " + KEYBYTES)
          }

          if (mod && mod.exports) {
            if (data.length + 24 > mod.memory.length)
              mod.realloc(data.length + 24)
            mod.memory.set(key, 8)
            mod.memory.set(data, 24)
            mod.exports.siphash(24, data.length)
            out.set(mod.memory.subarray(0, 8))
          } else {
            fallback(out, data, key)
          }

          return out
        }
      },
      { "./fallback": 61, "./siphash24": 63, nanoassert: 42 }
    ],
    63: [
      function(require, module, exports) {
        module.exports = loadWebAssembly

        loadWebAssembly.supported = typeof WebAssembly !== "undefined"

        function loadWebAssembly(opts) {
          if (!loadWebAssembly.supported) return null

          var imp = opts && opts.imports
          var wasm = toUint8Array(
            "AGFzbQEAAAABBgFgAn9/AAMCAQAFBQEBCpBOBxQCBm1lbW9yeQIAB3NpcGhhc2gAAArdCAHaCAIIfgJ/QvXKzYPXrNu38wAhAkLt3pHzlszct+QAIQNC4eSV89bs2bzsACEEQvPK0cunjNmy9AAhBUEIKQMAIQdBECkDACEIIAGtQjiGIQYgAUEHcSELIAAgAWogC2shCiAFIAiFIQUgBCAHhSEEIAMgCIUhAyACIAeFIQICQANAIAAgCkYNASAAKQMAIQkgBSAJhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAmFIQIgAEEIaiEADAALCwJAAkACQAJAAkACQAJAAkAgCw4HBwYFBAMCAQALIAYgADEABkIwhoQhBgsgBiAAMQAFQiiGhCEGCyAGIAAxAARCIIaEIQYLIAYgADEAA0IYhoQhBgsgBiAAMQACQhCGhCEGCyAGIAAxAAFCCIaEIQYLIAYgADEAAIQhBgsgBSAGhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAaFIQIgBEL/AYUhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEQQAgAiADIAQgBYWFhTcDAAs="
          )
          var ready = null

          var mod = {
            buffer: wasm,
            memory: null,
            exports: null,
            realloc: realloc,
            onload: onload
          }

          onload(function() {})

          return mod

          function realloc(size) {
            mod.exports.memory.grow(
              Math.max(0, Math.ceil(Math.abs(size - mod.memory.length) / 65536))
            )
            mod.memory = new Uint8Array(mod.exports.memory.buffer)
          }

          function onload(cb) {
            if (mod.exports) return cb()

            if (ready) {
              ready.then(cb.bind(null, null)).catch(cb)
              return
            }

            try {
              if (opts && opts.async) throw new Error("async")
              setup({
                instance: new WebAssembly.Instance(
                  new WebAssembly.Module(wasm),
                  imp
                )
              })
            } catch (err) {
              ready = WebAssembly.instantiate(wasm, imp).then(setup)
            }

            onload(cb)
          }

          function setup(w) {
            mod.exports = w.instance.exports
            mod.memory =
              mod.exports.memory &&
              mod.exports.memory.buffer &&
              new Uint8Array(mod.exports.memory.buffer)
          }
        }

        function toUint8Array(s) {
          if (typeof atob === "function")
            return new Uint8Array(
              atob(s)
                .split("")
                .map(charCodeAt)
            )
          return new (require("buf" + "fer")).Buffer(s, "base64")
        }

        function charCodeAt(c) {
          return c.charCodeAt(0)
        }
      },
      {}
    ],
    64: [
      function(require, module, exports) {
        var blake2b = require("blake2b")

        module.exports.crypto_generichash_PRIMITIVE = "blake2b"
        module.exports.crypto_generichash_BYTES_MIN = blake2b.BYTES_MIN
        module.exports.crypto_generichash_BYTES_MAX = blake2b.BYTES_MAX
        module.exports.crypto_generichash_BYTES = blake2b.BYTES
        module.exports.crypto_generichash_KEYBYTES_MIN = blake2b.KEYBYTES_MIN
        module.exports.crypto_generichash_KEYBYTES_MAX = blake2b.KEYBYTES_MAX
        module.exports.crypto_generichash_KEYBYTES = blake2b.KEYBYTES
        module.exports.crypto_generichash_WASM_SUPPORTED =
          blake2b.WASM_SUPPORTED
        module.exports.crypto_generichash_WASM_LOADED = false

        module.exports.crypto_generichash = function(output, input, key) {
          blake2b(output.length, key)
            .update(input)
            .final(output)
        }

        module.exports.crypto_generichash_ready = blake2b.ready

        module.exports.crypto_generichash_batch = function(
          output,
          inputArray,
          key
        ) {
          var ctx = blake2b(output.length, key)
          for (var i = 0; i < inputArray.length; i++) {
            ctx.update(inputArray[i])
          }
          ctx.final(output)
        }

        module.exports.crypto_generichash_instance = function(key, outlen) {
          if (outlen == null) outlen = module.exports.crypto_generichash_BYTES
          return blake2b(outlen, key)
        }

        blake2b.ready(function(err) {
          module.exports.crypto_generichash_WASM_LOADED = blake2b.WASM_LOADED
        })
      },
      { blake2b: 13 }
    ],
    65: [
      function(require, module, exports) {
        var assert = require("nanoassert")
        var randombytes_buf = require("./randombytes").randombytes_buf
        var blake2b = require("blake2b")

        module.exports.crypto_kdf_PRIMITIVE = "blake2b"
        module.exports.crypto_kdf_BYTES_MIN = 16
        module.exports.crypto_kdf_BYTES_MAX = 64
        module.exports.crypto_kdf_CONTEXTBYTES = 8
        module.exports.crypto_kdf_KEYBYTES = 32

        function STORE64_LE(dest, int) {
          var mul = 1
          var i = 0
          dest[0] = int & 0xff
          while (++i < 8 && (mul *= 0x100)) {
            dest[i] = (int / mul) & 0xff
          }
        }

        module.exports.crypto_kdf_derive_from_key = function crypto_kdf_derive_from_key(
          subkey,
          subkey_id,
          ctx,
          key
        ) {
          assert(
            subkey.length >= module.exports.crypto_kdf_BYTES_MIN,
            "subkey must be at least crypto_kdf_BYTES_MIN"
          )
          assert(
            subkey_id >= 0 && subkey_id <= 0x1fffffffffffff,
            "subkey_id must be safe integer"
          )
          assert(
            ctx.length >= module.exports.crypto_kdf_CONTEXTBYTES,
            "context must be at least crypto_kdf_CONTEXTBYTES"
          )

          var ctx_padded = new Uint8Array(blake2b.PERSONALBYTES)
          var salt = new Uint8Array(blake2b.SALTBYTES)

          ctx_padded.set(ctx, 0, module.exports.crypto_kdf_CONTEXTBYTES)
          STORE64_LE(salt, subkey_id)

          var outlen = Math.min(
            subkey.length,
            module.exports.crypto_kdf_BYTES_MAX
          )
          blake2b(
            outlen,
            key.subarray(0, module.exports.crypto_kdf_KEYBYTES),
            salt,
            ctx_padded,
            true
          ).final(subkey)
        }

        module.exports.crypto_kdf_keygen = function crypto_kdf_keygen(out) {
          assert(
            out.length >= module.exports.crypto_kdf_KEYBYTES,
            "out.length must be crypto_kdf_KEYBYTES"
          )
          randombytes_buf(out.subarray(0, module.exports.crypto_kdf_KEYBYTES))
        }
      },
      { "./randombytes": 69, blake2b: 13, nanoassert: 42 }
    ],
    66: [
      function(require, module, exports) {
        var siphash = require("siphash24")

        exports.crypto_shorthash_PRIMITIVE = "siphash24"
        exports.crypto_shorthash_BYTES = siphash.BYTES
        exports.crypto_shorthash_KEYBYTES = siphash.KEYBYTES
        exports.crypto_shorthash_WASM_SUPPORTED = siphash.WASM_SUPPORTED
        exports.crypto_shorthash_WASM_LOADED = siphash.WASM_LOADED
        exports.crypto_shorthash = shorthash

        function shorthash(out, data, key, noAssert) {
          siphash(data, key, out, noAssert)
        }
      },
      { siphash24: 62 }
    ],
    67: [
      function(require, module, exports) {
        var xsalsa20 = require("xsalsa20")

        exports.crypto_stream_KEYBYTES = 32
        exports.crypto_stream_NONCEBYTES = 24
        exports.crypto_stream_PRIMITIVE = "xsalsa20"

        exports.crypto_stream = function(out, nonce, key) {
          out.fill(0)
          exports.crypto_stream_xor(out, out, nonce, key)
        }

        exports.crypto_stream_xor = function(out, inp, nonce, key) {
          var xor = xsalsa20(nonce, key)
          xor.update(inp, out)
          xor.final()
        }

        exports.crypto_stream_xor_instance = function(nonce, key) {
          return new XOR(nonce, key)
        }

        function XOR(nonce, key) {
          this._instance = xsalsa20(nonce, key)
        }

        XOR.prototype.update = function(out, inp) {
          this._instance.update(inp, out)
        }

        XOR.prototype.final = function() {
          this._instance.finalize()
          this._instance = null
        }
      },
      { xsalsa20: 84 }
    ],
    68: [
      function(require, module, exports) {
        "use strict"

        // Based on https://github.com/dchest/tweetnacl-js/blob/6dcbcaf5f5cbfd313f2dcfe763db35c828c8ff5b/nacl-fast.js.

        var sodium = module.exports
        var cs = require("./crypto_stream")

        // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
        // Public domain.
        //
        // Implementation derived from TweetNaCl version 20140427.
        // See for details: http://tweetnacl.cr.yp.to/

        var gf = function(init) {
          var i,
            r = new Float64Array(16)
          if (init) for (i = 0; i < init.length; i++) r[i] = init[i]
          return r
        }

        // also forwarded at the bottom but randombytes is non-enumerable
        var randombytes = require("./randombytes").randombytes

        var _0 = new Uint8Array(16)
        var _9 = new Uint8Array(32)
        _9[0] = 9

        var gf0 = gf(),
          gf1 = gf([1]),
          _121665 = gf([0xdb41, 1]),
          D = gf([
            0x78a3,
            0x1359,
            0x4dca,
            0x75eb,
            0xd8ab,
            0x4141,
            0x0a4d,
            0x0070,
            0xe898,
            0x7779,
            0x4079,
            0x8cc7,
            0xfe73,
            0x2b6f,
            0x6cee,
            0x5203
          ]),
          D2 = gf([
            0xf159,
            0x26b2,
            0x9b94,
            0xebd6,
            0xb156,
            0x8283,
            0x149a,
            0x00e0,
            0xd130,
            0xeef3,
            0x80f2,
            0x198e,
            0xfce7,
            0x56df,
            0xd9dc,
            0x2406
          ]),
          X = gf([
            0xd51a,
            0x8f25,
            0x2d60,
            0xc956,
            0xa7b2,
            0x9525,
            0xc760,
            0x692c,
            0xdc5c,
            0xfdd6,
            0xe231,
            0xc0a4,
            0x53fe,
            0xcd6e,
            0x36d3,
            0x2169
          ]),
          Y = gf([
            0x6658,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666,
            0x6666
          ]),
          I = gf([
            0xa0b0,
            0x4a0e,
            0x1b27,
            0xc4ee,
            0xe478,
            0xad2f,
            0x1806,
            0x2f43,
            0xd7a7,
            0x3dfb,
            0x0099,
            0x2b4d,
            0xdf0b,
            0x4fc1,
            0x2480,
            0x2b83
          ])

        function ts64(x, i, h, l) {
          x[i] = (h >> 24) & 0xff
          x[i + 1] = (h >> 16) & 0xff
          x[i + 2] = (h >> 8) & 0xff
          x[i + 3] = h & 0xff
          x[i + 4] = (l >> 24) & 0xff
          x[i + 5] = (l >> 16) & 0xff
          x[i + 6] = (l >> 8) & 0xff
          x[i + 7] = l & 0xff
        }

        function vn(x, xi, y, yi, n) {
          var i,
            d = 0
          for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i]
          return (1 & ((d - 1) >>> 8)) - 1
        }

        function crypto_verify_16(x, xi, y, yi) {
          return vn(x, xi, y, yi, 16)
        }

        function crypto_verify_32(x, xi, y, yi) {
          return vn(x, xi, y, yi, 32)
        }

        /*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

        var poly1305 = function(key) {
          this.buffer = new Uint8Array(16)
          this.r = new Uint16Array(10)
          this.h = new Uint16Array(10)
          this.pad = new Uint16Array(8)
          this.leftover = 0
          this.fin = 0

          var t0, t1, t2, t3, t4, t5, t6, t7

          t0 = (key[0] & 0xff) | ((key[1] & 0xff) << 8)
          this.r[0] = t0 & 0x1fff
          t1 = (key[2] & 0xff) | ((key[3] & 0xff) << 8)
          this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff
          t2 = (key[4] & 0xff) | ((key[5] & 0xff) << 8)
          this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03
          t3 = (key[6] & 0xff) | ((key[7] & 0xff) << 8)
          this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff
          t4 = (key[8] & 0xff) | ((key[9] & 0xff) << 8)
          this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff
          this.r[5] = (t4 >>> 1) & 0x1ffe
          t5 = (key[10] & 0xff) | ((key[11] & 0xff) << 8)
          this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff
          t6 = (key[12] & 0xff) | ((key[13] & 0xff) << 8)
          this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81
          t7 = (key[14] & 0xff) | ((key[15] & 0xff) << 8)
          this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff
          this.r[9] = (t7 >>> 5) & 0x007f

          this.pad[0] = (key[16] & 0xff) | ((key[17] & 0xff) << 8)
          this.pad[1] = (key[18] & 0xff) | ((key[19] & 0xff) << 8)
          this.pad[2] = (key[20] & 0xff) | ((key[21] & 0xff) << 8)
          this.pad[3] = (key[22] & 0xff) | ((key[23] & 0xff) << 8)
          this.pad[4] = (key[24] & 0xff) | ((key[25] & 0xff) << 8)
          this.pad[5] = (key[26] & 0xff) | ((key[27] & 0xff) << 8)
          this.pad[6] = (key[28] & 0xff) | ((key[29] & 0xff) << 8)
          this.pad[7] = (key[30] & 0xff) | ((key[31] & 0xff) << 8)
        }

        poly1305.prototype.blocks = function(m, mpos, bytes) {
          var hibit = this.fin ? 0 : 1 << 11
          var t0, t1, t2, t3, t4, t5, t6, t7, c
          var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9

          var h0 = this.h[0],
            h1 = this.h[1],
            h2 = this.h[2],
            h3 = this.h[3],
            h4 = this.h[4],
            h5 = this.h[5],
            h6 = this.h[6],
            h7 = this.h[7],
            h8 = this.h[8],
            h9 = this.h[9]

          var r0 = this.r[0],
            r1 = this.r[1],
            r2 = this.r[2],
            r3 = this.r[3],
            r4 = this.r[4],
            r5 = this.r[5],
            r6 = this.r[6],
            r7 = this.r[7],
            r8 = this.r[8],
            r9 = this.r[9]

          while (bytes >= 16) {
            t0 = (m[mpos + 0] & 0xff) | ((m[mpos + 1] & 0xff) << 8)
            h0 += t0 & 0x1fff
            t1 = (m[mpos + 2] & 0xff) | ((m[mpos + 3] & 0xff) << 8)
            h1 += ((t0 >>> 13) | (t1 << 3)) & 0x1fff
            t2 = (m[mpos + 4] & 0xff) | ((m[mpos + 5] & 0xff) << 8)
            h2 += ((t1 >>> 10) | (t2 << 6)) & 0x1fff
            t3 = (m[mpos + 6] & 0xff) | ((m[mpos + 7] & 0xff) << 8)
            h3 += ((t2 >>> 7) | (t3 << 9)) & 0x1fff
            t4 = (m[mpos + 8] & 0xff) | ((m[mpos + 9] & 0xff) << 8)
            h4 += ((t3 >>> 4) | (t4 << 12)) & 0x1fff
            h5 += (t4 >>> 1) & 0x1fff
            t5 = (m[mpos + 10] & 0xff) | ((m[mpos + 11] & 0xff) << 8)
            h6 += ((t4 >>> 14) | (t5 << 2)) & 0x1fff
            t6 = (m[mpos + 12] & 0xff) | ((m[mpos + 13] & 0xff) << 8)
            h7 += ((t5 >>> 11) | (t6 << 5)) & 0x1fff
            t7 = (m[mpos + 14] & 0xff) | ((m[mpos + 15] & 0xff) << 8)
            h8 += ((t6 >>> 8) | (t7 << 8)) & 0x1fff
            h9 += (t7 >>> 5) | hibit

            c = 0

            d0 = c
            d0 += h0 * r0
            d0 += h1 * (5 * r9)
            d0 += h2 * (5 * r8)
            d0 += h3 * (5 * r7)
            d0 += h4 * (5 * r6)
            c = d0 >>> 13
            d0 &= 0x1fff
            d0 += h5 * (5 * r5)
            d0 += h6 * (5 * r4)
            d0 += h7 * (5 * r3)
            d0 += h8 * (5 * r2)
            d0 += h9 * (5 * r1)
            c += d0 >>> 13
            d0 &= 0x1fff

            d1 = c
            d1 += h0 * r1
            d1 += h1 * r0
            d1 += h2 * (5 * r9)
            d1 += h3 * (5 * r8)
            d1 += h4 * (5 * r7)
            c = d1 >>> 13
            d1 &= 0x1fff
            d1 += h5 * (5 * r6)
            d1 += h6 * (5 * r5)
            d1 += h7 * (5 * r4)
            d1 += h8 * (5 * r3)
            d1 += h9 * (5 * r2)
            c += d1 >>> 13
            d1 &= 0x1fff

            d2 = c
            d2 += h0 * r2
            d2 += h1 * r1
            d2 += h2 * r0
            d2 += h3 * (5 * r9)
            d2 += h4 * (5 * r8)
            c = d2 >>> 13
            d2 &= 0x1fff
            d2 += h5 * (5 * r7)
            d2 += h6 * (5 * r6)
            d2 += h7 * (5 * r5)
            d2 += h8 * (5 * r4)
            d2 += h9 * (5 * r3)
            c += d2 >>> 13
            d2 &= 0x1fff

            d3 = c
            d3 += h0 * r3
            d3 += h1 * r2
            d3 += h2 * r1
            d3 += h3 * r0
            d3 += h4 * (5 * r9)
            c = d3 >>> 13
            d3 &= 0x1fff
            d3 += h5 * (5 * r8)
            d3 += h6 * (5 * r7)
            d3 += h7 * (5 * r6)
            d3 += h8 * (5 * r5)
            d3 += h9 * (5 * r4)
            c += d3 >>> 13
            d3 &= 0x1fff

            d4 = c
            d4 += h0 * r4
            d4 += h1 * r3
            d4 += h2 * r2
            d4 += h3 * r1
            d4 += h4 * r0
            c = d4 >>> 13
            d4 &= 0x1fff
            d4 += h5 * (5 * r9)
            d4 += h6 * (5 * r8)
            d4 += h7 * (5 * r7)
            d4 += h8 * (5 * r6)
            d4 += h9 * (5 * r5)
            c += d4 >>> 13
            d4 &= 0x1fff

            d5 = c
            d5 += h0 * r5
            d5 += h1 * r4
            d5 += h2 * r3
            d5 += h3 * r2
            d5 += h4 * r1
            c = d5 >>> 13
            d5 &= 0x1fff
            d5 += h5 * r0
            d5 += h6 * (5 * r9)
            d5 += h7 * (5 * r8)
            d5 += h8 * (5 * r7)
            d5 += h9 * (5 * r6)
            c += d5 >>> 13
            d5 &= 0x1fff

            d6 = c
            d6 += h0 * r6
            d6 += h1 * r5
            d6 += h2 * r4
            d6 += h3 * r3
            d6 += h4 * r2
            c = d6 >>> 13
            d6 &= 0x1fff
            d6 += h5 * r1
            d6 += h6 * r0
            d6 += h7 * (5 * r9)
            d6 += h8 * (5 * r8)
            d6 += h9 * (5 * r7)
            c += d6 >>> 13
            d6 &= 0x1fff

            d7 = c
            d7 += h0 * r7
            d7 += h1 * r6
            d7 += h2 * r5
            d7 += h3 * r4
            d7 += h4 * r3
            c = d7 >>> 13
            d7 &= 0x1fff
            d7 += h5 * r2
            d7 += h6 * r1
            d7 += h7 * r0
            d7 += h8 * (5 * r9)
            d7 += h9 * (5 * r8)
            c += d7 >>> 13
            d7 &= 0x1fff

            d8 = c
            d8 += h0 * r8
            d8 += h1 * r7
            d8 += h2 * r6
            d8 += h3 * r5
            d8 += h4 * r4
            c = d8 >>> 13
            d8 &= 0x1fff
            d8 += h5 * r3
            d8 += h6 * r2
            d8 += h7 * r1
            d8 += h8 * r0
            d8 += h9 * (5 * r9)
            c += d8 >>> 13
            d8 &= 0x1fff

            d9 = c
            d9 += h0 * r9
            d9 += h1 * r8
            d9 += h2 * r7
            d9 += h3 * r6
            d9 += h4 * r5
            c = d9 >>> 13
            d9 &= 0x1fff
            d9 += h5 * r4
            d9 += h6 * r3
            d9 += h7 * r2
            d9 += h8 * r1
            d9 += h9 * r0
            c += d9 >>> 13
            d9 &= 0x1fff

            c = ((c << 2) + c) | 0
            c = (c + d0) | 0
            d0 = c & 0x1fff
            c = c >>> 13
            d1 += c

            h0 = d0
            h1 = d1
            h2 = d2
            h3 = d3
            h4 = d4
            h5 = d5
            h6 = d6
            h7 = d7
            h8 = d8
            h9 = d9

            mpos += 16
            bytes -= 16
          }
          this.h[0] = h0
          this.h[1] = h1
          this.h[2] = h2
          this.h[3] = h3
          this.h[4] = h4
          this.h[5] = h5
          this.h[6] = h6
          this.h[7] = h7
          this.h[8] = h8
          this.h[9] = h9
        }

        poly1305.prototype.finish = function(mac, macpos) {
          var g = new Uint16Array(10)
          var c, mask, f, i

          if (this.leftover) {
            i = this.leftover
            this.buffer[i++] = 1
            for (; i < 16; i++) this.buffer[i] = 0
            this.fin = 1
            this.blocks(this.buffer, 0, 16)
          }

          c = this.h[1] >>> 13
          this.h[1] &= 0x1fff
          for (i = 2; i < 10; i++) {
            this.h[i] += c
            c = this.h[i] >>> 13
            this.h[i] &= 0x1fff
          }
          this.h[0] += c * 5
          c = this.h[0] >>> 13
          this.h[0] &= 0x1fff
          this.h[1] += c
          c = this.h[1] >>> 13
          this.h[1] &= 0x1fff
          this.h[2] += c

          g[0] = this.h[0] + 5
          c = g[0] >>> 13
          g[0] &= 0x1fff
          for (i = 1; i < 10; i++) {
            g[i] = this.h[i] + c
            c = g[i] >>> 13
            g[i] &= 0x1fff
          }
          g[9] -= 1 << 13

          mask = (c ^ 1) - 1
          for (i = 0; i < 10; i++) g[i] &= mask
          mask = ~mask
          for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i]

          this.h[0] = (this.h[0] | (this.h[1] << 13)) & 0xffff
          this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 0xffff
          this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 0xffff
          this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 0xffff
          this.h[4] =
            ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) & 0xffff
          this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 0xffff
          this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 0xffff
          this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 0xffff

          f = this.h[0] + this.pad[0]
          this.h[0] = f & 0xffff
          for (i = 1; i < 8; i++) {
            f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0
            this.h[i] = f & 0xffff
          }

          mac[macpos + 0] = (this.h[0] >>> 0) & 0xff
          mac[macpos + 1] = (this.h[0] >>> 8) & 0xff
          mac[macpos + 2] = (this.h[1] >>> 0) & 0xff
          mac[macpos + 3] = (this.h[1] >>> 8) & 0xff
          mac[macpos + 4] = (this.h[2] >>> 0) & 0xff
          mac[macpos + 5] = (this.h[2] >>> 8) & 0xff
          mac[macpos + 6] = (this.h[3] >>> 0) & 0xff
          mac[macpos + 7] = (this.h[3] >>> 8) & 0xff
          mac[macpos + 8] = (this.h[4] >>> 0) & 0xff
          mac[macpos + 9] = (this.h[4] >>> 8) & 0xff
          mac[macpos + 10] = (this.h[5] >>> 0) & 0xff
          mac[macpos + 11] = (this.h[5] >>> 8) & 0xff
          mac[macpos + 12] = (this.h[6] >>> 0) & 0xff
          mac[macpos + 13] = (this.h[6] >>> 8) & 0xff
          mac[macpos + 14] = (this.h[7] >>> 0) & 0xff
          mac[macpos + 15] = (this.h[7] >>> 8) & 0xff
        }

        poly1305.prototype.update = function(m, mpos, bytes) {
          var i, want

          if (this.leftover) {
            want = 16 - this.leftover
            if (want > bytes) want = bytes
            for (i = 0; i < want; i++)
              this.buffer[this.leftover + i] = m[mpos + i]
            bytes -= want
            mpos += want
            this.leftover += want
            if (this.leftover < 16) return
            this.blocks(this.buffer, 0, 16)
            this.leftover = 0
          }

          if (bytes >= 16) {
            want = bytes - (bytes % 16)
            this.blocks(m, mpos, want)
            mpos += want
            bytes -= want
          }

          if (bytes) {
            for (i = 0; i < bytes; i++)
              this.buffer[this.leftover + i] = m[mpos + i]
            this.leftover += bytes
          }
        }

        function crypto_stream_xor(c, cpos, m, mpos, clen, n, k) {
          cs.crypto_stream_xor(c, m, n, k)
        }

        function crypto_stream(c, cpos, clen, n, k) {
          cs.crypto_stream(c, n, k)
        }

        function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
          var s = new poly1305(k)
          s.update(m, mpos, n)
          s.finish(out, outpos)
          return 0
        }

        function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
          var x = new Uint8Array(16)
          crypto_onetimeauth(x, 0, m, mpos, n, k)
          return crypto_verify_16(h, hpos, x, 0)
        }

        function crypto_secretbox(c, m, d, n, k) {
          var i
          if (d < 32) return -1
          crypto_stream_xor(c, 0, m, 0, d, n, k)
          crypto_onetimeauth(c, 16, c, 32, d - 32, c)
          for (i = 0; i < 16; i++) c[i] = 0
          return 0
        }

        function crypto_secretbox_open(m, c, d, n, k) {
          var i
          var x = new Uint8Array(32)
          if (d < 32) return -1
          crypto_stream(x, 0, 32, n, k)
          if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
            return -1
          crypto_stream_xor(m, 0, c, 0, d, n, k)
          for (i = 0; i < 32; i++) m[i] = 0
          return 0
        }

        function set25519(r, a) {
          var i
          for (i = 0; i < 16; i++) r[i] = a[i] | 0
        }

        function car25519(o) {
          var i,
            v,
            c = 1
          for (i = 0; i < 16; i++) {
            v = o[i] + c + 65535
            c = Math.floor(v / 65536)
            o[i] = v - c * 65536
          }
          o[0] += c - 1 + 37 * (c - 1)
        }

        function sel25519(p, q, b) {
          var t,
            c = ~(b - 1)
          for (var i = 0; i < 16; i++) {
            t = c & (p[i] ^ q[i])
            p[i] ^= t
            q[i] ^= t
          }
        }

        function pack25519(o, n) {
          var i, j, b
          var m = gf(),
            t = gf()
          for (i = 0; i < 16; i++) t[i] = n[i]
          car25519(t)
          car25519(t)
          car25519(t)
          for (j = 0; j < 2; j++) {
            m[0] = t[0] - 0xffed
            for (i = 1; i < 15; i++) {
              m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1)
              m[i - 1] &= 0xffff
            }
            m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1)
            b = (m[15] >> 16) & 1
            m[14] &= 0xffff
            sel25519(t, m, 1 - b)
          }
          for (i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 0xff
            o[2 * i + 1] = t[i] >> 8
          }
        }

        function neq25519(a, b) {
          var c = new Uint8Array(32),
            d = new Uint8Array(32)
          pack25519(c, a)
          pack25519(d, b)
          return crypto_verify_32(c, 0, d, 0)
        }

        function par25519(a) {
          var d = new Uint8Array(32)
          pack25519(d, a)
          return d[0] & 1
        }

        function unpack25519(o, n) {
          var i
          for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8)
          o[15] &= 0x7fff
        }

        function A(o, a, b) {
          for (var i = 0; i < 16; i++) o[i] = a[i] + b[i]
        }

        function Z(o, a, b) {
          for (var i = 0; i < 16; i++) o[i] = a[i] - b[i]
        }

        function M(o, a, b) {
          var v,
            c,
            t0 = 0,
            t1 = 0,
            t2 = 0,
            t3 = 0,
            t4 = 0,
            t5 = 0,
            t6 = 0,
            t7 = 0,
            t8 = 0,
            t9 = 0,
            t10 = 0,
            t11 = 0,
            t12 = 0,
            t13 = 0,
            t14 = 0,
            t15 = 0,
            t16 = 0,
            t17 = 0,
            t18 = 0,
            t19 = 0,
            t20 = 0,
            t21 = 0,
            t22 = 0,
            t23 = 0,
            t24 = 0,
            t25 = 0,
            t26 = 0,
            t27 = 0,
            t28 = 0,
            t29 = 0,
            t30 = 0,
            b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3],
            b4 = b[4],
            b5 = b[5],
            b6 = b[6],
            b7 = b[7],
            b8 = b[8],
            b9 = b[9],
            b10 = b[10],
            b11 = b[11],
            b12 = b[12],
            b13 = b[13],
            b14 = b[14],
            b15 = b[15]

          v = a[0]
          t0 += v * b0
          t1 += v * b1
          t2 += v * b2
          t3 += v * b3
          t4 += v * b4
          t5 += v * b5
          t6 += v * b6
          t7 += v * b7
          t8 += v * b8
          t9 += v * b9
          t10 += v * b10
          t11 += v * b11
          t12 += v * b12
          t13 += v * b13
          t14 += v * b14
          t15 += v * b15
          v = a[1]
          t1 += v * b0
          t2 += v * b1
          t3 += v * b2
          t4 += v * b3
          t5 += v * b4
          t6 += v * b5
          t7 += v * b6
          t8 += v * b7
          t9 += v * b8
          t10 += v * b9
          t11 += v * b10
          t12 += v * b11
          t13 += v * b12
          t14 += v * b13
          t15 += v * b14
          t16 += v * b15
          v = a[2]
          t2 += v * b0
          t3 += v * b1
          t4 += v * b2
          t5 += v * b3
          t6 += v * b4
          t7 += v * b5
          t8 += v * b6
          t9 += v * b7
          t10 += v * b8
          t11 += v * b9
          t12 += v * b10
          t13 += v * b11
          t14 += v * b12
          t15 += v * b13
          t16 += v * b14
          t17 += v * b15
          v = a[3]
          t3 += v * b0
          t4 += v * b1
          t5 += v * b2
          t6 += v * b3
          t7 += v * b4
          t8 += v * b5
          t9 += v * b6
          t10 += v * b7
          t11 += v * b8
          t12 += v * b9
          t13 += v * b10
          t14 += v * b11
          t15 += v * b12
          t16 += v * b13
          t17 += v * b14
          t18 += v * b15
          v = a[4]
          t4 += v * b0
          t5 += v * b1
          t6 += v * b2
          t7 += v * b3
          t8 += v * b4
          t9 += v * b5
          t10 += v * b6
          t11 += v * b7
          t12 += v * b8
          t13 += v * b9
          t14 += v * b10
          t15 += v * b11
          t16 += v * b12
          t17 += v * b13
          t18 += v * b14
          t19 += v * b15
          v = a[5]
          t5 += v * b0
          t6 += v * b1
          t7 += v * b2
          t8 += v * b3
          t9 += v * b4
          t10 += v * b5
          t11 += v * b6
          t12 += v * b7
          t13 += v * b8
          t14 += v * b9
          t15 += v * b10
          t16 += v * b11
          t17 += v * b12
          t18 += v * b13
          t19 += v * b14
          t20 += v * b15
          v = a[6]
          t6 += v * b0
          t7 += v * b1
          t8 += v * b2
          t9 += v * b3
          t10 += v * b4
          t11 += v * b5
          t12 += v * b6
          t13 += v * b7
          t14 += v * b8
          t15 += v * b9
          t16 += v * b10
          t17 += v * b11
          t18 += v * b12
          t19 += v * b13
          t20 += v * b14
          t21 += v * b15
          v = a[7]
          t7 += v * b0
          t8 += v * b1
          t9 += v * b2
          t10 += v * b3
          t11 += v * b4
          t12 += v * b5
          t13 += v * b6
          t14 += v * b7
          t15 += v * b8
          t16 += v * b9
          t17 += v * b10
          t18 += v * b11
          t19 += v * b12
          t20 += v * b13
          t21 += v * b14
          t22 += v * b15
          v = a[8]
          t8 += v * b0
          t9 += v * b1
          t10 += v * b2
          t11 += v * b3
          t12 += v * b4
          t13 += v * b5
          t14 += v * b6
          t15 += v * b7
          t16 += v * b8
          t17 += v * b9
          t18 += v * b10
          t19 += v * b11
          t20 += v * b12
          t21 += v * b13
          t22 += v * b14
          t23 += v * b15
          v = a[9]
          t9 += v * b0
          t10 += v * b1
          t11 += v * b2
          t12 += v * b3
          t13 += v * b4
          t14 += v * b5
          t15 += v * b6
          t16 += v * b7
          t17 += v * b8
          t18 += v * b9
          t19 += v * b10
          t20 += v * b11
          t21 += v * b12
          t22 += v * b13
          t23 += v * b14
          t24 += v * b15
          v = a[10]
          t10 += v * b0
          t11 += v * b1
          t12 += v * b2
          t13 += v * b3
          t14 += v * b4
          t15 += v * b5
          t16 += v * b6
          t17 += v * b7
          t18 += v * b8
          t19 += v * b9
          t20 += v * b10
          t21 += v * b11
          t22 += v * b12
          t23 += v * b13
          t24 += v * b14
          t25 += v * b15
          v = a[11]
          t11 += v * b0
          t12 += v * b1
          t13 += v * b2
          t14 += v * b3
          t15 += v * b4
          t16 += v * b5
          t17 += v * b6
          t18 += v * b7
          t19 += v * b8
          t20 += v * b9
          t21 += v * b10
          t22 += v * b11
          t23 += v * b12
          t24 += v * b13
          t25 += v * b14
          t26 += v * b15
          v = a[12]
          t12 += v * b0
          t13 += v * b1
          t14 += v * b2
          t15 += v * b3
          t16 += v * b4
          t17 += v * b5
          t18 += v * b6
          t19 += v * b7
          t20 += v * b8
          t21 += v * b9
          t22 += v * b10
          t23 += v * b11
          t24 += v * b12
          t25 += v * b13
          t26 += v * b14
          t27 += v * b15
          v = a[13]
          t13 += v * b0
          t14 += v * b1
          t15 += v * b2
          t16 += v * b3
          t17 += v * b4
          t18 += v * b5
          t19 += v * b6
          t20 += v * b7
          t21 += v * b8
          t22 += v * b9
          t23 += v * b10
          t24 += v * b11
          t25 += v * b12
          t26 += v * b13
          t27 += v * b14
          t28 += v * b15
          v = a[14]
          t14 += v * b0
          t15 += v * b1
          t16 += v * b2
          t17 += v * b3
          t18 += v * b4
          t19 += v * b5
          t20 += v * b6
          t21 += v * b7
          t22 += v * b8
          t23 += v * b9
          t24 += v * b10
          t25 += v * b11
          t26 += v * b12
          t27 += v * b13
          t28 += v * b14
          t29 += v * b15
          v = a[15]
          t15 += v * b0
          t16 += v * b1
          t17 += v * b2
          t18 += v * b3
          t19 += v * b4
          t20 += v * b5
          t21 += v * b6
          t22 += v * b7
          t23 += v * b8
          t24 += v * b9
          t25 += v * b10
          t26 += v * b11
          t27 += v * b12
          t28 += v * b13
          t29 += v * b14
          t30 += v * b15

          t0 += 38 * t16
          t1 += 38 * t17
          t2 += 38 * t18
          t3 += 38 * t19
          t4 += 38 * t20
          t5 += 38 * t21
          t6 += 38 * t22
          t7 += 38 * t23
          t8 += 38 * t24
          t9 += 38 * t25
          t10 += 38 * t26
          t11 += 38 * t27
          t12 += 38 * t28
          t13 += 38 * t29
          t14 += 38 * t30
          // t15 left as is

          // first car
          c = 1
          v = t0 + c + 65535
          c = Math.floor(v / 65536)
          t0 = v - c * 65536
          v = t1 + c + 65535
          c = Math.floor(v / 65536)
          t1 = v - c * 65536
          v = t2 + c + 65535
          c = Math.floor(v / 65536)
          t2 = v - c * 65536
          v = t3 + c + 65535
          c = Math.floor(v / 65536)
          t3 = v - c * 65536
          v = t4 + c + 65535
          c = Math.floor(v / 65536)
          t4 = v - c * 65536
          v = t5 + c + 65535
          c = Math.floor(v / 65536)
          t5 = v - c * 65536
          v = t6 + c + 65535
          c = Math.floor(v / 65536)
          t6 = v - c * 65536
          v = t7 + c + 65535
          c = Math.floor(v / 65536)
          t7 = v - c * 65536
          v = t8 + c + 65535
          c = Math.floor(v / 65536)
          t8 = v - c * 65536
          v = t9 + c + 65535
          c = Math.floor(v / 65536)
          t9 = v - c * 65536
          v = t10 + c + 65535
          c = Math.floor(v / 65536)
          t10 = v - c * 65536
          v = t11 + c + 65535
          c = Math.floor(v / 65536)
          t11 = v - c * 65536
          v = t12 + c + 65535
          c = Math.floor(v / 65536)
          t12 = v - c * 65536
          v = t13 + c + 65535
          c = Math.floor(v / 65536)
          t13 = v - c * 65536
          v = t14 + c + 65535
          c = Math.floor(v / 65536)
          t14 = v - c * 65536
          v = t15 + c + 65535
          c = Math.floor(v / 65536)
          t15 = v - c * 65536
          t0 += c - 1 + 37 * (c - 1)

          // second car
          c = 1
          v = t0 + c + 65535
          c = Math.floor(v / 65536)
          t0 = v - c * 65536
          v = t1 + c + 65535
          c = Math.floor(v / 65536)
          t1 = v - c * 65536
          v = t2 + c + 65535
          c = Math.floor(v / 65536)
          t2 = v - c * 65536
          v = t3 + c + 65535
          c = Math.floor(v / 65536)
          t3 = v - c * 65536
          v = t4 + c + 65535
          c = Math.floor(v / 65536)
          t4 = v - c * 65536
          v = t5 + c + 65535
          c = Math.floor(v / 65536)
          t5 = v - c * 65536
          v = t6 + c + 65535
          c = Math.floor(v / 65536)
          t6 = v - c * 65536
          v = t7 + c + 65535
          c = Math.floor(v / 65536)
          t7 = v - c * 65536
          v = t8 + c + 65535
          c = Math.floor(v / 65536)
          t8 = v - c * 65536
          v = t9 + c + 65535
          c = Math.floor(v / 65536)
          t9 = v - c * 65536
          v = t10 + c + 65535
          c = Math.floor(v / 65536)
          t10 = v - c * 65536
          v = t11 + c + 65535
          c = Math.floor(v / 65536)
          t11 = v - c * 65536
          v = t12 + c + 65535
          c = Math.floor(v / 65536)
          t12 = v - c * 65536
          v = t13 + c + 65535
          c = Math.floor(v / 65536)
          t13 = v - c * 65536
          v = t14 + c + 65535
          c = Math.floor(v / 65536)
          t14 = v - c * 65536
          v = t15 + c + 65535
          c = Math.floor(v / 65536)
          t15 = v - c * 65536
          t0 += c - 1 + 37 * (c - 1)

          o[0] = t0
          o[1] = t1
          o[2] = t2
          o[3] = t3
          o[4] = t4
          o[5] = t5
          o[6] = t6
          o[7] = t7
          o[8] = t8
          o[9] = t9
          o[10] = t10
          o[11] = t11
          o[12] = t12
          o[13] = t13
          o[14] = t14
          o[15] = t15
        }

        function S(o, a) {
          M(o, a, a)
        }

        function inv25519(o, i) {
          var c = gf()
          var a
          for (a = 0; a < 16; a++) c[a] = i[a]
          for (a = 253; a >= 0; a--) {
            S(c, c)
            if (a !== 2 && a !== 4) M(c, c, i)
          }
          for (a = 0; a < 16; a++) o[a] = c[a]
        }

        function pow2523(o, i) {
          var c = gf()
          var a
          for (a = 0; a < 16; a++) c[a] = i[a]
          for (a = 250; a >= 0; a--) {
            S(c, c)
            if (a !== 1) M(c, c, i)
          }
          for (a = 0; a < 16; a++) o[a] = c[a]
        }

        function crypto_scalarmult(q, n, p) {
          check(q, crypto_scalarmult_BYTES)
          check(n, crypto_scalarmult_SCALARBYTES)
          check(p, crypto_scalarmult_BYTES)
          var z = new Uint8Array(32)
          var x = new Float64Array(80),
            r,
            i
          var a = gf(),
            b = gf(),
            c = gf(),
            d = gf(),
            e = gf(),
            f = gf()
          for (i = 0; i < 31; i++) z[i] = n[i]
          z[31] = (n[31] & 127) | 64
          z[0] &= 248
          unpack25519(x, p)
          for (i = 0; i < 16; i++) {
            b[i] = x[i]
            d[i] = a[i] = c[i] = 0
          }
          a[0] = d[0] = 1
          for (i = 254; i >= 0; --i) {
            r = (z[i >>> 3] >>> (i & 7)) & 1
            sel25519(a, b, r)
            sel25519(c, d, r)
            A(e, a, c)
            Z(a, a, c)
            A(c, b, d)
            Z(b, b, d)
            S(d, e)
            S(f, a)
            M(a, c, a)
            M(c, b, e)
            A(e, a, c)
            Z(a, a, c)
            S(b, a)
            Z(c, d, f)
            M(a, c, _121665)
            A(a, a, d)
            M(c, c, a)
            M(a, d, f)
            M(d, b, x)
            S(b, e)
            sel25519(a, b, r)
            sel25519(c, d, r)
          }
          for (i = 0; i < 16; i++) {
            x[i + 16] = a[i]
            x[i + 32] = c[i]
            x[i + 48] = b[i]
            x[i + 64] = d[i]
          }
          var x32 = x.subarray(32)
          var x16 = x.subarray(16)
          inv25519(x32, x32)
          M(x16, x16, x32)
          pack25519(q, x16)
          return 0
        }

        function crypto_scalarmult_base(q, n) {
          return crypto_scalarmult(q, n, _9)
        }

        var K = [
          0x428a2f98,
          0xd728ae22,
          0x71374491,
          0x23ef65cd,
          0xb5c0fbcf,
          0xec4d3b2f,
          0xe9b5dba5,
          0x8189dbbc,
          0x3956c25b,
          0xf348b538,
          0x59f111f1,
          0xb605d019,
          0x923f82a4,
          0xaf194f9b,
          0xab1c5ed5,
          0xda6d8118,
          0xd807aa98,
          0xa3030242,
          0x12835b01,
          0x45706fbe,
          0x243185be,
          0x4ee4b28c,
          0x550c7dc3,
          0xd5ffb4e2,
          0x72be5d74,
          0xf27b896f,
          0x80deb1fe,
          0x3b1696b1,
          0x9bdc06a7,
          0x25c71235,
          0xc19bf174,
          0xcf692694,
          0xe49b69c1,
          0x9ef14ad2,
          0xefbe4786,
          0x384f25e3,
          0x0fc19dc6,
          0x8b8cd5b5,
          0x240ca1cc,
          0x77ac9c65,
          0x2de92c6f,
          0x592b0275,
          0x4a7484aa,
          0x6ea6e483,
          0x5cb0a9dc,
          0xbd41fbd4,
          0x76f988da,
          0x831153b5,
          0x983e5152,
          0xee66dfab,
          0xa831c66d,
          0x2db43210,
          0xb00327c8,
          0x98fb213f,
          0xbf597fc7,
          0xbeef0ee4,
          0xc6e00bf3,
          0x3da88fc2,
          0xd5a79147,
          0x930aa725,
          0x06ca6351,
          0xe003826f,
          0x14292967,
          0x0a0e6e70,
          0x27b70a85,
          0x46d22ffc,
          0x2e1b2138,
          0x5c26c926,
          0x4d2c6dfc,
          0x5ac42aed,
          0x53380d13,
          0x9d95b3df,
          0x650a7354,
          0x8baf63de,
          0x766a0abb,
          0x3c77b2a8,
          0x81c2c92e,
          0x47edaee6,
          0x92722c85,
          0x1482353b,
          0xa2bfe8a1,
          0x4cf10364,
          0xa81a664b,
          0xbc423001,
          0xc24b8b70,
          0xd0f89791,
          0xc76c51a3,
          0x0654be30,
          0xd192e819,
          0xd6ef5218,
          0xd6990624,
          0x5565a910,
          0xf40e3585,
          0x5771202a,
          0x106aa070,
          0x32bbd1b8,
          0x19a4c116,
          0xb8d2d0c8,
          0x1e376c08,
          0x5141ab53,
          0x2748774c,
          0xdf8eeb99,
          0x34b0bcb5,
          0xe19b48a8,
          0x391c0cb3,
          0xc5c95a63,
          0x4ed8aa4a,
          0xe3418acb,
          0x5b9cca4f,
          0x7763e373,
          0x682e6ff3,
          0xd6b2b8a3,
          0x748f82ee,
          0x5defb2fc,
          0x78a5636f,
          0x43172f60,
          0x84c87814,
          0xa1f0ab72,
          0x8cc70208,
          0x1a6439ec,
          0x90befffa,
          0x23631e28,
          0xa4506ceb,
          0xde82bde9,
          0xbef9a3f7,
          0xb2c67915,
          0xc67178f2,
          0xe372532b,
          0xca273ece,
          0xea26619c,
          0xd186b8c7,
          0x21c0c207,
          0xeada7dd6,
          0xcde0eb1e,
          0xf57d4f7f,
          0xee6ed178,
          0x06f067aa,
          0x72176fba,
          0x0a637dc5,
          0xa2c898a6,
          0x113f9804,
          0xbef90dae,
          0x1b710b35,
          0x131c471b,
          0x28db77f5,
          0x23047d84,
          0x32caab7b,
          0x40c72493,
          0x3c9ebe0a,
          0x15c9bebc,
          0x431d67c4,
          0x9c100d4c,
          0x4cc5d4be,
          0xcb3e42b6,
          0x597f299c,
          0xfc657e2a,
          0x5fcb6fab,
          0x3ad6faec,
          0x6c44198c,
          0x4a475817
        ]

        function crypto_hashblocks_hl(hh, hl, m, n) {
          var wh = new Int32Array(16),
            wl = new Int32Array(16),
            bh0,
            bh1,
            bh2,
            bh3,
            bh4,
            bh5,
            bh6,
            bh7,
            bl0,
            bl1,
            bl2,
            bl3,
            bl4,
            bl5,
            bl6,
            bl7,
            th,
            tl,
            i,
            j,
            h,
            l,
            a,
            b,
            c,
            d

          var ah0 = hh[0],
            ah1 = hh[1],
            ah2 = hh[2],
            ah3 = hh[3],
            ah4 = hh[4],
            ah5 = hh[5],
            ah6 = hh[6],
            ah7 = hh[7],
            al0 = hl[0],
            al1 = hl[1],
            al2 = hl[2],
            al3 = hl[3],
            al4 = hl[4],
            al5 = hl[5],
            al6 = hl[6],
            al7 = hl[7]

          var pos = 0
          while (n >= 128) {
            for (i = 0; i < 16; i++) {
              j = 8 * i + pos
              wh[i] =
                (m[j + 0] << 24) | (m[j + 1] << 16) | (m[j + 2] << 8) | m[j + 3]
              wl[i] =
                (m[j + 4] << 24) | (m[j + 5] << 16) | (m[j + 6] << 8) | m[j + 7]
            }
            for (i = 0; i < 80; i++) {
              bh0 = ah0
              bh1 = ah1
              bh2 = ah2
              bh3 = ah3
              bh4 = ah4
              bh5 = ah5
              bh6 = ah6
              bh7 = ah7

              bl0 = al0
              bl1 = al1
              bl2 = al2
              bl3 = al3
              bl4 = al4
              bl5 = al5
              bl6 = al6
              bl7 = al7

              // add
              h = ah7
              l = al7

              a = l & 0xffff
              b = l >>> 16
              c = h & 0xffff
              d = h >>> 16

              // Sigma1
              h =
                ((ah4 >>> 14) | (al4 << (32 - 14))) ^
                ((ah4 >>> 18) | (al4 << (32 - 18))) ^
                ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))))
              l =
                ((al4 >>> 14) | (ah4 << (32 - 14))) ^
                ((al4 >>> 18) | (ah4 << (32 - 18))) ^
                ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))))

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // Ch
              h = (ah4 & ah5) ^ (~ah4 & ah6)
              l = (al4 & al5) ^ (~al4 & al6)

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // K
              h = K[i * 2]
              l = K[i * 2 + 1]

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // w
              h = wh[i % 16]
              l = wl[i % 16]

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              b += a >>> 16
              c += b >>> 16
              d += c >>> 16

              th = (c & 0xffff) | (d << 16)
              tl = (a & 0xffff) | (b << 16)

              // add
              h = th
              l = tl

              a = l & 0xffff
              b = l >>> 16
              c = h & 0xffff
              d = h >>> 16

              // Sigma0
              h =
                ((ah0 >>> 28) | (al0 << (32 - 28))) ^
                ((al0 >>> (34 - 32)) | (ah0 << (32 - (34 - 32)))) ^
                ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))))
              l =
                ((al0 >>> 28) | (ah0 << (32 - 28))) ^
                ((ah0 >>> (34 - 32)) | (al0 << (32 - (34 - 32)))) ^
                ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))))

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              // Maj
              h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2)
              l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2)

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              b += a >>> 16
              c += b >>> 16
              d += c >>> 16

              bh7 = (c & 0xffff) | (d << 16)
              bl7 = (a & 0xffff) | (b << 16)

              // add
              h = bh3
              l = bl3

              a = l & 0xffff
              b = l >>> 16
              c = h & 0xffff
              d = h >>> 16

              h = th
              l = tl

              a += l & 0xffff
              b += l >>> 16
              c += h & 0xffff
              d += h >>> 16

              b += a >>> 16
              c += b >>> 16
              d += c >>> 16

              bh3 = (c & 0xffff) | (d << 16)
              bl3 = (a & 0xffff) | (b << 16)

              ah1 = bh0
              ah2 = bh1
              ah3 = bh2
              ah4 = bh3
              ah5 = bh4
              ah6 = bh5
              ah7 = bh6
              ah0 = bh7

              al1 = bl0
              al2 = bl1
              al3 = bl2
              al4 = bl3
              al5 = bl4
              al6 = bl5
              al7 = bl6
              al0 = bl7

              if (i % 16 === 15) {
                for (j = 0; j < 16; j++) {
                  // add
                  h = wh[j]
                  l = wl[j]

                  a = l & 0xffff
                  b = l >>> 16
                  c = h & 0xffff
                  d = h >>> 16

                  h = wh[(j + 9) % 16]
                  l = wl[(j + 9) % 16]

                  a += l & 0xffff
                  b += l >>> 16
                  c += h & 0xffff
                  d += h >>> 16

                  // sigma0
                  th = wh[(j + 1) % 16]
                  tl = wl[(j + 1) % 16]
                  h =
                    ((th >>> 1) | (tl << (32 - 1))) ^
                    ((th >>> 8) | (tl << (32 - 8))) ^
                    (th >>> 7)
                  l =
                    ((tl >>> 1) | (th << (32 - 1))) ^
                    ((tl >>> 8) | (th << (32 - 8))) ^
                    ((tl >>> 7) | (th << (32 - 7)))

                  a += l & 0xffff
                  b += l >>> 16
                  c += h & 0xffff
                  d += h >>> 16

                  // sigma1
                  th = wh[(j + 14) % 16]
                  tl = wl[(j + 14) % 16]
                  h =
                    ((th >>> 19) | (tl << (32 - 19))) ^
                    ((tl >>> (61 - 32)) | (th << (32 - (61 - 32)))) ^
                    (th >>> 6)
                  l =
                    ((tl >>> 19) | (th << (32 - 19))) ^
                    ((th >>> (61 - 32)) | (tl << (32 - (61 - 32)))) ^
                    ((tl >>> 6) | (th << (32 - 6)))

                  a += l & 0xffff
                  b += l >>> 16
                  c += h & 0xffff
                  d += h >>> 16

                  b += a >>> 16
                  c += b >>> 16
                  d += c >>> 16

                  wh[j] = (c & 0xffff) | (d << 16)
                  wl[j] = (a & 0xffff) | (b << 16)
                }
              }
            }

            // add
            h = ah0
            l = al0

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[0]
            l = hl[0]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[0] = ah0 = (c & 0xffff) | (d << 16)
            hl[0] = al0 = (a & 0xffff) | (b << 16)

            h = ah1
            l = al1

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[1]
            l = hl[1]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[1] = ah1 = (c & 0xffff) | (d << 16)
            hl[1] = al1 = (a & 0xffff) | (b << 16)

            h = ah2
            l = al2

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[2]
            l = hl[2]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[2] = ah2 = (c & 0xffff) | (d << 16)
            hl[2] = al2 = (a & 0xffff) | (b << 16)

            h = ah3
            l = al3

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[3]
            l = hl[3]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[3] = ah3 = (c & 0xffff) | (d << 16)
            hl[3] = al3 = (a & 0xffff) | (b << 16)

            h = ah4
            l = al4

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[4]
            l = hl[4]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[4] = ah4 = (c & 0xffff) | (d << 16)
            hl[4] = al4 = (a & 0xffff) | (b << 16)

            h = ah5
            l = al5

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[5]
            l = hl[5]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[5] = ah5 = (c & 0xffff) | (d << 16)
            hl[5] = al5 = (a & 0xffff) | (b << 16)

            h = ah6
            l = al6

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[6]
            l = hl[6]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[6] = ah6 = (c & 0xffff) | (d << 16)
            hl[6] = al6 = (a & 0xffff) | (b << 16)

            h = ah7
            l = al7

            a = l & 0xffff
            b = l >>> 16
            c = h & 0xffff
            d = h >>> 16

            h = hh[7]
            l = hl[7]

            a += l & 0xffff
            b += l >>> 16
            c += h & 0xffff
            d += h >>> 16

            b += a >>> 16
            c += b >>> 16
            d += c >>> 16

            hh[7] = ah7 = (c & 0xffff) | (d << 16)
            hl[7] = al7 = (a & 0xffff) | (b << 16)

            pos += 128
            n -= 128
          }

          return n
        }

        function crypto_hash(out, m, n) {
          var hh = new Int32Array(8),
            hl = new Int32Array(8),
            x = new Uint8Array(256),
            i,
            b = n

          hh[0] = 0x6a09e667
          hh[1] = 0xbb67ae85
          hh[2] = 0x3c6ef372
          hh[3] = 0xa54ff53a
          hh[4] = 0x510e527f
          hh[5] = 0x9b05688c
          hh[6] = 0x1f83d9ab
          hh[7] = 0x5be0cd19

          hl[0] = 0xf3bcc908
          hl[1] = 0x84caa73b
          hl[2] = 0xfe94f82b
          hl[3] = 0x5f1d36f1
          hl[4] = 0xade682d1
          hl[5] = 0x2b3e6c1f
          hl[6] = 0xfb41bd6b
          hl[7] = 0x137e2179

          crypto_hashblocks_hl(hh, hl, m, n)
          n %= 128

          for (i = 0; i < n; i++) x[i] = m[b - n + i]
          x[n] = 128

          n = 256 - 128 * (n < 112 ? 1 : 0)
          x[n - 9] = 0
          ts64(x, n - 8, (b / 0x20000000) | 0, b << 3)
          crypto_hashblocks_hl(hh, hl, x, n)

          for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i])

          return 0
        }

        function add(p, q) {
          var a = gf(),
            b = gf(),
            c = gf(),
            d = gf(),
            e = gf(),
            f = gf(),
            g = gf(),
            h = gf(),
            t = gf()

          Z(a, p[1], p[0])
          Z(t, q[1], q[0])
          M(a, a, t)
          A(b, p[0], p[1])
          A(t, q[0], q[1])
          M(b, b, t)
          M(c, p[3], q[3])
          M(c, c, D2)
          M(d, p[2], q[2])
          A(d, d, d)
          Z(e, b, a)
          Z(f, d, c)
          A(g, d, c)
          A(h, b, a)

          M(p[0], e, f)
          M(p[1], h, g)
          M(p[2], g, f)
          M(p[3], e, h)
        }

        function cswap(p, q, b) {
          var i
          for (i = 0; i < 4; i++) {
            sel25519(p[i], q[i], b)
          }
        }

        function pack(r, p) {
          var tx = gf(),
            ty = gf(),
            zi = gf()
          inv25519(zi, p[2])
          M(tx, p[0], zi)
          M(ty, p[1], zi)
          pack25519(r, ty)
          r[31] ^= par25519(tx) << 7
        }

        function scalarmult(p, q, s) {
          var b, i
          set25519(p[0], gf0)
          set25519(p[1], gf1)
          set25519(p[2], gf1)
          set25519(p[3], gf0)
          for (i = 255; i >= 0; --i) {
            b = (s[(i / 8) | 0] >> (i & 7)) & 1
            cswap(p, q, b)
            add(q, p)
            add(p, p)
            cswap(p, q, b)
          }
        }

        function scalarbase(p, s) {
          var q = [gf(), gf(), gf(), gf()]
          set25519(q[0], X)
          set25519(q[1], Y)
          set25519(q[2], gf1)
          M(q[3], X, Y)
          scalarmult(p, q, s)
        }

        function crypto_sign_keypair(pk, sk, seeded) {
          check(pk, sodium.crypto_sign_PUBLICKEYBYTES)
          check(sk, sodium.crypto_sign_SECRETKEYBYTES)

          var d = new Uint8Array(64)
          var p = [gf(), gf(), gf(), gf()]
          var i

          if (!seeded) randombytes(sk, 32)
          crypto_hash(d, sk, 32)
          d[0] &= 248
          d[31] &= 127
          d[31] |= 64

          scalarbase(p, d)
          pack(pk, p)

          for (i = 0; i < 32; i++) sk[i + 32] = pk[i]
          return 0
        }

        function crypto_sign_seed_keypair(pk, sk, seed) {
          check(seed, sodium.crypto_sign_SEEDBYTES)
          seed.copy(sk)
          crypto_sign_keypair(pk, sk, true)
        }

        var L = new Float64Array([
          0xed,
          0xd3,
          0xf5,
          0x5c,
          0x1a,
          0x63,
          0x12,
          0x58,
          0xd6,
          0x9c,
          0xf7,
          0xa2,
          0xde,
          0xf9,
          0xde,
          0x14,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0x10
        ])

        function modL(r, x) {
          var carry, i, j, k
          for (i = 63; i >= 32; --i) {
            carry = 0
            for (j = i - 32, k = i - 12; j < k; ++j) {
              x[j] += carry - 16 * x[i] * L[j - (i - 32)]
              carry = (x[j] + 128) >> 8
              x[j] -= carry * 256
            }
            x[j] += carry
            x[i] = 0
          }
          carry = 0
          for (j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j]
            carry = x[j] >> 8
            x[j] &= 255
          }
          for (j = 0; j < 32; j++) x[j] -= carry * L[j]
          for (i = 0; i < 32; i++) {
            x[i + 1] += x[i] >> 8
            r[i] = x[i] & 255
          }
        }

        function reduce(r) {
          var x = new Float64Array(64),
            i
          for (i = 0; i < 64; i++) x[i] = r[i]
          for (i = 0; i < 64; i++) r[i] = 0
          modL(r, x)
        }

        // Note: difference from C - smlen returned, not passed as argument.
        function crypto_sign(sm, m, sk) {
          check(sm, crypto_sign_BYTES + m.length)
          check(m, 0)
          check(sk, crypto_sign_SECRETKEYBYTES)
          var n = m.length

          var d = new Uint8Array(64),
            h = new Uint8Array(64),
            r = new Uint8Array(64)
          var i,
            j,
            x = new Float64Array(64)
          var p = [gf(), gf(), gf(), gf()]

          crypto_hash(d, sk, 32)
          d[0] &= 248
          d[31] &= 127
          d[31] |= 64

          var smlen = n + 64
          for (i = 0; i < n; i++) sm[64 + i] = m[i]
          for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i]

          crypto_hash(r, sm.subarray(32), n + 32)
          reduce(r)
          scalarbase(p, r)
          pack(sm, p)

          for (i = 32; i < 64; i++) sm[i] = sk[i]
          crypto_hash(h, sm, n + 64)
          reduce(h)

          for (i = 0; i < 64; i++) x[i] = 0
          for (i = 0; i < 32; i++) x[i] = r[i]
          for (i = 0; i < 32; i++) {
            for (j = 0; j < 32; j++) {
              x[i + j] += h[i] * d[j]
            }
          }

          modL(sm.subarray(32), x)
        }

        function crypto_sign_detached(sig, m, sk) {
          var sm = new Uint8Array(m.length + crypto_sign_BYTES)
          crypto_sign(sm, m, sk)
          for (var i = 0; i < crypto_sign_BYTES; i++) sig[i] = sm[i]
        }

        function unpackneg(r, p) {
          var t = gf(),
            chk = gf(),
            num = gf(),
            den = gf(),
            den2 = gf(),
            den4 = gf(),
            den6 = gf()

          set25519(r[2], gf1)
          unpack25519(r[1], p)
          S(num, r[1])
          M(den, num, D)
          Z(num, num, r[2])
          A(den, r[2], den)

          S(den2, den)
          S(den4, den2)
          M(den6, den4, den2)
          M(t, den6, num)
          M(t, t, den)

          pow2523(t, t)
          M(t, t, num)
          M(t, t, den)
          M(t, t, den)
          M(r[0], t, den)

          S(chk, r[0])
          M(chk, chk, den)
          if (neq25519(chk, num)) M(r[0], r[0], I)

          S(chk, r[0])
          M(chk, chk, den)
          if (neq25519(chk, num)) return -1

          if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0])

          M(r[3], r[0], r[1])
          return 0
        }

        function crypto_sign_open(msg, sm, pk) {
          check(msg, sm.length - crypto_sign_BYTES)
          check(sm, crypto_sign_BYTES)
          check(pk, crypto_sign_PUBLICKEYBYTES)
          var n = sm.length
          var m = new Uint8Array(sm.length)

          var i, mlen
          var t = new Uint8Array(32),
            h = new Uint8Array(64)
          var p = [gf(), gf(), gf(), gf()],
            q = [gf(), gf(), gf(), gf()]

          mlen = -1
          if (n < 64) return false

          if (unpackneg(q, pk)) return false

          for (i = 0; i < n; i++) m[i] = sm[i]
          for (i = 0; i < 32; i++) m[i + 32] = pk[i]
          crypto_hash(h, m, n)
          reduce(h)
          scalarmult(p, q, h)

          scalarbase(q, sm.subarray(32))
          add(p, q)
          pack(t, p)

          n -= 64
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i = 0; i < n; i++) m[i] = 0
            return false
          }

          for (i = 0; i < n; i++) msg[i] = sm[i + 64]
          mlen = n
          return true
        }

        function crypto_sign_verify_detached(sig, m, pk) {
          check(sig, crypto_sign_BYTES)
          var sm = new Uint8Array(m.length + crypto_sign_BYTES)
          var i = 0
          for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i]
          for (i = 0; i < m.length; i++) sm[i + crypto_sign_BYTES] = m[i]
          return crypto_sign_open(m, sm, pk)
        }

        function crypto_secretbox_detached(o, mac, msg, n, k) {
          check(mac, sodium.crypto_secretbox_MACBYTES)
          var tmp = new Uint8Array(msg.length + mac.length)
          crypto_secretbox_easy(tmp, msg, n, k)
          o.set(tmp.subarray(0, msg.length))
          mac.set(tmp.subarray(msg.length))
        }

        function crypto_secretbox_open_detached(msg, o, mac, n, k) {
          check(mac, sodium.crypto_secretbox_MACBYTES)
          var tmp = new Uint8Array(o.length + mac.length)
          tmp.set(o)
          tmp.set(mac, msg.length)
          return crypto_secretbox_open_easy(msg, tmp, n, k)
        }

        function crypto_secretbox_easy(o, msg, n, k) {
          check(msg, 0)
          check(o, msg.length + sodium.crypto_secretbox_MACBYTES)
          check(n, crypto_secretbox_NONCEBYTES)
          check(k, crypto_secretbox_KEYBYTES)

          var i
          var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length)
          var c = new Uint8Array(m.length)
          for (i = 0; i < msg.length; i++)
            m[i + crypto_secretbox_ZEROBYTES] = msg[i]
          crypto_secretbox(c, m, m.length, n, k)
          for (i = crypto_secretbox_BOXZEROBYTES; i < c.length; i++)
            o[i - crypto_secretbox_BOXZEROBYTES] = c[i]
        }

        function crypto_secretbox_open_easy(msg, box, n, k) {
          check(box, sodium.crypto_secretbox_MACBYTES)
          check(msg, box.length - sodium.crypto_secretbox_MACBYTES)
          check(n, crypto_secretbox_NONCEBYTES)
          check(k, crypto_secretbox_KEYBYTES)

          var i
          var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length)
          var m = new Uint8Array(c.length)
          for (i = 0; i < box.length; i++)
            c[i + crypto_secretbox_BOXZEROBYTES] = box[i]
          if (c.length < 32) return false
          if (crypto_secretbox_open(m, c, c.length, n, k) !== 0) return false

          for (i = crypto_secretbox_ZEROBYTES; i < m.length; i++)
            msg[i - crypto_secretbox_ZEROBYTES] = m[i]
          return true
        }

        var crypto_secretbox_KEYBYTES = 32,
          crypto_secretbox_NONCEBYTES = 24,
          crypto_secretbox_ZEROBYTES = 32,
          crypto_secretbox_BOXZEROBYTES = 16,
          crypto_scalarmult_BYTES = 32,
          crypto_scalarmult_SCALARBYTES = 32,
          crypto_box_PUBLICKEYBYTES = 32,
          crypto_box_SECRETKEYBYTES = 32,
          crypto_box_BEFORENMBYTES = 32,
          crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
          crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
          crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
          crypto_sign_BYTES = 64,
          crypto_sign_PUBLICKEYBYTES = 32,
          crypto_sign_SECRETKEYBYTES = 64,
          crypto_sign_SEEDBYTES = 32,
          crypto_hash_BYTES = 64

        sodium.memzero = function(len, offset) {
          for (var i = offset; i < len; i++) arr[i] = 0
        }

        sodium.crypto_sign_BYTES = crypto_sign_BYTES
        sodium.crypto_sign_PUBLICKEYBYTES = crypto_sign_PUBLICKEYBYTES
        sodium.crypto_sign_SECRETKEYBYTES = crypto_sign_SECRETKEYBYTES
        sodium.crypto_sign_SEEDBYTES = crypto_sign_SEEDBYTES
        sodium.crypto_sign_keypair = crypto_sign_keypair
        sodium.crypto_sign_seed_keypair = crypto_sign_seed_keypair
        sodium.crypto_sign = crypto_sign
        sodium.crypto_sign_open = crypto_sign_open
        sodium.crypto_sign_detached = crypto_sign_detached
        sodium.crypto_sign_verify_detached = crypto_sign_verify_detached

        forward(require("./crypto_generichash"))
        forward(require("./crypto_kdf"))
        forward(require("./crypto_shorthash"))
        forward(require("./randombytes"))
        forward(require("./crypto_stream"))

        sodium.crypto_scalarmult_BYTES = crypto_scalarmult_BYTES
        sodium.crypto_scalarmult_SCALARBYTES = crypto_scalarmult_SCALARBYTES
        sodium.crypto_scalarmult_base = crypto_scalarmult_base
        sodium.crypto_scalarmult = crypto_scalarmult
        ;(sodium.crypto_secretbox_KEYBYTES = crypto_secretbox_KEYBYTES),
          (sodium.crypto_secretbox_NONCEBYTES = crypto_secretbox_NONCEBYTES),
          (sodium.crypto_secretbox_MACBYTES = 16)
        sodium.crypto_secretbox_easy = crypto_secretbox_easy
        sodium.crypto_secretbox_open_easy = crypto_secretbox_open_easy
        sodium.crypto_secretbox_detached = crypto_secretbox_detached
        sodium.crypto_secretbox_open_detached = crypto_secretbox_open_detached

        function cleanup(arr) {
          for (var i = 0; i < arr.length; i++) arr[i] = 0
        }

        function check(buf, len) {
          if (!buf || (len && buf.length < len))
            throw new Error(
              "Argument must be a buffer" + (len ? " of length " + len : "")
            )
        }

        function forward(submodule) {
          Object.keys(submodule).forEach(function(prop) {
            module.exports[prop] = submodule[prop]
          })
        }
      },
      {
        "./crypto_generichash": 64,
        "./crypto_kdf": 65,
        "./crypto_shorthash": 66,
        "./crypto_stream": 67,
        "./randombytes": 69
      }
    ],
    69: [
      function(require, module, exports) {
        ;(function(global) {
          var assert = require("nanoassert")
          var randombytes = (function() {
            var QUOTA = 65536 // limit for QuotaExceededException
            var crypto =
              typeof global !== "undefined"
                ? (crypto = global.crypto || global.msCrypto)
                : null

            function browserBytes(out, n) {
              for (var i = 0; i < n; i += QUOTA) {
                crypto.getRandomValues(
                  out.subarray(i, i + Math.min(n - i, QUOTA))
                )
              }
            }

            function nodeBytes(out, n) {
              out.set(crypto.randomBytes(n))
            }

            function noImpl() {
              throw new Error("No secure random number generator available")
            }

            if (crypto && crypto.getRandomValues) {
              return browserBytes
            } else if (typeof require !== "undefined") {
              // Node.js.
              crypto = require("crypto")
              if (crypto && crypto.randomBytes) {
                return nodeBytes
              }
            }

            return noImpl
          })()

          Object.defineProperty(module.exports, "randombytes", {
            value: randombytes
          })

          module.exports.randombytes_buf = function(out) {
            assert(out, "out must be given")
            randombytes(out, out.length)
          }
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {}
        ))
      },
      { crypto: 14, nanoassert: 42 }
    ],
    70: [
      function(require, module, exports) {
        module.exports = require("sodium-javascript")
      },
      { "sodium-javascript": 68 }
    ],
    71: [
      function(require, module, exports) {
        module.exports = indexOf

        function indexOf(left, right) {
          var result = new Array(right.length)
          var i = 0
          var j = 0

          while (i < left.length && j < right.length) {
            var a = left[i]
            var b = right[j]

            if (a === b) {
              result[j++] = i
              continue
            }

            if (a < b) {
              i++
              continue
            }

            result[j++] = -1
            continue
          }

          for (; j < right.length; j++) result[j] = -1

          return result
        }
      },
      {}
    ],
    72: [
      function(require, module, exports) {
        ;(function(Buffer) {
          var pager = require("memory-pager")

          module.exports = Bitfield

          function Bitfield(opts) {
            if (!(this instanceof Bitfield)) return new Bitfield(opts)
            if (!opts) opts = {}
            if (Buffer.isBuffer(opts)) opts = { buffer: opts }

            this.pageOffset = opts.pageOffset || 0
            this.pageSize = opts.pageSize || 1024
            this.pages = opts.pages || pager(this.pageSize)

            this.byteLength = this.pages.length * this.pageSize
            this.length = 8 * this.byteLength

            if (!powerOfTwo(this.pageSize))
              throw new Error("The page size should be a power of two")

            this._trackUpdates = !!opts.trackUpdates
            this._pageMask = this.pageSize - 1

            if (opts.buffer) {
              for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
                this.pages.set(
                  i / this.pageSize,
                  opts.buffer.slice(i, i + this.pageSize)
                )
              }
              this.byteLength = opts.buffer.length
              this.length = 8 * this.byteLength
            }
          }

          Bitfield.prototype.get = function(i) {
            var o = i & 7
            var j = (i - o) / 8

            return !!(this.getByte(j) & (128 >> o))
          }

          Bitfield.prototype.getByte = function(i) {
            var o = i & this._pageMask
            var j = (i - o) / this.pageSize
            var page = this.pages.get(j, true)

            return page ? page.buffer[o + this.pageOffset] : 0
          }

          Bitfield.prototype.set = function(i, v) {
            var o = i & 7
            var j = (i - o) / 8
            var b = this.getByte(j)

            return this.setByte(j, v ? b | (128 >> o) : b & (255 ^ (128 >> o)))
          }

          Bitfield.prototype.toBuffer = function() {
            var all = alloc(this.pages.length * this.pageSize)

            for (var i = 0; i < this.pages.length; i++) {
              var next = this.pages.get(i, true)
              var allOffset = i * this.pageSize
              if (next)
                next.buffer.copy(
                  all,
                  allOffset,
                  this.pageOffset,
                  this.pageOffset + this.pageSize
                )
            }

            return all
          }

          Bitfield.prototype.setByte = function(i, b) {
            var o = i & this._pageMask
            var j = (i - o) / this.pageSize
            var page = this.pages.get(j, false)

            o += this.pageOffset

            if (page.buffer[o] === b) return false
            page.buffer[o] = b

            if (i >= this.byteLength) {
              this.byteLength = i + 1
              this.length = this.byteLength * 8
            }

            if (this._trackUpdates) this.pages.updated(page)

            return true
          }

          function alloc(n) {
            if (Buffer.alloc) return Buffer.alloc(n)
            var b = new Buffer(n)
            b.fill(0)
            return b
          }

          function powerOfTwo(x) {
            return !(x & (x - 1))
          }
        }.call(this, require("buffer").Buffer))
      },
      { buffer: 20, "memory-pager": 40 }
    ],
    73: [
      function(require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict"

        /*<replacement>*/

        var Buffer = require("safe-buffer").Buffer
        /*</replacement>*/

        var isEncoding =
          Buffer.isEncoding ||
          function(encoding) {
            encoding = "" + encoding
            switch (encoding && encoding.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return true
              default:
                return false
            }
          }

        function _normalizeEncoding(enc) {
          if (!enc) return "utf8"
          var retried
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8"
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le"
              case "latin1":
              case "binary":
                return "latin1"
              case "base64":
              case "ascii":
              case "hex":
                return enc
              default:
                if (retried) return // undefined
                enc = ("" + enc).toLowerCase()
                retried = true
            }
          }
        }

        // Do not cache `Buffer.isEncoding` when checking encoding names as some
        // modules monkey-patch it to support additional encodings
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc)
          if (
            typeof nenc !== "string" &&
            (Buffer.isEncoding === isEncoding || !isEncoding(enc))
          )
            throw new Error("Unknown encoding: " + enc)
          return nenc || enc
        }

        // StringDecoder provides an interface for efficiently splitting a series of
        // buffers into a series of JS strings without breaking apart multi-byte
        // characters.
        exports.StringDecoder = StringDecoder
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding)
          var nb
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text
              this.end = utf16End
              nb = 4
              break
            case "utf8":
              this.fillLast = utf8FillLast
              nb = 4
              break
            case "base64":
              this.text = base64Text
              this.end = base64End
              nb = 3
              break
            default:
              this.write = simpleWrite
              this.end = simpleEnd
              return
          }
          this.lastNeed = 0
          this.lastTotal = 0
          this.lastChar = Buffer.allocUnsafe(nb)
        }

        StringDecoder.prototype.write = function(buf) {
          if (buf.length === 0) return ""
          var r
          var i
          if (this.lastNeed) {
            r = this.fillLast(buf)
            if (r === undefined) return ""
            i = this.lastNeed
            this.lastNeed = 0
          } else {
            i = 0
          }
          if (i < buf.length)
            return r ? r + this.text(buf, i) : this.text(buf, i)
          return r || ""
        }

        StringDecoder.prototype.end = utf8End

        // Returns only complete characters in a Buffer
        StringDecoder.prototype.text = utf8Text

        // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
        StringDecoder.prototype.fillLast = function(buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(
              this.lastChar,
              this.lastTotal - this.lastNeed,
              0,
              this.lastNeed
            )
            return this.lastChar.toString(this.encoding, 0, this.lastTotal)
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length)
          this.lastNeed -= buf.length
        }

        // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
        // continuation byte. If an invalid byte is detected, -2 is returned.
        function utf8CheckByte(byte) {
          if (byte <= 0x7f) return 0
          else if (byte >> 5 === 0x06) return 2
          else if (byte >> 4 === 0x0e) return 3
          else if (byte >> 3 === 0x1e) return 4
          return byte >> 6 === 0x02 ? -1 : -2
        }

        // Checks at most 3 bytes at the end of a Buffer in order to detect an
        // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
        // needed to complete the UTF-8 character (if applicable) are returned.
        function utf8CheckIncomplete(self, buf, i) {
          var j = buf.length - 1
          if (j < i) return 0
          var nb = utf8CheckByte(buf[j])
          if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 1
            return nb
          }
          if (--j < i || nb === -2) return 0
          nb = utf8CheckByte(buf[j])
          if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 2
            return nb
          }
          if (--j < i || nb === -2) return 0
          nb = utf8CheckByte(buf[j])
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2) nb = 0
              else self.lastNeed = nb - 3
            }
            return nb
          }
          return 0
        }

        // Validates as many continuation bytes for a multi-byte UTF-8 character as
        // needed or are available. If we see a non-continuation byte where we expect
        // one, we "replace" the validated continuation bytes we've seen so far with
        // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
        // behavior. The continuation byte check is included three times in the case
        // where all of the continuation bytes for a character exist in the same buffer.
        // It is also done this way as a slight performance increase instead of using a
        // loop.
        function utf8CheckExtraBytes(self, buf, p) {
          if ((buf[0] & 0xc0) !== 0x80) {
            self.lastNeed = 0
            return "\ufffd"
          }
          if (self.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 0xc0) !== 0x80) {
              self.lastNeed = 1
              return "\ufffd"
            }
            if (self.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 0xc0) !== 0x80) {
                self.lastNeed = 2
                return "\ufffd"
              }
            }
          }
        }

        // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed
          var r = utf8CheckExtraBytes(this, buf, p)
          if (r !== undefined) return r
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed)
            return this.lastChar.toString(this.encoding, 0, this.lastTotal)
          }
          buf.copy(this.lastChar, p, 0, buf.length)
          this.lastNeed -= buf.length
        }

        // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
        // partial character, the character's bytes are buffered until the required
        // number of bytes are available.
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i)
          if (!this.lastNeed) return buf.toString("utf8", i)
          this.lastTotal = total
          var end = buf.length - (total - this.lastNeed)
          buf.copy(this.lastChar, 0, end)
          return buf.toString("utf8", i, end)
        }

        // For UTF-8, a replacement character is added when ending on a partial
        // character.
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : ""
          if (this.lastNeed) return r + "\ufffd"
          return r
        }

        // UTF-16LE typically needs two bytes per character, but even if we have an even
        // number of bytes available, we need to check if we end on a leading/high
        // surrogate. In that case, we need to wait for the next two bytes in order to
        // decode the last character properly.
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i)
            if (r) {
              var c = r.charCodeAt(r.length - 1)
              if (c >= 0xd800 && c <= 0xdbff) {
                this.lastNeed = 2
                this.lastTotal = 4
                this.lastChar[0] = buf[buf.length - 2]
                this.lastChar[1] = buf[buf.length - 1]
                return r.slice(0, -1)
              }
            }
            return r
          }
          this.lastNeed = 1
          this.lastTotal = 2
          this.lastChar[0] = buf[buf.length - 1]
          return buf.toString("utf16le", i, buf.length - 1)
        }

        // For UTF-16LE we do not explicitly append special replacement characters if we
        // end on a partial character, we simply let v8 handle that.
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : ""
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed
            return r + this.lastChar.toString("utf16le", 0, end)
          }
          return r
        }

        function base64Text(buf, i) {
          var n = (buf.length - i) % 3
          if (n === 0) return buf.toString("base64", i)
          this.lastNeed = 3 - n
          this.lastTotal = 3
          if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1]
          } else {
            this.lastChar[0] = buf[buf.length - 2]
            this.lastChar[1] = buf[buf.length - 1]
          }
          return buf.toString("base64", i, buf.length - n)
        }

        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : ""
          if (this.lastNeed)
            return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed)
          return r
        }

        // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
        function simpleWrite(buf) {
          return buf.toString(this.encoding)
        }

        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : ""
        }
      },
      { "safe-buffer": 59 }
    ],
    74: [
      function(require, module, exports) {
        ;(function(process) {
          "use strict"

          var nextTick = nextTickArgs
          process.nextTick(upgrade, 42) // pass 42 and see if upgrade is called with it

          module.exports = thunky

          function thunky(fn) {
            var state = run
            return thunk

            function thunk(callback) {
              state(callback || noop)
            }

            function run(callback) {
              var stack = [callback]
              state = wait
              fn(done)

              function wait(callback) {
                stack.push(callback)
              }

              function done(err) {
                var args = arguments
                state = isError(err) ? run : finished
                while (stack.length) finished(stack.shift())

                function finished(callback) {
                  nextTick(apply, callback, args)
                }
              }
            }
          }

          function isError(err) {
            // inlined from util so this works in the browser
            return Object.prototype.toString.call(err) === "[object Error]"
          }

          function noop() {}

          function apply(callback, args) {
            callback.apply(null, args)
          }

          function upgrade(val) {
            if (val === 42) nextTick = process.nextTick
          }

          function nextTickArgs(fn, a, b) {
            process.nextTick(function() {
              fn(a, b)
            })
          }
        }.call(this, require("_process")))
      },
      { _process: 44 }
    ],
    75: [
      function(require, module, exports) {
        ;(function(setImmediate, clearImmediate) {
          var nextTick = require("process/browser.js").nextTick
          var apply = Function.prototype.apply
          var slice = Array.prototype.slice
          var immediateIds = {}
          var nextImmediateId = 0

          // DOM APIs, for completeness

          exports.setTimeout = function() {
            return new Timeout(
              apply.call(setTimeout, window, arguments),
              clearTimeout
            )
          }
          exports.setInterval = function() {
            return new Timeout(
              apply.call(setInterval, window, arguments),
              clearInterval
            )
          }
          exports.clearTimeout = exports.clearInterval = function(timeout) {
            timeout.close()
          }

          function Timeout(id, clearFn) {
            this._id = id
            this._clearFn = clearFn
          }
          Timeout.prototype.unref = Timeout.prototype.ref = function() {}
          Timeout.prototype.close = function() {
            this._clearFn.call(window, this._id)
          }

          // Does not start the time, just sets up the members needed.
          exports.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId)
            item._idleTimeout = msecs
          }

          exports.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId)
            item._idleTimeout = -1
          }

          exports._unrefActive = exports.active = function(item) {
            clearTimeout(item._idleTimeoutId)

            var msecs = item._idleTimeout
            if (msecs >= 0) {
              item._idleTimeoutId = setTimeout(function onTimeout() {
                if (item._onTimeout) item._onTimeout()
              }, msecs)
            }
          }

          // That's not how node.js implements it but the exposed api is the same.
          exports.setImmediate =
            typeof setImmediate === "function"
              ? setImmediate
              : function(fn) {
                  var id = nextImmediateId++
                  var args =
                    arguments.length < 2 ? false : slice.call(arguments, 1)

                  immediateIds[id] = true

                  nextTick(function onNextTick() {
                    if (immediateIds[id]) {
                      // fn.call() is faster so we optimize for the common use-case
                      // @see http://jsperf.com/call-apply-segu
                      if (args) {
                        fn.apply(null, args)
                      } else {
                        fn.call(null)
                      }
                      // Prevent ids from leaking
                      exports.clearImmediate(id)
                    }
                  })

                  return id
                }

          exports.clearImmediate =
            typeof clearImmediate === "function"
              ? clearImmediate
              : function(id) {
                  delete immediateIds[id]
                }
        }.call(
          this,
          require("timers").setImmediate,
          require("timers").clearImmediate
        ))
      },
      { "process/browser.js": 44, timers: 75 }
    ],
    76: [
      function(require, module, exports) {
        var bufferAlloc = require("buffer-alloc")

        var UINT_32_MAX = Math.pow(2, 32)

        exports.encodingLength = function() {
          return 8
        }

        exports.encode = function(num, buf, offset) {
          if (!buf) buf = bufferAlloc(8)
          if (!offset) offset = 0

          var top = Math.floor(num / UINT_32_MAX)
          var rem = num - top * UINT_32_MAX

          buf.writeUInt32BE(top, offset)
          buf.writeUInt32BE(rem, offset + 4)
          return buf
        }

        exports.decode = function(buf, offset) {
          if (!offset) offset = 0

          var top = buf.readUInt32BE(offset)
          var rem = buf.readUInt32BE(offset + 4)

          return top * UINT_32_MAX + rem
        }

        exports.encode.bytes = 8
        exports.decode.bytes = 8
      },
      { "buffer-alloc": 16 }
    ],
    77: [
      function(require, module, exports) {
        module.exports = remove

        function remove(arr, i) {
          if (i >= arr.length || i < 0) return
          var last = arr.pop()
          if (i < arr.length) {
            var tmp = arr[i]
            arr[i] = last
            return tmp
          }
          return last
        }
      },
      {}
    ],
    78: [
      function(require, module, exports) {
        exports.add = add
        exports.has = has
        exports.remove = remove
        exports.swap = swap

        function add(list, item) {
          if (has(list, item)) return item
          item._index = list.length
          list.push(item)
          return item
        }

        function has(list, item) {
          return item._index < list.length && list[item._index] === item
        }

        function remove(list, item) {
          if (!has(list, item)) return null

          var last = list.pop()
          if (last !== item) {
            list[item._index] = last
            last._index = item._index
          }

          return item
        }

        function swap(list, a, b) {
          if (!has(list, a) || !has(list, b)) return
          var tmp = a._index
          a._index = b._index
          list[a._index] = a
          b._index = tmp
          list[b._index] = b
        }
      },
      {}
    ],
    79: [
      function(require, module, exports) {
        ;(function(global) {
          /**
           * Module exports.
           */

          module.exports = deprecate

          /**
           * Mark that a method should not be used.
           * Returns a modified function which warns once by default.
           *
           * If `localStorage.noDeprecation = true` is set, then it is a no-op.
           *
           * If `localStorage.throwDeprecation = true` is set, then deprecated functions
           * will throw an Error when invoked.
           *
           * If `localStorage.traceDeprecation = true` is set, then deprecated functions
           * will invoke `console.trace()` instead of `console.error()`.
           *
           * @param {Function} fn - the function to deprecate
           * @param {String} msg - the string to print to the console when `fn` is invoked
           * @returns {Function} a new "deprecated" version of `fn`
           * @api public
           */

          function deprecate(fn, msg) {
            if (config("noDeprecation")) {
              return fn
            }

            var warned = false
            function deprecated() {
              if (!warned) {
                if (config("throwDeprecation")) {
                  throw new Error(msg)
                } else if (config("traceDeprecation")) {
                  console.trace(msg)
                } else {
                  console.warn(msg)
                }
                warned = true
              }
              return fn.apply(this, arguments)
            }

            return deprecated
          }

          /**
           * Checks `localStorage` for boolean values for the given `name`.
           *
           * @param {String} name
           * @returns {Boolean}
           * @api private
           */

          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage) return false
            } catch (_) {
              return false
            }
            var val = global.localStorage[name]
            if (null == val) return false
            return String(val).toLowerCase() === "true"
          }
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined"
                ? window
                : {}
        ))
      },
      {}
    ],
    80: [
      function(require, module, exports) {
        module.exports = read

        var MSB = 0x80,
          REST = 0x7f

        function read(buf, offset) {
          var res = 0,
            offset = offset || 0,
            shift = 0,
            counter = offset,
            b,
            l = buf.length

          do {
            if (counter >= l) {
              read.bytes = 0
              throw new RangeError("Could not decode varint")
            }
            b = buf[counter++]
            res +=
              shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift)
            shift += 7
          } while (b >= MSB)

          read.bytes = counter - offset

          return res
        }
      },
      {}
    ],
    81: [
      function(require, module, exports) {
        arguments[4][8][0].apply(exports, arguments)
      },
      { dup: 8 }
    ],
    82: [
      function(require, module, exports) {
        arguments[4][9][0].apply(exports, arguments)
      },
      { "./decode.js": 80, "./encode.js": 81, "./length.js": 83, dup: 9 }
    ],
    83: [
      function(require, module, exports) {
        arguments[4][10][0].apply(exports, arguments)
      },
      { dup: 10 }
    ],
    84: [
      function(require, module, exports) {
        var xsalsa20 = require("./xsalsa20")()

        var SIGMA = new Uint8Array([
          101,
          120,
          112,
          97,
          110,
          100,
          32,
          51,
          50,
          45,
          98,
          121,
          116,
          101,
          32,
          107
        ])
        var head = 144
        var top = head
        var free = []

        module.exports = XSalsa20

        XSalsa20.NONCEBYTES = 24
        XSalsa20.KEYBYTES = 32

        function XSalsa20(nonce, key) {
          if (!(this instanceof XSalsa20)) return new XSalsa20(nonce, key)
          if (!nonce || nonce.length < 24)
            throw new Error("nonce must be at least 24 bytes")
          if (!key || key.length < 32)
            throw new Error("key must be at least 32 bytes")
          this._xor =
            xsalsa20 && xsalsa20.exports
              ? new WASM(nonce, key)
              : new Fallback(nonce, key)
        }

        XSalsa20.prototype.update = function(input, output) {
          if (!input) throw new Error("input must be Uint8Array or Buffer")
          if (!output) output = new Uint8Array(input.length)
          if (input.length) this._xor.update(input, output)
          return output
        }

        XSalsa20.prototype.final = XSalsa20.prototype.finalize = function() {
          this._xor.finalize()
          this._xor = null
        }

        function WASM(nonce, key) {
          if (!free.length) {
            free.push(head)
            head += 64
          }

          this._pointer = free.pop()
          this._nonce = this._pointer + 8
          this._key = this._nonce + 24
          this._overflow = 0

          xsalsa20.memory.fill(0, this._pointer, this._pointer + 8)
          xsalsa20.memory.set(nonce, this._nonce)
          xsalsa20.memory.set(key, this._key)
        }

        WASM.prototype.update = function(input, output) {
          var len = this._overflow + input.length
          var start = head + this._overflow

          top = head + len
          if (top >= xsalsa20.memory.length) xsalsa20.realloc(top)

          xsalsa20.memory.set(input, start)
          xsalsa20.exports.xsalsa20_xor(
            this._pointer,
            head,
            head,
            len,
            this._nonce,
            this._key
          )
          output.set(xsalsa20.memory.subarray(start, head + len))

          this._overflow = len & 63
        }

        WASM.prototype.finalize = function() {
          xsalsa20.memory.fill(0, this._pointer, this._key + 32)
          if (top > head) {
            xsalsa20.memory.fill(0, head, top)
            top = 0
          }
          free.push(this._pointer)
        }

        function Fallback(nonce, key) {
          this._s = new Uint8Array(32)
          this._z = new Uint8Array(16)
          this._overflow = 0
          core_hsalsa20(this._s, nonce, key, SIGMA)
          for (var i = 0; i < 8; i++) this._z[i] = nonce[i + 16]
        }

        Fallback.prototype.update = function(input, output) {
          var x = new Uint8Array(64)
          var u = 0
          var i = this._overflow
          var b = input.length + this._overflow
          var z = this._z
          var mpos = -this._overflow
          var cpos = -this._overflow

          while (b >= 64) {
            core_salsa20(x, z, this._s, SIGMA)
            for (; i < 64; i++) output[cpos + i] = input[mpos + i] ^ x[i]
            u = 1
            for (i = 8; i < 16; i++) {
              u += (z[i] & 0xff) | 0
              z[i] = u & 0xff
              u >>>= 8
            }
            b -= 64
            cpos += 64
            mpos += 64
            i = 0
          }
          if (b > 0) {
            core_salsa20(x, z, this._s, SIGMA)
            for (; i < b; i++) output[cpos + i] = input[mpos + i] ^ x[i]
          }

          this._overflow = b & 63
        }

        Fallback.prototype.finalize = function() {
          this._s.fill(0)
          this._z.fill(0)
        }

        // below methods are ported from tweet nacl

        function core_salsa20(o, p, k, c) {
          var j0 =
              (c[0] & 0xff) |
              ((c[1] & 0xff) << 8) |
              ((c[2] & 0xff) << 16) |
              ((c[3] & 0xff) << 24),
            j1 =
              (k[0] & 0xff) |
              ((k[1] & 0xff) << 8) |
              ((k[2] & 0xff) << 16) |
              ((k[3] & 0xff) << 24),
            j2 =
              (k[4] & 0xff) |
              ((k[5] & 0xff) << 8) |
              ((k[6] & 0xff) << 16) |
              ((k[7] & 0xff) << 24),
            j3 =
              (k[8] & 0xff) |
              ((k[9] & 0xff) << 8) |
              ((k[10] & 0xff) << 16) |
              ((k[11] & 0xff) << 24),
            j4 =
              (k[12] & 0xff) |
              ((k[13] & 0xff) << 8) |
              ((k[14] & 0xff) << 16) |
              ((k[15] & 0xff) << 24),
            j5 =
              (c[4] & 0xff) |
              ((c[5] & 0xff) << 8) |
              ((c[6] & 0xff) << 16) |
              ((c[7] & 0xff) << 24),
            j6 =
              (p[0] & 0xff) |
              ((p[1] & 0xff) << 8) |
              ((p[2] & 0xff) << 16) |
              ((p[3] & 0xff) << 24),
            j7 =
              (p[4] & 0xff) |
              ((p[5] & 0xff) << 8) |
              ((p[6] & 0xff) << 16) |
              ((p[7] & 0xff) << 24),
            j8 =
              (p[8] & 0xff) |
              ((p[9] & 0xff) << 8) |
              ((p[10] & 0xff) << 16) |
              ((p[11] & 0xff) << 24),
            j9 =
              (p[12] & 0xff) |
              ((p[13] & 0xff) << 8) |
              ((p[14] & 0xff) << 16) |
              ((p[15] & 0xff) << 24),
            j10 =
              (c[8] & 0xff) |
              ((c[9] & 0xff) << 8) |
              ((c[10] & 0xff) << 16) |
              ((c[11] & 0xff) << 24),
            j11 =
              (k[16] & 0xff) |
              ((k[17] & 0xff) << 8) |
              ((k[18] & 0xff) << 16) |
              ((k[19] & 0xff) << 24),
            j12 =
              (k[20] & 0xff) |
              ((k[21] & 0xff) << 8) |
              ((k[22] & 0xff) << 16) |
              ((k[23] & 0xff) << 24),
            j13 =
              (k[24] & 0xff) |
              ((k[25] & 0xff) << 8) |
              ((k[26] & 0xff) << 16) |
              ((k[27] & 0xff) << 24),
            j14 =
              (k[28] & 0xff) |
              ((k[29] & 0xff) << 8) |
              ((k[30] & 0xff) << 16) |
              ((k[31] & 0xff) << 24),
            j15 =
              (c[12] & 0xff) |
              ((c[13] & 0xff) << 8) |
              ((c[14] & 0xff) << 16) |
              ((c[15] & 0xff) << 24)

          var x0 = j0,
            x1 = j1,
            x2 = j2,
            x3 = j3,
            x4 = j4,
            x5 = j5,
            x6 = j6,
            x7 = j7,
            x8 = j8,
            x9 = j9,
            x10 = j10,
            x11 = j11,
            x12 = j12,
            x13 = j13,
            x14 = j14,
            x15 = j15,
            u

          for (var i = 0; i < 20; i += 2) {
            u = (x0 + x12) | 0
            x4 ^= (u << 7) | (u >>> 25)
            u = (x4 + x0) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x4) | 0
            x12 ^= (u << 13) | (u >>> 19)
            u = (x12 + x8) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x1) | 0
            x9 ^= (u << 7) | (u >>> 25)
            u = (x9 + x5) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x9) | 0
            x1 ^= (u << 13) | (u >>> 19)
            u = (x1 + x13) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x6) | 0
            x14 ^= (u << 7) | (u >>> 25)
            u = (x14 + x10) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x14) | 0
            x6 ^= (u << 13) | (u >>> 19)
            u = (x6 + x2) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x11) | 0
            x3 ^= (u << 7) | (u >>> 25)
            u = (x3 + x15) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x3) | 0
            x11 ^= (u << 13) | (u >>> 19)
            u = (x11 + x7) | 0
            x15 ^= (u << 18) | (u >>> 14)

            u = (x0 + x3) | 0
            x1 ^= (u << 7) | (u >>> 25)
            u = (x1 + x0) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x1) | 0
            x3 ^= (u << 13) | (u >>> 19)
            u = (x3 + x2) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x4) | 0
            x6 ^= (u << 7) | (u >>> 25)
            u = (x6 + x5) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x6) | 0
            x4 ^= (u << 13) | (u >>> 19)
            u = (x4 + x7) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x9) | 0
            x11 ^= (u << 7) | (u >>> 25)
            u = (x11 + x10) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x11) | 0
            x9 ^= (u << 13) | (u >>> 19)
            u = (x9 + x8) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x14) | 0
            x12 ^= (u << 7) | (u >>> 25)
            u = (x12 + x15) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x12) | 0
            x14 ^= (u << 13) | (u >>> 19)
            u = (x14 + x13) | 0
            x15 ^= (u << 18) | (u >>> 14)
          }
          x0 = (x0 + j0) | 0
          x1 = (x1 + j1) | 0
          x2 = (x2 + j2) | 0
          x3 = (x3 + j3) | 0
          x4 = (x4 + j4) | 0
          x5 = (x5 + j5) | 0
          x6 = (x6 + j6) | 0
          x7 = (x7 + j7) | 0
          x8 = (x8 + j8) | 0
          x9 = (x9 + j9) | 0
          x10 = (x10 + j10) | 0
          x11 = (x11 + j11) | 0
          x12 = (x12 + j12) | 0
          x13 = (x13 + j13) | 0
          x14 = (x14 + j14) | 0
          x15 = (x15 + j15) | 0

          o[0] = (x0 >>> 0) & 0xff
          o[1] = (x0 >>> 8) & 0xff
          o[2] = (x0 >>> 16) & 0xff
          o[3] = (x0 >>> 24) & 0xff

          o[4] = (x1 >>> 0) & 0xff
          o[5] = (x1 >>> 8) & 0xff
          o[6] = (x1 >>> 16) & 0xff
          o[7] = (x1 >>> 24) & 0xff

          o[8] = (x2 >>> 0) & 0xff
          o[9] = (x2 >>> 8) & 0xff
          o[10] = (x2 >>> 16) & 0xff
          o[11] = (x2 >>> 24) & 0xff

          o[12] = (x3 >>> 0) & 0xff
          o[13] = (x3 >>> 8) & 0xff
          o[14] = (x3 >>> 16) & 0xff
          o[15] = (x3 >>> 24) & 0xff

          o[16] = (x4 >>> 0) & 0xff
          o[17] = (x4 >>> 8) & 0xff
          o[18] = (x4 >>> 16) & 0xff
          o[19] = (x4 >>> 24) & 0xff

          o[20] = (x5 >>> 0) & 0xff
          o[21] = (x5 >>> 8) & 0xff
          o[22] = (x5 >>> 16) & 0xff
          o[23] = (x5 >>> 24) & 0xff

          o[24] = (x6 >>> 0) & 0xff
          o[25] = (x6 >>> 8) & 0xff
          o[26] = (x6 >>> 16) & 0xff
          o[27] = (x6 >>> 24) & 0xff

          o[28] = (x7 >>> 0) & 0xff
          o[29] = (x7 >>> 8) & 0xff
          o[30] = (x7 >>> 16) & 0xff
          o[31] = (x7 >>> 24) & 0xff

          o[32] = (x8 >>> 0) & 0xff
          o[33] = (x8 >>> 8) & 0xff
          o[34] = (x8 >>> 16) & 0xff
          o[35] = (x8 >>> 24) & 0xff

          o[36] = (x9 >>> 0) & 0xff
          o[37] = (x9 >>> 8) & 0xff
          o[38] = (x9 >>> 16) & 0xff
          o[39] = (x9 >>> 24) & 0xff

          o[40] = (x10 >>> 0) & 0xff
          o[41] = (x10 >>> 8) & 0xff
          o[42] = (x10 >>> 16) & 0xff
          o[43] = (x10 >>> 24) & 0xff

          o[44] = (x11 >>> 0) & 0xff
          o[45] = (x11 >>> 8) & 0xff
          o[46] = (x11 >>> 16) & 0xff
          o[47] = (x11 >>> 24) & 0xff

          o[48] = (x12 >>> 0) & 0xff
          o[49] = (x12 >>> 8) & 0xff
          o[50] = (x12 >>> 16) & 0xff
          o[51] = (x12 >>> 24) & 0xff

          o[52] = (x13 >>> 0) & 0xff
          o[53] = (x13 >>> 8) & 0xff
          o[54] = (x13 >>> 16) & 0xff
          o[55] = (x13 >>> 24) & 0xff

          o[56] = (x14 >>> 0) & 0xff
          o[57] = (x14 >>> 8) & 0xff
          o[58] = (x14 >>> 16) & 0xff
          o[59] = (x14 >>> 24) & 0xff

          o[60] = (x15 >>> 0) & 0xff
          o[61] = (x15 >>> 8) & 0xff
          o[62] = (x15 >>> 16) & 0xff
          o[63] = (x15 >>> 24) & 0xff
        }

        function core_hsalsa20(o, p, k, c) {
          var j0 =
              (c[0] & 0xff) |
              ((c[1] & 0xff) << 8) |
              ((c[2] & 0xff) << 16) |
              ((c[3] & 0xff) << 24),
            j1 =
              (k[0] & 0xff) |
              ((k[1] & 0xff) << 8) |
              ((k[2] & 0xff) << 16) |
              ((k[3] & 0xff) << 24),
            j2 =
              (k[4] & 0xff) |
              ((k[5] & 0xff) << 8) |
              ((k[6] & 0xff) << 16) |
              ((k[7] & 0xff) << 24),
            j3 =
              (k[8] & 0xff) |
              ((k[9] & 0xff) << 8) |
              ((k[10] & 0xff) << 16) |
              ((k[11] & 0xff) << 24),
            j4 =
              (k[12] & 0xff) |
              ((k[13] & 0xff) << 8) |
              ((k[14] & 0xff) << 16) |
              ((k[15] & 0xff) << 24),
            j5 =
              (c[4] & 0xff) |
              ((c[5] & 0xff) << 8) |
              ((c[6] & 0xff) << 16) |
              ((c[7] & 0xff) << 24),
            j6 =
              (p[0] & 0xff) |
              ((p[1] & 0xff) << 8) |
              ((p[2] & 0xff) << 16) |
              ((p[3] & 0xff) << 24),
            j7 =
              (p[4] & 0xff) |
              ((p[5] & 0xff) << 8) |
              ((p[6] & 0xff) << 16) |
              ((p[7] & 0xff) << 24),
            j8 =
              (p[8] & 0xff) |
              ((p[9] & 0xff) << 8) |
              ((p[10] & 0xff) << 16) |
              ((p[11] & 0xff) << 24),
            j9 =
              (p[12] & 0xff) |
              ((p[13] & 0xff) << 8) |
              ((p[14] & 0xff) << 16) |
              ((p[15] & 0xff) << 24),
            j10 =
              (c[8] & 0xff) |
              ((c[9] & 0xff) << 8) |
              ((c[10] & 0xff) << 16) |
              ((c[11] & 0xff) << 24),
            j11 =
              (k[16] & 0xff) |
              ((k[17] & 0xff) << 8) |
              ((k[18] & 0xff) << 16) |
              ((k[19] & 0xff) << 24),
            j12 =
              (k[20] & 0xff) |
              ((k[21] & 0xff) << 8) |
              ((k[22] & 0xff) << 16) |
              ((k[23] & 0xff) << 24),
            j13 =
              (k[24] & 0xff) |
              ((k[25] & 0xff) << 8) |
              ((k[26] & 0xff) << 16) |
              ((k[27] & 0xff) << 24),
            j14 =
              (k[28] & 0xff) |
              ((k[29] & 0xff) << 8) |
              ((k[30] & 0xff) << 16) |
              ((k[31] & 0xff) << 24),
            j15 =
              (c[12] & 0xff) |
              ((c[13] & 0xff) << 8) |
              ((c[14] & 0xff) << 16) |
              ((c[15] & 0xff) << 24)

          var x0 = j0,
            x1 = j1,
            x2 = j2,
            x3 = j3,
            x4 = j4,
            x5 = j5,
            x6 = j6,
            x7 = j7,
            x8 = j8,
            x9 = j9,
            x10 = j10,
            x11 = j11,
            x12 = j12,
            x13 = j13,
            x14 = j14,
            x15 = j15,
            u

          for (var i = 0; i < 20; i += 2) {
            u = (x0 + x12) | 0
            x4 ^= (u << 7) | (u >>> 25)
            u = (x4 + x0) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x4) | 0
            x12 ^= (u << 13) | (u >>> 19)
            u = (x12 + x8) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x1) | 0
            x9 ^= (u << 7) | (u >>> 25)
            u = (x9 + x5) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x9) | 0
            x1 ^= (u << 13) | (u >>> 19)
            u = (x1 + x13) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x6) | 0
            x14 ^= (u << 7) | (u >>> 25)
            u = (x14 + x10) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x14) | 0
            x6 ^= (u << 13) | (u >>> 19)
            u = (x6 + x2) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x11) | 0
            x3 ^= (u << 7) | (u >>> 25)
            u = (x3 + x15) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x3) | 0
            x11 ^= (u << 13) | (u >>> 19)
            u = (x11 + x7) | 0
            x15 ^= (u << 18) | (u >>> 14)

            u = (x0 + x3) | 0
            x1 ^= (u << 7) | (u >>> 25)
            u = (x1 + x0) | 0
            x2 ^= (u << 9) | (u >>> 23)
            u = (x2 + x1) | 0
            x3 ^= (u << 13) | (u >>> 19)
            u = (x3 + x2) | 0
            x0 ^= (u << 18) | (u >>> 14)

            u = (x5 + x4) | 0
            x6 ^= (u << 7) | (u >>> 25)
            u = (x6 + x5) | 0
            x7 ^= (u << 9) | (u >>> 23)
            u = (x7 + x6) | 0
            x4 ^= (u << 13) | (u >>> 19)
            u = (x4 + x7) | 0
            x5 ^= (u << 18) | (u >>> 14)

            u = (x10 + x9) | 0
            x11 ^= (u << 7) | (u >>> 25)
            u = (x11 + x10) | 0
            x8 ^= (u << 9) | (u >>> 23)
            u = (x8 + x11) | 0
            x9 ^= (u << 13) | (u >>> 19)
            u = (x9 + x8) | 0
            x10 ^= (u << 18) | (u >>> 14)

            u = (x15 + x14) | 0
            x12 ^= (u << 7) | (u >>> 25)
            u = (x12 + x15) | 0
            x13 ^= (u << 9) | (u >>> 23)
            u = (x13 + x12) | 0
            x14 ^= (u << 13) | (u >>> 19)
            u = (x14 + x13) | 0
            x15 ^= (u << 18) | (u >>> 14)
          }

          o[0] = (x0 >>> 0) & 0xff
          o[1] = (x0 >>> 8) & 0xff
          o[2] = (x0 >>> 16) & 0xff
          o[3] = (x0 >>> 24) & 0xff

          o[4] = (x5 >>> 0) & 0xff
          o[5] = (x5 >>> 8) & 0xff
          o[6] = (x5 >>> 16) & 0xff
          o[7] = (x5 >>> 24) & 0xff

          o[8] = (x10 >>> 0) & 0xff
          o[9] = (x10 >>> 8) & 0xff
          o[10] = (x10 >>> 16) & 0xff
          o[11] = (x10 >>> 24) & 0xff

          o[12] = (x15 >>> 0) & 0xff
          o[13] = (x15 >>> 8) & 0xff
          o[14] = (x15 >>> 16) & 0xff
          o[15] = (x15 >>> 24) & 0xff

          o[16] = (x6 >>> 0) & 0xff
          o[17] = (x6 >>> 8) & 0xff
          o[18] = (x6 >>> 16) & 0xff
          o[19] = (x6 >>> 24) & 0xff

          o[20] = (x7 >>> 0) & 0xff
          o[21] = (x7 >>> 8) & 0xff
          o[22] = (x7 >>> 16) & 0xff
          o[23] = (x7 >>> 24) & 0xff

          o[24] = (x8 >>> 0) & 0xff
          o[25] = (x8 >>> 8) & 0xff
          o[26] = (x8 >>> 16) & 0xff
          o[27] = (x8 >>> 24) & 0xff

          o[28] = (x9 >>> 0) & 0xff
          o[29] = (x9 >>> 8) & 0xff
          o[30] = (x9 >>> 16) & 0xff
          o[31] = (x9 >>> 24) & 0xff
        }
      },
      { "./xsalsa20": 85 }
    ],
    85: [
      function(require, module, exports) {
        module.exports = loadWebAssembly

        loadWebAssembly.supported = typeof WebAssembly !== "undefined"

        function loadWebAssembly(opts) {
          if (!loadWebAssembly.supported) return null

          var imp = opts && opts.imports
          var wasm = toUint8Array(
            "AGFzbQEAAAABGgNgBn9/f39/fwBgBn9/f39+fwF+YAN/f38AAwcGAAEBAgICBQUBAQroBwcoAwZtZW1vcnkCAAx4c2Fsc2EyMF94b3IAAAxjb3JlX3NhbHNhMjAABArqEQYYACAAIAEgAiADIAQgACkDACAFEAE3AwALPQBB8AAgAyAFEAMgACABIAIgA0EQaiAEQfAAEAJB8ABCADcDAEH4AEIANwMAQYABQgA3AwBBiAFCADcDAAuHBQEBfyACQQBGBEBCAA8LQdAAIAUpAwA3AwBB2AAgBUEIaikDADcDAEHgACAFQRBqKQMANwMAQegAIAVBGGopAwA3AwBBACADKQMANwMAQQggBDcDAAJAA0AgAkHAAEkNAUEQQQBB0AAQBSAAIAEpAwBBECkDAIU3AwAgAEEIaiABQQhqKQMAQRgpAwCFNwMAIABBEGogAUEQaikDAEEgKQMAhTcDACAAQRhqIAFBGGopAwBBKCkDAIU3AwAgAEEgaiABQSBqKQMAQTApAwCFNwMAIABBKGogAUEoaikDAEE4KQMAhTcDACAAQTBqIAFBMGopAwBBwAApAwCFNwMAIABBOGogAUE4aikDAEHIACkDAIU3AwBBCEEIKQMAQgF8NwMAIABBwABqIQAgAUHAAGohASACQcAAayECDAALC0EIKQMAIQQgAkEASwRAQRBBAEHQABAFAkACQAJAAkACQAJAAkACQCACQQhuDgcHBgUEAwIBAAsgAEE4aiABQThqKQMAQcgAKQMAhTcDAAsgAEEwaiABQTBqKQMAQcAAKQMAhTcDAAsgAEEoaiABQShqKQMAQTgpAwCFNwMACyAAQSBqIAFBIGopAwBBMCkDAIU3AwALIABBGGogAUEYaikDAEEoKQMAhTcDAAsgAEEQaiABQRBqKQMAQSApAwCFNwMACyAAQQhqIAFBCGopAwBBGCkDAIU3AwALIAAgASkDAEEQKQMAhTcDAAtBEEIANwMAQRhCADcDAEEgQgA3AwBBKEIANwMAQTBCADcDAEE4QgA3AwBBwABCADcDAEHIAEIANwMAQdAAQgA3AwBB2ABCADcDAEHgAEIANwMAQegAQgA3AwAgBA8LnQUBEX9B5fDBiwYhA0HuyIGZAyEIQbLaiMsHIQ1B9MqB2QYhEiACKAIAIQQgAkEEaigCACEFIAJBCGooAgAhBiACQQxqKAIAIQcgAkEQaigCACEOIAJBFGooAgAhDyACQRhqKAIAIRAgAkEcaigCACERIAEoAgAhCSABQQRqKAIAIQogAUEIaigCACELIAFBDGooAgAhDEEUIRMCQANAIBNBAEYNASAHIAMgD2pBB3dzIQcgCyAHIANqQQl3cyELIA8gCyAHakENd3MhDyADIA8gC2pBEndzIQMgDCAIIARqQQd3cyEMIBAgDCAIakEJd3MhECAEIBAgDGpBDXdzIQQgCCAEIBBqQRJ3cyEIIBEgDSAJakEHd3MhESAFIBEgDWpBCXdzIQUgCSAFIBFqQQ13cyEJIA0gCSAFakESd3MhDSAGIBIgDmpBB3dzIQYgCiAGIBJqQQl3cyEKIA4gCiAGakENd3MhDiASIA4gCmpBEndzIRIgBCADIAZqQQd3cyEEIAUgBCADakEJd3MhBSAGIAUgBGpBDXdzIQYgAyAGIAVqQRJ3cyEDIAkgCCAHakEHd3MhCSAKIAkgCGpBCXdzIQogByAKIAlqQQ13cyEHIAggByAKakESd3MhCCAOIA0gDGpBB3dzIQ4gCyAOIA1qQQl3cyELIAwgCyAOakENd3MhDCANIAwgC2pBEndzIQ0gDyASIBFqQQd3cyEPIBAgDyASakEJd3MhECARIBAgD2pBDXdzIREgEiARIBBqQRJ3cyESIBNBAmshEwwACwsgACADNgIAIABBBGogCDYCACAAQQhqIA02AgAgAEEMaiASNgIAIABBEGogCTYCACAAQRRqIAo2AgAgAEEYaiALNgIAIABBHGogDDYCAAsKACAAIAEgAhAFC90GASF/QeXwwYsGIQNB7siBmQMhCEGy2ojLByENQfTKgdkGIRIgAigCACEEIAJBBGooAgAhBSACQQhqKAIAIQYgAkEMaigCACEHIAJBEGooAgAhDiACQRRqKAIAIQ8gAkEYaigCACEQIAJBHGooAgAhESABKAIAIQkgAUEEaigCACEKIAFBCGooAgAhCyABQQxqKAIAIQwgAyETIAQhFCAFIRUgBiEWIAchFyAIIRggCSEZIAohGiALIRsgDCEcIA0hHSAOIR4gDyEfIBAhICARISEgEiEiQRQhIwJAA0AgI0EARg0BIAcgAyAPakEHd3MhByALIAcgA2pBCXdzIQsgDyALIAdqQQ13cyEPIAMgDyALakESd3MhAyAMIAggBGpBB3dzIQwgECAMIAhqQQl3cyEQIAQgECAMakENd3MhBCAIIAQgEGpBEndzIQggESANIAlqQQd3cyERIAUgESANakEJd3MhBSAJIAUgEWpBDXdzIQkgDSAJIAVqQRJ3cyENIAYgEiAOakEHd3MhBiAKIAYgEmpBCXdzIQogDiAKIAZqQQ13cyEOIBIgDiAKakESd3MhEiAEIAMgBmpBB3dzIQQgBSAEIANqQQl3cyEFIAYgBSAEakENd3MhBiADIAYgBWpBEndzIQMgCSAIIAdqQQd3cyEJIAogCSAIakEJd3MhCiAHIAogCWpBDXdzIQcgCCAHIApqQRJ3cyEIIA4gDSAMakEHd3MhDiALIA4gDWpBCXdzIQsgDCALIA5qQQ13cyEMIA0gDCALakESd3MhDSAPIBIgEWpBB3dzIQ8gECAPIBJqQQl3cyEQIBEgECAPakENd3MhESASIBEgEGpBEndzIRIgI0ECayEjDAALCyAAIAMgE2o2AgAgAEEEaiAEIBRqNgIAIABBCGogBSAVajYCACAAQQxqIAYgFmo2AgAgAEEQaiAHIBdqNgIAIABBFGogCCAYajYCACAAQRhqIAkgGWo2AgAgAEEcaiAKIBpqNgIAIABBIGogCyAbajYCACAAQSRqIAwgHGo2AgAgAEEoaiANIB1qNgIAIABBLGogDiAeajYCACAAQTBqIA8gH2o2AgAgAEE0aiAQICBqNgIAIABBOGogESAhajYCACAAQTxqIBIgImo2AgAL"
          )
          var ready = null

          var mod = {
            buffer: wasm,
            memory: null,
            exports: null,
            realloc: realloc,
            onload: onload
          }

          onload(function() {})

          return mod

          function realloc(size) {
            mod.exports.memory.grow(
              Math.ceil(Math.abs(size - mod.memory.length) / 65536)
            )
            mod.memory = new Uint8Array(mod.exports.memory.buffer)
          }

          function onload(cb) {
            if (mod.exports) return cb()

            if (ready) {
              ready.then(cb.bind(null, null)).catch(cb)
              return
            }

            try {
              if (opts && opts.async) throw new Error("async")
              setup({
                instance: new WebAssembly.Instance(
                  new WebAssembly.Module(wasm),
                  imp
                )
              })
            } catch (err) {
              ready = WebAssembly.instantiate(wasm, imp).then(setup)
            }

            onload(cb)
          }

          function setup(w) {
            mod.exports = w.instance.exports
            mod.memory =
              mod.exports.memory &&
              mod.exports.memory.buffer &&
              new Uint8Array(mod.exports.memory.buffer)
          }
        }

        function toUint8Array(s) {
          if (typeof atob === "function")
            return new Uint8Array(
              atob(s)
                .split("")
                .map(charCodeAt)
            )
          return new (require("buf" + "fer")).Buffer(s, "base64")
        }

        function charCodeAt(c) {
          return c.charCodeAt(0)
        }
      },
      {}
    ],
    86: [
      function(require, module, exports) {
        "use strict"

        var hypercore = require("hypercore")
        var RandomAccessFile = require("./random-access-file")

        const main = async () => {
          const volume = await RandomAccessFile.mount()
          var feed = hypercore(volume, { valueEncoding: "json" })

          feed.append({
            hello: "world"
          })

          feed.append({
            hej: "verden"
          })

          feed.append({
            hola: "mundo"
          })

          feed.flush(function() {
            console.log(
              "Appended 3 more blocks, %d in total (%d bytes)\n",
              feed.length,
              feed.byteLength
            )

            feed
              .createReadStream()
              .on("data", console.log.bind(console))
              .on("end", console.log.bind(console, "\n(end)"))
          })
        }

        main()
      },
      { "./random-access-file": 87, hypercore: 30 }
    ],
    87: [
      function(require, module, exports) {
        "use strict"

        const RandomAccess = require("random-access-storage")
        const { Buffer } = require("Buffer")

        const MAX_SIZE = (1 << 30) * 2 - (1 << 12) - 1

        class RandomAccessFile extends RandomAccess {
          constructor(volume, name, options = {}) {
            super()
            this.name = name
            this.options = options
            this.volume = volume
            this.url = `${volume.url}${name}`
            this.file = null
          }
          static async mount(url = null) {
            const volume = await browser.FileSystem.mount({
              url: url,
              read: true,
              write: true
            })

            return (name, options) =>
              new RandomAccessFile(volume, name, options)
          }
          static async open(self, mode) {
            self.file = await browser.FileSystem.open(self.url, {
              read: true,
              write: true
            })

            console.log("opened", self)
            return self
          }
          static async delete(self, position, size) {
            const stat = await browser.File.stat(self.file)
            if (position + size < stat.size) {
              return null
            } else {
              const data =
                position > 0
                  ? await browser.File.read(file, {
                      position: 0,
                      size: position
                    })
                  : null

              self.file = await browser.FileSystem.open(self.fileURL, {
                truncate: true,
                read: true,
                write: true
              })

              if (data) {
                await browser.File.write(self.file, data, { position: 0 })
              }
            }
          }
          _open(request) {
            console.log("_open", request, this)
            RandomAccessFile.open(this, { read: true, write: true })
              .then(self => request.callback(null, self))
              .catch(error => request.callback(error))
          }
          // _openReadonly(request) {
          //   console.log("_openReadonly", request)
          //   RandomAccessFile.open(this, { read: true })
          //     .then(self => request.callback(null, self))
          //     .catch(error => request.callback(error))
          // }
          _write(request) {
            console.log("_write", request, this.file, this.url)
            const { offset, size, data } = request
            browser.File.write(this.file, data.buffer, {
              position: offset,
              size
            })
              .then(() => request.callback(null))
              .catch(error => request.callback)
          }
          static async read(file, buffer, position, size) {
            const content = await browser.File.read(file, {
              position: position,
              size: MAX_SIZE < size ? undefined : size
            })
            Buffer.from(content).copy(buffer)
            return buffer

            // if (data.byteLength < options.size) {
            //   const result = new Uint8Array(options.size)
            //   result.set(data)
            //   return result
            // } else {
            //   return data
            // }
          }
          _read(request) {
            console.log("_read", request)
            const { offset, size } = request
            const buffer = request.data || Buffer.allocUnsafe(size)
            RandomAccessFile.read(this.file, buffer, offset, size)
              .then(data => request.callback(null, data))
              .catch(error => request.callback(error))
          }
          _del(request) {
            console.log("_del", request)
            RandomAccessFile.delete(this, request.offset, request.size)
              .then(() => request.callback(null))
              .catch(error => request.callback(null))
          }
          _stat(request) {
            console.log("_stat", request)
            browser.File.stat(this.file)
              .then(stat => request.callback(null, stat))
              .catch(error => request.callback(error))
          }
          _close(request) {
            console.log("_close", request)
            browser.File.close(this.file)
              .then(() => request.callback((this.file = null)))
              .catch(error => request.callback(error))
          }
          _destroy(request) {
            console.log("_destroy", request)
            browser.FileSystem.removeFile(this.fileURL, { ignoreAbsent: true })
              .then(() => request.callback(null))
              .catch(error => request.callback(error))
          }
        }

        module.exports = RandomAccessFile
      },
      { Buffer: 1, "random-access-storage": 47 }
    ]
  },
  {},
  [86]
)
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LWxydS9jcmMxNi5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1scnUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXRvbWljLWJhdGNoZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkLXJsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXRmaWVsZC1ybGUvbm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvYml0ZmllbGQtcmxlL25vZGVfbW9kdWxlcy92YXJpbnQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkLXJsZS9ub2RlX21vZHVsZXMvdmFyaW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkLXJsZS9ub2RlX21vZHVsZXMvdmFyaW50L2xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9ibGFrZTJiLXdhc20vYmxha2UyYi5qcyIsIm5vZGVfbW9kdWxlcy9ibGFrZTJiLXdhc20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmxha2UyYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLWFsbG9jLXVuc2FmZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItYWxsb2MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLWVxdWFscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItZmlsbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXItZnJvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWxrLXdyaXRlLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2RlY3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmxhdC10cmVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zyb20yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS1wcm90b2NvbC9mZWVkLmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS1wcm90b2NvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcmNvcmUtcHJvdG9jb2wvbWVzc2FnZXMuanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS9saWIvYml0ZmllbGQuanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2xpYi9jcnlwdG8uanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2xpYi9yZXBsaWNhdGUuanMiLCJub2RlX21vZHVsZXMvaHlwZXJjb3JlL2xpYi9zdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyY29yZS9saWIvdHJlZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xhc3Qtb25lLXdpbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVtb3J5LXBhZ2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lcmtsZS10cmVlLXN0cmVhbS9nZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvbmFub2Fzc2VydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9jb2wtYnVmZmVycy1lbmNvZGluZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZG9tLWFjY2Vzcy1maWxlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFuZG9tLWFjY2Vzcy1zdG9yYWdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmVkLXZhcmludC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaXBoYXNoMjQvZmFsbGJhY2suanMiLCJub2RlX21vZHVsZXMvc2lwaGFzaDI0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpcGhhc2gyNC9zaXBoYXNoMjQuanMiLCJub2RlX21vZHVsZXMvc29kaXVtLWphdmFzY3JpcHQvY3J5cHRvX2dlbmVyaWNoYXNoLmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS1qYXZhc2NyaXB0L2NyeXB0b19rZGYuanMiLCJub2RlX21vZHVsZXMvc29kaXVtLWphdmFzY3JpcHQvY3J5cHRvX3Nob3J0aGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9zb2RpdW0tamF2YXNjcmlwdC9jcnlwdG9fc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS1qYXZhc2NyaXB0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS1qYXZhc2NyaXB0L3JhbmRvbWJ5dGVzLmpzIiwibm9kZV9tb2R1bGVzL3NvZGl1bS11bml2ZXJzYWwvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zb3J0ZWQtaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zcGFyc2UtYml0ZmllbGQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3RodW5reS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3VpbnQ2NGJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Vub3JkZXJlZC1hcnJheS1yZW1vdmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdW5vcmRlcmVkLXNldC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMveHNhbHNhMjAvaW5kZXguanMiLCJub2RlX21vZHVsZXMveHNhbHNhMjAveHNhbHNhMjAuanMiLCJzcmMvaHlwZXIuanMiLCJzcmMvcmFuZG9tLWFjY2Vzcy1maWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelRBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDempDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5UkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzd0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4Q0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHwgKHZhbHVlICYmIGlzQXJyYXlCdWZmZXIodmFsdWUuYnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhidWYpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzQXJyYXlCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogbmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlcnMgZnJvbSBhbm90aGVyIGNvbnRleHQgKGkuZS4gYW4gaWZyYW1lKSBkbyBub3QgcGFzcyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrXG4vLyBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gICAgICB0eXBlb2Ygb2JqLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKVxufVxuXG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gY3JjMTYgaW1wbCwgb3B0aW1pemVkIGZvciBudW1lcmljIGlucHV0c1xuXG52YXIgVEFCTEUgPSBbXG4gIDB4MDAwMCwgMHgxMDIxLCAweDIwNDIsIDB4MzA2MywgMHg0MDg0LCAweDUwYTUsIDB4NjBjNiwgMHg3MGU3LFxuICAweDgxMDgsIDB4OTEyOSwgMHhhMTRhLCAweGIxNmIsIDB4YzE4YywgMHhkMWFkLCAweGUxY2UsIDB4ZjFlZixcbiAgMHgxMjMxLCAweDAyMTAsIDB4MzI3MywgMHgyMjUyLCAweDUyYjUsIDB4NDI5NCwgMHg3MmY3LCAweDYyZDYsXG4gIDB4OTMzOSwgMHg4MzE4LCAweGIzN2IsIDB4YTM1YSwgMHhkM2JkLCAweGMzOWMsIDB4ZjNmZiwgMHhlM2RlLFxuICAweDI0NjIsIDB4MzQ0MywgMHgwNDIwLCAweDE0MDEsIDB4NjRlNiwgMHg3NGM3LCAweDQ0YTQsIDB4NTQ4NSxcbiAgMHhhNTZhLCAweGI1NGIsIDB4ODUyOCwgMHg5NTA5LCAweGU1ZWUsIDB4ZjVjZiwgMHhjNWFjLCAweGQ1OGQsXG4gIDB4MzY1MywgMHgyNjcyLCAweDE2MTEsIDB4MDYzMCwgMHg3NmQ3LCAweDY2ZjYsIDB4NTY5NSwgMHg0NmI0LFxuICAweGI3NWIsIDB4YTc3YSwgMHg5NzE5LCAweDg3MzgsIDB4ZjdkZiwgMHhlN2ZlLCAweGQ3OWQsIDB4YzdiYyxcbiAgMHg0OGM0LCAweDU4ZTUsIDB4Njg4NiwgMHg3OGE3LCAweDA4NDAsIDB4MTg2MSwgMHgyODAyLCAweDM4MjMsXG4gIDB4YzljYywgMHhkOWVkLCAweGU5OGUsIDB4ZjlhZiwgMHg4OTQ4LCAweDk5NjksIDB4YTkwYSwgMHhiOTJiLFxuICAweDVhZjUsIDB4NGFkNCwgMHg3YWI3LCAweDZhOTYsIDB4MWE3MSwgMHgwYTUwLCAweDNhMzMsIDB4MmExMixcbiAgMHhkYmZkLCAweGNiZGMsIDB4ZmJiZiwgMHhlYjllLCAweDliNzksIDB4OGI1OCwgMHhiYjNiLCAweGFiMWEsXG4gIDB4NmNhNiwgMHg3Yzg3LCAweDRjZTQsIDB4NWNjNSwgMHgyYzIyLCAweDNjMDMsIDB4MGM2MCwgMHgxYzQxLFxuICAweGVkYWUsIDB4ZmQ4ZiwgMHhjZGVjLCAweGRkY2QsIDB4YWQyYSwgMHhiZDBiLCAweDhkNjgsIDB4OWQ0OSxcbiAgMHg3ZTk3LCAweDZlYjYsIDB4NWVkNSwgMHg0ZWY0LCAweDNlMTMsIDB4MmUzMiwgMHgxZTUxLCAweDBlNzAsXG4gIDB4ZmY5ZiwgMHhlZmJlLCAweGRmZGQsIDB4Y2ZmYywgMHhiZjFiLCAweGFmM2EsIDB4OWY1OSwgMHg4Zjc4LFxuICAweDkxODgsIDB4ODFhOSwgMHhiMWNhLCAweGExZWIsIDB4ZDEwYywgMHhjMTJkLCAweGYxNGUsIDB4ZTE2ZixcbiAgMHgxMDgwLCAweDAwYTEsIDB4MzBjMiwgMHgyMGUzLCAweDUwMDQsIDB4NDAyNSwgMHg3MDQ2LCAweDYwNjcsXG4gIDB4ODNiOSwgMHg5Mzk4LCAweGEzZmIsIDB4YjNkYSwgMHhjMzNkLCAweGQzMWMsIDB4ZTM3ZiwgMHhmMzVlLFxuICAweDAyYjEsIDB4MTI5MCwgMHgyMmYzLCAweDMyZDIsIDB4NDIzNSwgMHg1MjE0LCAweDYyNzcsIDB4NzI1NixcbiAgMHhiNWVhLCAweGE1Y2IsIDB4OTVhOCwgMHg4NTg5LCAweGY1NmUsIDB4ZTU0ZiwgMHhkNTJjLCAweGM1MGQsXG4gIDB4MzRlMiwgMHgyNGMzLCAweDE0YTAsIDB4MDQ4MSwgMHg3NDY2LCAweDY0NDcsIDB4NTQyNCwgMHg0NDA1LFxuICAweGE3ZGIsIDB4YjdmYSwgMHg4Nzk5LCAweDk3YjgsIDB4ZTc1ZiwgMHhmNzdlLCAweGM3MWQsIDB4ZDczYyxcbiAgMHgyNmQzLCAweDM2ZjIsIDB4MDY5MSwgMHgxNmIwLCAweDY2NTcsIDB4NzY3NiwgMHg0NjE1LCAweDU2MzQsXG4gIDB4ZDk0YywgMHhjOTZkLCAweGY5MGUsIDB4ZTkyZiwgMHg5OWM4LCAweDg5ZTksIDB4Yjk4YSwgMHhhOWFiLFxuICAweDU4NDQsIDB4NDg2NSwgMHg3ODA2LCAweDY4MjcsIDB4MThjMCwgMHgwOGUxLCAweDM4ODIsIDB4MjhhMyxcbiAgMHhjYjdkLCAweGRiNWMsIDB4ZWIzZiwgMHhmYjFlLCAweDhiZjksIDB4OWJkOCwgMHhhYmJiLCAweGJiOWEsXG4gIDB4NGE3NSwgMHg1YTU0LCAweDZhMzcsIDB4N2ExNiwgMHgwYWYxLCAweDFhZDAsIDB4MmFiMywgMHgzYTkyLFxuICAweGZkMmUsIDB4ZWQwZiwgMHhkZDZjLCAweGNkNGQsIDB4YmRhYSwgMHhhZDhiLCAweDlkZTgsIDB4OGRjOSxcbiAgMHg3YzI2LCAweDZjMDcsIDB4NWM2NCwgMHg0YzQ1LCAweDNjYTIsIDB4MmM4MywgMHgxY2UwLCAweDBjYzEsXG4gIDB4ZWYxZiwgMHhmZjNlLCAweGNmNWQsIDB4ZGY3YywgMHhhZjliLCAweGJmYmEsIDB4OGZkOSwgMHg5ZmY4LFxuICAweDZlMTcsIDB4N2UzNiwgMHg0ZTU1LCAweDVlNzQsIDB4MmU5MywgMHgzZWIyLCAweDBlZDEsIDB4MWVmMFxuXVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzE2XG5cbmZ1bmN0aW9uIGNyYzE2IChuKSB7XG4gIHZhciBjcmMgPSAwXG4gIHZhciByID0gMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgciA9IG4gJiAweGZmXG4gICAgbiA9IChuIC0gcikgLyAyNTZcbiAgICBjcmMgPSAoKGNyYyA8PCA4KSBeIFRBQkxFWygoY3JjID4+IDgpIF4gcikgJiAweGZmXSkgJiAweGZmZmZcbiAgfVxuXG4gIHJldHVybiBjcmNcbn1cbiIsInZhciBoYXNoID0gcmVxdWlyZSgnLi9jcmMxNicpXG5cbm1vZHVsZS5leHBvcnRzID0gTFJVXG5cbmZ1bmN0aW9uIExSVSAobWF4LCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMUlUpKSByZXR1cm4gbmV3IExSVShtYXgsIG9wdHMpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgLy8gaG93IG1hbnkgY29sbGlzaW9ucyBiZWZvcmUgZXZpY3RpbmcgKGZhY3RvciBvZiB0d28gZm9yIGZhc3QgbW9kdWxvKVxuICB0aGlzLmNvbGxpc2lvbnMgPSBmYWN0b3JPZlR3byhvcHRzLmNvbGxpc2lvbnMgfHwgb3B0cy5idWNrZXRTaXplIHx8IDQpXG4gIC8vIGJ1Y2tldHMgc2hvdWxkIGJlIGEgZmFjdG9yIG9mIHR3byBmb3IgZmFzdCBtb2R1bG8gYXMgd2VsbFxuICB0aGlzLmJ1Y2tldHMgPSBmYWN0b3JPZihtYXgsIHRoaXMuY29sbGlzaW9ucykgLyB0aGlzLmNvbGxpc2lvbnNcblxuICAvLyB3ZSB1c2UgMTZiaXQgaGFzaGluZyB0byBidWNrZXQgaW5kZXggbXVzdCBiZSA8MHhmZmZmXG4gIHdoaWxlICh0aGlzLmJ1Y2tldHMgPiA2NTUzNikge1xuICAgIHRoaXMuYnVja2V0cyA+Pj0gMVxuICAgIHRoaXMuY29sbGlzaW9ucyA8PD0gMVxuICB9XG5cbiAgdGhpcy5zaXplID0gdGhpcy5idWNrZXRzICogdGhpcy5jb2xsaXNpb25zXG4gIHRoaXMud3JhcCA9ICFvcHRzLmluZGV4ZWRWYWx1ZXNcbiAgdGhpcy5jYWNoZSA9IG5ldyBBcnJheSh0aGlzLnNpemUpXG4gIHRoaXMuaGFzaCA9IHRoaXMuYnVja2V0cyA9PT0gNjU1MzYgPyBoYXNoIDogbWFza2VkSGFzaCh0aGlzLmJ1Y2tldHMgLSAxKVxuICB0aGlzLmV2aWN0ID0gb3B0cy5ldmljdCB8fCBudWxsXG59XG5cbkxSVS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWwpIHtcbiAgdmFyIHBhZ2VTdGFydCA9IHRoaXMuY29sbGlzaW9ucyAqIHRoaXMuaGFzaChpbmRleClcbiAgdmFyIHBhZ2VFbmQgPSBwYWdlU3RhcnQgKyB0aGlzLmNvbGxpc2lvbnNcbiAgdmFyIHB0ciA9IHBhZ2VTdGFydFxuICB2YXIgcGFnZSA9IG51bGxcblxuICB3aGlsZSAocHRyIDwgcGFnZUVuZCkge1xuICAgIHBhZ2UgPSB0aGlzLmNhY2hlW3B0cl1cblxuICAgIGlmICghcGFnZSkge1xuICAgICAgLy8gbm8gZXhpdGluZyB2ZXJzaW9uLCBidXQgd2UgaGF2ZSBzcGFjZSB0byBzdG9yZSBpdFxuICAgICAgcGFnZSA9IHRoaXMuY2FjaGVbcHRyXSA9IHRoaXMud3JhcCA/IG5ldyBOb2RlKGluZGV4LCB2YWwpIDogdmFsXG4gICAgICBtb3ZlKHRoaXMuY2FjaGUsIHBhZ2VTdGFydCwgcHRyLCBwYWdlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhZ2UuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgdmVyc2lvbiBhbmQgbW92ZSB0byBoZWFkIG9mIGJ1Y2tldFxuICAgICAgaWYgKHRoaXMud3JhcCkgcGFnZS52YWx1ZSA9IHZhbFxuICAgICAgZWxzZSB0aGlzLmNhY2hlW3B0cl0gPSB2YWxcbiAgICAgIG1vdmUodGhpcy5jYWNoZSwgcGFnZVN0YXJ0LCBwdHIsIHBhZ2UpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBwdHIrK1xuICB9XG5cbiAgLy8gYnVja2V0IGlzIGZ1bGwsIHVwZGF0ZSBvbGRlc3QgKGxhc3QgZWxlbWVudCBpbiBidWNrZXQpXG4gIGlmICh0aGlzLndyYXApIHtcbiAgICBpZiAodGhpcy5ldmljdCkgdGhpcy5ldmljdChwYWdlLmluZGV4LCBwYWdlLnZhbHVlKVxuICAgIHBhZ2UuaW5kZXggPSBpbmRleFxuICAgIHBhZ2UudmFsdWUgPSB2YWxcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5ldmljdCkgdGhpcy5ldmljdChwYWdlLmluZGV4LCBwYWdlKVxuICAgIHRoaXMuY2FjaGVbcHRyIC0gMV0gPSB2YWxcbiAgfVxuICBtb3ZlKHRoaXMuY2FjaGUsIHBhZ2VTdGFydCwgcHRyIC0gMSwgcGFnZSlcbn1cblxuTFJVLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdmFyIHBhZ2VTdGFydCA9IHRoaXMuY29sbGlzaW9ucyAqIHRoaXMuaGFzaChpbmRleClcbiAgdmFyIHBhZ2VFbmQgPSBwYWdlU3RhcnQgKyB0aGlzLmNvbGxpc2lvbnNcbiAgdmFyIHB0ciA9IHBhZ2VTdGFydFxuXG4gIHdoaWxlIChwdHIgPCBwYWdlRW5kKSB7XG4gICAgdmFyIHBhZ2UgPSB0aGlzLmNhY2hlW3B0cisrXVxuXG4gICAgaWYgKCFwYWdlKSByZXR1cm4gbnVsbFxuICAgIGlmIChwYWdlLmluZGV4ICE9PSBpbmRleCkgY29udGludWVcblxuICAgIC8vIHdlIGZvdW5kIGl0ISBtb3ZlIHRvIGhlYWQgb2YgYnVja2V0IGFuZCByZXR1cm4gdmFsdWVcbiAgICBtb3ZlKHRoaXMuY2FjaGUsIHBhZ2VTdGFydCwgcHRyIC0gMSwgcGFnZSlcblxuICAgIHJldHVybiB0aGlzLndyYXAgPyBwYWdlLnZhbHVlIDogcGFnZVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbW92ZSAobGlzdCwgaW5kZXgsIGl0ZW1JbmRleCwgaXRlbSkge1xuICB3aGlsZSAoaXRlbUluZGV4ID4gaW5kZXgpIGxpc3RbaXRlbUluZGV4XSA9IGxpc3RbLS1pdGVtSW5kZXhdXG4gIGxpc3RbaW5kZXhdID0gaXRlbVxufVxuXG5mdW5jdGlvbiBOb2RlIChpbmRleCwgdmFsdWUpIHtcbiAgdGhpcy5pbmRleCA9IGluZGV4XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxufVxuXG5mdW5jdGlvbiBmYWN0b3JPZiAobiwgZmFjdG9yKSB7XG4gIG4gPSBmYWN0b3JPZlR3byhuKVxuICB3aGlsZSAobiAmIChmYWN0b3IgLSAxKSkgbiA8PD0gMVxuICByZXR1cm4gblxufVxuXG5mdW5jdGlvbiBmYWN0b3JPZlR3byAobikge1xuICBpZiAobiAmJiAhKG4gJiAobiAtIDEpKSkgcmV0dXJuIG5cbiAgdmFyIHAgPSAxXG4gIHdoaWxlIChwIDwgbikgcCA8PD0gMVxuICByZXR1cm4gcFxufVxuXG5mdW5jdGlvbiBtYXNrZWRIYXNoIChtYXNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBoYXNoKG4pICYgbWFza1xuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGJhdGNoZXJcblxuZnVuY3Rpb24gYmF0Y2hlciAocnVuKSB7XG4gIHZhciBydW5uaW5nID0gZmFsc2VcbiAgdmFyIHBlbmRpbmdCYXRjaCA9IG51bGxcbiAgdmFyIHBlbmRpbmdDYWxsYmFja3MgPSBudWxsXG4gIHZhciBjYWxsYmFja3MgPSBudWxsXG5cbiAgcmV0dXJuIGFwcGVuZFxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgIGlmIChjYWxsYmFja3MpIGNhbGxBbGwoY2FsbGJhY2tzLCBlcnIpXG5cbiAgICBydW5uaW5nID0gZmFsc2VcbiAgICBjYWxsYmFja3MgPSBwZW5kaW5nQ2FsbGJhY2tzXG4gICAgdmFyIG5leHRCYXRjaCA9IHBlbmRpbmdCYXRjaFxuXG4gICAgcGVuZGluZ0JhdGNoID0gbnVsbFxuICAgIHBlbmRpbmdDYWxsYmFja3MgPSBudWxsXG5cbiAgICBpZiAoIW5leHRCYXRjaCB8fCAhbmV4dEJhdGNoLmxlbmd0aCkge1xuICAgICAgaWYgKCFjYWxsYmFja3MgfHwgIWNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2tzID0gbnVsbFxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICghbmV4dEJhdGNoKSBuZXh0QmF0Y2ggPSBbXVxuICAgIH1cblxuICAgIHJ1bm5pbmcgPSB0cnVlXG4gICAgcnVuKG5leHRCYXRjaCwgZG9uZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZCAodmFsLCBjYikge1xuICAgIGlmIChydW5uaW5nKSB7XG4gICAgICBpZiAoIXBlbmRpbmdCYXRjaCkge1xuICAgICAgICBwZW5kaW5nQmF0Y2ggPSBbXVxuICAgICAgICBwZW5kaW5nQ2FsbGJhY2tzID0gW11cbiAgICAgIH1cbiAgICAgIHB1c2hBbGwocGVuZGluZ0JhdGNoLCB2YWwpXG4gICAgICBpZiAoY2IpIHBlbmRpbmdDYWxsYmFja3MucHVzaChjYilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNiKSBjYWxsYmFja3MgPSBbY2JdXG4gICAgICBydW5uaW5nID0gdHJ1ZVxuICAgICAgcnVuKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdLCBkb25lKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQWxsIChsaXN0LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgcHVzaEFycmF5KGxpc3QsIHZhbClcbiAgZWxzZSBsaXN0LnB1c2godmFsKVxufVxuXG5mdW5jdGlvbiBwdXNoQXJyYXkgKGxpc3QsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykgbGlzdC5wdXNoKHZhbFtpXSlcbn1cblxuZnVuY3Rpb24gY2FsbEFsbCAobGlzdCwgZXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgbGlzdFtpXShlcnIpXG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsInZhciB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuXG5leHBvcnRzLmVuY29kZSA9IGVuY29kZVxuZXhwb3J0cy5lbmNvZGUuYnl0ZXMgPSAwXG5leHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcblxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGVcbmV4cG9ydHMuZGVjb2RlLmJ5dGVzID0gMFxuZXhwb3J0cy5kZWNvZGluZ0xlbmd0aCA9IGRlY29kaW5nTGVuZ3RoXG5cbmZ1bmN0aW9uIFN0YXRlIChpbnB1dCwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdGhpcy5pbnB1dE9mZnNldCA9IDBcbiAgdGhpcy5pbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aFxuICB0aGlzLmlucHV0ID0gaW5wdXRcbiAgdGhpcy5vdXRwdXRPZmZzZXQgPSBvZmZzZXRcbiAgdGhpcy5vdXRwdXQgPSBvdXRwdXRcbn1cblxuZnVuY3Rpb24gZW5jb2RlIChiaXRmaWVsZCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgaWYgKCFidWZmZXIpIGJ1ZmZlciA9IG5ldyBCdWZmZXIoZW5jb2RpbmdMZW5ndGgoYml0ZmllbGQpKVxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoYml0ZmllbGQsIGJ1ZmZlciwgb2Zmc2V0KVxuICBybGUoc3RhdGUpXG4gIGVuY29kZS5ieXRlcyA9IHN0YXRlLm91dHB1dE9mZnNldCAtIG9mZnNldFxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChiaXRmaWVsZCkge1xuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoYml0ZmllbGQsIG51bGwsIDApXG4gIHJsZShzdGF0ZSlcbiAgcmV0dXJuIHN0YXRlLm91dHB1dE9mZnNldFxufVxuXG5mdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgdmFyIGJpdGZpZWxkID0gbmV3IEJ1ZmZlcihkZWNvZGluZ0xlbmd0aChidWZmZXIsIG9mZnNldCkpXG4gIHZhciBwdHIgPSAwXG5cbiAgd2hpbGUgKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICB2YXIgbmV4dCA9IHZhcmludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpXG4gICAgdmFyIHJlcGVhdCA9IG5leHQgJiAxXG4gICAgdmFyIGxlbiA9IHJlcGVhdCA/IChuZXh0IC0gKG5leHQgJiAzKSkgLyA0IDogbmV4dCAvIDJcblxuICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG5cbiAgICBpZiAocmVwZWF0KSB7XG4gICAgICBiaXRmaWVsZC5maWxsKG5leHQgJiAyID8gMjU1IDogMCwgcHRyLCBwdHIgKyBsZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5jb3B5KGJpdGZpZWxkLCBwdHIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKVxuICAgICAgb2Zmc2V0ICs9IGxlblxuICAgIH1cblxuICAgIHB0ciArPSBsZW5cbiAgfVxuXG4gIGRlY29kZS5ieXRlcyA9IGJ1ZmZlci5sZW5ndGggLSBvZmZzZXRcblxuICByZXR1cm4gYml0ZmllbGRcbn1cblxuZnVuY3Rpb24gZGVjb2RpbmdMZW5ndGggKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgdmFyIGxlbiA9IDBcblxuICB3aGlsZSAob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCkge1xuICAgIHZhciBuZXh0ID0gdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gICAgdmFyIHJlcGVhdCA9IG5leHQgJiAxXG4gICAgdmFyIHNsaWNlID0gcmVwZWF0ID8gKG5leHQgLSAobmV4dCAmIDMpKSAvIDQgOiBuZXh0IC8gMlxuXG4gICAgbGVuICs9IHNsaWNlXG4gICAgaWYgKCFyZXBlYXQpIG9mZnNldCArPSBzbGljZVxuICB9XG5cbiAgaWYgKG9mZnNldCA+IGJ1ZmZlci5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSTEUgYml0ZmllbGQnKVxuXG4gIHJldHVybiBsZW5cbn1cblxuZnVuY3Rpb24gcmxlIChzdGF0ZSkge1xuICB2YXIgbGVuID0gMFxuICB2YXIgYml0cyA9IDBcbiAgdmFyIGlucHV0ID0gc3RhdGUuaW5wdXRcblxuICB3aGlsZSAoc3RhdGUuaW5wdXRMZW5ndGggPiAwICYmICFpbnB1dFtzdGF0ZS5pbnB1dExlbmd0aCAtIDFdKSBzdGF0ZS5pbnB1dExlbmd0aC0tXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5pbnB1dExlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlucHV0W2ldID09PSBiaXRzKSB7XG4gICAgICBsZW4rK1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAobGVuKSBlbmNvZGVVcGRhdGUoc3RhdGUsIGksIGxlbiwgYml0cylcblxuICAgIGlmIChpbnB1dFtpXSA9PT0gMCB8fCBpbnB1dFtpXSA9PT0gMjU1KSB7XG4gICAgICBiaXRzID0gaW5wdXRbaV1cbiAgICAgIGxlbiA9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuID0gMFxuICAgIH1cbiAgfVxuXG4gIGlmIChsZW4pIGVuY29kZVVwZGF0ZShzdGF0ZSwgc3RhdGUuaW5wdXRMZW5ndGgsIGxlbiwgYml0cylcbiAgZW5jb2RlRmluYWwoc3RhdGUpXG59XG5cbmZ1bmN0aW9uIGVuY29kZUhlYWQgKHN0YXRlLCBlbmQpIHtcbiAgdmFyIGhlYWRMZW5ndGggPSBlbmQgLSBzdGF0ZS5pbnB1dE9mZnNldFxuICB2YXJpbnQuZW5jb2RlKDIgKiBoZWFkTGVuZ3RoLCBzdGF0ZS5vdXRwdXQsIHN0YXRlLm91dHB1dE9mZnNldClcbiAgc3RhdGUub3V0cHV0T2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcbiAgc3RhdGUuaW5wdXQuY29weShzdGF0ZS5vdXRwdXQsIHN0YXRlLm91dHB1dE9mZnNldCwgc3RhdGUuaW5wdXRPZmZzZXQsIGVuZClcbiAgc3RhdGUub3V0cHV0T2Zmc2V0ICs9IGhlYWRMZW5ndGhcbn1cblxuZnVuY3Rpb24gZW5jb2RlRmluYWwgKHN0YXRlKSB7XG4gIHZhciBoZWFkTGVuZ3RoID0gc3RhdGUuaW5wdXRMZW5ndGggLSBzdGF0ZS5pbnB1dE9mZnNldFxuICBpZiAoIWhlYWRMZW5ndGgpIHJldHVyblxuXG4gIGlmICghc3RhdGUub3V0cHV0KSB7XG4gICAgc3RhdGUub3V0cHV0T2Zmc2V0ICs9IChoZWFkTGVuZ3RoICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKDIgKiBoZWFkTGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICBlbmNvZGVIZWFkKHN0YXRlLCBzdGF0ZS5pbnB1dExlbmd0aClcbiAgfVxuXG4gIHN0YXRlLmlucHV0T2Zmc2V0ID0gc3RhdGUuaW5wdXRMZW5ndGhcbn1cblxuZnVuY3Rpb24gZW5jb2RlVXBkYXRlIChzdGF0ZSwgaSwgbGVuLCBiaXQpIHtcbiAgdmFyIGhlYWRMZW5ndGggPSBpIC0gbGVuIC0gc3RhdGUuaW5wdXRPZmZzZXRcbiAgdmFyIGhlYWRDb3N0ID0gKGhlYWRMZW5ndGggPyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoMiAqIGhlYWRMZW5ndGgpICsgaGVhZExlbmd0aCA6IDApXG4gIHZhciBlbmMgPSA0ICogbGVuICsgKGJpdCA/IDIgOiAwKSArIDEgLy8gbGVuIDw8IDIgfCBiaXQgPDwgMSB8IDFcbiAgdmFyIGVuY0Nvc3QgPSBoZWFkQ29zdCArIHZhcmludC5lbmNvZGluZ0xlbmd0aChlbmMpXG4gIHZhciBiYXNlQ29zdCA9IHZhcmludC5lbmNvZGluZ0xlbmd0aCgyICogKGkgLSBzdGF0ZS5pbnB1dE9mZnNldCkpICsgaSAtIHN0YXRlLmlucHV0T2Zmc2V0XG5cbiAgaWYgKGVuY0Nvc3QgPj0gYmFzZUNvc3QpIHJldHVyblxuXG4gIGlmICghc3RhdGUub3V0cHV0KSB7XG4gICAgc3RhdGUub3V0cHV0T2Zmc2V0ICs9IGVuY0Nvc3RcbiAgICBzdGF0ZS5pbnB1dE9mZnNldCA9IGlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChoZWFkTGVuZ3RoKSBlbmNvZGVIZWFkKHN0YXRlLCBpIC0gbGVuKVxuXG4gIHZhcmludC5lbmNvZGUoZW5jLCBzdGF0ZS5vdXRwdXQsIHN0YXRlLm91dHB1dE9mZnNldClcbiAgc3RhdGUub3V0cHV0T2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcbiAgc3RhdGUuaW5wdXRPZmZzZXQgPSBpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYoY291bnRlciA+PSBsKSB7XG4gICAgICByZWFkLmJ5dGVzID0gMFxuICAgICAgcmVhZC5ieXRlc1JlYWQgPSAwIC8vIERFUFJFQ0FURURcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdXG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QpICogTWF0aC5wb3coMiwgc2hpZnQpXG4gICAgc2hpZnQgKz0gN1xuICB9IHdoaWxlIChiID49IE1TQilcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldFxuXG4gIHJldHVybiByZXNcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZW5jb2RlXG5cbnZhciBNU0IgPSAweDgwXG4gICwgUkVTVCA9IDB4N0ZcbiAgLCBNU0JBTEwgPSB+UkVTVFxuICAsIElOVCA9IE1hdGgucG93KDIsIDMxKVxuXG5mdW5jdGlvbiBlbmNvZGUobnVtLCBvdXQsIG9mZnNldCkge1xuICBvdXQgPSBvdXQgfHwgW11cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuXG4gIHdoaWxlKG51bSA+PSBJTlQpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtIC89IDEyOFxuICB9XG4gIHdoaWxlKG51bSAmIE1TQkFMTCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gPj4+PSA3XG4gIH1cbiAgb3V0W29mZnNldF0gPSBudW0gfCAwXG4gIFxuICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXQgKyAxXG4gIFxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlbmNvZGU6IHJlcXVpcmUoJy4vZW5jb2RlLmpzJylcbiAgLCBkZWNvZGU6IHJlcXVpcmUoJy4vZGVjb2RlLmpzJylcbiAgLCBlbmNvZGluZ0xlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGguanMnKVxufVxuIiwiXG52YXIgTjEgPSBNYXRoLnBvdygyLCAgNylcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KVxudmFyIE4zID0gTWF0aC5wb3coMiwgMjEpXG52YXIgTjQgPSBNYXRoLnBvdygyLCAyOClcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KVxudmFyIE42ID0gTWF0aC5wb3coMiwgNDIpXG52YXIgTjcgPSBNYXRoLnBvdygyLCA0OSlcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KVxudmFyIE45ID0gTWF0aC5wb3coMiwgNjMpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgPCBOMSA/IDFcbiAgOiB2YWx1ZSA8IE4yID8gMlxuICA6IHZhbHVlIDwgTjMgPyAzXG4gIDogdmFsdWUgPCBONCA/IDRcbiAgOiB2YWx1ZSA8IE41ID8gNVxuICA6IHZhbHVlIDwgTjYgPyA2XG4gIDogdmFsdWUgPCBONyA/IDdcbiAgOiB2YWx1ZSA8IE44ID8gOFxuICA6IHZhbHVlIDwgTjkgPyA5XG4gIDogICAgICAgICAgICAgIDEwXG4gIClcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBsb2FkV2ViQXNzZW1ibHlcblxubG9hZFdlYkFzc2VtYmx5LnN1cHBvcnRlZCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ3VuZGVmaW5lZCdcblxuZnVuY3Rpb24gbG9hZFdlYkFzc2VtYmx5IChvcHRzKSB7XG4gIGlmICghbG9hZFdlYkFzc2VtYmx5LnN1cHBvcnRlZCkgcmV0dXJuIG51bGxcblxuICB2YXIgaW1wID0gb3B0cyAmJiBvcHRzLmltcG9ydHNcbiAgdmFyIHdhc20gPSB0b1VpbnQ4QXJyYXkoJ0FHRnpiUUVBQUFBQkVBTmdBbjkvQUdBRGYzOS9BR0FCZndBREJRUUFBUUlDQlFVQkFRcm9Cd2ROQlFadFpXMXZjbmtDQUF4aWJHRnJaVEppWDJsdWFYUUFBQTVpYkdGclpUSmlYM1Z3WkdGMFpRQUJEV0pzWVd0bE1tSmZabWx1WVd3QUFoQmliR0ZyWlRKaVgyTnZiWEJ5WlhOekFBTUswMEFFbGdNQUlBQkNBRGNEQUNBQVFRaHFRZ0EzQXdBZ0FFRVFha0lBTndNQUlBQkJHR3BDQURjREFDQUFRU0JxUWdBM0F3QWdBRUVvYWtJQU53TUFJQUJCTUdwQ0FEY0RBQ0FBUVRocVFnQTNBd0FnQUVIQUFHcENBRGNEQUNBQVFjZ0Fha0lBTndNQUlBQkIwQUJxUWdBM0F3QWdBRUhZQUdwQ0FEY0RBQ0FBUWVBQWFrSUFOd01BSUFCQjZBQnFRZ0EzQXdBZ0FFSHdBR3BDQURjREFDQUFRZmdBYWtJQU53TUFJQUJCZ0FGcVFvaVM4NTMvelBtRTZnQkJBQ2tEQUlVM0F3QWdBRUdJQVdwQ3U4NnFwdGpRNjdPN2YwRUlLUU1BaFRjREFDQUFRWkFCYWtLcjhOUDByKzY4dHp4QkVDa0RBSVUzQXdBZ0FFR1lBV3BDOGUzMCtLV24vYWVsZjBFWUtRTUFoVGNEQUNBQVFhQUJha0xSaFpyditzK1VoOUVBUVNBcEF3Q0ZOd01BSUFCQnFBRnFRcC9ZK2RuQ2tkcUNtMzlCS0NrREFJVTNBd0FnQUVHd0FXcEM2L3FHMnIrMTlzRWZRVEFwQXdDRk53TUFJQUJCdUFGcVF2bkMrSnVSbzdQdzJ3QkJPQ2tEQUlVM0F3QWdBRUhBQVdwQ0FEY0RBQ0FBUWNnQmFrSUFOd01BSUFCQjBBRnFRZ0EzQXdBTGJRRURmeUFBUWNBQmFpRURJQUJCeUFGcUlRUWdCQ2tEQUtjaEJRSkFBMEFnQVNBQ1JnMEJJQVZCZ0FGR0JFQWdBeUFES1FNQUlBV3RmRGNEQUVFQUlRVWdBQkFEQ3lBQUlBVnFJQUV0QUFBNkFBQWdCVUVCYWlFRklBRkJBV29oQVF3QUN3c2dCQ0FGclRjREFBdGtBUU4vSUFCQndBRnFJUUVnQUVISUFXb2hBaUFCSUFFcEF3QWdBaWtEQUh3M0F3QWdBRUhRQVdwQ2Z6Y0RBQ0FDS1FNQXB5RURBa0FEUUNBRFFZQUJSZzBCSUFBZ0EycEJBRG9BQUNBRFFRRnFJUU1NQUFzTElBSWdBNjAzQXdBZ0FCQURDK1U3QWlCK0NYOGdBRUdBQVdvaElTQUFRWWdCYWlFaUlBQkJrQUZxSVNNZ0FFR1lBV29oSkNBQVFhQUJhaUVsSUFCQnFBRnFJU1lnQUVHd0FXb2hKeUFBUWJnQmFpRW9JQ0VwQXdBaEFTQWlLUU1BSVFJZ0l5a0RBQ0VESUNRcEF3QWhCQ0FsS1FNQUlRVWdKaWtEQUNFR0lDY3BBd0FoQnlBb0tRTUFJUWhDaUpMem5mL00rWVRxQUNFSlFydk9xcWJZME91enUzOGhDa0tyOE5QMHIrNjh0endoQzBMeDdmVDRwYWY5cDZWL0lReEMwWVdhNy9yUGxJZlJBQ0VOUXAvWStkbkNrZHFDbTM4aERrTHIrb2JhdjdYMndSOGhEMEw1d3ZpYmthT3o4TnNBSVJBZ0FDa0RBQ0VSSUFCQkNHb3BBd0FoRWlBQVFSQnFLUU1BSVJNZ0FFRVlhaWtEQUNFVUlBQkJJR29wQXdBaEZTQUFRU2hxS1FNQUlSWWdBRUV3YWlrREFDRVhJQUJCT0dvcEF3QWhHQ0FBUWNBQWFpa0RBQ0VaSUFCQnlBQnFLUU1BSVJvZ0FFSFFBR29wQXdBaEd5QUFRZGdBYWlrREFDRWNJQUJCNEFCcUtRTUFJUjBnQUVIb0FHb3BBd0FoSGlBQVFmQUFhaWtEQUNFZklBQkIrQUJxS1FNQUlTQWdEU0FBUWNBQmFpa0RBSVVoRFNBUElBQkIwQUZxS1FNQWhTRVBJQUVnQlNBUmZId2hBU0FOSUFHRlFpQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ0dJb2hCU0FCSUFVZ0VueDhJUUVnRFNBQmhVSVFpaUVOSUFrZ0RYd2hDU0FGSUFtRlFqK0tJUVVnQWlBR0lCTjhmQ0VDSUE0Z0FvVkNJSW9oRGlBS0lBNThJUW9nQmlBS2hVSVlpaUVHSUFJZ0JpQVVmSHdoQWlBT0lBS0ZRaENLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNQNG9oQmlBRElBY2dGWHg4SVFNZ0R5QURoVUlnaWlFUElBc2dEM3doQ3lBSElBdUZRaGlLSVFjZ0F5QUhJQlo4ZkNFRElBOGdBNFZDRUlvaER5QUxJQTk4SVFzZ0J5QUxoVUkvaWlFSElBUWdDQ0FYZkh3aEJDQVFJQVNGUWlDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDR0lvaENDQUVJQWdnR0h4OElRUWdFQ0FFaFVJUWlpRVFJQXdnRUh3aERDQUlJQXlGUWorS0lRZ2dBU0FHSUJsOGZDRUJJQkFnQVlWQ0lJb2hFQ0FMSUJCOElRc2dCaUFMaFVJWWlpRUdJQUVnQmlBYWZId2hBU0FRSUFHRlFoQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ1A0b2hCaUFDSUFjZ0czeDhJUUlnRFNBQ2hVSWdpaUVOSUF3Z0RYd2hEQ0FISUF5RlFoaUtJUWNnQWlBSElCeDhmQ0VDSUEwZ0FvVkNFSW9oRFNBTUlBMThJUXdnQnlBTWhVSS9paUVISUFNZ0NDQWRmSHdoQXlBT0lBT0ZRaUNLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNHSW9oQ0NBRElBZ2dIbng4SVFNZ0RpQURoVUlRaWlFT0lBa2dEbndoQ1NBSUlBbUZRaitLSVFnZ0JDQUZJQjk4ZkNFRUlBOGdCSVZDSUlvaER5QUtJQTk4SVFvZ0JTQUtoVUlZaWlFRklBUWdCU0FnZkh3aEJDQVBJQVNGUWhDS0lROGdDaUFQZkNFS0lBVWdDb1ZDUDRvaEJTQUJJQVVnSDN4OElRRWdEU0FCaFVJZ2lpRU5JQWtnRFh3aENTQUZJQW1GUWhpS0lRVWdBU0FGSUJ0OGZDRUJJQTBnQVlWQ0VJb2hEU0FKSUExOElRa2dCU0FKaFVJL2lpRUZJQUlnQmlBVmZId2hBaUFPSUFLRlFpQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ0dJb2hCaUFDSUFZZ0dYeDhJUUlnRGlBQ2hVSVFpaUVPSUFvZ0Rud2hDaUFHSUFxRlFqK0tJUVlnQXlBSElCcDhmQ0VESUE4Z0E0VkNJSW9oRHlBTElBOThJUXNnQnlBTGhVSVlpaUVISUFNZ0J5QWdmSHdoQXlBUElBT0ZRaENLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNQNG9oQnlBRUlBZ2dIbng4SVFRZ0VDQUVoVUlnaWlFUUlBd2dFSHdoRENBSUlBeUZRaGlLSVFnZ0JDQUlJQmQ4ZkNFRUlCQWdCSVZDRUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUkvaWlFSUlBRWdCaUFTZkh3aEFTQVFJQUdGUWlDS0lSQWdDeUFRZkNFTElBWWdDNFZDR0lvaEJpQUJJQVlnSFh4OElRRWdFQ0FCaFVJUWlpRVFJQXNnRUh3aEN5QUdJQXVGUWorS0lRWWdBaUFISUJGOGZDRUNJQTBnQW9WQ0lJb2hEU0FNSUExOElRd2dCeUFNaFVJWWlpRUhJQUlnQnlBVGZId2hBaUFOSUFLRlFoQ0tJUTBnRENBTmZDRU1JQWNnRElWQ1A0b2hCeUFESUFnZ0hIeDhJUU1nRGlBRGhVSWdpaUVPSUFrZ0Rud2hDU0FJSUFtRlFoaUtJUWdnQXlBSUlCaDhmQ0VESUE0Z0E0VkNFSW9oRGlBSklBNThJUWtnQ0NBSmhVSS9paUVJSUFRZ0JTQVdmSHdoQkNBUElBU0ZRaUNLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNHSW9oQlNBRUlBVWdGSHg4SVFRZ0R5QUVoVUlRaWlFUElBb2dEM3doQ2lBRklBcUZRaitLSVFVZ0FTQUZJQng4ZkNFQklBMGdBWVZDSUlvaERTQUpJQTE4SVFrZ0JTQUpoVUlZaWlFRklBRWdCU0FaZkh3aEFTQU5JQUdGUWhDS0lRMGdDU0FOZkNFSklBVWdDWVZDUDRvaEJTQUNJQVlnSFh4OElRSWdEaUFDaFVJZ2lpRU9JQW9nRG53aENpQUdJQXFGUWhpS0lRWWdBaUFHSUJGOGZDRUNJQTRnQW9WQ0VJb2hEaUFLSUE1OElRb2dCaUFLaFVJL2lpRUdJQU1nQnlBV2ZId2hBeUFQSUFPRlFpQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ0dJb2hCeUFESUFjZ0UzeDhJUU1nRHlBRGhVSVFpaUVQSUFzZ0Qzd2hDeUFISUF1RlFqK0tJUWNnQkNBSUlDQjhmQ0VFSUJBZ0JJVkNJSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSVlpaUVJSUFRZ0NDQWVmSHdoQkNBUUlBU0ZRaENLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNQNG9oQ0NBQklBWWdHM3g4SVFFZ0VDQUJoVUlnaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaGlLSVFZZ0FTQUdJQjk4ZkNFQklCQWdBWVZDRUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUkvaWlFR0lBSWdCeUFVZkh3aEFpQU5JQUtGUWlDS0lRMGdEQ0FOZkNFTUlBY2dESVZDR0lvaEJ5QUNJQWNnRjN4OElRSWdEU0FDaFVJUWlpRU5JQXdnRFh3aERDQUhJQXlGUWorS0lRY2dBeUFJSUJoOGZDRURJQTRnQTRWQ0lJb2hEaUFKSUE1OElRa2dDQ0FKaFVJWWlpRUlJQU1nQ0NBU2ZId2hBeUFPSUFPRlFoQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ1A0b2hDQ0FFSUFVZ0dueDhJUVFnRHlBRWhVSWdpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFoaUtJUVVnQkNBRklCVjhmQ0VFSUE4Z0JJVkNFSW9oRHlBS0lBOThJUW9nQlNBS2hVSS9paUVGSUFFZ0JTQVlmSHdoQVNBTklBR0ZRaUNLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNHSW9oQlNBQklBVWdHbng4SVFFZ0RTQUJoVUlRaWlFTklBa2dEWHdoQ1NBRklBbUZRaitLSVFVZ0FpQUdJQlI4ZkNFQ0lBNGdBb1ZDSUlvaERpQUtJQTU4SVFvZ0JpQUtoVUlZaWlFR0lBSWdCaUFTZkh3aEFpQU9JQUtGUWhDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDUDRvaEJpQURJQWNnSG54OElRTWdEeUFEaFVJZ2lpRVBJQXNnRDN3aEN5QUhJQXVGUWhpS0lRY2dBeUFISUIxOGZDRURJQThnQTRWQ0VJb2hEeUFMSUE5OElRc2dCeUFMaFVJL2lpRUhJQVFnQ0NBY2ZId2hCQ0FRSUFTRlFpQ0tJUkFnRENBUWZDRU1JQWdnRElWQ0dJb2hDQ0FFSUFnZ0gzeDhJUVFnRUNBRWhVSVFpaUVRSUF3Z0VId2hEQ0FJSUF5RlFqK0tJUWdnQVNBR0lCTjhmQ0VCSUJBZ0FZVkNJSW9oRUNBTElCQjhJUXNnQmlBTGhVSVlpaUVHSUFFZ0JpQVhmSHdoQVNBUUlBR0ZRaENLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNQNG9oQmlBQ0lBY2dGbng4SVFJZ0RTQUNoVUlnaWlFTklBd2dEWHdoRENBSElBeUZRaGlLSVFjZ0FpQUhJQnQ4ZkNFQ0lBMGdBb1ZDRUlvaERTQU1JQTE4SVF3Z0J5QU1oVUkvaWlFSElBTWdDQ0FWZkh3aEF5QU9JQU9GUWlDS0lRNGdDU0FPZkNFSklBZ2dDWVZDR0lvaENDQURJQWdnRVh4OElRTWdEaUFEaFVJUWlpRU9JQWtnRG53aENTQUlJQW1GUWorS0lRZ2dCQ0FGSUNCOGZDRUVJQThnQklWQ0lJb2hEeUFLSUE5OElRb2dCU0FLaFVJWWlpRUZJQVFnQlNBWmZId2hCQ0FQSUFTRlFoQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ1A0b2hCU0FCSUFVZ0dueDhJUUVnRFNBQmhVSWdpaUVOSUFrZ0RYd2hDU0FGSUFtRlFoaUtJUVVnQVNBRklCRjhmQ0VCSUEwZ0FZVkNFSW9oRFNBSklBMThJUWtnQlNBSmhVSS9paUVGSUFJZ0JpQVdmSHdoQWlBT0lBS0ZRaUNLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNHSW9oQmlBQ0lBWWdHSHg4SVFJZ0RpQUNoVUlRaWlFT0lBb2dEbndoQ2lBR0lBcUZRaitLSVFZZ0F5QUhJQk44ZkNFRElBOGdBNFZDSUlvaER5QUxJQTk4SVFzZ0J5QUxoVUlZaWlFSElBTWdCeUFWZkh3aEF5QVBJQU9GUWhDS0lROGdDeUFQZkNFTElBY2dDNFZDUDRvaEJ5QUVJQWdnRzN4OElRUWdFQ0FFaFVJZ2lpRVFJQXdnRUh3aERDQUlJQXlGUWhpS0lRZ2dCQ0FJSUNCOGZDRUVJQkFnQklWQ0VJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJL2lpRUlJQUVnQmlBZmZId2hBU0FRSUFHRlFpQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ0dJb2hCaUFCSUFZZ0VueDhJUUVnRUNBQmhVSVFpaUVRSUFzZ0VId2hDeUFHSUF1RlFqK0tJUVlnQWlBSElCeDhmQ0VDSUEwZ0FvVkNJSW9oRFNBTUlBMThJUXdnQnlBTWhVSVlpaUVISUFJZ0J5QWRmSHdoQWlBTklBS0ZRaENLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNQNG9oQnlBRElBZ2dGM3g4SVFNZ0RpQURoVUlnaWlFT0lBa2dEbndoQ1NBSUlBbUZRaGlLSVFnZ0F5QUlJQmw4ZkNFRElBNGdBNFZDRUlvaERpQUpJQTU4SVFrZ0NDQUpoVUkvaWlFSUlBUWdCU0FVZkh3aEJDQVBJQVNGUWlDS0lROGdDaUFQZkNFS0lBVWdDb1ZDR0lvaEJTQUVJQVVnSG54OElRUWdEeUFFaFVJUWlpRVBJQW9nRDN3aENpQUZJQXFGUWorS0lRVWdBU0FGSUJOOGZDRUJJQTBnQVlWQ0lJb2hEU0FKSUExOElRa2dCU0FKaFVJWWlpRUZJQUVnQlNBZGZId2hBU0FOSUFHRlFoQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ1A0b2hCU0FDSUFZZ0YzeDhJUUlnRGlBQ2hVSWdpaUVPSUFvZ0Rud2hDaUFHSUFxRlFoaUtJUVlnQWlBR0lCdDhmQ0VDSUE0Z0FvVkNFSW9oRGlBS0lBNThJUW9nQmlBS2hVSS9paUVHSUFNZ0J5QVJmSHdoQXlBUElBT0ZRaUNLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNHSW9oQnlBRElBY2dISHg4SVFNZ0R5QURoVUlRaWlFUElBc2dEM3doQ3lBSElBdUZRaitLSVFjZ0JDQUlJQmw4ZkNFRUlCQWdCSVZDSUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUlZaWlFSUlBUWdDQ0FVZkh3aEJDQVFJQVNGUWhDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDUDRvaENDQUJJQVlnRlh4OElRRWdFQ0FCaFVJZ2lpRVFJQXNnRUh3aEN5QUdJQXVGUWhpS0lRWWdBU0FHSUI1OGZDRUJJQkFnQVlWQ0VJb2hFQ0FMSUJCOElRc2dCaUFMaFVJL2lpRUdJQUlnQnlBWWZId2hBaUFOSUFLRlFpQ0tJUTBnRENBTmZDRU1JQWNnRElWQ0dJb2hCeUFDSUFjZ0ZueDhJUUlnRFNBQ2hVSVFpaUVOSUF3Z0RYd2hEQ0FISUF5RlFqK0tJUWNnQXlBSUlDQjhmQ0VESUE0Z0E0VkNJSW9oRGlBSklBNThJUWtnQ0NBSmhVSVlpaUVJSUFNZ0NDQWZmSHdoQXlBT0lBT0ZRaENLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNQNG9oQ0NBRUlBVWdFbng4SVFRZ0R5QUVoVUlnaWlFUElBb2dEM3doQ2lBRklBcUZRaGlLSVFVZ0JDQUZJQnA4ZkNFRUlBOGdCSVZDRUlvaER5QUtJQTk4SVFvZ0JTQUtoVUkvaWlFRklBRWdCU0FkZkh3aEFTQU5JQUdGUWlDS0lRMGdDU0FOZkNFSklBVWdDWVZDR0lvaEJTQUJJQVVnRm54OElRRWdEU0FCaFVJUWlpRU5JQWtnRFh3aENTQUZJQW1GUWorS0lRVWdBaUFHSUJKOGZDRUNJQTRnQW9WQ0lJb2hEaUFLSUE1OElRb2dCaUFLaFVJWWlpRUdJQUlnQmlBZ2ZId2hBaUFPSUFLRlFoQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ1A0b2hCaUFESUFjZ0gzeDhJUU1nRHlBRGhVSWdpaUVQSUFzZ0Qzd2hDeUFISUF1RlFoaUtJUWNnQXlBSElCNThmQ0VESUE4Z0E0VkNFSW9oRHlBTElBOThJUXNnQnlBTGhVSS9paUVISUFRZ0NDQVZmSHdoQkNBUUlBU0ZRaUNLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNHSW9oQ0NBRUlBZ2dHM3g4SVFRZ0VDQUVoVUlRaWlFUUlBd2dFSHdoRENBSUlBeUZRaitLSVFnZ0FTQUdJQkY4ZkNFQklCQWdBWVZDSUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUlZaWlFR0lBRWdCaUFZZkh3aEFTQVFJQUdGUWhDS0lSQWdDeUFRZkNFTElBWWdDNFZDUDRvaEJpQUNJQWNnRjN4OElRSWdEU0FDaFVJZ2lpRU5JQXdnRFh3aERDQUhJQXlGUWhpS0lRY2dBaUFISUJSOGZDRUNJQTBnQW9WQ0VJb2hEU0FNSUExOElRd2dCeUFNaFVJL2lpRUhJQU1nQ0NBYWZId2hBeUFPSUFPRlFpQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ0dJb2hDQ0FESUFnZ0UzeDhJUU1nRGlBRGhVSVFpaUVPSUFrZ0Rud2hDU0FJSUFtRlFqK0tJUWdnQkNBRklCbDhmQ0VFSUE4Z0JJVkNJSW9oRHlBS0lBOThJUW9nQlNBS2hVSVlpaUVGSUFRZ0JTQWNmSHdoQkNBUElBU0ZRaENLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNQNG9oQlNBQklBVWdIbng4SVFFZ0RTQUJoVUlnaWlFTklBa2dEWHdoQ1NBRklBbUZRaGlLSVFVZ0FTQUZJQng4ZkNFQklBMGdBWVZDRUlvaERTQUpJQTE4SVFrZ0JTQUpoVUkvaWlFRklBSWdCaUFZZkh3aEFpQU9JQUtGUWlDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDR0lvaEJpQUNJQVlnSDN4OElRSWdEaUFDaFVJUWlpRU9JQW9nRG53aENpQUdJQXFGUWorS0lRWWdBeUFISUIxOGZDRURJQThnQTRWQ0lJb2hEeUFMSUE5OElRc2dCeUFMaFVJWWlpRUhJQU1nQnlBU2ZId2hBeUFQSUFPRlFoQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ1A0b2hCeUFFSUFnZ0ZIeDhJUVFnRUNBRWhVSWdpaUVRSUF3Z0VId2hEQ0FJSUF5RlFoaUtJUWdnQkNBSUlCcDhmQ0VFSUJBZ0JJVkNFSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSS9paUVJSUFFZ0JpQVdmSHdoQVNBUUlBR0ZRaUNLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNHSW9oQmlBQklBWWdFWHg4SVFFZ0VDQUJoVUlRaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaitLSVFZZ0FpQUhJQ0I4ZkNFQ0lBMGdBb1ZDSUlvaERTQU1JQTE4SVF3Z0J5QU1oVUlZaWlFSElBSWdCeUFWZkh3aEFpQU5JQUtGUWhDS0lRMGdEQ0FOZkNFTUlBY2dESVZDUDRvaEJ5QURJQWdnR1h4OElRTWdEaUFEaFVJZ2lpRU9JQWtnRG53aENTQUlJQW1GUWhpS0lRZ2dBeUFJSUJkOGZDRURJQTRnQTRWQ0VJb2hEaUFKSUE1OElRa2dDQ0FKaFVJL2lpRUlJQVFnQlNBVGZId2hCQ0FQSUFTRlFpQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ0dJb2hCU0FFSUFVZ0czeDhJUVFnRHlBRWhVSVFpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFqK0tJUVVnQVNBRklCZDhmQ0VCSUEwZ0FZVkNJSW9oRFNBSklBMThJUWtnQlNBSmhVSVlpaUVGSUFFZ0JTQWdmSHdoQVNBTklBR0ZRaENLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNQNG9oQlNBQ0lBWWdIM3g4SVFJZ0RpQUNoVUlnaWlFT0lBb2dEbndoQ2lBR0lBcUZRaGlLSVFZZ0FpQUdJQnA4ZkNFQ0lBNGdBb1ZDRUlvaERpQUtJQTU4SVFvZ0JpQUtoVUkvaWlFR0lBTWdCeUFjZkh3aEF5QVBJQU9GUWlDS0lROGdDeUFQZkNFTElBY2dDNFZDR0lvaEJ5QURJQWNnRkh4OElRTWdEeUFEaFVJUWlpRVBJQXNnRDN3aEN5QUhJQXVGUWorS0lRY2dCQ0FJSUJGOGZDRUVJQkFnQklWQ0lJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJWWlpRUlJQVFnQ0NBWmZId2hCQ0FRSUFTRlFoQ0tJUkFnRENBUWZDRU1JQWdnRElWQ1A0b2hDQ0FCSUFZZ0hYeDhJUUVnRUNBQmhVSWdpaUVRSUFzZ0VId2hDeUFHSUF1RlFoaUtJUVlnQVNBR0lCTjhmQ0VCSUJBZ0FZVkNFSW9oRUNBTElCQjhJUXNnQmlBTGhVSS9paUVHSUFJZ0J5QWVmSHdoQWlBTklBS0ZRaUNLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNHSW9oQnlBQ0lBY2dHSHg4SVFJZ0RTQUNoVUlRaWlFTklBd2dEWHdoRENBSElBeUZRaitLSVFjZ0F5QUlJQko4ZkNFRElBNGdBNFZDSUlvaERpQUpJQTU4SVFrZ0NDQUpoVUlZaWlFSUlBTWdDQ0FWZkh3aEF5QU9JQU9GUWhDS0lRNGdDU0FPZkNFSklBZ2dDWVZDUDRvaENDQUVJQVVnRzN4OElRUWdEeUFFaFVJZ2lpRVBJQW9nRDN3aENpQUZJQXFGUWhpS0lRVWdCQ0FGSUJaOGZDRUVJQThnQklWQ0VJb2hEeUFLSUE5OElRb2dCU0FLaFVJL2lpRUZJQUVnQlNBYmZId2hBU0FOSUFHRlFpQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ0dJb2hCU0FCSUFVZ0UzeDhJUUVnRFNBQmhVSVFpaUVOSUFrZ0RYd2hDU0FGSUFtRlFqK0tJUVVnQWlBR0lCbDhmQ0VDSUE0Z0FvVkNJSW9oRGlBS0lBNThJUW9nQmlBS2hVSVlpaUVHSUFJZ0JpQVZmSHdoQWlBT0lBS0ZRaENLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNQNG9oQmlBRElBY2dHSHg4SVFNZ0R5QURoVUlnaWlFUElBc2dEM3doQ3lBSElBdUZRaGlLSVFjZ0F5QUhJQmQ4ZkNFRElBOGdBNFZDRUlvaER5QUxJQTk4SVFzZ0J5QUxoVUkvaWlFSElBUWdDQ0FTZkh3aEJDQVFJQVNGUWlDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDR0lvaENDQUVJQWdnRm54OElRUWdFQ0FFaFVJUWlpRVFJQXdnRUh3aERDQUlJQXlGUWorS0lRZ2dBU0FHSUNCOGZDRUJJQkFnQVlWQ0lJb2hFQ0FMSUJCOElRc2dCaUFMaFVJWWlpRUdJQUVnQmlBY2ZId2hBU0FRSUFHRlFoQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ1A0b2hCaUFDSUFjZ0dueDhJUUlnRFNBQ2hVSWdpaUVOSUF3Z0RYd2hEQ0FISUF5RlFoaUtJUWNnQWlBSElCOThmQ0VDSUEwZ0FvVkNFSW9oRFNBTUlBMThJUXdnQnlBTWhVSS9paUVISUFNZ0NDQVVmSHdoQXlBT0lBT0ZRaUNLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNHSW9oQ0NBRElBZ2dIWHg4SVFNZ0RpQURoVUlRaWlFT0lBa2dEbndoQ1NBSUlBbUZRaitLSVFnZ0JDQUZJQjU4ZkNFRUlBOGdCSVZDSUlvaER5QUtJQTk4SVFvZ0JTQUtoVUlZaWlFRklBUWdCU0FSZkh3aEJDQVBJQVNGUWhDS0lROGdDaUFQZkNFS0lBVWdDb1ZDUDRvaEJTQUJJQVVnRVh4OElRRWdEU0FCaFVJZ2lpRU5JQWtnRFh3aENTQUZJQW1GUWhpS0lRVWdBU0FGSUJKOGZDRUJJQTBnQVlWQ0VJb2hEU0FKSUExOElRa2dCU0FKaFVJL2lpRUZJQUlnQmlBVGZId2hBaUFPSUFLRlFpQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ0dJb2hCaUFDSUFZZ0ZIeDhJUUlnRGlBQ2hVSVFpaUVPSUFvZ0Rud2hDaUFHSUFxRlFqK0tJUVlnQXlBSElCVjhmQ0VESUE4Z0E0VkNJSW9oRHlBTElBOThJUXNnQnlBTGhVSVlpaUVISUFNZ0J5QVdmSHdoQXlBUElBT0ZRaENLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNQNG9oQnlBRUlBZ2dGM3g4SVFRZ0VDQUVoVUlnaWlFUUlBd2dFSHdoRENBSUlBeUZRaGlLSVFnZ0JDQUlJQmg4ZkNFRUlCQWdCSVZDRUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUkvaWlFSUlBRWdCaUFaZkh3aEFTQVFJQUdGUWlDS0lSQWdDeUFRZkNFTElBWWdDNFZDR0lvaEJpQUJJQVlnR254OElRRWdFQ0FCaFVJUWlpRVFJQXNnRUh3aEN5QUdJQXVGUWorS0lRWWdBaUFISUJ0OGZDRUNJQTBnQW9WQ0lJb2hEU0FNSUExOElRd2dCeUFNaFVJWWlpRUhJQUlnQnlBY2ZId2hBaUFOSUFLRlFoQ0tJUTBnRENBTmZDRU1JQWNnRElWQ1A0b2hCeUFESUFnZ0hYeDhJUU1nRGlBRGhVSWdpaUVPSUFrZ0Rud2hDU0FJSUFtRlFoaUtJUWdnQXlBSUlCNThmQ0VESUE0Z0E0VkNFSW9oRGlBSklBNThJUWtnQ0NBSmhVSS9paUVJSUFRZ0JTQWZmSHdoQkNBUElBU0ZRaUNLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNHSW9oQlNBRUlBVWdJSHg4SVFRZ0R5QUVoVUlRaWlFUElBb2dEM3doQ2lBRklBcUZRaitLSVFVZ0FTQUZJQjk4ZkNFQklBMGdBWVZDSUlvaERTQUpJQTE4SVFrZ0JTQUpoVUlZaWlFRklBRWdCU0FiZkh3aEFTQU5JQUdGUWhDS0lRMGdDU0FOZkNFSklBVWdDWVZDUDRvaEJTQUNJQVlnRlh4OElRSWdEaUFDaFVJZ2lpRU9JQW9nRG53aENpQUdJQXFGUWhpS0lRWWdBaUFHSUJsOGZDRUNJQTRnQW9WQ0VJb2hEaUFLSUE1OElRb2dCaUFLaFVJL2lpRUdJQU1nQnlBYWZId2hBeUFQSUFPRlFpQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ0dJb2hCeUFESUFjZ0lIeDhJUU1nRHlBRGhVSVFpaUVQSUFzZ0Qzd2hDeUFISUF1RlFqK0tJUWNnQkNBSUlCNThmQ0VFSUJBZ0JJVkNJSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSVlpaUVJSUFRZ0NDQVhmSHdoQkNBUUlBU0ZRaENLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNQNG9oQ0NBQklBWWdFbng4SVFFZ0VDQUJoVUlnaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaGlLSVFZZ0FTQUdJQjE4ZkNFQklCQWdBWVZDRUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUkvaWlFR0lBSWdCeUFSZkh3aEFpQU5JQUtGUWlDS0lRMGdEQ0FOZkNFTUlBY2dESVZDR0lvaEJ5QUNJQWNnRTN4OElRSWdEU0FDaFVJUWlpRU5JQXdnRFh3aERDQUhJQXlGUWorS0lRY2dBeUFJSUJ4OGZDRURJQTRnQTRWQ0lJb2hEaUFKSUE1OElRa2dDQ0FKaFVJWWlpRUlJQU1nQ0NBWWZId2hBeUFPSUFPRlFoQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ1A0b2hDQ0FFSUFVZ0ZueDhJUVFnRHlBRWhVSWdpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFoaUtJUVVnQkNBRklCUjhmQ0VFSUE4Z0JJVkNFSW9oRHlBS0lBOThJUW9nQlNBS2hVSS9paUVGSUNFZ0lTa0RBQ0FCSUFtRmhUY0RBQ0FpSUNJcEF3QWdBaUFLaFlVM0F3QWdJeUFqS1FNQUlBTWdDNFdGTndNQUlDUWdKQ2tEQUNBRUlBeUZoVGNEQUNBbElDVXBBd0FnQlNBTmhZVTNBd0FnSmlBbUtRTUFJQVlnRG9XRk53TUFJQ2NnSnlrREFDQUhJQStGaFRjREFDQW9JQ2dwQXdBZ0NDQVFoWVUzQXdBTCcpXG4gIHZhciByZWFkeSA9IG51bGxcblxuICB2YXIgbW9kID0ge1xuICAgIGJ1ZmZlcjogd2FzbSxcbiAgICBtZW1vcnk6IG51bGwsXG4gICAgZXhwb3J0czogbnVsbCxcbiAgICByZWFsbG9jOiByZWFsbG9jLFxuICAgIG9ubG9hZDogb25sb2FkXG4gIH1cblxuICBvbmxvYWQoZnVuY3Rpb24gKCkge30pXG5cbiAgcmV0dXJuIG1vZFxuXG4gIGZ1bmN0aW9uIHJlYWxsb2MgKHNpemUpIHtcbiAgICBtb2QuZXhwb3J0cy5tZW1vcnkuZ3JvdyhNYXRoLmNlaWwoTWF0aC5hYnMoc2l6ZSAtIG1vZC5tZW1vcnkubGVuZ3RoKSAvIDY1NTM2KSlcbiAgICBtb2QubWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkobW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubG9hZCAoY2IpIHtcbiAgICBpZiAobW9kLmV4cG9ydHMpIHJldHVybiBjYigpXG5cbiAgICBpZiAocmVhZHkpIHtcbiAgICAgIHJlYWR5LnRoZW4oY2IuYmluZChudWxsLCBudWxsKSkuY2F0Y2goY2IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hc3luYykgdGhyb3cgbmV3IEVycm9yKCdhc3luYycpXG4gICAgICBzZXR1cCh7aW5zdGFuY2U6IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKHdhc20pLCBpbXApfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlYWR5ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUod2FzbSwgaW1wKS50aGVuKHNldHVwKVxuICAgIH1cblxuICAgIG9ubG9hZChjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwICh3KSB7XG4gICAgbW9kLmV4cG9ydHMgPSB3Lmluc3RhbmNlLmV4cG9ydHNcbiAgICBtb2QubWVtb3J5ID0gbW9kLmV4cG9ydHMubWVtb3J5ICYmIG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIgJiYgbmV3IFVpbnQ4QXJyYXkobW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcilcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1VpbnQ4QXJyYXkgKHMpIHtcbiAgaWYgKHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXRvYihzKS5zcGxpdCgnJykubWFwKGNoYXJDb2RlQXQpKVxuICByZXR1cm4gbmV3IChyZXF1aXJlKCdidWYnICsgJ2ZlcicpLkJ1ZmZlcikocywgJ2Jhc2U2NCcpXG59XG5cbmZ1bmN0aW9uIGNoYXJDb2RlQXQgKGMpIHtcbiAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ25hbm9hc3NlcnQnKVxudmFyIHdhc20gPSByZXF1aXJlKCcuL2JsYWtlMmInKSgpXG5cbnZhciBoZWFkID0gNjRcbnZhciBmcmVlTGlzdCA9IFtdXG5cbm1vZHVsZS5leHBvcnRzID0gQmxha2UyYlxudmFyIEJZVEVTX01JTiA9IG1vZHVsZS5leHBvcnRzLkJZVEVTX01JTiA9IDE2XG52YXIgQllURVNfTUFYID0gbW9kdWxlLmV4cG9ydHMuQllURVNfTUFYID0gNjRcbnZhciBCWVRFUyA9IG1vZHVsZS5leHBvcnRzLkJZVEVTID0gMzJcbnZhciBLRVlCWVRFU19NSU4gPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFU19NSU4gPSAxNlxudmFyIEtFWUJZVEVTX01BWCA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTX01BWCA9IDY0XG52YXIgS0VZQllURVMgPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFUyA9IDMyXG52YXIgU0FMVEJZVEVTID0gbW9kdWxlLmV4cG9ydHMuU0FMVEJZVEVTID0gMTZcbnZhciBQRVJTT05BTEJZVEVTID0gbW9kdWxlLmV4cG9ydHMuUEVSU09OQUxCWVRFUyA9IDE2XG5cbmZ1bmN0aW9uIEJsYWtlMmIgKGRpZ2VzdExlbmd0aCwga2V5LCBzYWx0LCBwZXJzb25hbCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJsYWtlMmIpKSByZXR1cm4gbmV3IEJsYWtlMmIoZGlnZXN0TGVuZ3RoLCBrZXksIHNhbHQsIHBlcnNvbmFsLCBub0Fzc2VydClcbiAgaWYgKCEod2FzbSAmJiB3YXNtLmV4cG9ydHMpKSB0aHJvdyBuZXcgRXJyb3IoJ1dBU00gbm90IGxvYWRlZC4gV2FpdCBmb3IgQmxha2UyYi5yZWFkeShjYiknKVxuICBpZiAoIWRpZ2VzdExlbmd0aCkgZGlnZXN0TGVuZ3RoID0gMzJcblxuICBpZiAobm9Bc3NlcnQgIT09IHRydWUpIHtcbiAgICBhc3NlcnQoZGlnZXN0TGVuZ3RoID49IEJZVEVTX01JTiwgJ2RpZ2VzdExlbmd0aCBtdXN0IGJlIGF0IGxlYXN0ICcgKyBCWVRFU19NSU4gKyAnLCB3YXMgZ2l2ZW4gJyArIGRpZ2VzdExlbmd0aClcbiAgICBhc3NlcnQoZGlnZXN0TGVuZ3RoIDw9IEJZVEVTX01BWCwgJ2RpZ2VzdExlbmd0aCBtdXN0IGJlIGF0IG1vc3QgJyArIEJZVEVTX01BWCArICcsIHdhcyBnaXZlbiAnICsgZGlnZXN0TGVuZ3RoKVxuICAgIGlmIChrZXkgIT0gbnVsbCkgYXNzZXJ0KGtleS5sZW5ndGggPj0gS0VZQllURVNfTUlOLCAna2V5IG11c3QgYmUgYXQgbGVhc3QgJyArIEtFWUJZVEVTX01JTiArICcsIHdhcyBnaXZlbiAnICsga2V5Lmxlbmd0aClcbiAgICBpZiAoa2V5ICE9IG51bGwpIGFzc2VydChrZXkubGVuZ3RoIDw9IEtFWUJZVEVTX01BWCwgJ2tleSBtdXN0IGJlIGF0IGxlYXN0ICcgKyBLRVlCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKHNhbHQgIT0gbnVsbCkgYXNzZXJ0KHNhbHQubGVuZ3RoID09PSBTQUxUQllURVMsICdzYWx0IG11c3QgYmUgZXhhY3RseSAnICsgU0FMVEJZVEVTICsgJywgd2FzIGdpdmVuICcgKyBzYWx0Lmxlbmd0aClcbiAgICBpZiAocGVyc29uYWwgIT0gbnVsbCkgYXNzZXJ0KHBlcnNvbmFsLmxlbmd0aCA9PT0gUEVSU09OQUxCWVRFUywgJ3BlcnNvbmFsIG11c3QgYmUgZXhhY3RseSAnICsgUEVSU09OQUxCWVRFUyArICcsIHdhcyBnaXZlbiAnICsgcGVyc29uYWwubGVuZ3RoKVxuICB9XG5cbiAgaWYgKCFmcmVlTGlzdC5sZW5ndGgpIHtcbiAgICBmcmVlTGlzdC5wdXNoKGhlYWQpXG4gICAgaGVhZCArPSAyMTZcbiAgfVxuXG4gIHRoaXMuZGlnZXN0TGVuZ3RoID0gZGlnZXN0TGVuZ3RoXG4gIHRoaXMuZmluYWxpemVkID0gZmFsc2VcbiAgdGhpcy5wb2ludGVyID0gZnJlZUxpc3QucG9wKClcblxuICB3YXNtLm1lbW9yeS5maWxsKDAsIDAsIDY0KVxuICB3YXNtLm1lbW9yeVswXSA9IHRoaXMuZGlnZXN0TGVuZ3RoXG4gIHdhc20ubWVtb3J5WzFdID0ga2V5ID8ga2V5Lmxlbmd0aCA6IDBcbiAgd2FzbS5tZW1vcnlbMl0gPSAxIC8vIGZhbm91dFxuICB3YXNtLm1lbW9yeVszXSA9IDEgLy8gZGVwdGhcblxuICBpZiAoc2FsdCkgd2FzbS5tZW1vcnkuc2V0KHNhbHQsIDMyKVxuICBpZiAocGVyc29uYWwpIHdhc20ubWVtb3J5LnNldChwZXJzb25hbCwgNDgpXG5cbiAgaWYgKHRoaXMucG9pbnRlciArIDIxNiA+IHdhc20ubWVtb3J5Lmxlbmd0aCkgd2FzbS5yZWFsbG9jKHRoaXMucG9pbnRlciArIDIxNikgLy8gd2UgbmVlZCAyMTYgYnl0ZXMgZm9yIHRoZSBzdGF0ZVxuICB3YXNtLmV4cG9ydHMuYmxha2UyYl9pbml0KHRoaXMucG9pbnRlciwgdGhpcy5kaWdlc3RMZW5ndGgpXG5cbiAgaWYgKGtleSkge1xuICAgIHRoaXMudXBkYXRlKGtleSlcbiAgICB3YXNtLm1lbW9yeS5maWxsKDAsIGhlYWQsIGhlYWQgKyBrZXkubGVuZ3RoKSAvLyB3aGl0ZW91dCBrZXlcbiAgICB3YXNtLm1lbW9yeVt0aGlzLnBvaW50ZXIgKyAyMDBdID0gMTI4XG4gIH1cbn1cblxuXG5CbGFrZTJiLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgYXNzZXJ0KHRoaXMuZmluYWxpemVkID09PSBmYWxzZSwgJ0hhc2ggaW5zdGFuY2UgZmluYWxpemVkJylcbiAgYXNzZXJ0KGlucHV0LCAnaW5wdXQgbXVzdCBiZSBUeXBlZEFycmF5IG9yIEJ1ZmZlcicpXG5cbiAgaWYgKGhlYWQgKyBpbnB1dC5sZW5ndGggPiB3YXNtLm1lbW9yeS5sZW5ndGgpIHdhc20ucmVhbGxvYyhoZWFkICsgaW5wdXQubGVuZ3RoKVxuICB3YXNtLm1lbW9yeS5zZXQoaW5wdXQsIGhlYWQpXG4gIHdhc20uZXhwb3J0cy5ibGFrZTJiX3VwZGF0ZSh0aGlzLnBvaW50ZXIsIGhlYWQsIGhlYWQgKyBpbnB1dC5sZW5ndGgpXG4gIHJldHVybiB0aGlzXG59XG5cbkJsYWtlMmIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgYXNzZXJ0KHRoaXMuZmluYWxpemVkID09PSBmYWxzZSwgJ0hhc2ggaW5zdGFuY2UgZmluYWxpemVkJylcbiAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlXG5cbiAgZnJlZUxpc3QucHVzaCh0aGlzLnBvaW50ZXIpXG4gIHdhc20uZXhwb3J0cy5ibGFrZTJiX2ZpbmFsKHRoaXMucG9pbnRlcilcblxuICBpZiAoIWVuYyB8fCBlbmMgPT09ICdiaW5hcnknKSB7XG4gICAgcmV0dXJuIHdhc20ubWVtb3J5LnNsaWNlKHRoaXMucG9pbnRlciArIDEyOCwgdGhpcy5wb2ludGVyICsgMTI4ICsgdGhpcy5kaWdlc3RMZW5ndGgpXG4gIH1cblxuICBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgIHJldHVybiBoZXhTbGljZSh3YXNtLm1lbW9yeSwgdGhpcy5wb2ludGVyICsgMTI4LCB0aGlzLmRpZ2VzdExlbmd0aClcbiAgfVxuXG4gIGFzc2VydChlbmMubGVuZ3RoID49IHRoaXMuZGlnZXN0TGVuZ3RoLCAnaW5wdXQgbXVzdCBiZSBUeXBlZEFycmF5IG9yIEJ1ZmZlcicpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaWdlc3RMZW5ndGg7IGkrKykge1xuICAgIGVuY1tpXSA9IHdhc20ubWVtb3J5W3RoaXMucG9pbnRlciArIDEyOCArIGldXG4gIH1cblxuICByZXR1cm4gZW5jXG59XG5cbi8vIGxpYnNvZGl1bSBjb21wYXRcbkJsYWtlMmIucHJvdG90eXBlLmZpbmFsID0gQmxha2UyYi5wcm90b3R5cGUuZGlnZXN0XG5cbkJsYWtlMmIuV0FTTSA9IHdhc20gJiYgd2FzbS5idWZmZXJcbkJsYWtlMmIuU1VQUE9SVEVEID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSAndW5kZWZpbmVkJ1xuXG5CbGFrZTJiLnJlYWR5ID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICghY2IpIGNiID0gbm9vcFxuICBpZiAoIXdhc20pIHJldHVybiBjYihuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IG5vdCBzdXBwb3J0ZWQnKSlcblxuICAvLyBiYWNrd2FyZHMgY29tcGF0LCBjYW4gYmUgcmVtb3ZlZCBpbiBhIG5ldyBtYWpvclxuICB2YXIgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZWplY3QsIHJlc29sdmUpIHtcbiAgICB3YXNtLm9ubG9hZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXNvbHZlKClcbiAgICAgIGVsc2UgcmVqZWN0KClcbiAgICAgIGNiKGVycilcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBwXG59XG5cbkJsYWtlMmIucHJvdG90eXBlLnJlYWR5ID0gQmxha2UyYi5yZWFkeVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBsZW4pIHtcbiAgdmFyIHN0ciA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHN0ciArPSB0b0hleChidWZbc3RhcnQgKyBpXSlcbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbmFub2Fzc2VydCcpXG52YXIgYjJ3YXNtID0gcmVxdWlyZSgnYmxha2UyYi13YXNtJylcblxuLy8gNjQtYml0IHVuc2lnbmVkIGFkZGl0aW9uXG4vLyBTZXRzIHZbYSxhKzFdICs9IHZbYixiKzFdXG4vLyB2IHNob3VsZCBiZSBhIFVpbnQzMkFycmF5XG5mdW5jdGlvbiBBREQ2NEFBICh2LCBhLCBiKSB7XG4gIHZhciBvMCA9IHZbYV0gKyB2W2JdXG4gIHZhciBvMSA9IHZbYSArIDFdICsgdltiICsgMV1cbiAgaWYgKG8wID49IDB4MTAwMDAwMDAwKSB7XG4gICAgbzErK1xuICB9XG4gIHZbYV0gPSBvMFxuICB2W2EgKyAxXSA9IG8xXG59XG5cbi8vIDY0LWJpdCB1bnNpZ25lZCBhZGRpdGlvblxuLy8gU2V0cyB2W2EsYSsxXSArPSBiXG4vLyBiMCBpcyB0aGUgbG93IDMyIGJpdHMgb2YgYiwgYjEgcmVwcmVzZW50cyB0aGUgaGlnaCAzMiBiaXRzXG5mdW5jdGlvbiBBREQ2NEFDICh2LCBhLCBiMCwgYjEpIHtcbiAgdmFyIG8wID0gdlthXSArIGIwXG4gIGlmIChiMCA8IDApIHtcbiAgICBvMCArPSAweDEwMDAwMDAwMFxuICB9XG4gIHZhciBvMSA9IHZbYSArIDFdICsgYjFcbiAgaWYgKG8wID49IDB4MTAwMDAwMDAwKSB7XG4gICAgbzErK1xuICB9XG4gIHZbYV0gPSBvMFxuICB2W2EgKyAxXSA9IG8xXG59XG5cbi8vIExpdHRsZS1lbmRpYW4gYnl0ZSBhY2Nlc3NcbmZ1bmN0aW9uIEIyQl9HRVQzMiAoYXJyLCBpKSB7XG4gIHJldHVybiAoYXJyW2ldIF5cbiAgKGFycltpICsgMV0gPDwgOCkgXlxuICAoYXJyW2kgKyAyXSA8PCAxNikgXlxuICAoYXJyW2kgKyAzXSA8PCAyNCkpXG59XG5cbi8vIEcgTWl4aW5nIGZ1bmN0aW9uXG4vLyBUaGUgUk9UUnMgYXJlIGlubGluZWQgZm9yIHNwZWVkXG5mdW5jdGlvbiBCMkJfRyAoYSwgYiwgYywgZCwgaXgsIGl5KSB7XG4gIHZhciB4MCA9IG1baXhdXG4gIHZhciB4MSA9IG1baXggKyAxXVxuICB2YXIgeTAgPSBtW2l5XVxuICB2YXIgeTEgPSBtW2l5ICsgMV1cblxuICBBREQ2NEFBKHYsIGEsIGIpIC8vIHZbYSxhKzFdICs9IHZbYixiKzFdIC4uLiBpbiBKUyB3ZSBtdXN0IHN0b3JlIGEgdWludDY0IGFzIHR3byB1aW50MzJzXG4gIEFERDY0QUModiwgYSwgeDAsIHgxKSAvLyB2W2EsIGErMV0gKz0geCAuLi4geDAgaXMgdGhlIGxvdyAzMiBiaXRzIG9mIHgsIHgxIGlzIHRoZSBoaWdoIDMyIGJpdHNcblxuICAvLyB2W2QsZCsxXSA9ICh2W2QsZCsxXSB4b3IgdlthLGErMV0pIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IDMyIGJpdHNcbiAgdmFyIHhvcjAgPSB2W2RdIF4gdlthXVxuICB2YXIgeG9yMSA9IHZbZCArIDFdIF4gdlthICsgMV1cbiAgdltkXSA9IHhvcjFcbiAgdltkICsgMV0gPSB4b3IwXG5cbiAgQURENjRBQSh2LCBjLCBkKVxuXG4gIC8vIHZbYixiKzFdID0gKHZbYixiKzFdIHhvciB2W2MsYysxXSkgcm90YXRlZCByaWdodCBieSAyNCBiaXRzXG4gIHhvcjAgPSB2W2JdIF4gdltjXVxuICB4b3IxID0gdltiICsgMV0gXiB2W2MgKyAxXVxuICB2W2JdID0gKHhvcjAgPj4+IDI0KSBeICh4b3IxIDw8IDgpXG4gIHZbYiArIDFdID0gKHhvcjEgPj4+IDI0KSBeICh4b3IwIDw8IDgpXG5cbiAgQURENjRBQSh2LCBhLCBiKVxuICBBREQ2NEFDKHYsIGEsIHkwLCB5MSlcblxuICAvLyB2W2QsZCsxXSA9ICh2W2QsZCsxXSB4b3IgdlthLGErMV0pIHJvdGF0ZWQgcmlnaHQgYnkgMTYgYml0c1xuICB4b3IwID0gdltkXSBeIHZbYV1cbiAgeG9yMSA9IHZbZCArIDFdIF4gdlthICsgMV1cbiAgdltkXSA9ICh4b3IwID4+PiAxNikgXiAoeG9yMSA8PCAxNilcbiAgdltkICsgMV0gPSAoeG9yMSA+Pj4gMTYpIF4gKHhvcjAgPDwgMTYpXG5cbiAgQURENjRBQSh2LCBjLCBkKVxuXG4gIC8vIHZbYixiKzFdID0gKHZbYixiKzFdIHhvciB2W2MsYysxXSkgcm90YXRlZCByaWdodCBieSA2MyBiaXRzXG4gIHhvcjAgPSB2W2JdIF4gdltjXVxuICB4b3IxID0gdltiICsgMV0gXiB2W2MgKyAxXVxuICB2W2JdID0gKHhvcjEgPj4+IDMxKSBeICh4b3IwIDw8IDEpXG4gIHZbYiArIDFdID0gKHhvcjAgPj4+IDMxKSBeICh4b3IxIDw8IDEpXG59XG5cbi8vIEluaXRpYWxpemF0aW9uIFZlY3RvclxudmFyIEJMQUtFMkJfSVYzMiA9IG5ldyBVaW50MzJBcnJheShbXG4gIDB4RjNCQ0M5MDgsIDB4NkEwOUU2NjcsIDB4ODRDQUE3M0IsIDB4QkI2N0FFODUsXG4gIDB4RkU5NEY4MkIsIDB4M0M2RUYzNzIsIDB4NUYxRDM2RjEsIDB4QTU0RkY1M0EsXG4gIDB4QURFNjgyRDEsIDB4NTEwRTUyN0YsIDB4MkIzRTZDMUYsIDB4OUIwNTY4OEMsXG4gIDB4RkI0MUJENkIsIDB4MUY4M0Q5QUIsIDB4MTM3RTIxNzksIDB4NUJFMENEMTlcbl0pXG5cbnZhciBTSUdNQTggPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gIDcsIDksIDMsIDEsIDEzLCAxMiwgMTEsIDE0LCAyLCA2LCA1LCAxMCwgNCwgMCwgMTUsIDgsXG4gIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gIDEyLCA1LCAxLCAxNSwgMTQsIDEzLCA0LCAxMCwgMCwgNywgNiwgMywgOSwgMiwgOCwgMTEsXG4gIDEzLCAxMSwgNywgMTQsIDEyLCAxLCAzLCA5LCA1LCAwLCAxNSwgNCwgOCwgNiwgMiwgMTAsXG4gIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gIDEwLCAyLCA4LCA0LCA3LCA2LCAxLCA1LCAxNSwgMTEsIDksIDE0LCAzLCAxMiwgMTMsIDAsXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDNcbl1cblxuLy8gVGhlc2UgYXJlIG9mZnNldHMgaW50byBhIHVpbnQ2NCBidWZmZXIuXG4vLyBNdWx0aXBseSB0aGVtIGFsbCBieSAyIHRvIG1ha2UgdGhlbSBvZmZzZXRzIGludG8gYSB1aW50MzIgYnVmZmVyLFxuLy8gYmVjYXVzZSB0aGlzIGlzIEphdmFzY3JpcHQgYW5kIHdlIGRvbid0IGhhdmUgdWludDY0c1xudmFyIFNJR01BODIgPSBuZXcgVWludDhBcnJheShTSUdNQTgubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICogMiB9KSlcblxuLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24uICdsYXN0JyBmbGFnIGluZGljYXRlcyBsYXN0IGJsb2NrLlxuLy8gTm90ZSB3ZSdyZSByZXByZXNlbnRpbmcgMTYgdWludDY0cyBhcyAzMiB1aW50MzJzXG52YXIgdiA9IG5ldyBVaW50MzJBcnJheSgzMilcbnZhciBtID0gbmV3IFVpbnQzMkFycmF5KDMyKVxuZnVuY3Rpb24gYmxha2UyYkNvbXByZXNzIChjdHgsIGxhc3QpIHtcbiAgdmFyIGkgPSAwXG5cbiAgLy8gaW5pdCB3b3JrIHZhcmlhYmxlc1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHZbaV0gPSBjdHguaFtpXVxuICAgIHZbaSArIDE2XSA9IEJMQUtFMkJfSVYzMltpXVxuICB9XG5cbiAgLy8gbG93IDY0IGJpdHMgb2Ygb2Zmc2V0XG4gIHZbMjRdID0gdlsyNF0gXiBjdHgudFxuICB2WzI1XSA9IHZbMjVdIF4gKGN0eC50IC8gMHgxMDAwMDAwMDApXG4gIC8vIGhpZ2ggNjQgYml0cyBub3Qgc3VwcG9ydGVkLCBvZmZzZXQgbWF5IG5vdCBiZSBoaWdoZXIgdGhhbiAyKio1My0xXG5cbiAgLy8gbGFzdCBibG9jayBmbGFnIHNldCA/XG4gIGlmIChsYXN0KSB7XG4gICAgdlsyOF0gPSB+dlsyOF1cbiAgICB2WzI5XSA9IH52WzI5XVxuICB9XG5cbiAgLy8gZ2V0IGxpdHRsZS1lbmRpYW4gd29yZHNcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBtW2ldID0gQjJCX0dFVDMyKGN0eC5iLCA0ICogaSlcbiAgfVxuXG4gIC8vIHR3ZWx2ZSByb3VuZHMgb2YgbWl4aW5nXG4gIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgQjJCX0coMCwgOCwgMTYsIDI0LCBTSUdNQTgyW2kgKiAxNiArIDBdLCBTSUdNQTgyW2kgKiAxNiArIDFdKVxuICAgIEIyQl9HKDIsIDEwLCAxOCwgMjYsIFNJR01BODJbaSAqIDE2ICsgMl0sIFNJR01BODJbaSAqIDE2ICsgM10pXG4gICAgQjJCX0coNCwgMTIsIDIwLCAyOCwgU0lHTUE4MltpICogMTYgKyA0XSwgU0lHTUE4MltpICogMTYgKyA1XSlcbiAgICBCMkJfRyg2LCAxNCwgMjIsIDMwLCBTSUdNQTgyW2kgKiAxNiArIDZdLCBTSUdNQTgyW2kgKiAxNiArIDddKVxuICAgIEIyQl9HKDAsIDEwLCAyMCwgMzAsIFNJR01BODJbaSAqIDE2ICsgOF0sIFNJR01BODJbaSAqIDE2ICsgOV0pXG4gICAgQjJCX0coMiwgMTIsIDIyLCAyNCwgU0lHTUE4MltpICogMTYgKyAxMF0sIFNJR01BODJbaSAqIDE2ICsgMTFdKVxuICAgIEIyQl9HKDQsIDE0LCAxNiwgMjYsIFNJR01BODJbaSAqIDE2ICsgMTJdLCBTSUdNQTgyW2kgKiAxNiArIDEzXSlcbiAgICBCMkJfRyg2LCA4LCAxOCwgMjgsIFNJR01BODJbaSAqIDE2ICsgMTRdLCBTSUdNQTgyW2kgKiAxNiArIDE1XSlcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgY3R4LmhbaV0gPSBjdHguaFtpXSBeIHZbaV0gXiB2W2kgKyAxNl1cbiAgfVxufVxuXG4vLyByZXVzYWJsZSBwYXJhbWV0ZXJfYmxvY2tcbnZhciBwYXJhbWV0ZXJfYmxvY2sgPSBuZXcgVWludDhBcnJheShbXG4gIDAsIDAsIDAsIDAsICAgICAgLy8gIDA6IG91dGxlbiwga2V5bGVuLCBmYW5vdXQsIGRlcHRoXG4gIDAsIDAsIDAsIDAsICAgICAgLy8gIDQ6IGxlYWYgbGVuZ3RoLCBzZXF1ZW50aWFsIG1vZGVcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAgODogbm9kZSBvZmZzZXRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAxMjogbm9kZSBvZmZzZXRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAxNjogbm9kZSBkZXB0aCwgaW5uZXIgbGVuZ3RoLCByZnVcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAyMDogcmZ1XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMjQ6IHJmdVxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDI4OiByZnVcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAzMjogc2FsdFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDM2OiBzYWx0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gNDA6IHNhbHRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA0NDogc2FsdFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDQ4OiBwZXJzb25hbFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDUyOiBwZXJzb25hbFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDU2OiBwZXJzb25hbFxuICAwLCAwLCAwLCAwICAgICAgIC8vIDYwOiBwZXJzb25hbFxuXSlcblxuLy8gQ3JlYXRlcyBhIEJMQUtFMmIgaGFzaGluZyBjb250ZXh0XG4vLyBSZXF1aXJlcyBhbiBvdXRwdXQgbGVuZ3RoIGJldHdlZW4gMSBhbmQgNjQgYnl0ZXNcbi8vIFRha2VzIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkga2V5XG5mdW5jdGlvbiBCbGFrZTJiIChvdXRsZW4sIGtleSwgc2FsdCwgcGVyc29uYWwpIHtcbiAgLy8gemVybyBvdXQgcGFyYW1ldGVyX2Jsb2NrIGJlZm9yZSB1c2FnZVxuICBwYXJhbWV0ZXJfYmxvY2suZmlsbCgwKVxuICAvLyBzdGF0ZSwgJ3BhcmFtIGJsb2NrJ1xuXG4gIHRoaXMuYiA9IG5ldyBVaW50OEFycmF5KDEyOClcbiAgdGhpcy5oID0gbmV3IFVpbnQzMkFycmF5KDE2KVxuICB0aGlzLnQgPSAwIC8vIGlucHV0IGNvdW50XG4gIHRoaXMuYyA9IDAgLy8gcG9pbnRlciB3aXRoaW4gYnVmZmVyXG4gIHRoaXMub3V0bGVuID0gb3V0bGVuIC8vIG91dHB1dCBsZW5ndGggaW4gYnl0ZXNcblxuICBwYXJhbWV0ZXJfYmxvY2tbMF0gPSBvdXRsZW5cbiAgaWYgKGtleSkgcGFyYW1ldGVyX2Jsb2NrWzFdID0ga2V5Lmxlbmd0aFxuICBwYXJhbWV0ZXJfYmxvY2tbMl0gPSAxIC8vIGZhbm91dFxuICBwYXJhbWV0ZXJfYmxvY2tbM10gPSAxIC8vIGRlcHRoXG5cbiAgaWYgKHNhbHQpIHBhcmFtZXRlcl9ibG9jay5zZXQoc2FsdCwgMzIpXG4gIGlmIChwZXJzb25hbCkgcGFyYW1ldGVyX2Jsb2NrLnNldChwZXJzb25hbCwgNDgpXG5cbiAgLy8gaW5pdGlhbGl6ZSBoYXNoIHN0YXRlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHRoaXMuaFtpXSA9IEJMQUtFMkJfSVYzMltpXSBeIEIyQl9HRVQzMihwYXJhbWV0ZXJfYmxvY2ssIGkgKiA0KVxuICB9XG5cbiAgLy8ga2V5IHRoZSBoYXNoLCBpZiBhcHBsaWNhYmxlXG4gIGlmIChrZXkpIHtcbiAgICBibGFrZTJiVXBkYXRlKHRoaXMsIGtleSlcbiAgICAvLyBhdCB0aGUgZW5kXG4gICAgdGhpcy5jID0gMTI4XG4gIH1cbn1cblxuQmxha2UyYi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGFzc2VydChpbnB1dCAhPSBudWxsLCAnaW5wdXQgbXVzdCBiZSBVaW50OEFycmF5IG9yIEJ1ZmZlcicpXG4gIGJsYWtlMmJVcGRhdGUodGhpcywgaW5wdXQpXG4gIHJldHVybiB0aGlzXG59XG5cbkJsYWtlMmIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgdmFyIGJ1ZiA9ICghb3V0IHx8IG91dCA9PT0gJ2JpbmFyeScgfHwgb3V0ID09PSAnaGV4JykgPyBuZXcgVWludDhBcnJheSh0aGlzLm91dGxlbikgOiBvdXRcbiAgYXNzZXJ0KGJ1Zi5sZW5ndGggPj0gdGhpcy5vdXRsZW4sICdvdXQgbXVzdCBoYXZlIGF0IGxlYXN0IG91dGxlbiBieXRlcyBvZiBzcGFjZScpXG4gIGJsYWtlMmJGaW5hbCh0aGlzLCBidWYpXG4gIGlmIChvdXQgPT09ICdoZXgnKSByZXR1cm4gaGV4U2xpY2UoYnVmKVxuICByZXR1cm4gYnVmXG59XG5cbkJsYWtlMmIucHJvdG90eXBlLmZpbmFsID0gQmxha2UyYi5wcm90b3R5cGUuZGlnZXN0XG5cbkJsYWtlMmIucmVhZHkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgYjJ3YXNtLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICBjYigpIC8vIGlnbm9yZSB0aGUgZXJyb3JcbiAgfSlcbn1cblxuLy8gVXBkYXRlcyBhIEJMQUtFMmIgc3RyZWFtaW5nIGhhc2hcbi8vIFJlcXVpcmVzIGhhc2ggY29udGV4dCBhbmQgVWludDhBcnJheSAoYnl0ZSBhcnJheSlcbmZ1bmN0aW9uIGJsYWtlMmJVcGRhdGUgKGN0eCwgaW5wdXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjdHguYyA9PT0gMTI4KSB7IC8vIGJ1ZmZlciBmdWxsID9cbiAgICAgIGN0eC50ICs9IGN0eC5jIC8vIGFkZCBjb3VudGVyc1xuICAgICAgYmxha2UyYkNvbXByZXNzKGN0eCwgZmFsc2UpIC8vIGNvbXByZXNzIChub3QgbGFzdClcbiAgICAgIGN0eC5jID0gMCAvLyBjb3VudGVyIHRvIHplcm9cbiAgICB9XG4gICAgY3R4LmJbY3R4LmMrK10gPSBpbnB1dFtpXVxuICB9XG59XG5cbi8vIENvbXBsZXRlcyBhIEJMQUtFMmIgc3RyZWFtaW5nIGhhc2hcbi8vIFJldHVybnMgYSBVaW50OEFycmF5IGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgZGlnZXN0XG5mdW5jdGlvbiBibGFrZTJiRmluYWwgKGN0eCwgb3V0KSB7XG4gIGN0eC50ICs9IGN0eC5jIC8vIG1hcmsgbGFzdCBibG9jayBvZmZzZXRcblxuICB3aGlsZSAoY3R4LmMgPCAxMjgpIHsgLy8gZmlsbCB1cCB3aXRoIHplcm9zXG4gICAgY3R4LmJbY3R4LmMrK10gPSAwXG4gIH1cbiAgYmxha2UyYkNvbXByZXNzKGN0eCwgdHJ1ZSkgLy8gZmluYWwgYmxvY2sgZmxhZyA9IDFcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGN0eC5vdXRsZW47IGkrKykge1xuICAgIG91dFtpXSA9IGN0eC5oW2kgPj4gMl0gPj4gKDggKiAoaSAmIDMpKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Zikge1xuICB2YXIgc3RyID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHN0ciArPSB0b0hleChidWZbaV0pXG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG52YXIgUHJvdG8gPSBCbGFrZTJiXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlSGFzaCAob3V0bGVuLCBrZXksIHNhbHQsIHBlcnNvbmFsLCBub0Fzc2VydCkge1xuICBpZiAobm9Bc3NlcnQgIT09IHRydWUpIHtcbiAgICBhc3NlcnQob3V0bGVuID49IEJZVEVTX01JTiwgJ291dGxlbiBtdXN0IGJlIGF0IGxlYXN0ICcgKyBCWVRFU19NSU4gKyAnLCB3YXMgZ2l2ZW4gJyArIG91dGxlbilcbiAgICBhc3NlcnQob3V0bGVuIDw9IEJZVEVTX01BWCwgJ291dGxlbiBtdXN0IGJlIGF0IG1vc3QgJyArIEJZVEVTX01BWCArICcsIHdhcyBnaXZlbiAnICsgb3V0bGVuKVxuICAgIGlmIChrZXkgIT0gbnVsbCkgYXNzZXJ0KGtleS5sZW5ndGggPj0gS0VZQllURVNfTUlOLCAna2V5IG11c3QgYmUgYXQgbGVhc3QgJyArIEtFWUJZVEVTX01JTiArICcsIHdhcyBnaXZlbiAnICsga2V5Lmxlbmd0aClcbiAgICBpZiAoa2V5ICE9IG51bGwpIGFzc2VydChrZXkubGVuZ3RoIDw9IEtFWUJZVEVTX01BWCwgJ2tleSBtdXN0IGJlIGF0IGxlYXN0ICcgKyBLRVlCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKHNhbHQgIT0gbnVsbCkgYXNzZXJ0KHNhbHQubGVuZ3RoID09PSBTQUxUQllURVMsICdzYWx0IG11c3QgYmUgZXhhY3RseSAnICsgU0FMVEJZVEVTICsgJywgd2FzIGdpdmVuICcgKyBzYWx0Lmxlbmd0aClcbiAgICBpZiAocGVyc29uYWwgIT0gbnVsbCkgYXNzZXJ0KHBlcnNvbmFsLmxlbmd0aCA9PT0gUEVSU09OQUxCWVRFUywgJ3BlcnNvbmFsIG11c3QgYmUgZXhhY3RseSAnICsgUEVSU09OQUxCWVRFUyArICcsIHdhcyBnaXZlbiAnICsgcGVyc29uYWwubGVuZ3RoKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm90byhvdXRsZW4sIGtleSwgc2FsdCwgcGVyc29uYWwpXG59XG5cbm1vZHVsZS5leHBvcnRzLnJlYWR5ID0gZnVuY3Rpb24gKGNiKSB7XG4gIGIyd2FzbS5yZWFkeShmdW5jdGlvbiAoKSB7IC8vIGlnbm9yZSBlcnJvcnNcbiAgICBjYigpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzLldBU01fU1VQUE9SVEVEID0gYjJ3YXNtLlNVUFBPUlRFRFxubW9kdWxlLmV4cG9ydHMuV0FTTV9MT0FERUQgPSBmYWxzZVxuXG52YXIgQllURVNfTUlOID0gbW9kdWxlLmV4cG9ydHMuQllURVNfTUlOID0gMTZcbnZhciBCWVRFU19NQVggPSBtb2R1bGUuZXhwb3J0cy5CWVRFU19NQVggPSA2NFxudmFyIEJZVEVTID0gbW9kdWxlLmV4cG9ydHMuQllURVMgPSAzMlxudmFyIEtFWUJZVEVTX01JTiA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTX01JTiA9IDE2XG52YXIgS0VZQllURVNfTUFYID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVNfTUFYID0gNjRcbnZhciBLRVlCWVRFUyA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTID0gMzJcbnZhciBTQUxUQllURVMgPSBtb2R1bGUuZXhwb3J0cy5TQUxUQllURVMgPSAxNlxudmFyIFBFUlNPTkFMQllURVMgPSBtb2R1bGUuZXhwb3J0cy5QRVJTT05BTEJZVEVTID0gMTZcblxuYjJ3YXNtLnJlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKCFlcnIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cy5XQVNNX0xPQURFRCA9IHRydWVcbiAgICBQcm90byA9IGIyd2FzbVxuICB9XG59KVxuIiwiIiwiZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxuXG4gIGlmIChCdWZmZXIuYWxsb2NVbnNhZmUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFsbG9jVW5zYWZlXG4iLCJ2YXIgYnVmZmVyRmlsbCA9IHJlcXVpcmUoJ2J1ZmZlci1maWxsJylcbnZhciBhbGxvY1Vuc2FmZSA9IHJlcXVpcmUoJ2J1ZmZlci1hbGxvYy11bnNhZmUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5hbGxvYykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgYnVmZmVyID0gYWxsb2NVbnNhZmUoc2l6ZSlcblxuICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYnVmZmVyRmlsbChidWZmZXIsIDApXG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gYnVmZmVyRmlsbChidWZmZXIsIGZpbGwsIGVuY29kaW5nKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYSwgYikge1xuXHRpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpO1xuXHR9XG5cblx0aWYgKGEgPT09IGIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICh0eXBlb2YgYS5lcXVhbHMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gYS5lcXVhbHMoYik7XG5cdH1cblxuXHRpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKGFbaV0gIT09IGJbaV0pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIvKiBOb2RlLmpzIDYuNC4wIGFuZCB1cCBoYXMgZnVsbCBzdXBwb3J0ICovXG52YXIgaGFzRnVsbFN1cHBvcnQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoJ2xhdGluMScpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jID8gQnVmZmVyLmFsbG9jKDQpIDogbmV3IEJ1ZmZlcig0KVxuXG4gICAgYnVmLmZpbGwoJ2FiJywgJ3VjczInKVxuXG4gICAgcmV0dXJuIChidWYudG9TdHJpbmcoJ2hleCcpID09PSAnNjEwMDYyMDAnKVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0oKSlcblxuZnVuY3Rpb24gaXNTaW5nbGVCeXRlICh2YWwpIHtcbiAgcmV0dXJuICh2YWwubGVuZ3RoID09PSAxICYmIHZhbC5jaGFyQ29kZUF0KDApIDwgMjU2KVxufVxuXG5mdW5jdGlvbiBmaWxsV2l0aE51bWJlciAoYnVmZmVyLCB2YWwsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmIChlbmQgPiBzdGFydCkge1xuICAgIGJ1ZmZlci5maWxsKHZhbCwgc3RhcnQsIGVuZClcbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gZmlsbFdpdGhCdWZmZXIgKGJ1ZmZlciwgdmFsLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gYnVmZmVyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBidWZmZXIubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgdmFyIHBvcyA9IHN0YXJ0XG4gIHZhciBsZW4gPSB2YWwubGVuZ3RoXG4gIHdoaWxlIChwb3MgPD0gKGVuZCAtIGxlbikpIHtcbiAgICB2YWwuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gbGVuXG4gIH1cblxuICBpZiAocG9zICE9PSBlbmQpIHtcbiAgICB2YWwuY29weShidWZmZXIsIHBvcywgMCwgZW5kIC0gcG9zKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBmaWxsIChidWZmZXIsIHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgaWYgKGhhc0Z1bGxTdXBwb3J0KSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5maWxsKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZmlsbFdpdGhOdW1iZXIoYnVmZmVyLCB2YWwsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSBidWZmZXIubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IGJ1ZmZlci5sZW5ndGhcbiAgICB9XG5cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICBlbmNvZGluZyA9ICdiaW5hcnknXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cblxuICAgIGlmICh2YWwgPT09ICcnKSB7XG4gICAgICByZXR1cm4gZmlsbFdpdGhOdW1iZXIoYnVmZmVyLCAwLCBzdGFydCwgZW5kKVxuICAgIH1cblxuICAgIGlmIChpc1NpbmdsZUJ5dGUodmFsKSkge1xuICAgICAgcmV0dXJuIGZpbGxXaXRoTnVtYmVyKGJ1ZmZlciwgdmFsLmNoYXJDb2RlQXQoMCksIHN0YXJ0LCBlbmQpXG4gICAgfVxuXG4gICAgdmFsID0gbmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIGZpbGxXaXRoQnVmZmVyKGJ1ZmZlciwgdmFsLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLy8gT3RoZXIgdmFsdWVzIChlLmcuIHVuZGVmaW5lZCwgYm9vbGVhbiwgb2JqZWN0KSByZXN1bHRzIGluIHplcm8tZmlsbFxuICByZXR1cm4gZmlsbFdpdGhOdW1iZXIoYnVmZmVyLCAwLCBzdGFydCwgZW5kKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbGxcbiIsInZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxudmFyIGlzTW9kZXJuID0gKFxuICB0eXBlb2YgQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIEJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nXG4pXG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIgKGlucHV0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGlucHV0KS5zbGljZSg4LCAtMSkgPT09ICdBcnJheUJ1ZmZlcidcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChvYmosIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBieXRlT2Zmc2V0ID4+Pj0gMFxuXG4gIHZhciBtYXhMZW5ndGggPSBvYmouYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXRcblxuICBpZiAobWF4TGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kc1wiKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gbWF4TGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID4+Pj0gMFxuXG4gICAgaWYgKGxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInbGVuZ3RoJyBpcyBvdXQgb2YgYm91bmRzXCIpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzTW9kZXJuXG4gICAgPyBCdWZmZXIuZnJvbShvYmouc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGxlbmd0aCkpXG4gICAgOiBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KG9iai5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgbGVuZ3RoKSkpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgcmV0dXJuIGlzTW9kZXJuXG4gICAgPyBCdWZmZXIuZnJvbShzdHJpbmcsIGVuY29kaW5nKVxuICAgIDogbmV3IEJ1ZmZlcihzdHJpbmcsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBidWZmZXJGcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gaXNNb2Rlcm5cbiAgICA/IEJ1ZmZlci5mcm9tKHZhbHVlKVxuICAgIDogbmV3IEJ1ZmZlcih2YWx1ZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWZmZXJGcm9tXG4iLCJ2YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBidWZmZXJGcm9tID0gcmVxdWlyZSgnYnVmZmVyLWZyb20nKVxuXG52YXIgU0lHTkFMX0ZMVVNIID0gYnVmZmVyRnJvbShbMF0pXG5cbnZhciBCdWxrID0gZnVuY3Rpb24gKG9wdHMsIHdvcmtlciwgZmx1c2gpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1bGspKSByZXR1cm4gbmV3IEJ1bGsob3B0cywgd29ya2VyLCBmbHVzaClcblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbHVzaCA9IHdvcmtlclxuICAgIHdvcmtlciA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuXG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMsIG9wdHMpXG4gIHRoaXMuX3dvcmtlciA9IHdvcmtlclxuICB0aGlzLl9mbHVzaCA9IGZsdXNoXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoQnVsaywgc3RyZWFtLldyaXRhYmxlKVxuXG5CdWxrLm9iaiA9IGZ1bmN0aW9uIChvcHRzLCB3b3JrZXIsIGZsdXNoKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIEJ1bGsub2JqKG51bGwsIG9wdHMsIHdvcmtlcilcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgb3B0cy5vYmplY3RNb2RlID0gdHJ1ZVxuICByZXR1cm4gbmV3IEJ1bGsob3B0cywgd29ya2VyLCBmbHVzaClcbn1cblxuQnVsay5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuYywgY2IpIHtcbiAgaWYgKCF0aGlzLl9mbHVzaCkgcmV0dXJuIHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5lbmQobnVsbCwgbnVsbCwgZGF0YSlcbiAgaWYgKHR5cGVvZiBlbmMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmVuZChkYXRhLCBudWxsLCBlbmMpXG4gIGlmIChkYXRhKSB0aGlzLndyaXRlKGRhdGEpXG4gIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcpIHRoaXMud3JpdGUoU0lHTkFMX0ZMVVNIKVxuICByZXR1cm4gc3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbCh0aGlzLCBjYilcbn1cblxuQnVsay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuQnVsay5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYywgY2IpIHtcbiAgaWYgKGRhdGEgPT09IFNJR05BTF9GTFVTSCkgdGhpcy5fZmx1c2goY2IpXG4gIGVsc2UgdGhpcy5fd29ya2VyKFtkYXRhXSwgY2IpXG59XG5cbkJ1bGsucHJvdG90eXBlLl93cml0ZXYgPSBmdW5jdGlvbiAoYmF0Y2gsIGNiKSB7XG4gIHZhciBsZW4gPSBiYXRjaC5sZW5ndGhcbiAgaWYgKGJhdGNoW2JhdGNoLmxlbmd0aCAtIDFdLmNodW5rID09PSBTSUdOQUxfRkxVU0gpIHtcbiAgICBjYiA9IHRoaXMuX2ZsdXNoZXIoY2IpXG4gICAgaWYgKCEtLWxlbikgcmV0dXJuIGNiKClcbiAgfVxuICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJyW2ldID0gYmF0Y2hbaV0uY2h1bmtcbiAgdGhpcy5fd29ya2VyKGFyciwgY2IpXG59XG5cbkJ1bGsucHJvdG90eXBlLl9mbHVzaGVyID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5fZmx1c2goY2IpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWxrXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNvZGVjc1xuXG52YXIgZnJvbUJ1ZmZlciA9IChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tKVxuICA/IEJ1ZmZlci5mcm9tXG4gIDogQnVmZmVyXG5cbmNvZGVjcy5hc2NpaSA9IGNyZWF0ZVN0cmluZygnYXNjaWknKVxuY29kZWNzLnV0ZjggPSBjcmVhdGVTdHJpbmcoJ3V0Zi04JylcbmNvZGVjcy5oZXggPSBjcmVhdGVTdHJpbmcoJ2hleCcpXG5jb2RlY3MuYmFzZTY0ID0gY3JlYXRlU3RyaW5nKCdiYXNlNjQnKVxuY29kZWNzLnVjczIgPSBjcmVhdGVTdHJpbmcoJ3VjczInKVxuY29kZWNzLnV0ZjE2bGUgPSBjcmVhdGVTdHJpbmcoJ3V0ZjE2bGUnKVxuY29kZWNzLm5kanNvbiA9IGNyZWF0ZUpTT04odHJ1ZSlcbmNvZGVjcy5qc29uID0gY3JlYXRlSlNPTihmYWxzZSlcbmNvZGVjcy5iaW5hcnkgPSB7XG4gIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlQmluYXJ5IChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgPyBmcm9tQnVmZmVyKG9iaiwgJ3V0Zi04JykgOiBvYmpcbiAgfSxcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGVCaW5hcnkgKGJ1Zikge1xuICAgIHJldHVybiBidWZcbiAgfVxufVxuXG5mdW5jdGlvbiBjb2RlY3MgKGZtdCkge1xuICBpZiAodHlwZW9mIGZtdCA9PT0gJ29iamVjdCcgJiYgZm10ICYmIGZtdC5lbmNvZGUgJiYgZm10LmRlY29kZSkgcmV0dXJuIGZtdFxuXG4gIHN3aXRjaCAoZm10KSB7XG4gICAgY2FzZSAnbmRqc29uJzogcmV0dXJuIGNvZGVjcy5uZGpzb25cbiAgICBjYXNlICdqc29uJzogcmV0dXJuIGNvZGVjcy5qc29uXG4gICAgY2FzZSAnYXNjaWknOiByZXR1cm4gY29kZWNzLmFzY2lpXG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ3V0ZjgnOiByZXR1cm4gY29kZWNzLnV0ZjhcbiAgICBjYXNlICdoZXgnOiByZXR1cm4gY29kZWNzLmhleFxuICAgIGNhc2UgJ2Jhc2U2NCc6IHJldHVybiBjb2RlY3MuYmFzZTY0XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3VjczInOiByZXR1cm4gY29kZWNzLnVjczJcbiAgICBjYXNlICd1dGYxNi1sZSc6XG4gICAgY2FzZSAndXRmMTZsZSc6IHJldHVybiBjb2RlY3MudXRmMTZsZVxuICB9XG5cbiAgcmV0dXJuIGNvZGVjcy5iaW5hcnlcbn1cblxuZnVuY3Rpb24gY3JlYXRlSlNPTiAobmV3bGluZSkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogbmV3bGluZSA/IGVuY29kZU5ESlNPTiA6IGVuY29kZUpTT04sXG4gICAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGVKU09OIChidWYpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGJ1Zi50b1N0cmluZygpKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZUpTT04gKHZhbCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHZhbCkpXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVOREpTT04gKHZhbCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHZhbCkgKyAnXFxuJylcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmcgKHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZVN0cmluZyAodmFsKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHZhbCA9IHZhbC50b1N0cmluZygpXG4gICAgICByZXR1cm4gZnJvbUJ1ZmZlcih2YWwsIHR5cGUpXG4gICAgfSxcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZVN0cmluZyAoYnVmKSB7XG4gICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKHR5cGUpXG4gICAgfVxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGxcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgb2JqZWN0S2V5c1BvbHlmaWxsXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGZ1bmN0aW9uQmluZFBvbHlmaWxsXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX2V2ZW50cycpKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbnZhciBoYXNEZWZpbmVQcm9wZXJ0eTtcbnRyeSB7XG4gIHZhciBvID0ge307XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7XG4gIGhhc0RlZmluZVByb3BlcnR5ID0gby54ID09PSAwO1xufSBjYXRjaCAoZXJyKSB7IGhhc0RlZmluZVByb3BlcnR5ID0gZmFsc2UgfVxuaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgcG9zaXRpdmUgbnVtYmVyICh3aG9zZSB2YWx1ZSBpcyB6ZXJvIG9yXG4gICAgICAvLyBncmVhdGVyIGFuZCBub3QgYSBOYU4pLlxuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVmYXVsdE1heExpc3RlbmVyc1wiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gZGVmYXVsdE1heExpc3RlbmVycztcbn1cblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgY2FzZSAxOlxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnIFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0LicpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignJXM6ICVzJywgdy5uYW1lLCB3Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IGJpbmQuY2FsbChvbmNlV3JhcHBlciwgc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb2JqZWN0Q3JlYXRlUG9seWZpbGwocHJvdG8pIHtcbiAgdmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXR1cm4gbmV3IEY7XG59XG5mdW5jdGlvbiBvYmplY3RLZXlzUG9seWZpbGwob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHtcbiAgICBrZXlzLnB1c2goayk7XG4gIH1cbiAgcmV0dXJuIGs7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KSB7XG4gIHZhciBmbiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCJleHBvcnRzLmZ1bGxSb290cyA9IGZ1bmN0aW9uIChpbmRleCwgcmVzdWx0KSB7XG4gIGlmIChpbmRleCAmIDEpIHRocm93IG5ldyBFcnJvcignWW91IGNhbiBvbmx5IGxvb2sgdXAgcm9vdHMgZm9yIGRlcHRoKDApIGJsb2NrcycpXG4gIGlmICghcmVzdWx0KSByZXN1bHQgPSBbXVxuXG4gIGluZGV4IC89IDJcblxuICB2YXIgb2Zmc2V0ID0gMFxuICB2YXIgZmFjdG9yID0gMVxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFpbmRleCkgcmV0dXJuIHJlc3VsdFxuICAgIHdoaWxlIChmYWN0b3IgKiAyIDw9IGluZGV4KSBmYWN0b3IgKj0gMlxuICAgIHJlc3VsdC5wdXNoKG9mZnNldCArIGZhY3RvciAtIDEpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgMiAqIGZhY3RvclxuICAgIGluZGV4IC09IGZhY3RvclxuICAgIGZhY3RvciA9IDFcbiAgfVxufVxuXG5leHBvcnRzLmRlcHRoID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHZhciBkZXB0aCA9IDBcblxuICBpbmRleCArPSAxXG4gIHdoaWxlICghKGluZGV4ICYgMSkpIHtcbiAgICBkZXB0aCsrXG4gICAgaW5kZXggPSByaWdodFNoaWZ0KGluZGV4KVxuICB9XG5cbiAgcmV0dXJuIGRlcHRoXG59XG5cbmV4cG9ydHMuc2libGluZyA9IGZ1bmN0aW9uIChpbmRleCwgZGVwdGgpIHtcbiAgaWYgKCFkZXB0aCkgZGVwdGggPSBleHBvcnRzLmRlcHRoKGluZGV4KVxuICB2YXIgb2Zmc2V0ID0gZXhwb3J0cy5vZmZzZXQoaW5kZXgsIGRlcHRoKVxuXG4gIHJldHVybiBleHBvcnRzLmluZGV4KGRlcHRoLCBvZmZzZXQgJiAxID8gb2Zmc2V0IC0gMSA6IG9mZnNldCArIDEpXG59XG5cbmV4cG9ydHMucGFyZW50ID0gZnVuY3Rpb24gKGluZGV4LCBkZXB0aCkge1xuICBpZiAoIWRlcHRoKSBkZXB0aCA9IGV4cG9ydHMuZGVwdGgoaW5kZXgpXG4gIHZhciBvZmZzZXQgPSBleHBvcnRzLm9mZnNldChpbmRleCwgZGVwdGgpXG5cbiAgcmV0dXJuIGV4cG9ydHMuaW5kZXgoZGVwdGggKyAxLCByaWdodFNoaWZ0KG9mZnNldCkpXG59XG5cbmV4cG9ydHMubGVmdENoaWxkID0gZnVuY3Rpb24gKGluZGV4LCBkZXB0aCkge1xuICBpZiAoIShpbmRleCAmIDEpKSByZXR1cm4gLTFcbiAgaWYgKCFkZXB0aCkgZGVwdGggPSBleHBvcnRzLmRlcHRoKGluZGV4KVxuICByZXR1cm4gZXhwb3J0cy5pbmRleChkZXB0aCAtIDEsIGV4cG9ydHMub2Zmc2V0KGluZGV4LCBkZXB0aCkgKiAyKVxufVxuXG5leHBvcnRzLnJpZ2h0Q2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgsIGRlcHRoKSB7XG4gIGlmICghKGluZGV4ICYgMSkpIHJldHVybiAtMVxuICBpZiAoIWRlcHRoKSBkZXB0aCA9IGV4cG9ydHMuZGVwdGgoaW5kZXgpXG4gIHJldHVybiBleHBvcnRzLmluZGV4KGRlcHRoIC0gMSwgMSArIChleHBvcnRzLm9mZnNldChpbmRleCwgZGVwdGgpICogMikpXG59XG5cbmV4cG9ydHMuY2hpbGRyZW4gPSBmdW5jdGlvbiAoaW5kZXgsIGRlcHRoKSB7XG4gIGlmICghKGluZGV4ICYgMSkpIHJldHVybiBudWxsXG5cbiAgaWYgKCFkZXB0aCkgZGVwdGggPSBleHBvcnRzLmRlcHRoKGluZGV4KVxuICB2YXIgb2Zmc2V0ID0gZXhwb3J0cy5vZmZzZXQoaW5kZXgsIGRlcHRoKSAqIDJcblxuICByZXR1cm4gW1xuICAgIGV4cG9ydHMuaW5kZXgoZGVwdGggLSAxLCBvZmZzZXQpLFxuICAgIGV4cG9ydHMuaW5kZXgoZGVwdGggLSAxLCBvZmZzZXQgKyAxKVxuICBdXG59XG5cbmV4cG9ydHMubGVmdFNwYW4gPSBmdW5jdGlvbiAoaW5kZXgsIGRlcHRoKSB7XG4gIGlmICghKGluZGV4ICYgMSkpIHJldHVybiBpbmRleFxuICBpZiAoIWRlcHRoKSBkZXB0aCA9IGV4cG9ydHMuZGVwdGgoaW5kZXgpXG4gIHJldHVybiBleHBvcnRzLm9mZnNldChpbmRleCwgZGVwdGgpICogdHdvUG93KGRlcHRoICsgMSlcbn1cblxuZXhwb3J0cy5yaWdodFNwYW4gPSBmdW5jdGlvbiAoaW5kZXgsIGRlcHRoKSB7XG4gIGlmICghKGluZGV4ICYgMSkpIHJldHVybiBpbmRleFxuICBpZiAoIWRlcHRoKSBkZXB0aCA9IGV4cG9ydHMuZGVwdGgoaW5kZXgpXG4gIHJldHVybiAoZXhwb3J0cy5vZmZzZXQoaW5kZXgsIGRlcHRoKSArIDEpICogdHdvUG93KGRlcHRoICsgMSkgLSAyXG59XG5cbmV4cG9ydHMuY291bnQgPSBmdW5jdGlvbiAoaW5kZXgsIGRlcHRoKSB7XG4gIGlmICghKGluZGV4ICYgMSkpIHJldHVybiAxXG4gIGlmICghZGVwdGgpIGRlcHRoID0gZXhwb3J0cy5kZXB0aChpbmRleClcbiAgcmV0dXJuIHR3b1BvdyhkZXB0aCArIDEpIC0gMVxufVxuXG5leHBvcnRzLnNwYW5zID0gZnVuY3Rpb24gKGluZGV4LCBkZXB0aCkge1xuICBpZiAoIShpbmRleCAmIDEpKSByZXR1cm4gW2luZGV4LCBpbmRleF1cbiAgaWYgKCFkZXB0aCkgZGVwdGggPSBleHBvcnRzLmRlcHRoKGluZGV4KVxuXG4gIHZhciBvZmZzZXQgPSBleHBvcnRzLm9mZnNldChpbmRleCwgZGVwdGgpXG4gIHZhciB3aWR0aCA9IHR3b1BvdyhkZXB0aCArIDEpXG5cbiAgcmV0dXJuIFtvZmZzZXQgKiB3aWR0aCwgKG9mZnNldCArIDEpICogd2lkdGggLSAyXVxufVxuXG5leHBvcnRzLmluZGV4ID0gZnVuY3Rpb24gKGRlcHRoLCBvZmZzZXQpIHtcbiAgcmV0dXJuICgxICsgMiAqIG9mZnNldCkgKiB0d29Qb3coZGVwdGgpIC0gMVxufVxuXG5leHBvcnRzLm9mZnNldCA9IGZ1bmN0aW9uIChpbmRleCwgZGVwdGgpIHtcbiAgaWYgKCEoaW5kZXggJiAxKSkgcmV0dXJuIGluZGV4IC8gMlxuICBpZiAoIWRlcHRoKSBkZXB0aCA9IGV4cG9ydHMuZGVwdGgoaW5kZXgpXG5cbiAgcmV0dXJuICgoaW5kZXggKyAxKSAvIHR3b1BvdyhkZXB0aCkgLSAxKSAvIDJcbn1cblxuZXhwb3J0cy5pdGVyYXRvciA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB2YXIgaXRlID0gbmV3IEl0ZXJhdG9yKClcbiAgaXRlLnNlZWsoaW5kZXggfHwgMClcbiAgcmV0dXJuIGl0ZVxufVxuXG5mdW5jdGlvbiB0d29Qb3cgKG4pIHtcbiAgcmV0dXJuIG4gPCAzMSA/IDEgPDwgbiA6ICgoMSA8PCAzMCkgKiAoMSA8PCAobiAtIDMwKSkpXG59XG5cbmZ1bmN0aW9uIHJpZ2h0U2hpZnQgKG4pIHtcbiAgcmV0dXJuIChuIC0gKG4gJiAxKSkgLyAyXG59XG5cbmZ1bmN0aW9uIEl0ZXJhdG9yIChpbmRleCkge1xuICB0aGlzLmluZGV4ID0gMFxuICB0aGlzLm9mZnNldCA9IDBcbiAgdGhpcy5mYWN0b3IgPSAwXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHRoaXMuaW5kZXggPSBpbmRleFxuICBpZiAodGhpcy5pbmRleCAmIDEpIHtcbiAgICB0aGlzLm9mZnNldCA9IGV4cG9ydHMub2Zmc2V0KGluZGV4KVxuICAgIHRoaXMuZmFjdG9yID0gdHdvUG93KGV4cG9ydHMuZGVwdGgoaW5kZXgpICsgMSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9mZnNldCA9IGluZGV4IC8gMlxuICAgIHRoaXMuZmFjdG9yID0gMlxuICB9XG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5pc0xlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhKHRoaXMub2Zmc2V0ICYgMSlcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLmlzUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5pc0xlZnQoKVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLm9mZnNldCkgcmV0dXJuIHRoaXMuaW5kZXhcbiAgdGhpcy5vZmZzZXQtLVxuICB0aGlzLmluZGV4IC09IHRoaXMuZmFjdG9yXG4gIHJldHVybiB0aGlzLmluZGV4XG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm9mZnNldCsrXG4gIHRoaXMuaW5kZXggKz0gdGhpcy5mYWN0b3JcbiAgcmV0dXJuIHRoaXMuaW5kZXhcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLnNpYmxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzTGVmdCgpID8gdGhpcy5uZXh0KCkgOiB0aGlzLnByZXYoKVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5vZmZzZXQgJiAxKSB7XG4gICAgdGhpcy5pbmRleCAtPSB0aGlzLmZhY3RvciAvIDJcbiAgICB0aGlzLm9mZnNldCA9ICh0aGlzLm9mZnNldCAtIDEpIC8gMlxuICB9IGVsc2Uge1xuICAgIHRoaXMuaW5kZXggKz0gdGhpcy5mYWN0b3IgLyAyXG4gICAgdGhpcy5vZmZzZXQgLz0gMlxuICB9XG4gIHRoaXMuZmFjdG9yICo9IDJcbiAgcmV0dXJuIHRoaXMuaW5kZXhcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLmxlZnRTcGFuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmluZGV4ID0gdGhpcy5pbmRleCAtIHRoaXMuZmFjdG9yIC8gMiArIDFcbiAgdGhpcy5vZmZzZXQgPSB0aGlzLmluZGV4IC8gMlxuICB0aGlzLmZhY3RvciA9IDJcbiAgcmV0dXJuIHRoaXMuaW5kZXhcbn1cblxuSXRlcmF0b3IucHJvdG90eXBlLnJpZ2h0U3BhbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pbmRleCA9IHRoaXMuaW5kZXggKyB0aGlzLmZhY3RvciAvIDIgLSAxXG4gIHRoaXMub2Zmc2V0ID0gdGhpcy5pbmRleCAvIDJcbiAgdGhpcy5mYWN0b3IgPSAyXG4gIHJldHVybiB0aGlzLmluZGV4XG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5sZWZ0Q2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmZhY3RvciA9PT0gMikgcmV0dXJuIHRoaXMuaW5kZXhcbiAgdGhpcy5mYWN0b3IgLz0gMlxuICB0aGlzLmluZGV4IC09IHRoaXMuZmFjdG9yIC8gMlxuICB0aGlzLm9mZnNldCAqPSAyXG4gIHJldHVybiB0aGlzLmluZGV4XG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5yaWdodENoaWxkID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5mYWN0b3IgPT09IDIpIHJldHVybiB0aGlzLmluZGV4XG4gIHRoaXMuZmFjdG9yIC89IDJcbiAgdGhpcy5pbmRleCArPSB0aGlzLmZhY3RvciAvIDJcbiAgdGhpcy5vZmZzZXQgPSAyICogdGhpcy5vZmZzZXQgKyAxXG4gIHJldHVybiB0aGlzLmluZGV4XG59XG4iLCJ2YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZyb20yXG5cbmZyb20yLmN0b3IgPSBjdG9yXG5mcm9tMi5vYmogPSBvYmpcblxudmFyIFByb3RvID0gY3RvcigpXG5cbmZ1bmN0aW9uIHRvRnVuY3Rpb24obGlzdCkge1xuICBsaXN0ID0gbGlzdC5zbGljZSgpXG4gIHJldHVybiBmdW5jdGlvbiAoXywgY2IpIHtcbiAgICB2YXIgZXJyID0gbnVsbFxuICAgIHZhciBpdGVtID0gbGlzdC5sZW5ndGggPyBsaXN0LnNoaWZ0KCkgOiBudWxsXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgZXJyID0gaXRlbVxuICAgICAgaXRlbSA9IG51bGxcbiAgICB9XG5cbiAgICBjYihlcnIsIGl0ZW0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbTIob3B0cywgcmVhZCkge1xuICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICByZWFkID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG5cbiAgdmFyIHJzID0gbmV3IFByb3RvKG9wdHMpXG4gIHJzLl9mcm9tID0gQXJyYXkuaXNBcnJheShyZWFkKSA/IHRvRnVuY3Rpb24ocmVhZCkgOiAocmVhZCB8fCBub29wKVxuICByZXR1cm4gcnNcbn1cblxuZnVuY3Rpb24gY3RvcihvcHRzLCByZWFkKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlYWQgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cblxuICBvcHRzID0gZGVmYXVsdHMob3B0cylcblxuICBpbmhlcml0cyhDbGFzcywgUmVhZGFibGUpXG4gIGZ1bmN0aW9uIENsYXNzKG92ZXJyaWRlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENsYXNzKSkgcmV0dXJuIG5ldyBDbGFzcyhvdmVycmlkZSlcbiAgICB0aGlzLl9yZWFkaW5nID0gZmFsc2VcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNoZWNrXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIFJlYWRhYmxlLmNhbGwodGhpcywgb3ZlcnJpZGUgfHwgb3B0cylcblxuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBod20gPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmtcblxuICAgIGZ1bmN0aW9uIGNoZWNrKGVyciwgZGF0YSkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIGlmIChlcnIpIHJldHVybiBzZWxmLmRlc3Ryb3koZXJyKVxuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBzZWxmLnB1c2gobnVsbClcbiAgICAgIHNlbGYuX3JlYWRpbmcgPSBmYWxzZVxuICAgICAgaWYgKHNlbGYucHVzaChkYXRhKSkgc2VsZi5fcmVhZChod20pXG4gICAgfVxuICB9XG5cbiAgQ2xhc3MucHJvdG90eXBlLl9mcm9tID0gcmVhZCB8fCBub29wXG4gIENsYXNzLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGluZyB8fCB0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgdGhpcy5fcmVhZGluZyA9IHRydWVcbiAgICB0aGlzLl9mcm9tKHNpemUsIHRoaXMuX2NhbGxiYWNrKVxuICB9XG5cbiAgQ2xhc3MucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGlmIChlcnIpIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIENsYXNzXG59XG5cbmZ1bmN0aW9uIG9iaihvcHRzLCByZWFkKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgcmVhZCA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuXG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzKVxuICBvcHRzLm9iamVjdE1vZGUgPSB0cnVlXG4gIG9wdHMuaGlnaFdhdGVyTWFyayA9IDE2XG5cbiAgcmV0dXJuIGZyb20yKG9wdHMsIHJlYWQpXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gZGVmYXVsdHMob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fVxuICByZXR1cm4gb3B0c1xufVxuIiwidmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKVxudmFyIGJ1ZmZlckFsbG9jID0gcmVxdWlyZSgnYnVmZmVyLWFsbG9jLXVuc2FmZScpXG5cbm1vZHVsZS5leHBvcnRzID0gRmVlZFxuXG5mdW5jdGlvbiBGZWVkIChzdHJlYW0pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZlZWQpKSByZXR1cm4gbmV3IEZlZWQoc3RyZWFtKVxuICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcblxuICB0aGlzLmtleSA9IG51bGxcbiAgdGhpcy5kaXNjb3ZlcnlLZXkgPSBudWxsXG4gIHRoaXMuc3RyZWFtID0gc3RyZWFtXG4gIHRoaXMucGVlciA9IG51bGwgLy8gc3VwcG9ydCBhIHBlZXIgb2JqZWN0IHRvIGF2b2lkIGV2ZW50IGVtaXR0ZXIgKyBjbG9zdXJlcyBvdmVyaGVhZFxuXG4gIHRoaXMuaWQgPSAtMVxuICB0aGlzLnJlbW90ZUlkID0gLTFcbiAgdGhpcy5oZWFkZXIgPSAwXG4gIHRoaXMuaGVhZGVyTGVuZ3RoID0gMFxuICB0aGlzLmNsb3NlZCA9IGZhbHNlXG5cbiAgdGhpcy5fYnVmZmVyID0gW11cbn1cblxuaW5oZXJpdHMoRmVlZCwgZXZlbnRzLkV2ZW50RW1pdHRlcilcblxuRmVlZC5wcm90b3R5cGUuaGFuZHNoYWtlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbmQoMSwgbWVzc2FnZXMuSGFuZHNoYWtlLCBtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbmQoMiwgbWVzc2FnZXMuSW5mbywgbWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUuaGF2ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLl9zZW5kKDMsIG1lc3NhZ2VzLkhhdmUsIG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLnVuaGF2ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLl9zZW5kKDQsIG1lc3NhZ2VzLlVuaGF2ZSwgbWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUud2FudCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLl9zZW5kKDUsIG1lc3NhZ2VzLldhbnQsIG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLnVud2FudCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLl9zZW5kKDYsIG1lc3NhZ2VzLlVud2FudCwgbWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLl9zZW5kKDcsIG1lc3NhZ2VzLlJlcXVlc3QsIG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLl9zZW5kKDgsIG1lc3NhZ2VzLkNhbmNlbCwgbWVzc2FnZSlcbn1cblxuRmVlZC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLl9zZW5kKDksIG1lc3NhZ2VzLkRhdGEsIG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLmV4dGVuc2lvbiA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XG4gIHZhciBpZCA9IHRoaXMuc3RyZWFtLmV4dGVuc2lvbnMuaW5kZXhPZih0eXBlKVxuICBpZiAoaWQgPT09IC0xKSByZXR1cm4gZmFsc2VcblxuICB2YXIgaGVhZGVyID0gdGhpcy5oZWFkZXIgfCAxNVxuICB2YXIgbGVuID0gdGhpcy5oZWFkZXJMZW5ndGggKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoaWQpICsgbWVzc2FnZS5sZW5ndGhcbiAgdmFyIGJveCA9IGJ1ZmZlckFsbG9jKHZhcmludC5lbmNvZGluZ0xlbmd0aChsZW4pICsgbGVuKVxuICB2YXIgb2Zmc2V0ID0gMFxuXG4gIHZhcmludC5lbmNvZGUobGVuLCBib3gsIG9mZnNldClcbiAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcblxuICB2YXJpbnQuZW5jb2RlKGhlYWRlciwgYm94LCBvZmZzZXQpXG4gIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG5cbiAgdmFyaW50LmVuY29kZShpZCwgYm94LCBvZmZzZXQpXG4gIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG5cbiAgbWVzc2FnZS5jb3B5KGJveCwgb2Zmc2V0KVxuICByZXR1cm4gdGhpcy5zdHJlYW0uX3B1c2goYm94KVxufVxuXG5GZWVkLnByb3RvdHlwZS5yZW1vdGVTdXBwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLnN0cmVhbS5yZW1vdGVTdXBwb3J0cyhuYW1lKVxufVxuXG5GZWVkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLnN0cmVhbS5kZXN0cm95KGVycilcbn1cblxuRmVlZC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gdGhpcy5zdHJlYW0uZmVlZHMuaW5kZXhPZih0aGlzKVxuXG4gIGlmIChpID4gLTEpIHtcbiAgICB0aGlzLnN0cmVhbS5mZWVkc1tpXSA9IHRoaXMuc3RyZWFtLmZlZWRzW3RoaXMuc3RyZWFtLmZlZWRzLmxlbmd0aCAtIDFdXG4gICAgdGhpcy5zdHJlYW0uZmVlZHMucG9wKClcbiAgICB0aGlzLnN0cmVhbS5fbG9jYWxGZWVkc1t0aGlzLmlkXSA9IG51bGxcbiAgICB0aGlzLmlkID0gLTFcblxuICAgIGlmICh0aGlzLnN0cmVhbS5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmICh0aGlzLnN0cmVhbS5leHBlY3RlZEZlZWRzIDw9IDAgfHwgLS10aGlzLnN0cmVhbS5leHBlY3RlZEZlZWRzKSByZXR1cm5cblxuICAgIHRoaXMuc3RyZWFtLl9wcmVmaW5hbGl6ZSgpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX29uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuXG4gIHRoaXMuY2xvc2VkID0gdHJ1ZVxuXG4gIGlmICghdGhpcy5zdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgdGhpcy5jbG9zZSgpXG4gICAgaWYgKHRoaXMucmVtb3RlSWQgPiAtMSkgdGhpcy5zdHJlYW0uX3JlbW90ZUZlZWRzW3RoaXMucmVtb3RlSWRdID0gbnVsbFxuICAgIHZhciBoZXggPSB0aGlzLmRpc2NvdmVyeUtleS50b1N0cmluZygnaGV4JylcbiAgICBpZiAodGhpcy5zdHJlYW0uX2ZlZWRzW2hleF0gPT09IHRoaXMpIGRlbGV0ZSB0aGlzLnN0cmVhbS5fZmVlZHNbaGV4XVxuICB9XG5cbiAgaWYgKHRoaXMucGVlcikgdGhpcy5wZWVyLm9uY2xvc2UoKVxuICBlbHNlIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuXG5GZWVkLnByb3RvdHlwZS5fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUpXG5cbiAgZnVuY3Rpb24gcmVzdW1lICgpIHtcbiAgICB3aGlsZSAoc2VsZi5fYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdmFyIG5leHQgPSBzZWxmLl9idWZmZXIuc2hpZnQoKVxuICAgICAgc2VsZi5fZW1pdChuZXh0LnR5cGUsIG5leHQubWVzc2FnZSlcbiAgICB9XG4gICAgc2VsZi5fYnVmZmVyID0gbnVsbFxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9vbmV4dGVuc2lvbiA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVyblxuXG4gIHZhciBpZCA9IHZhcmludC5kZWNvZGUoZGF0YSwgc3RhcnQpXG4gIHZhciByID0gdGhpcy5zdHJlYW0ucmVtb3RlRXh0ZW5zaW9uc1xuICB2YXIgbG9jYWxJZCA9ICFyIHx8IGlkID49IHIubGVuZ3RoID8gLTEgOiByW2lkXVxuXG4gIGlmIChsb2NhbElkID09PSAtMSkgcmV0dXJuXG5cbiAgdmFyIG1lc3NhZ2UgPSBkYXRhLnNsaWNlKHN0YXJ0ICsgdmFyaW50LmRlY29kZS5ieXRlcywgZW5kKVxuICB2YXIgbmFtZSA9IHRoaXMuc3RyZWFtLmV4dGVuc2lvbnNbbG9jYWxJZF1cblxuICBpZiAodGhpcy5wZWVyICYmIHRoaXMucGVlci5vbmV4dGVuc2lvbikgdGhpcy5wZWVyLm9uZXh0ZW5zaW9uKG5hbWUsIG1lc3NhZ2UpXG4gIGVsc2UgdGhpcy5lbWl0KCdleHRlbnNpb24nLCBuYW1lLCBtZXNzYWdlKVxufVxuXG5GZWVkLnByb3RvdHlwZS5fb25tZXNzYWdlID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIG1lc3NhZ2UgPSBkZWNvZGVNZXNzYWdlKHR5cGUsIGRhdGEsIHN0YXJ0LCBlbmQpXG4gIGlmICghbWVzc2FnZSB8fCB0aGlzLmNsb3NlZCkgcmV0dXJuXG5cbiAgaWYgKHR5cGUgPT09IDEpIHJldHVybiB0aGlzLnN0cmVhbS5fb25oYW5kc2hha2UobWVzc2FnZSlcblxuICBpZiAoIXRoaXMuX2J1ZmZlcikge1xuICAgIHRoaXMuX2VtaXQodHlwZSwgbWVzc2FnZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0aGlzLl9idWZmZXIubGVuZ3RoID4gMTYpIHtcbiAgICB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdSZW1vdGUgc2VudCB0b28gbWFueSBtZXNzYWdlcyBvbiBhbiB1bm9wZW5lZCBmZWVkJykpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLl9idWZmZXIucHVzaCh7dHlwZTogdHlwZSwgbWVzc2FnZTogbWVzc2FnZX0pXG59XG5cbkZlZWQucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24gKHR5cGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMucGVlcikge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAyOiByZXR1cm4gdGhpcy5wZWVyLm9uaW5mbyhtZXNzYWdlKVxuICAgICAgY2FzZSAzOiByZXR1cm4gdGhpcy5wZWVyLm9uaGF2ZShtZXNzYWdlKVxuICAgICAgY2FzZSA0OiByZXR1cm4gdGhpcy5wZWVyLm9udW5oYXZlKG1lc3NhZ2UpXG4gICAgICBjYXNlIDU6IHJldHVybiB0aGlzLnBlZXIub253YW50KG1lc3NhZ2UpXG4gICAgICBjYXNlIDY6IHJldHVybiB0aGlzLnBlZXIub251bndhbnQobWVzc2FnZSlcbiAgICAgIGNhc2UgNzogcmV0dXJuIHRoaXMucGVlci5vbnJlcXVlc3QobWVzc2FnZSlcbiAgICAgIGNhc2UgODogcmV0dXJuIHRoaXMucGVlci5vbmNhbmNlbChtZXNzYWdlKVxuICAgICAgY2FzZSA5OiByZXR1cm4gdGhpcy5wZWVyLm9uZGF0YShtZXNzYWdlKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgMjogcmV0dXJuIHRoaXMuZW1pdCgnaW5mbycsIG1lc3NhZ2UpXG4gICAgICBjYXNlIDM6IHJldHVybiB0aGlzLmVtaXQoJ2hhdmUnLCBtZXNzYWdlKVxuICAgICAgY2FzZSA0OiByZXR1cm4gdGhpcy5lbWl0KCd1bmhhdmUnLCBtZXNzYWdlKVxuICAgICAgY2FzZSA1OiByZXR1cm4gdGhpcy5lbWl0KCd3YW50JywgbWVzc2FnZSlcbiAgICAgIGNhc2UgNjogcmV0dXJuIHRoaXMuZW1pdCgndW53YW50JywgbWVzc2FnZSlcbiAgICAgIGNhc2UgNzogcmV0dXJuIHRoaXMuZW1pdCgncmVxdWVzdCcsIG1lc3NhZ2UpXG4gICAgICBjYXNlIDg6IHJldHVybiB0aGlzLmVtaXQoJ2NhbmNlbCcsIG1lc3NhZ2UpXG4gICAgICBjYXNlIDk6IHJldHVybiB0aGlzLmVtaXQoJ2RhdGEnLCBtZXNzYWdlKVxuICAgIH1cbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uICh0eXBlLCBlbmMsIG1lc3NhZ2UpIHtcbiAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyIHwgdHlwZVxuICB2YXIgbGVuID0gdGhpcy5oZWFkZXJMZW5ndGggKyBlbmMuZW5jb2RpbmdMZW5ndGgobWVzc2FnZSlcbiAgdmFyIGJveCA9IGJ1ZmZlckFsbG9jKHZhcmludC5lbmNvZGluZ0xlbmd0aChsZW4pICsgbGVuKVxuICB2YXIgb2Zmc2V0ID0gMFxuXG4gIHZhcmludC5lbmNvZGUobGVuLCBib3gsIG9mZnNldClcbiAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcblxuICB2YXJpbnQuZW5jb2RlKGhlYWRlciwgYm94LCBvZmZzZXQpXG4gIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG5cbiAgZW5jLmVuY29kZShtZXNzYWdlLCBib3gsIG9mZnNldClcblxuICByZXR1cm4gdGhpcy5zdHJlYW0uX3B1c2goYm94KVxufVxuXG5mdW5jdGlvbiBkZWNvZGVNZXNzYWdlICh0eXBlLCBkYXRhLCBzdGFydCwgZW5kKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgMTogcmV0dXJuIGRlY29kZShtZXNzYWdlcy5IYW5kc2hha2UsIGRhdGEsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSAyOiByZXR1cm4gZGVjb2RlKG1lc3NhZ2VzLkluZm8sIGRhdGEsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSAzOiByZXR1cm4gZGVjb2RlKG1lc3NhZ2VzLkhhdmUsIGRhdGEsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSA0OiByZXR1cm4gZGVjb2RlKG1lc3NhZ2VzLlVuaGF2ZSwgZGF0YSwgc3RhcnQsIGVuZClcbiAgICBjYXNlIDU6IHJldHVybiBkZWNvZGUobWVzc2FnZXMuV2FudCwgZGF0YSwgc3RhcnQsIGVuZClcbiAgICBjYXNlIDY6IHJldHVybiBkZWNvZGUobWVzc2FnZXMuVW53YW50LCBkYXRhLCBzdGFydCwgZW5kKVxuICAgIGNhc2UgNzogcmV0dXJuIGRlY29kZShtZXNzYWdlcy5SZXF1ZXN0LCBkYXRhLCBzdGFydCwgZW5kKVxuICAgIGNhc2UgODogcmV0dXJuIGRlY29kZShtZXNzYWdlcy5DYW5jZWwsIGRhdGEsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSA5OiByZXR1cm4gZGVjb2RlKG1lc3NhZ2VzLkRhdGEsIGRhdGEsIHN0YXJ0LCBlbmQpXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjb2RlIChlbmMsIGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW5jLmRlY29kZShkYXRhLCBzdGFydCwgZW5kKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG4iLCJ2YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxudmFyIHNvZGl1bSA9IHJlcXVpcmUoJ3NvZGl1bS11bml2ZXJzYWwnKVxudmFyIGluZGV4T2YgPSByZXF1aXJlKCdzb3J0ZWQtaW5kZXhvZicpXG52YXIgZmVlZCA9IHJlcXVpcmUoJy4vZmVlZCcpXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJylcbnZhciBidWZmZXJBbGxvYyA9IHJlcXVpcmUoJ2J1ZmZlci1hbGxvYy11bnNhZmUnKVxudmFyIGJ1ZmZlckZyb20gPSByZXF1aXJlKCdidWZmZXItZnJvbScpXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvdG9jb2xcblxuZnVuY3Rpb24gUHJvdG9jb2wgKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb3RvY29sKSkgcmV0dXJuIG5ldyBQcm90b2NvbChvcHRzKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIHN0cmVhbS5EdXBsZXguY2FsbCh0aGlzKVxuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLmlkID0gb3B0cy5pZCB8fCByYW5kb21CeXRlcygzMilcbiAgdGhpcy5saXZlID0gISFvcHRzLmxpdmVcbiAgdGhpcy5hY2sgPSAhIW9wdHMuYWNrXG4gIHRoaXMudXNlckRhdGEgPSBvcHRzLnVzZXJEYXRhIHx8IG51bGxcbiAgdGhpcy5yZW1vdGVJZCA9IG51bGxcbiAgdGhpcy5yZW1vdGVMaXZlID0gZmFsc2VcbiAgdGhpcy5yZW1vdGVVc2VyRGF0YSA9IG51bGxcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHRoaXMuZW5jcnlwdGVkID0gb3B0cy5lbmNyeXB0ICE9PSBmYWxzZVxuICB0aGlzLmtleSA9IG51bGxcbiAgdGhpcy5kaXNjb3ZlcnlLZXkgPSBudWxsXG4gIHRoaXMucmVtb3RlRGlzY292ZXJ5S2V5ID0gbnVsbFxuICB0aGlzLmZlZWRzID0gW11cbiAgdGhpcy5leHBlY3RlZEZlZWRzID0gb3B0cy5leHBlY3RlZEZlZWRzIHx8IDBcbiAgdGhpcy5leHRlbnNpb25zID0gb3B0cy5leHRlbnNpb25zIHx8IFtdXG4gIHRoaXMucmVtb3RlRXh0ZW5zaW9ucyA9IG51bGxcblxuICB0aGlzLl9sb2NhbEZlZWRzID0gW11cbiAgdGhpcy5fcmVtb3RlRmVlZHMgPSBbXVxuICB0aGlzLl9mZWVkcyA9IHt9XG5cbiAgdGhpcy5fbm9uY2UgPSBudWxsXG4gIHRoaXMuX3JlbW90ZU5vbmNlID0gbnVsbFxuICB0aGlzLl94b3IgPSBudWxsXG4gIHRoaXMuX3JlbW90ZVhvciA9IG51bGxcbiAgdGhpcy5fbmVlZHNLZXkgPSBmYWxzZVxuICB0aGlzLl9sZW5ndGggPSBidWZmZXJBbGxvYyh2YXJpbnQuZW5jb2RpbmdMZW5ndGgoODM4ODYwOCkpXG4gIHRoaXMuX21pc3NpbmcgPSAwXG4gIHRoaXMuX2J1ZiA9IG51bGxcbiAgdGhpcy5fcG9pbnRlciA9IDBcbiAgdGhpcy5fZGF0YSA9IG51bGxcbiAgdGhpcy5fc3RhcnQgPSAwXG4gIHRoaXMuX2NiID0gbnVsbFxuICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcbiAgdGhpcy5fa2VlcEFsaXZlID0gMFxuICB0aGlzLl9yZW1vdGVLZWVwQWxpdmUgPSAwXG4gIHRoaXMuX21heWJlRmluYWxpemUgPSBtYXliZUZpbmFsaXplXG5cbiAgaWYgKG9wdHMudGltZW91dCAhPT0gMCAmJiBvcHRzLnRpbWVvdXQgIT09IGZhbHNlKSB0aGlzLnNldFRpbWVvdXQob3B0cy50aW1lb3V0IHx8IDUwMDAsIHRoaXMuX29udGltZW91dClcbiAgdGhpcy5vbignZmluaXNoJywgdGhpcy5maW5hbGl6ZSlcblxuICBmdW5jdGlvbiBtYXliZUZpbmFsaXplIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5kZXN0cm95KGVycilcbiAgICBpZiAoIXNlbGYuZXhwZWN0ZWRGZWVkcykgc2VsZi5maW5hbGl6ZSgpXG4gIH1cbn1cblxuaW5oZXJpdHMoUHJvdG9jb2wsIHN0cmVhbS5EdXBsZXgpXG5cblByb3RvY29sLnByb3RvdHlwZS5fcHJlZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5lbWl0KCdwcmVmaW5hbGl6ZScsIHRoaXMuX21heWJlRmluYWxpemUpKSB0aGlzLmZpbmFsaXplKClcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIG9udGltZW91dCkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICBpZiAob250aW1lb3V0KSB0aGlzLm9uY2UoJ3RpbWVvdXQnLCBvbnRpbWVvdXQpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5fa2VlcEFsaXZlID0gMFxuICB0aGlzLl9yZW1vdGVLZWVwQWxpdmUgPSAwXG5cbiAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbClcbiAgaWYgKCFtcykgcmV0dXJuXG5cbiAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChraWNrLCAobXMgLyA0KSB8IDApXG4gIGlmICh0aGlzLl9pbnRlcnZhbC51bnJlZikgdGhpcy5faW50ZXJ2YWwudW5yZWYoKVxuXG4gIGZ1bmN0aW9uIGtpY2sgKCkge1xuICAgIHNlbGYuX2tpY2soKVxuICB9XG59XG5cblByb3RvY29sLnByb3RvdHlwZS5mZWVkID0gZnVuY3Rpb24gKGtleSwgb3B0cykge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybiBudWxsXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgdmFyIGRrID0gb3B0cy5kaXNjb3ZlcnlLZXkgfHwgZGlzY292ZXJ5S2V5KGtleSlcbiAgdmFyIGNoID0gdGhpcy5fZmVlZChkaylcblxuICBpZiAoY2guaWQgPiAtMSkge1xuICAgIGlmIChvcHRzLnBlZXIpIGNoLnBlZXIgPSBvcHRzLnBlZXJcbiAgICByZXR1cm4gY2hcbiAgfVxuXG4gIGlmICh0aGlzLl9sb2NhbEZlZWRzLmxlbmd0aCA+PSAxMjgpIHtcbiAgICB0aGlzLl90b29NYW55RmVlZHMoKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjaC5pZCA9IHRoaXMuX2xvY2FsRmVlZHMucHVzaChjaCkgLSAxXG4gIGNoLmhlYWRlciA9IGNoLmlkIDw8IDRcbiAgY2guaGVhZGVyTGVuZ3RoID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGNoLmhlYWRlcilcbiAgY2gua2V5ID0ga2V5XG4gIGNoLmRpc2NvdmVyeUtleSA9IGRrXG4gIGlmIChvcHRzLnBlZXIpIGNoLnBlZXIgPSBvcHRzLnBlZXJcblxuICB0aGlzLmZlZWRzLnB1c2goY2gpXG5cbiAgdmFyIGZpcnN0ID0gIXRoaXMua2V5XG4gIHZhciBmZWVkID0ge1xuICAgIGRpc2NvdmVyeUtleTogZGssXG4gICAgbm9uY2U6IG51bGxcbiAgfVxuXG4gIGlmIChmaXJzdCkge1xuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy5kaXNjb3ZlcnlLZXkgPSBka1xuXG4gICAgaWYgKCF0aGlzLl9zYW1lS2V5KCkpIHJldHVybiBudWxsXG5cbiAgICBpZiAodGhpcy5lbmNyeXB0ZWQpIHtcbiAgICAgIGZlZWQubm9uY2UgPSB0aGlzLl9ub25jZSA9IHJhbmRvbUJ5dGVzKDI0KVxuICAgICAgdGhpcy5feG9yID0gc29kaXVtLmNyeXB0b19zdHJlYW1feG9yX2luc3RhbmNlKHRoaXMuX25vbmNlLCB0aGlzLmtleSlcbiAgICAgIGlmICh0aGlzLl9yZW1vdGVOb25jZSkge1xuICAgICAgICB0aGlzLl9yZW1vdGVYb3IgPSBzb2RpdW0uY3J5cHRvX3N0cmVhbV94b3JfaW5zdGFuY2UodGhpcy5fcmVtb3RlTm9uY2UsIHRoaXMua2V5KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc0tleSkge1xuICAgICAgdGhpcy5fbmVlZHNLZXkgPSBmYWxzZVxuICAgICAgdGhpcy5fcmVzdW1lKClcbiAgICB9XG4gIH1cblxuICB2YXIgYm94ID0gZW5jb2RlRmVlZChmZWVkLCBjaC5pZClcbiAgaWYgKCFmZWVkLm5vbmNlICYmIHRoaXMuZW5jcnlwdGVkKSB0aGlzLl94b3IudXBkYXRlKGJveCwgYm94KVxuICB0aGlzLl9rZWVwQWxpdmUgPSAwXG4gIHRoaXMucHVzaChib3gpXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm4gbnVsbFxuXG4gIGlmIChmaXJzdCkge1xuICAgIGNoLmhhbmRzaGFrZSh7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGxpdmU6IHRoaXMubGl2ZSxcbiAgICAgIHVzZXJEYXRhOiB0aGlzLnVzZXJEYXRhLFxuICAgICAgZXh0ZW5zaW9uczogdGhpcy5leHRlbnNpb25zLFxuICAgICAgYWNrOiB0aGlzLmFja1xuICAgIH0pXG4gIH1cblxuICBpZiAoY2guX2J1ZmZlci5sZW5ndGgpIGNoLl9yZXN1bWUoKVxuICBlbHNlIGNoLl9idWZmZXIgPSBudWxsXG5cbiAgcmV0dXJuIGNoXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUpXG5cbiAgZnVuY3Rpb24gcmVzdW1lICgpIHtcbiAgICBpZiAoIXNlbGYuX2RhdGEpIHJldHVyblxuXG4gICAgdmFyIGRhdGEgPSBzZWxmLl9kYXRhXG4gICAgdmFyIHN0YXJ0ID0gc2VsZi5fc3RhcnRcbiAgICB2YXIgY2IgPSBzZWxmLl9jYlxuXG4gICAgc2VsZi5fZGF0YSA9IG51bGxcbiAgICBzZWxmLl9zdGFydCA9IDBcbiAgICBzZWxmLl9jYiA9IG51bGxcbiAgICBzZWxmLl9wYXJzZShkYXRhLCBzdGFydCwgY2IpXG4gIH1cbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9raWNrID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcmVtb3RlS2VlcEFsaXZlID4gNCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgdGhpcy5lbWl0KCd0aW1lb3V0JylcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mZWVkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaCA9IHRoaXMuZmVlZHNbaV1cbiAgICBpZiAoY2gucGVlcikgY2gucGVlci5vbnRpY2soKVxuICAgIGVsc2UgY2guZW1pdCgndGljaycpXG4gIH1cblxuICB0aGlzLl9yZW1vdGVLZWVwQWxpdmUrK1xuXG4gIGlmICh0aGlzLl9rZWVwQWxpdmUgPiAyKSB7XG4gICAgdGhpcy5waW5nKClcbiAgICB0aGlzLl9rZWVwQWxpdmUgPSAwXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fa2VlcEFsaXZlKytcbiAgfVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmtleSkgcmV0dXJuIHRydWVcbiAgdmFyIHBpbmcgPSBidWZmZXJGcm9tKFswXSlcbiAgaWYgKHRoaXMuX3hvcikgdGhpcy5feG9yLnVwZGF0ZShwaW5nLCBwaW5nKVxuICByZXR1cm4gdGhpcy5wdXNoKHBpbmcpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5fY2xvc2UoKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgdGhpcy5fY2xvc2UoKVxuICB0aGlzLnB1c2gobnVsbClcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbClcblxuICB2YXIgZmVlZHMgPSB0aGlzLmZlZWRzXG4gIHRoaXMuZmVlZHMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZlZWRzLmxlbmd0aDsgaSsrKSBmZWVkc1tpXS5fb25jbG9zZSgpXG5cbiAgaWYgKHRoaXMuX3hvcikge1xuICAgIHRoaXMuX3hvci5maW5hbCgpXG4gICAgdGhpcy5feG9yID0gbnVsbFxuICB9XG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZG8gbm90aGluZywgdXNlciBiYWNrLXByZXNzdXJlc1xufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9rZWVwQWxpdmUgPSAwXG4gIGlmICh0aGlzLl94b3IpIHRoaXMuX3hvci51cGRhdGUoZGF0YSwgZGF0YSlcbiAgcmV0dXJuIHRoaXMucHVzaChkYXRhKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYywgY2IpIHtcbiAgdGhpcy5fcmVtb3RlS2VlcEFsaXZlID0gMFxuICB0aGlzLl9wYXJzZShkYXRhLCAwLCBjYilcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9mZWVkID0gZnVuY3Rpb24gKGRrKSB7XG4gIHZhciBoZXggPSBkay50b1N0cmluZygnaGV4JylcbiAgdmFyIGNoID0gdGhpcy5fZmVlZHNbaGV4XVxuICBpZiAoY2gpIHJldHVybiBjaFxuICBjaCA9IHRoaXMuX2ZlZWRzW2hleF0gPSBmZWVkKHRoaXMpXG4gIHJldHVybiBjaFxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUucmVtb3RlU3VwcG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgaSA9IHRoaXMuZXh0ZW5zaW9ucy5pbmRleE9mKG5hbWUpXG4gIHJldHVybiBpID4gLTEgJiYgISF0aGlzLnJlbW90ZUV4dGVuc2lvbnMgJiYgdGhpcy5yZW1vdGVFeHRlbnNpb25zLmluZGV4T2YoaSkgPiAtMVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX29uaGFuZHNoYWtlID0gZnVuY3Rpb24gKGhhbmRzaGFrZSkge1xuICBpZiAodGhpcy5yZW1vdGVJZCkgcmV0dXJuXG5cbiAgdGhpcy5yZW1vdGVJZCA9IGhhbmRzaGFrZS5pZCB8fCByYW5kb21CeXRlcygzMilcbiAgdGhpcy5yZW1vdGVMaXZlID0gaGFuZHNoYWtlLmxpdmVcbiAgdGhpcy5yZW1vdGVVc2VyRGF0YSA9IGhhbmRzaGFrZS51c2VyRGF0YVxuICB0aGlzLnJlbW90ZUV4dGVuc2lvbnMgPSBpbmRleE9mKHRoaXMuZXh0ZW5zaW9ucywgaGFuZHNoYWtlLmV4dGVuc2lvbnMpXG4gIHRoaXMucmVtb3RlQWNrID0gaGFuZHNoYWtlLmFja1xuXG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJylcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9vbm9wZW4gPSBmdW5jdGlvbiAoaWQsIGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGZlZWQgPSBkZWNvZGVGZWVkKGRhdGEsIHN0YXJ0LCBlbmQpXG5cbiAgaWYgKCFmZWVkKSByZXR1cm4gdGhpcy5fYmFkRmVlZCgpXG5cbiAgaWYgKCF0aGlzLnJlbW90ZURpc2NvdmVyeUtleSkge1xuICAgIHRoaXMucmVtb3RlRGlzY292ZXJ5S2V5ID0gZmVlZC5kaXNjb3ZlcnlLZXlcbiAgICBpZiAoIXRoaXMuX3NhbWVLZXkoKSkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5lbmNyeXB0ZWQgJiYgIXRoaXMuX3JlbW90ZU5vbmNlKSB7XG4gICAgICBpZiAoIWZlZWQubm9uY2UpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignUmVtb3RlIGRpZCBub3QgaW5jbHVkZSBhIG5vbmNlJykpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5fcmVtb3RlTm9uY2UgPSBmZWVkLm5vbmNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5jcnlwdGVkICYmIHRoaXMua2V5ICYmICF0aGlzLl9yZW1vdGVYb3IpIHtcbiAgICAgIHRoaXMuX3JlbW90ZVhvciA9IHNvZGl1bS5jcnlwdG9fc3RyZWFtX3hvcl9pbnN0YW5jZSh0aGlzLl9yZW1vdGVOb25jZSwgdGhpcy5rZXkpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcmVtb3RlRmVlZHNbaWRdID0gdGhpcy5fZmVlZChmZWVkLmRpc2NvdmVyeUtleSlcbiAgZmVlZC5yZW1vdGVJZCA9IGlkXG5cbiAgdGhpcy5lbWl0KCdmZWVkJywgZmVlZC5kaXNjb3ZlcnlLZXkpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fb25tZXNzYWdlID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCAtIHN0YXJ0IDwgMikgcmV0dXJuXG5cbiAgdmFyIGhlYWRlciA9IGRlY29kZUhlYWRlcihkYXRhLCBzdGFydClcbiAgaWYgKGhlYWRlciA9PT0gLTEpIHJldHVybiB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdSZW1vdGUgc2VudCBpbnZhbGlkIGhlYWRlcicpKVxuXG4gIHN0YXJ0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcblxuICB2YXIgaWQgPSBoZWFkZXIgPj4gNFxuICB2YXIgdHlwZSA9IGhlYWRlciAmIDE1XG5cbiAgaWYgKGlkID49IDEyOCkgcmV0dXJuIHRoaXMuX3Rvb01hbnlGZWVkcygpXG4gIHdoaWxlICh0aGlzLl9yZW1vdGVGZWVkcy5sZW5ndGggPCBpZCkgdGhpcy5fcmVtb3RlRmVlZHMucHVzaChudWxsKVxuXG4gIHZhciBjaCA9IHRoaXMuX3JlbW90ZUZlZWRzW2lkXVxuXG4gIGlmICh0eXBlID09PSAwKSB7XG4gICAgaWYgKGNoKSBjaC5fb25jbG9zZSgpXG4gICAgcmV0dXJuIHRoaXMuX29ub3BlbihpZCwgZGF0YSwgc3RhcnQsIGVuZClcbiAgfVxuXG4gIGlmICghY2gpIHJldHVybiB0aGlzLl9iYWRGZWVkKClcbiAgaWYgKHR5cGUgPT09IDE1KSByZXR1cm4gY2guX29uZXh0ZW5zaW9uKGRhdGEsIHN0YXJ0LCBlbmQpXG4gIGNoLl9vbm1lc3NhZ2UodHlwZSwgZGF0YSwgc3RhcnQsIGVuZClcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9wYXJzZSA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgY2IpIHtcbiAgdmFyIGRlY3J5cHRlZCA9ICEhdGhpcy5fcmVtb3RlWG9yXG5cbiAgaWYgKHN0YXJ0KSB7XG4gICAgZGF0YSA9IGRhdGEuc2xpY2Uoc3RhcnQpXG4gICAgc3RhcnQgPSAwXG4gIH1cblxuICBpZiAodGhpcy5fcmVtb3RlWG9yKSB0aGlzLl9yZW1vdGVYb3IudXBkYXRlKGRhdGEsIGRhdGEpXG5cbiAgd2hpbGUgKHN0YXJ0IDwgZGF0YS5sZW5ndGggJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgaWYgKHRoaXMuX21pc3NpbmcpIHN0YXJ0ID0gdGhpcy5fcGFyc2VNZXNzYWdlKGRhdGEsIHN0YXJ0KVxuICAgIGVsc2Ugc3RhcnQgPSB0aGlzLl9wYXJzZUxlbmd0aChkYXRhLCBzdGFydClcblxuICAgIGlmICh0aGlzLl9uZWVkc0tleSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnRcbiAgICAgIHRoaXMuX2NiID0gY2JcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghZGVjcnlwdGVkICYmIHRoaXMuX3JlbW90ZVhvcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlKGRhdGEsIHN0YXJ0LCBjYilcbiAgICB9XG4gIH1cblxuICBjYigpXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fcGFyc2VNZXNzYWdlID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0KSB7XG4gIHZhciBlbmQgPSBzdGFydCArIHRoaXMuX21pc3NpbmdcblxuICBpZiAoZW5kIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgdmFyIHJldCA9IGVuZFxuXG4gICAgaWYgKHRoaXMuX2J1Zikge1xuICAgICAgZGF0YS5jb3B5KHRoaXMuX2J1ZiwgdGhpcy5fcG9pbnRlciwgc3RhcnQpXG4gICAgICBkYXRhID0gdGhpcy5fYnVmXG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IGRhdGEubGVuZ3RoXG4gICAgICB0aGlzLl9idWYgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5fbWlzc2luZyA9IDBcbiAgICB0aGlzLl9wb2ludGVyID0gMFxuICAgIGlmICh0aGlzLmVuY3J5cHRlZCAmJiAhdGhpcy5rZXkpIHRoaXMuX25lZWRzS2V5ID0gdHJ1ZVxuICAgIHRoaXMuX29ubWVzc2FnZShkYXRhLCBzdGFydCwgZW5kKVxuXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgaWYgKCF0aGlzLl9idWYpIHtcbiAgICB0aGlzLl9idWYgPSBidWZmZXJBbGxvYyh0aGlzLl9taXNzaW5nKVxuICAgIHRoaXMuX3BvaW50ZXIgPSAwXG4gIH1cblxuICB2YXIgcmVtID0gZGF0YS5sZW5ndGggLSBzdGFydFxuXG4gIGRhdGEuY29weSh0aGlzLl9idWYsIHRoaXMuX3BvaW50ZXIsIHN0YXJ0KVxuICB0aGlzLl9wb2ludGVyICs9IHJlbVxuICB0aGlzLl9taXNzaW5nIC09IHJlbVxuXG4gIHJldHVybiBkYXRhLmxlbmd0aFxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX3BhcnNlTGVuZ3RoID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0KSB7XG4gIHdoaWxlICghdGhpcy5fbWlzc2luZyAmJiBzdGFydCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGUgPSB0aGlzLl9sZW5ndGhbdGhpcy5fcG9pbnRlcisrXSA9IGRhdGFbc3RhcnQrK11cblxuICAgIGlmICghKGJ5dGUgJiAweDgwKSkge1xuICAgICAgdGhpcy5fbWlzc2luZyA9IHZhcmludC5kZWNvZGUodGhpcy5fbGVuZ3RoKVxuICAgICAgdGhpcy5fcG9pbnRlciA9IDBcbiAgICAgIGlmICh0aGlzLl9taXNzaW5nID4gODM4ODYwOCkgcmV0dXJuIHRoaXMuX3Rvb0JpZyhkYXRhLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGFydFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9wb2ludGVyID49IHRoaXMuX2xlbmd0aC5sZW5ndGgpIHJldHVybiB0aGlzLl90b29CaWcoZGF0YS5sZW5ndGgpXG4gIH1cblxuICByZXR1cm4gc3RhcnRcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9zYW1lS2V5ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZGlzY292ZXJ5S2V5IHx8ICF0aGlzLnJlbW90ZURpc2NvdmVyeUtleSkgcmV0dXJuIHRydWVcbiAgaWYgKHRoaXMucmVtb3RlRGlzY292ZXJ5S2V5LnRvU3RyaW5nKCdoZXgnKSA9PT0gdGhpcy5kaXNjb3ZlcnlLZXkudG9TdHJpbmcoJ2hleCcpKSByZXR1cm4gdHJ1ZVxuICB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdGaXJzdCBzaGFyZWQgaHlwZXJjb3JlIG11c3QgYmUgdGhlIHNhbWUnKSlcbiAgcmV0dXJuIGZhbHNlXG59XG5cblByb3RvY29sLnByb3RvdHlwZS5fdG9vTWFueUZlZWRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdPbmx5IDEyOCBmZWVkcyBjdXJyZW50bHkgc3VwcG9ydGVkLiBPcGVuIGEgR2l0aHViIGlzc3VlIGlmIHlvdSBuZWVkIG1vcmUnKSlcbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl90b29CaWcgPSBmdW5jdGlvbiAobGVuKSB7XG4gIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ1JlbW90ZSBtZXNzYWdlIGlzIGxhcmdlciB0aGFuIDhNQiAobWF4IGFsbG93ZWQpJykpXG4gIHJldHVybiBsZW5cbn1cblxuUHJvdG9jb2wucHJvdG90eXBlLl9iYWRGZWVkID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdSZW1vdGUgc2VudCBpbnZhbGlkIGZlZWQgbWVzc2FnZScpKVxufVxuXG5Qcm90b2NvbC5wcm90b3R5cGUuX29udGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kZXN0cm95KG5ldyBFcnJvcignUmVtb3RlIHRpbWVkIG91dCcpKVxufVxuXG5mdW5jdGlvbiBkZWNvZGVIZWFkZXIgKGRhdGEsIHN0YXJ0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHZhcmludC5kZWNvZGUoZGF0YSwgc3RhcnQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAtMVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29kZUZlZWQgKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGZlZWQgPSBudWxsXG5cbiAgdHJ5IHtcbiAgICBmZWVkID0gbWVzc2FnZXMuRmVlZC5kZWNvZGUoZGF0YSwgc3RhcnQsIGVuZClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmIChmZWVkLmRpc2NvdmVyeUtleS5sZW5ndGggIT09IDMyKSByZXR1cm4gbnVsbFxuICBpZiAoZmVlZC5ub25jZSAmJiBmZWVkLm5vbmNlLmxlbmd0aCAhPT0gMjQpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGZlZWRcbn1cblxuZnVuY3Rpb24gZW5jb2RlRmVlZCAoZmVlZCwgaWQpIHtcbiAgdmFyIGhlYWRlciA9IGlkIDw8IDRcbiAgdmFyIGxlbiA9IHZhcmludC5lbmNvZGluZ0xlbmd0aChoZWFkZXIpICsgbWVzc2FnZXMuRmVlZC5lbmNvZGluZ0xlbmd0aChmZWVkKVxuICB2YXIgYm94ID0gYnVmZmVyQWxsb2ModmFyaW50LmVuY29kaW5nTGVuZ3RoKGxlbikgKyBsZW4pXG4gIHZhciBvZmZzZXQgPSAwXG5cbiAgdmFyaW50LmVuY29kZShsZW4sIGJveCwgb2Zmc2V0KVxuICBvZmZzZXQgKz0gdmFyaW50LmVuY29kZS5ieXRlc1xuXG4gIHZhcmludC5lbmNvZGUoaGVhZGVyLCBib3gsIG9mZnNldClcbiAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcblxuICBtZXNzYWdlcy5GZWVkLmVuY29kZShmZWVkLCBib3gsIG9mZnNldClcbiAgcmV0dXJuIGJveFxufVxuXG5mdW5jdGlvbiBkaXNjb3ZlcnlLZXkgKGtleSkge1xuICB2YXIgYnVmID0gYnVmZmVyQWxsb2MoMzIpXG4gIHNvZGl1bS5jcnlwdG9fZ2VuZXJpY2hhc2goYnVmLCBidWZmZXJGcm9tKCdoeXBlcmNvcmUnKSwga2V5KVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzIChuKSB7XG4gIHZhciBidWYgPSBidWZmZXJBbGxvYyhuKVxuICBzb2RpdW0ucmFuZG9tYnl0ZXNfYnVmKGJ1ZilcbiAgcmV0dXJuIGJ1ZlxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IHRoZSBwcm90b2NvbC1idWZmZXJzIGNsaSB0b29sXG5cbi8qIGVzbGludC1kaXNhYmxlIHF1b3RlcyAqL1xuLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuLy8gUmVtZW1iZXIgdG8gYG5wbSBpbnN0YWxsIC0tc2F2ZSBwcm90b2NvbC1idWZmZXJzLWVuY29kaW5nc2BcbnZhciBlbmNvZGluZ3MgPSByZXF1aXJlKCdwcm90b2NvbC1idWZmZXJzLWVuY29kaW5ncycpXG52YXIgdmFyaW50ID0gZW5jb2RpbmdzLnZhcmludFxudmFyIHNraXAgPSBlbmNvZGluZ3Muc2tpcFxuXG52YXIgRmVlZCA9IGV4cG9ydHMuRmVlZCA9IHtcbiAgYnVmZmVyOiB0cnVlLFxuICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgZW5jb2RlOiBudWxsLFxuICBkZWNvZGU6IG51bGxcbn1cblxudmFyIEhhbmRzaGFrZSA9IGV4cG9ydHMuSGFuZHNoYWtlID0ge1xuICBidWZmZXI6IHRydWUsXG4gIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICBlbmNvZGU6IG51bGwsXG4gIGRlY29kZTogbnVsbFxufVxuXG52YXIgSW5mbyA9IGV4cG9ydHMuSW5mbyA9IHtcbiAgYnVmZmVyOiB0cnVlLFxuICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgZW5jb2RlOiBudWxsLFxuICBkZWNvZGU6IG51bGxcbn1cblxudmFyIEhhdmUgPSBleHBvcnRzLkhhdmUgPSB7XG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gIGVuY29kZTogbnVsbCxcbiAgZGVjb2RlOiBudWxsXG59XG5cbnZhciBVbmhhdmUgPSBleHBvcnRzLlVuaGF2ZSA9IHtcbiAgYnVmZmVyOiB0cnVlLFxuICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgZW5jb2RlOiBudWxsLFxuICBkZWNvZGU6IG51bGxcbn1cblxudmFyIFdhbnQgPSBleHBvcnRzLldhbnQgPSB7XG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gIGVuY29kZTogbnVsbCxcbiAgZGVjb2RlOiBudWxsXG59XG5cbnZhciBVbndhbnQgPSBleHBvcnRzLlVud2FudCA9IHtcbiAgYnVmZmVyOiB0cnVlLFxuICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgZW5jb2RlOiBudWxsLFxuICBkZWNvZGU6IG51bGxcbn1cblxudmFyIFJlcXVlc3QgPSBleHBvcnRzLlJlcXVlc3QgPSB7XG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gIGVuY29kZTogbnVsbCxcbiAgZGVjb2RlOiBudWxsXG59XG5cbnZhciBDYW5jZWwgPSBleHBvcnRzLkNhbmNlbCA9IHtcbiAgYnVmZmVyOiB0cnVlLFxuICBlbmNvZGluZ0xlbmd0aDogbnVsbCxcbiAgZW5jb2RlOiBudWxsLFxuICBkZWNvZGU6IG51bGxcbn1cblxudmFyIERhdGEgPSBleHBvcnRzLkRhdGEgPSB7XG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgZW5jb2RpbmdMZW5ndGg6IG51bGwsXG4gIGVuY29kZTogbnVsbCxcbiAgZGVjb2RlOiBudWxsXG59XG5cbmRlZmluZUZlZWQoKVxuZGVmaW5lSGFuZHNoYWtlKClcbmRlZmluZUluZm8oKVxuZGVmaW5lSGF2ZSgpXG5kZWZpbmVVbmhhdmUoKVxuZGVmaW5lV2FudCgpXG5kZWZpbmVVbndhbnQoKVxuZGVmaW5lUmVxdWVzdCgpXG5kZWZpbmVDYW5jZWwoKVxuZGVmaW5lRGF0YSgpXG5cbmZ1bmN0aW9uIGRlZmluZUZlZWQgKCkge1xuICB2YXIgZW5jID0gW1xuICAgIGVuY29kaW5ncy5ieXRlc1xuICBdXG5cbiAgRmVlZC5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gIEZlZWQuZW5jb2RlID0gZW5jb2RlXG4gIEZlZWQuZGVjb2RlID0gZGVjb2RlXG5cbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgIHZhciBsZW5ndGggPSAwXG4gICAgaWYgKCFkZWZpbmVkKG9iai5kaXNjb3ZlcnlLZXkpKSB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjb3ZlcnlLZXkgaXMgcmVxdWlyZWRcIilcbiAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5kaXNjb3ZlcnlLZXkpXG4gICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICBpZiAoZGVmaW5lZChvYmoubm9uY2UpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5ub25jZSlcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICBpZiAoIWRlZmluZWQob2JqLmRpc2NvdmVyeUtleSkpIHRocm93IG5ldyBFcnJvcihcImRpc2NvdmVyeUtleSBpcyByZXF1aXJlZFwiKVxuICAgIGJ1ZltvZmZzZXQrK10gPSAxMFxuICAgIGVuY1swXS5lbmNvZGUob2JqLmRpc2NvdmVyeUtleSwgYnVmLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICBpZiAoZGVmaW5lZChvYmoubm9uY2UpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMThcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLm5vbmNlLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGRpc2NvdmVyeUtleTogbnVsbCxcbiAgICAgIG5vbmNlOiBudWxsXG4gICAgfVxuICAgIHZhciBmb3VuZDAgPSBmYWxzZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICBpZiAoIWZvdW5kMCkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIG9iai5kaXNjb3ZlcnlLZXkgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBmb3VuZDAgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgb2JqLm5vbmNlID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lSGFuZHNoYWtlICgpIHtcbiAgdmFyIGVuYyA9IFtcbiAgICBlbmNvZGluZ3MuYnl0ZXMsXG4gICAgZW5jb2RpbmdzLmJvb2wsXG4gICAgZW5jb2RpbmdzLnN0cmluZ1xuICBdXG5cbiAgSGFuZHNoYWtlLmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgSGFuZHNoYWtlLmVuY29kZSA9IGVuY29kZVxuICBIYW5kc2hha2UuZGVjb2RlID0gZGVjb2RlXG5cbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgIHZhciBsZW5ndGggPSAwXG4gICAgaWYgKGRlZmluZWQob2JqLmlkKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouaWQpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmoubGl2ZSkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMV0uZW5jb2RpbmdMZW5ndGgob2JqLmxpdmUpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmoudXNlckRhdGEpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai51c2VyRGF0YSlcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5leHRlbnNpb25zKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmouZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWRlZmluZWQob2JqLmV4dGVuc2lvbnNbaV0pKSBjb250aW51ZVxuICAgICAgICB2YXIgbGVuID0gZW5jWzJdLmVuY29kaW5nTGVuZ3RoKG9iai5leHRlbnNpb25zW2ldKVxuICAgICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouYWNrKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1sxXS5lbmNvZGluZ0xlbmd0aChvYmouYWNrKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIGlmIChkZWZpbmVkKG9iai5pZCkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxMFxuICAgICAgZW5jWzBdLmVuY29kZShvYmouaWQsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmxpdmUpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMTZcbiAgICAgIGVuY1sxXS5lbmNvZGUob2JqLmxpdmUsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLnVzZXJEYXRhKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDI2XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai51c2VyRGF0YSwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouZXh0ZW5zaW9ucykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFkZWZpbmVkKG9iai5leHRlbnNpb25zW2ldKSkgY29udGludWVcbiAgICAgICAgYnVmW29mZnNldCsrXSA9IDM0XG4gICAgICAgIGVuY1syXS5lbmNvZGUob2JqLmV4dGVuc2lvbnNbaV0sIGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzJdLmVuY29kZS5ieXRlc1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouYWNrKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDQwXG4gICAgICBlbmNbMV0uZW5jb2RlKG9iai5hY2ssIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge1xuICAgICAgaWQ6IG51bGwsXG4gICAgICBsaXZlOiBmYWxzZSxcbiAgICAgIHVzZXJEYXRhOiBudWxsLFxuICAgICAgZXh0ZW5zaW9uczogW10sXG4gICAgICBhY2s6IGZhbHNlXG4gICAgfVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgfVxuICAgICAgdmFyIHByZWZpeCA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIG9iai5pZCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgb2JqLmxpdmUgPSBlbmNbMV0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzFdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIG9iai51c2VyRGF0YSA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgb2JqLmV4dGVuc2lvbnMucHVzaChlbmNbMl0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KSlcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1syXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBvYmouYWNrID0gZW5jWzFdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lSW5mbyAoKSB7XG4gIHZhciBlbmMgPSBbXG4gICAgZW5jb2RpbmdzLmJvb2xcbiAgXVxuXG4gIEluZm8uZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICBJbmZvLmVuY29kZSA9IGVuY29kZVxuICBJbmZvLmRlY29kZSA9IGRlY29kZVxuXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmIChkZWZpbmVkKG9iai51cGxvYWRpbmcpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai51cGxvYWRpbmcpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouZG93bmxvYWRpbmcpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5kb3dubG9hZGluZylcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICBpZiAoZGVmaW5lZChvYmoudXBsb2FkaW5nKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDhcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLnVwbG9hZGluZywgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouZG93bmxvYWRpbmcpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMTZcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLmRvd25sb2FkaW5nLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHVwbG9hZGluZzogZmFsc2UsXG4gICAgICBkb3dubG9hZGluZzogZmFsc2VcbiAgICB9XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgb2JqLnVwbG9hZGluZyA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgb2JqLmRvd25sb2FkaW5nID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lSGF2ZSAoKSB7XG4gIHZhciBlbmMgPSBbXG4gICAgZW5jb2RpbmdzLnZhcmludCxcbiAgICBlbmNvZGluZ3MuYnl0ZXNcbiAgXVxuXG4gIEhhdmUuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICBIYXZlLmVuY29kZSA9IGVuY29kZVxuICBIYXZlLmRlY29kZSA9IGRlY29kZVxuXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmICghZGVmaW5lZChvYmouc3RhcnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCBpcyByZXF1aXJlZFwiKVxuICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLnN0YXJ0KVxuICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgaWYgKGRlZmluZWQob2JqLmxlbmd0aCkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmxlbmd0aClcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5iaXRmaWVsZCkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMV0uZW5jb2RpbmdMZW5ndGgob2JqLmJpdGZpZWxkKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIGlmICghZGVmaW5lZChvYmouc3RhcnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCBpcyByZXF1aXJlZFwiKVxuICAgIGJ1ZltvZmZzZXQrK10gPSA4XG4gICAgZW5jWzBdLmVuY29kZShvYmouc3RhcnQsIGJ1Ziwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgaWYgKGRlZmluZWQob2JqLmxlbmd0aCkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxNlxuICAgICAgZW5jWzBdLmVuY29kZShvYmoubGVuZ3RoLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5iaXRmaWVsZCkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAyNlxuICAgICAgZW5jWzFdLmVuY29kZShvYmouYml0ZmllbGQsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBsZW5ndGg6IDEsXG4gICAgICBiaXRmaWVsZDogbnVsbFxuICAgIH1cbiAgICB2YXIgZm91bmQwID0gZmFsc2VcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFmb3VuZDApIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBvYmouc3RhcnQgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBmb3VuZDAgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgb2JqLmxlbmd0aCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgb2JqLmJpdGZpZWxkID0gZW5jWzFdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lVW5oYXZlICgpIHtcbiAgdmFyIGVuYyA9IFtcbiAgICBlbmNvZGluZ3MudmFyaW50XG4gIF1cblxuICBVbmhhdmUuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICBVbmhhdmUuZW5jb2RlID0gZW5jb2RlXG4gIFVuaGF2ZS5kZWNvZGUgPSBkZWNvZGVcblxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoIWRlZmluZWQob2JqLnN0YXJ0KSkgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQgaXMgcmVxdWlyZWRcIilcbiAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5zdGFydClcbiAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIGlmIChkZWZpbmVkKG9iai5sZW5ndGgpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5sZW5ndGgpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgaWYgKCFkZWZpbmVkKG9iai5zdGFydCkpIHRocm93IG5ldyBFcnJvcihcInN0YXJ0IGlzIHJlcXVpcmVkXCIpXG4gICAgYnVmW29mZnNldCsrXSA9IDhcbiAgICBlbmNbMF0uZW5jb2RlKG9iai5zdGFydCwgYnVmLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICBpZiAoZGVmaW5lZChvYmoubGVuZ3RoKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDE2XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5sZW5ndGgsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBsZW5ndGg6IDFcbiAgICB9XG4gICAgdmFyIGZvdW5kMCA9IGZhbHNlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgIGlmICghZm91bmQwKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgb2JqLnN0YXJ0ID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgZm91bmQwID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIG9iai5sZW5ndGggPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVXYW50ICgpIHtcbiAgdmFyIGVuYyA9IFtcbiAgICBlbmNvZGluZ3MudmFyaW50XG4gIF1cblxuICBXYW50LmVuY29kaW5nTGVuZ3RoID0gZW5jb2RpbmdMZW5ndGhcbiAgV2FudC5lbmNvZGUgPSBlbmNvZGVcbiAgV2FudC5kZWNvZGUgPSBkZWNvZGVcblxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoIWRlZmluZWQob2JqLnN0YXJ0KSkgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQgaXMgcmVxdWlyZWRcIilcbiAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5zdGFydClcbiAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIGlmIChkZWZpbmVkKG9iai5sZW5ndGgpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5sZW5ndGgpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgaWYgKCFkZWZpbmVkKG9iai5zdGFydCkpIHRocm93IG5ldyBFcnJvcihcInN0YXJ0IGlzIHJlcXVpcmVkXCIpXG4gICAgYnVmW29mZnNldCsrXSA9IDhcbiAgICBlbmNbMF0uZW5jb2RlKG9iai5zdGFydCwgYnVmLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICBpZiAoZGVmaW5lZChvYmoubGVuZ3RoKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDE2XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5sZW5ndGgsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChidWYsIG9mZnNldCwgZW5kKSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gYnVmLmxlbmd0aFxuICAgIGlmICghKGVuZCA8PSBidWYubGVuZ3RoICYmIG9mZnNldCA8PSBidWYubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgb2JqID0ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBsZW5ndGg6IDBcbiAgICB9XG4gICAgdmFyIGZvdW5kMCA9IGZhbHNlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgIGlmICghZm91bmQwKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgb2JqLnN0YXJ0ID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgZm91bmQwID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIG9iai5sZW5ndGggPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVVbndhbnQgKCkge1xuICB2YXIgZW5jID0gW1xuICAgIGVuY29kaW5ncy52YXJpbnRcbiAgXVxuXG4gIFVud2FudC5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gIFVud2FudC5lbmNvZGUgPSBlbmNvZGVcbiAgVW53YW50LmRlY29kZSA9IGRlY29kZVxuXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmICghZGVmaW5lZChvYmouc3RhcnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCBpcyByZXF1aXJlZFwiKVxuICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLnN0YXJ0KVxuICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgaWYgKGRlZmluZWQob2JqLmxlbmd0aCkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmxlbmd0aClcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICBpZiAoIWRlZmluZWQob2JqLnN0YXJ0KSkgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQgaXMgcmVxdWlyZWRcIilcbiAgICBidWZbb2Zmc2V0KytdID0gOFxuICAgIGVuY1swXS5lbmNvZGUob2JqLnN0YXJ0LCBidWYsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIGlmIChkZWZpbmVkKG9iai5sZW5ndGgpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMTZcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLmxlbmd0aCwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmogPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGxlbmd0aDogMFxuICAgIH1cbiAgICB2YXIgZm91bmQwID0gZmFsc2VcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFmb3VuZDApIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBvYmouc3RhcnQgPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBmb3VuZDAgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgb2JqLmxlbmd0aCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlcXVlc3QgKCkge1xuICB2YXIgZW5jID0gW1xuICAgIGVuY29kaW5ncy52YXJpbnQsXG4gICAgZW5jb2RpbmdzLmJvb2xcbiAgXVxuXG4gIFJlcXVlc3QuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICBSZXF1ZXN0LmVuY29kZSA9IGVuY29kZVxuICBSZXF1ZXN0LmRlY29kZSA9IGRlY29kZVxuXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmICghZGVmaW5lZChvYmouaW5kZXgpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyByZXF1aXJlZFwiKVxuICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmluZGV4KVxuICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgaWYgKGRlZmluZWQob2JqLmJ5dGVzKSkge1xuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouYnl0ZXMpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouaGFzaCkpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMV0uZW5jb2RpbmdMZW5ndGgob2JqLmhhc2gpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmoubm9kZXMpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5ub2RlcylcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAob2JqLCBidWYsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFidWYpIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aChvYmopKVxuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICBpZiAoIWRlZmluZWQob2JqLmluZGV4KSkgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgcmVxdWlyZWRcIilcbiAgICBidWZbb2Zmc2V0KytdID0gOFxuICAgIGVuY1swXS5lbmNvZGUob2JqLmluZGV4LCBidWYsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIGlmIChkZWZpbmVkKG9iai5ieXRlcykpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAxNlxuICAgICAgZW5jWzBdLmVuY29kZShvYmouYnl0ZXMsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmhhc2gpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMjRcbiAgICAgIGVuY1sxXS5lbmNvZGUob2JqLmhhc2gsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1sxXS5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLm5vZGVzKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDMyXG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5ub2RlcywgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmogPSB7XG4gICAgICBpbmRleDogMCxcbiAgICAgIGJ5dGVzOiAwLFxuICAgICAgaGFzaDogZmFsc2UsXG4gICAgICBub2RlczogMFxuICAgIH1cbiAgICB2YXIgZm91bmQwID0gZmFsc2VcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFmb3VuZDApIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICAgICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB2YXJpbnQuZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgIHZhciB0YWcgPSBwcmVmaXggPj4gM1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBvYmouaW5kZXggPSBlbmNbMF0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICBmb3VuZDAgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgb2JqLmJ5dGVzID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBvYmouaGFzaCA9IGVuY1sxXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMV0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgb2JqLm5vZGVzID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ2FuY2VsICgpIHtcbiAgdmFyIGVuYyA9IFtcbiAgICBlbmNvZGluZ3MudmFyaW50LFxuICAgIGVuY29kaW5ncy5ib29sXG4gIF1cblxuICBDYW5jZWwuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aFxuICBDYW5jZWwuZW5jb2RlID0gZW5jb2RlXG4gIENhbmNlbC5kZWNvZGUgPSBkZWNvZGVcblxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoIWRlZmluZWQob2JqLmluZGV4KSkgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgcmVxdWlyZWRcIilcbiAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5pbmRleClcbiAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIGlmIChkZWZpbmVkKG9iai5ieXRlcykpIHtcbiAgICAgIHZhciBsZW4gPSBlbmNbMF0uZW5jb2RpbmdMZW5ndGgob2JqLmJ5dGVzKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLmhhc2gpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzFdLmVuY29kaW5nTGVuZ3RoKG9iai5oYXNoKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChvYmosIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIGlmICghZGVmaW5lZChvYmouaW5kZXgpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyByZXF1aXJlZFwiKVxuICAgIGJ1ZltvZmZzZXQrK10gPSA4XG4gICAgZW5jWzBdLmVuY29kZShvYmouaW5kZXgsIGJ1Ziwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBlbmNbMF0uZW5jb2RlLmJ5dGVzXG4gICAgaWYgKGRlZmluZWQob2JqLmJ5dGVzKSkge1xuICAgICAgYnVmW29mZnNldCsrXSA9IDE2XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5ieXRlcywgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChvYmouaGFzaCkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAyNFxuICAgICAgZW5jWzFdLmVuY29kZShvYmouaGFzaCwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzFdLmVuY29kZS5ieXRlc1xuICAgIH1cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgaWYgKCEoZW5kIDw9IGJ1Zi5sZW5ndGggJiYgb2Zmc2V0IDw9IGJ1Zi5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuICAgIHZhciBvYmogPSB7XG4gICAgICBpbmRleDogMCxcbiAgICAgIGJ5dGVzOiAwLFxuICAgICAgaGFzaDogZmFsc2VcbiAgICB9XG4gICAgdmFyIGZvdW5kMCA9IGZhbHNlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgIGlmICghZm91bmQwKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgb2JqLmluZGV4ID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgZm91bmQwID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIG9iai5ieXRlcyA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMF0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgb2JqLmhhc2ggPSBlbmNbMV0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gZW5jWzFdLmRlY29kZS5ieXRlc1xuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXQgPSBza2lwKHByZWZpeCAmIDcsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVEYXRhICgpIHtcbiAgdmFyIE5vZGUgPSBEYXRhLk5vZGUgPSB7XG4gICAgYnVmZmVyOiB0cnVlLFxuICAgIGVuY29kaW5nTGVuZ3RoOiBudWxsLFxuICAgIGVuY29kZTogbnVsbCxcbiAgICBkZWNvZGU6IG51bGxcbiAgfVxuXG4gIGRlZmluZU5vZGUoKVxuXG4gIGZ1bmN0aW9uIGRlZmluZU5vZGUgKCkge1xuICAgIHZhciBlbmMgPSBbXG4gICAgICBlbmNvZGluZ3MudmFyaW50LFxuICAgICAgZW5jb2RpbmdzLmJ5dGVzXG4gICAgXVxuXG4gICAgTm9kZS5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gICAgTm9kZS5lbmNvZGUgPSBlbmNvZGVcbiAgICBOb2RlLmRlY29kZSA9IGRlY29kZVxuXG4gICAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IDBcbiAgICAgIGlmICghZGVmaW5lZChvYmouaW5kZXgpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpcyByZXF1aXJlZFwiKVxuICAgICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouaW5kZXgpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgICAgaWYgKCFkZWZpbmVkKG9iai5oYXNoKSkgdGhyb3cgbmV3IEVycm9yKFwiaGFzaCBpcyByZXF1aXJlZFwiKVxuICAgICAgdmFyIGxlbiA9IGVuY1sxXS5lbmNvZGluZ0xlbmd0aChvYmouaGFzaClcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgICBpZiAoIWRlZmluZWQob2JqLnNpemUpKSB0aHJvdyBuZXcgRXJyb3IoXCJzaXplIGlzIHJlcXVpcmVkXCIpXG4gICAgICB2YXIgbGVuID0gZW5jWzBdLmVuY29kaW5nTGVuZ3RoKG9iai5zaXplKVxuICAgICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICAgIHJldHVybiBsZW5ndGhcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgICBpZiAoIWJ1ZikgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG9iaikpXG4gICAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgICBpZiAoIWRlZmluZWQob2JqLmluZGV4KSkgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgcmVxdWlyZWRcIilcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSA4XG4gICAgICBlbmNbMF0uZW5jb2RlKG9iai5pbmRleCwgYnVmLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gZW5jWzBdLmVuY29kZS5ieXRlc1xuICAgICAgaWYgKCFkZWZpbmVkKG9iai5oYXNoKSkgdGhyb3cgbmV3IEVycm9yKFwiaGFzaCBpcyByZXF1aXJlZFwiKVxuICAgICAgYnVmW29mZnNldCsrXSA9IDE4XG4gICAgICBlbmNbMV0uZW5jb2RlKG9iai5oYXNoLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMV0uZW5jb2RlLmJ5dGVzXG4gICAgICBpZiAoIWRlZmluZWQob2JqLnNpemUpKSB0aHJvdyBuZXcgRXJyb3IoXCJzaXplIGlzIHJlcXVpcmVkXCIpXG4gICAgICBidWZbb2Zmc2V0KytdID0gMjRcbiAgICAgIGVuY1swXS5lbmNvZGUob2JqLnNpemUsIGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgICAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcbiAgICAgIGlmICghZW5kKSBlbmQgPSBidWYubGVuZ3RoXG4gICAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBoYXNoOiBudWxsLFxuICAgICAgICBzaXplOiAwXG4gICAgICB9XG4gICAgICB2YXIgZm91bmQwID0gZmFsc2VcbiAgICAgIHZhciBmb3VuZDEgPSBmYWxzZVxuICAgICAgdmFyIGZvdW5kMiA9IGZhbHNlXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoZW5kIDw9IG9mZnNldCkge1xuICAgICAgICAgIGlmICghZm91bmQwIHx8ICFmb3VuZDEgfHwgIWZvdW5kMikgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBtZXNzYWdlIGlzIG5vdCB2YWxpZFwiKVxuICAgICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IHZhcmludC5kZWNvZGUuYnl0ZXNcbiAgICAgICAgdmFyIHRhZyA9IHByZWZpeCA+PiAzXG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG9iai5pbmRleCA9IGVuY1swXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgICBmb3VuZDAgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgb2JqLmhhc2ggPSBlbmNbMV0uZGVjb2RlKGJ1Ziwgb2Zmc2V0KVxuICAgICAgICAgIG9mZnNldCArPSBlbmNbMV0uZGVjb2RlLmJ5dGVzXG4gICAgICAgICAgZm91bmQxID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG9iai5zaXplID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgICBvZmZzZXQgKz0gZW5jWzBdLmRlY29kZS5ieXRlc1xuICAgICAgICAgIGZvdW5kMiA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgb2Zmc2V0ID0gc2tpcChwcmVmaXggJiA3LCBidWYsIG9mZnNldClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbmMgPSBbXG4gICAgZW5jb2RpbmdzLnZhcmludCxcbiAgICBlbmNvZGluZ3MuYnl0ZXMsXG4gICAgTm9kZVxuICBdXG5cbiAgRGF0YS5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoXG4gIERhdGEuZW5jb2RlID0gZW5jb2RlXG4gIERhdGEuZGVjb2RlID0gZGVjb2RlXG5cbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG9iaikge1xuICAgIHZhciBsZW5ndGggPSAwXG4gICAgaWYgKCFkZWZpbmVkKG9iai5pbmRleCkpIHRocm93IG5ldyBFcnJvcihcImluZGV4IGlzIHJlcXVpcmVkXCIpXG4gICAgdmFyIGxlbiA9IGVuY1swXS5lbmNvZGluZ0xlbmd0aChvYmouaW5kZXgpXG4gICAgbGVuZ3RoICs9IDEgKyBsZW5cbiAgICBpZiAoZGVmaW5lZChvYmoudmFsdWUpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzFdLmVuY29kaW5nTGVuZ3RoKG9iai52YWx1ZSlcbiAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5ub2RlcykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZGVmaW5lZChvYmoubm9kZXNbaV0pKSBjb250aW51ZVxuICAgICAgICB2YXIgbGVuID0gZW5jWzJdLmVuY29kaW5nTGVuZ3RoKG9iai5ub2Rlc1tpXSlcbiAgICAgICAgbGVuZ3RoICs9IHZhcmludC5lbmNvZGluZ0xlbmd0aChsZW4pXG4gICAgICAgIGxlbmd0aCArPSAxICsgbGVuXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5zaWduYXR1cmUpKSB7XG4gICAgICB2YXIgbGVuID0gZW5jWzFdLmVuY29kaW5nTGVuZ3RoKG9iai5zaWduYXR1cmUpXG4gICAgICBsZW5ndGggKz0gMSArIGxlblxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKG9iaiwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuICAgIGlmICghYnVmKSBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgob2JqKSlcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgaWYgKCFkZWZpbmVkKG9iai5pbmRleCkpIHRocm93IG5ldyBFcnJvcihcImluZGV4IGlzIHJlcXVpcmVkXCIpXG4gICAgYnVmW29mZnNldCsrXSA9IDhcbiAgICBlbmNbMF0uZW5jb2RlKG9iai5pbmRleCwgYnVmLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGVuY1swXS5lbmNvZGUuYnl0ZXNcbiAgICBpZiAoZGVmaW5lZChvYmoudmFsdWUpKSB7XG4gICAgICBidWZbb2Zmc2V0KytdID0gMThcbiAgICAgIGVuY1sxXS5lbmNvZGUob2JqLnZhbHVlLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMV0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG9iai5ub2RlcykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZGVmaW5lZChvYmoubm9kZXNbaV0pKSBjb250aW51ZVxuICAgICAgICBidWZbb2Zmc2V0KytdID0gMjZcbiAgICAgICAgdmFyaW50LmVuY29kZShlbmNbMl0uZW5jb2RpbmdMZW5ndGgob2JqLm5vZGVzW2ldKSwgYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG4gICAgICAgIGVuY1syXS5lbmNvZGUob2JqLm5vZGVzW2ldLCBidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1syXS5lbmNvZGUuYnl0ZXNcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmluZWQob2JqLnNpZ25hdHVyZSkpIHtcbiAgICAgIGJ1ZltvZmZzZXQrK10gPSAzNFxuICAgICAgZW5jWzFdLmVuY29kZShvYmouc2lnbmF0dXJlLCBidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBlbmNbMV0uZW5jb2RlLmJ5dGVzXG4gICAgfVxuICAgIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICAgIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IGJ1Zi5sZW5ndGhcbiAgICBpZiAoIShlbmQgPD0gYnVmLmxlbmd0aCAmJiBvZmZzZXQgPD0gYnVmLmxlbmd0aCkpIHRocm93IG5ldyBFcnJvcihcIkRlY29kZWQgbWVzc2FnZSBpcyBub3QgdmFsaWRcIilcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGluZGV4OiAwLFxuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBub2RlczogW10sXG4gICAgICBzaWduYXR1cmU6IG51bGxcbiAgICB9XG4gICAgdmFyIGZvdW5kMCA9IGZhbHNlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gb2Zmc2V0KSB7XG4gICAgICAgIGlmICghZm91bmQwKSB0aHJvdyBuZXcgRXJyb3IoXCJEZWNvZGVkIG1lc3NhZ2UgaXMgbm90IHZhbGlkXCIpXG4gICAgICAgIGRlY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldFxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdmFyaW50LmRlY29kZShidWYsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICB2YXIgdGFnID0gcHJlZml4ID4+IDNcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgb2JqLmluZGV4ID0gZW5jWzBdLmRlY29kZShidWYsIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IGVuY1swXS5kZWNvZGUuYnl0ZXNcbiAgICAgICAgZm91bmQwID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIG9iai52YWx1ZSA9IGVuY1sxXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMV0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgdmFyIGxlbiA9IHZhcmludC5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgICAgIG9iai5ub2Rlcy5wdXNoKGVuY1syXS5kZWNvZGUoYnVmLCBvZmZzZXQsIG9mZnNldCArIGxlbikpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMl0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgb2JqLnNpZ25hdHVyZSA9IGVuY1sxXS5kZWNvZGUoYnVmLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBlbmNbMV0uZGVjb2RlLmJ5dGVzXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG9mZnNldCA9IHNraXAocHJlZml4ICYgNywgYnVmLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZWQgKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJyB8fCAhaXNOYU4odmFsKSlcbn1cbiIsInZhciBlcXVhbHMgPSByZXF1aXJlKCdidWZmZXItZXF1YWxzJylcbnZhciBsb3cgPSByZXF1aXJlKCdsYXN0LW9uZS13aW5zJylcbnZhciByZW1vdmUgPSByZXF1aXJlKCd1bm9yZGVyZWQtYXJyYXktcmVtb3ZlJylcbnZhciBzZXQgPSByZXF1aXJlKCd1bm9yZGVyZWQtc2V0JylcbnZhciBtZXJrbGUgPSByZXF1aXJlKCdtZXJrbGUtdHJlZS1zdHJlYW0vZ2VuZXJhdG9yJylcbnZhciBmbGF0ID0gcmVxdWlyZSgnZmxhdC10cmVlJylcbnZhciBidWxrID0gcmVxdWlyZSgnYnVsay13cml0ZS1zdHJlYW0nKVxudmFyIGZyb20gPSByZXF1aXJlKCdmcm9tMicpXG52YXIgY29kZWNzID0gcmVxdWlyZSgnY29kZWNzJylcbnZhciB0aHVua3kgPSByZXF1aXJlKCd0aHVua3knKVxudmFyIGJhdGNoZXIgPSByZXF1aXJlKCdhdG9taWMtYmF0Y2hlcicpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcbnZhciByYWYgPSByZXF1aXJlKCdyYW5kb20tYWNjZXNzLWZpbGUnKVxudmFyIGJpdGZpZWxkID0gcmVxdWlyZSgnLi9saWIvYml0ZmllbGQnKVxudmFyIHNwYXJzZUJpdGZpZWxkID0gcmVxdWlyZSgnc3BhcnNlLWJpdGZpZWxkJylcbnZhciB0cmVlSW5kZXggPSByZXF1aXJlKCcuL2xpYi90cmVlLWluZGV4JylcbnZhciBzdG9yYWdlID0gcmVxdWlyZSgnLi9saWIvc3RvcmFnZScpXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnLi9saWIvY3J5cHRvJylcbnZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJylcbnZhciBidWZmZXJGcm9tID0gcmVxdWlyZSgnYnVmZmVyLWZyb20nKVxudmFyIGJ1ZmZlckFsbG9jID0gcmVxdWlyZSgnYnVmZmVyLWFsbG9jLXVuc2FmZScpXG52YXIgcmVwbGljYXRlID0gbnVsbFxuXG5tb2R1bGUuZXhwb3J0cyA9IEZlZWRcblxuZnVuY3Rpb24gRmVlZCAoY3JlYXRlU3RvcmFnZSwga2V5LCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWVkKSkgcmV0dXJuIG5ldyBGZWVkKGNyZWF0ZVN0b3JhZ2UsIGtleSwgb3B0cylcbiAgZXZlbnRzLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG5cbiAgaWYgKHR5cGVvZiBjcmVhdGVTdG9yYWdlID09PSAnc3RyaW5nJykgY3JlYXRlU3RvcmFnZSA9IGRlZmF1bHRTdG9yYWdlKGNyZWF0ZVN0b3JhZ2UpXG4gIGlmICh0eXBlb2YgY3JlYXRlU3RvcmFnZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdTdG9yYWdlIHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9yIHN0cmluZycpXG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSBrZXkgPSBidWZmZXJGcm9tKGtleSwgJ2hleCcpXG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSAmJiAhb3B0cykge1xuICAgIG9wdHMgPSBrZXlcbiAgICBrZXkgPSBudWxsXG4gIH1cblxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBzZWNyZXRLZXkgPSBvcHRzLnNlY3JldEtleSB8fCBudWxsXG4gIGlmICh0eXBlb2Ygc2VjcmV0S2V5ID09PSAnc3RyaW5nJykgc2VjcmV0S2V5ID0gYnVmZmVyRnJvbShzZWNyZXRLZXksICdoZXgnKVxuXG4gIHRoaXMuaWQgPSBvcHRzLmlkIHx8IGNyeXB0by5yYW5kb21CeXRlcygzMilcbiAgdGhpcy5saXZlID0gb3B0cy5saXZlICE9PSBmYWxzZVxuICB0aGlzLnNwYXJzZSA9ICEhb3B0cy5zcGFyc2VcbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMuYnl0ZUxlbmd0aCA9IDBcbiAgdGhpcy5tYXhSZXF1ZXN0cyA9IG9wdHMubWF4UmVxdWVzdHMgfHwgMTZcbiAgdGhpcy5rZXkgPSBrZXkgfHwgbnVsbFxuICB0aGlzLmRpc2NvdmVyeUtleSA9IHRoaXMua2V5ICYmIGNyeXB0by5kaXNjb3ZlcnlLZXkodGhpcy5rZXkpXG4gIHRoaXMuc2VjcmV0S2V5ID0gc2VjcmV0S2V5XG4gIHRoaXMuYml0ZmllbGQgPSBudWxsXG4gIHRoaXMudHJlZSA9IG51bGxcbiAgdGhpcy53cml0YWJsZSA9ICEhb3B0cy53cml0YWJsZVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZVxuICB0aGlzLm9wZW5lZCA9IGZhbHNlXG4gIHRoaXMuY2xvc2VkID0gZmFsc2VcbiAgdGhpcy5hbGxvd1B1c2ggPSAhIW9wdHMuYWxsb3dQdXNoXG4gIHRoaXMucGVlcnMgPSBbXVxuXG4gIC8vIGhvb2tzXG4gIHRoaXMuX29ud3JpdGUgPSBvcHRzLm9ud3JpdGUgfHwgbnVsbFxuXG4gIHRoaXMuX3JlYWR5ID0gdGh1bmt5KG9wZW4pIC8vIFRPRE86IGlmIG9wZW4gZmFpbHMsIGRvIG5vdCByZW9wZW4gbmV4dCB0aW1lXG4gIHRoaXMuX2luZGV4aW5nID0gISFvcHRzLmluZGV4aW5nXG4gIHRoaXMuX2NyZWF0ZUlmTWlzc2luZyA9IG9wdHMuY3JlYXRlSWZNaXNzaW5nICE9PSBmYWxzZVxuICB0aGlzLl9vdmVyd3JpdGUgPSAhIW9wdHMub3ZlcndyaXRlXG4gIHRoaXMuX3N0b3JlU2VjcmV0S2V5ID0gb3B0cy5zdG9yZVNlY3JldEtleSAhPT0gZmFsc2VcbiAgdGhpcy5fbWVya2xlID0gbnVsbFxuICB0aGlzLl9zdG9yYWdlID0gc3RvcmFnZShjcmVhdGVTdG9yYWdlLCBvcHRzLnN0b3JhZ2VDYWNoZVNpemUpXG4gIHRoaXMuX2JhdGNoID0gYmF0Y2hlcih0aGlzLl9vbndyaXRlID8gd29ya0hvb2sgOiB3b3JrKVxuXG4gIHRoaXMuX3dhaXRpbmcgPSBbXVxuICB0aGlzLl9zZWxlY3Rpb25zID0gW11cbiAgdGhpcy5fcmVzZXJ2ZWQgPSBzcGFyc2VCaXRmaWVsZCgpXG4gIHRoaXMuX3N5bmNlZCA9IG51bGxcblxuICB0aGlzLl9jb2RlYyA9IHRvQ29kZWMob3B0cy52YWx1ZUVuY29kaW5nKVxuICB0aGlzLl9zeW5jID0gbG93KHN5bmMpXG4gIGlmICghdGhpcy5zcGFyc2UpIHRoaXMuZG93bmxvYWQoe3N0YXJ0OiAwLCBlbmQ6IC0xfSlcblxuICAvLyBvcGVuIGl0IHJpZ2h0IGF3YXkuIFRPRE86IGRvIG5vdCByZW9wZW4gKGkuZSwgc2V0IGEgZmxhZyBub3QgdG8gcmV0cnkpXG4gIHRoaXMuX3JlYWR5KG9uZXJyb3IpXG5cbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgaWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmtIb29rICh2YWx1ZXMsIGNiKSB7XG4gICAgc2VsZi5fYXBwZW5kSG9vayh2YWx1ZXMsIGNiKVxuICB9XG5cbiAgZnVuY3Rpb24gd29yayAodmFsdWVzLCBjYikge1xuICAgIHNlbGYuX2FwcGVuZCh2YWx1ZXMsIGNiKVxuICB9XG5cbiAgZnVuY3Rpb24gc3luYyAoXywgY2IpIHtcbiAgICBzZWxmLl9zeW5jQml0ZmllbGQoY2IpXG4gIH1cblxuICBmdW5jdGlvbiBvcGVuIChjYikge1xuICAgIHNlbGYuX29wZW4oY2IpXG4gIH1cbn1cblxuaW5oZXJpdHMoRmVlZCwgZXZlbnRzLkV2ZW50RW1pdHRlcilcblxuRmVlZC5kaXNjb3ZlcnlLZXkgPSBjcnlwdG8uZGlzY292ZXJ5S2V5XG5cbi8vIFRPRE86IGluc3RlYWQgb2YgdXNpbmcgYSBnZXR0ZXIsIHVwZGF0ZSBvbiByZW1vdGUtdXBkYXRlL2FkZC9yZW1vdmVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZWVkLnByb3RvdHlwZSwgJ3JlbW90ZUxlbmd0aCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IDBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZW1vdGVMZW5ndGggPSB0aGlzLnBlZXJzW2ldLnJlbW90ZUxlbmd0aFxuICAgICAgaWYgKHJlbW90ZUxlbmd0aCA+IGxlbikgbGVuID0gcmVtb3RlTGVuZ3RoXG4gICAgfVxuICAgIHJldHVybiBsZW5cbiAgfVxufSlcblxuRmVlZC5wcm90b3R5cGUucmVwbGljYXRlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8gTGF6eSBsb2FkIHJlcGxpY2F0aW9uIGRlcHNcbiAgaWYgKCFyZXBsaWNhdGUpIHJlcGxpY2F0ZSA9IHJlcXVpcmUoJy4vbGliL3JlcGxpY2F0ZScpXG5cbiAgaWYgKCghdGhpcy5fc2VsZWN0aW9ucy5sZW5ndGggfHwgdGhpcy5fc2VsZWN0aW9uc1swXS5lbmQgIT09IC0xKSAmJiAhdGhpcy5zcGFyc2UgJiYgIShvcHRzICYmIG9wdHMubGl2ZSkpIHtcbiAgICAvLyBoYWNrISEgcHJvcGVyIGZpeCBpcyB0byByZWZhY3RvciAuL3JlcGxpY2F0ZSB0byAqbm90KiBjbGVhciBvdXIgbm9uLXNwYXJzZSBzZWxlY3Rpb25cbiAgICB0aGlzLmRvd25sb2FkKHtzdGFydDogMCwgZW5kOiAtMX0pXG4gIH1cblxuICByZXR1cm4gcmVwbGljYXRlKHRoaXMsIG9wdHMgfHwge30pXG59XG5cbkZlZWQucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKG9ucmVhZHkpIHtcbiAgdGhpcy5fcmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghZXJyKSBvbnJlYWR5KClcbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGxlbiwgY2IpIHtcbiAgaWYgKHR5cGVvZiBsZW4gPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLnVwZGF0ZSgtMSwgbGVuKVxuICBpZiAodHlwZW9mIGxlbiAhPT0gJ251bWJlcicpIGxlbiA9IC0xXG4gIGlmICghY2IpIGNiID0gbm9vcFxuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMucmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKGxlbiA9PT0gLTEpIGxlbiA9IHNlbGYubGVuZ3RoICsgMVxuICAgIGlmIChzZWxmLmxlbmd0aCA+PSBsZW4pIHJldHVybiBjYihudWxsKVxuXG4gICAgaWYgKHNlbGYud3JpdGFibGUpIGNiID0gc2VsZi5fd3JpdGVTdGF0ZVJlbG9hZGVyKGNiKVxuXG4gICAgc2VsZi5fd2FpdGluZy5wdXNoKHtcbiAgICAgIGhhc2g6IHRydWUsXG4gICAgICBieXRlczogMCxcbiAgICAgIGluZGV4OiBsZW4gLSAxLFxuICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgY2FsbGJhY2s6IGNiXG4gICAgfSlcblxuICAgIHNlbGYuX3VwZGF0ZVBlZXJzKClcbiAgfSlcbn1cblxuLy8gd2lsbCByZWxvYWQgdGhlIHdyaXRhYmxlIHN0YXRlLiB1c2VkIGJ5IC51cGRhdGUgb24gYSB3cml0YWJsZSBwZWVyXG5GZWVkLnByb3RvdHlwZS5fd3JpdGVTdGF0ZVJlbG9hZGVyID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBzZWxmLl9yb290cyhzZWxmLmxlbmd0aCwgZnVuY3Rpb24gKGVyciwgcm9vdHMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBzZWxmLl9tZXJrbGUgPSBtZXJrbGUoY3J5cHRvLCByb290cylcbiAgICAgIGNiKG51bGwpXG4gICAgfSlcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGdlbmVyYXRlZEtleSA9IGZhbHNlXG5cbiAgLy8gVE9ETzogY2xlYW4gdXAgdGhlIGR1cGxpY2F0ZSBjb2RlIGJlbG93IC4uLlxuXG4gIHRoaXMuX3N0b3JhZ2Uub3BlbktleShmdW5jdGlvbiAoXywga2V5KSB7XG4gICAgaWYgKGtleSAmJiAhc2VsZi5fb3ZlcndyaXRlICYmICFzZWxmLmtleSkgc2VsZi5rZXkgPSBrZXlcblxuICAgIGlmICghc2VsZi5rZXkgJiYgc2VsZi5saXZlKSB7XG4gICAgICB2YXIga2V5UGFpciA9IGNyeXB0by5rZXlQYWlyKClcbiAgICAgIHNlbGYuc2VjcmV0S2V5ID0ga2V5UGFpci5zZWNyZXRLZXlcbiAgICAgIHNlbGYua2V5ID0ga2V5UGFpci5wdWJsaWNLZXlcbiAgICAgIGdlbmVyYXRlZEtleSA9IHRydWVcbiAgICB9XG5cbiAgICBzZWxmLmRpc2NvdmVyeUtleSA9IHNlbGYua2V5ICYmIGNyeXB0by5kaXNjb3ZlcnlLZXkoc2VsZi5rZXkpXG4gICAgc2VsZi5fc3RvcmFnZS5vcGVuKHtrZXk6IHNlbGYua2V5LCBkaXNjb3ZlcnlLZXk6IHNlbGYuZGlzY292ZXJ5S2V5fSwgb25vcGVuKVxuICB9KVxuXG4gIGZ1bmN0aW9uIG9ub3BlbiAoZXJyLCBzdGF0ZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICAvLyBpZiBubyBrZXkgYnV0IHdlIGhhdmUgZGF0YSBkbyBhIGJpdGZpZWxkIHJlc2V0IHNpbmNlIHdlIGNhbm5vdCB2ZXJpZnkgdGhlIGRhdGEuXG4gICAgaWYgKCFzdGF0ZS5rZXkgJiYgc3RhdGUuYml0ZmllbGQubGVuZ3RoKSB7XG4gICAgICBzZWxmLl9vdmVyd3JpdGUgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX292ZXJ3cml0ZSkge1xuICAgICAgc3RhdGUuYml0ZmllbGQuZmlsbCgwKVxuICAgICAgc3RhdGUua2V5ID0gc3RhdGUuc2VjcmV0S2V5ID0gbnVsbFxuICAgIH1cblxuICAgIHNlbGYuYml0ZmllbGQgPSBiaXRmaWVsZChzdGF0ZS5iaXRmaWVsZClcbiAgICBzZWxmLnRyZWUgPSB0cmVlSW5kZXgoc2VsZi5iaXRmaWVsZC50cmVlKVxuICAgIHNlbGYubGVuZ3RoID0gc2VsZi50cmVlLmJsb2NrcygpXG5cbiAgICBpZiAoc3RhdGUua2V5ICYmIHNlbGYua2V5ICYmICFlcXVhbHMoc3RhdGUua2V5LCBzZWxmLmtleSkpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0Fub3RoZXIgaHlwZXJjb3JlIGlzIHN0b3JlZCBoZXJlJykpXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmtleSkgc2VsZi5rZXkgPSBzdGF0ZS5rZXlcbiAgICBpZiAoc3RhdGUuc2VjcmV0S2V5KSBzZWxmLnNlY3JldEtleSA9IHN0YXRlLnNlY3JldEtleVxuXG4gICAgLy8gdmVyaWZ5IGtleSBhbmQgc2VjcmV0S2V5IGdvIHRvZ2V0aGVyXG4gICAgaWYgKHNlbGYua2V5ICYmIHNlbGYuc2VjcmV0S2V5KSB7XG4gICAgICB2YXIgY2hhbGxlbmdlID0gYnVmZmVyQWxsb2MoMClcbiAgICAgIGlmICghY3J5cHRvLnZlcmlmeShjaGFsbGVuZ2UsIGNyeXB0by5zaWduKGNoYWxsZW5nZSwgc2VsZi5zZWNyZXRLZXkpLCBzZWxmLmtleSkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignS2V5IGFuZCBzZWNyZXQgZG8gbm90IG1hdGNoJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLmxlbmd0aCkgcmV0dXJuIG9uc2lnbmF0dXJlKG51bGwsIG51bGwpXG4gICAgc2VsZi5fc3RvcmFnZS5nZXRTaWduYXR1cmUoc2VsZi5sZW5ndGggLSAxLCBvbnNpZ25hdHVyZSlcblxuICAgIGZ1bmN0aW9uIG9uc2lnbmF0dXJlIChfLCBzaWcpIHtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCkgc2VsZi5saXZlID0gISFzaWdcblxuICAgICAgaWYgKChnZW5lcmF0ZWRLZXkgfHwgIXNlbGYua2V5KSAmJiAhc2VsZi5fY3JlYXRlSWZNaXNzaW5nKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ05vIGh5cGVyY29yZSBpcyBzdG9yZWQgaGVyZScpKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYua2V5ICYmIHNlbGYubGl2ZSkge1xuICAgICAgICB2YXIga2V5UGFpciA9IGNyeXB0by5rZXlQYWlyKClcbiAgICAgICAgc2VsZi5zZWNyZXRLZXkgPSBrZXlQYWlyLnNlY3JldEtleVxuICAgICAgICBzZWxmLmtleSA9IGtleVBhaXIucHVibGljS2V5XG4gICAgICB9XG5cbiAgICAgIHZhciB3cml0YWJsZSA9ICEhc2VsZi5zZWNyZXRLZXkgfHwgc2VsZi5rZXkgPT09IG51bGxcblxuICAgICAgaWYgKCF3cml0YWJsZSAmJiBzZWxmLndyaXRhYmxlKSByZXR1cm4gY2IobmV3IEVycm9yKCdGZWVkIGlzIG5vdCB3cml0YWJsZScpKVxuICAgICAgc2VsZi53cml0YWJsZSA9IHdyaXRhYmxlXG4gICAgICBzZWxmLmRpc2NvdmVyeUtleSA9IHNlbGYua2V5ICYmIGNyeXB0by5kaXNjb3ZlcnlLZXkoc2VsZi5rZXkpXG5cbiAgICAgIGlmIChzZWxmLl9zdG9yZVNlY3JldEtleSAmJiAhc2VsZi5zZWNyZXRLZXkpIHtcbiAgICAgICAgc2VsZi5fc3RvcmVTZWNyZXRLZXkgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICB2YXIgc2hvdWxkV3JpdGVLZXkgPSBnZW5lcmF0ZWRLZXkgfHwgIXNhZmVCdWZmZXJFcXVhbHMoc2VsZi5rZXksIHN0YXRlLmtleSlcbiAgICAgIHZhciBzaG91bGRXcml0ZVNlY3JldEtleSA9IHNlbGYuX3N0b3JlU2VjcmV0S2V5ICYmIChnZW5lcmF0ZWRLZXkgfHwgIXNhZmVCdWZmZXJFcXVhbHMoc2VsZi5zZWNyZXRLZXksIHN0YXRlLnNlY3JldEtleSkpXG5cbiAgICAgIHZhciBtaXNzaW5nID0gMSArXG4gICAgICAgIChzaG91bGRXcml0ZUtleSA/IDEgOiAwKSArXG4gICAgICAgIChzaG91bGRXcml0ZVNlY3JldEtleSA/IDEgOiAwKSArXG4gICAgICAgIChzZWxmLl9vdmVyd3JpdGUgPyAxIDogMClcbiAgICAgIHZhciBlcnJvciA9IG51bGxcblxuICAgICAgaWYgKHNob3VsZFdyaXRlS2V5KSBzZWxmLl9zdG9yYWdlLmtleS53cml0ZSgwLCBzZWxmLmtleSwgZG9uZSlcbiAgICAgIGlmIChzaG91bGRXcml0ZVNlY3JldEtleSkgc2VsZi5fc3RvcmFnZS5zZWNyZXRLZXkud3JpdGUoMCwgc2VsZi5zZWNyZXRLZXksIGRvbmUpXG5cbiAgICAgIGlmIChzZWxmLl9vdmVyd3JpdGUpIHsgLy8gVE9ETzogc3VwcG9ydCBzdG9yYWdlLnJlc2l6ZSBmb3IgdGhpcyBpbnN0ZWFkXG4gICAgICAgIHNlbGYuX3N0b3JhZ2UucHV0Qml0ZmllbGQoMCwgc3RhdGUuYml0ZmllbGQsIGRvbmUpXG4gICAgICB9XG5cbiAgICAgIGRvbmUobnVsbClcblxuICAgICAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgICAgIGlmICgtLW1pc3NpbmcpIHJldHVyblxuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjYihlcnJvcilcbiAgICAgICAgc2VsZi5fcm9vdHMoc2VsZi5sZW5ndGgsIG9ucm9vdHMpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9ucm9vdHMgKGVyciwgcm9vdHMpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgICAgICBzZWxmLl9tZXJrbGUgPSBtZXJrbGUoY3J5cHRvLCByb290cylcbiAgICAgICAgc2VsZi5ieXRlTGVuZ3RoID0gcm9vdHMucmVkdWNlKGFkZFNpemUsIDApXG4gICAgICAgIHNlbGYub3BlbmVkID0gdHJ1ZVxuICAgICAgICBzZWxmLmVtaXQoJ3JlYWR5JylcblxuICAgICAgICBjYihudWxsKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uIChyYW5nZSwgY2IpIHtcbiAgaWYgKHR5cGVvZiByYW5nZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZG93bmxvYWQobnVsbCwgcmFuZ2UpXG4gIGlmICh0eXBlb2YgcmFuZ2UgPT09ICdudW1iZXInKSByYW5nZSA9IHtzdGFydDogcmFuZ2UsIGVuZDogcmFuZ2UgKyAxfVxuICBpZiAoIXJhbmdlKSByYW5nZSA9IHt9XG5cbiAgLy8gVE9ETzogaWYgbm8gcGVlcnMsIGNoZWNrIGlmIHJhbmdlIGlzIGFscmVhZHkgc2F0aXNmaWVkIGFuZCBuZXh0VGljayhjYikgaWYgc29cbiAgLy8gdGhpcy5fdXBkYXRlUGVlcnMgZG9lcyB0aGlzIGZvciB1cyB3aGVuIHRoZXJlIGlzIGEgcGVlciB0aG91Z2gsIHNvIG5vdCBjcml0aWNhbFxuXG4gIHZhciBzZWwgPSB7XG4gICAgX2luZGV4OiB0aGlzLl9zZWxlY3Rpb25zLmxlbmd0aCxcbiAgICBoYXNoOiAhIXJhbmdlLmhhc2gsXG4gICAgaXRlcmF0b3I6IG51bGwsXG4gICAgc3RhcnQ6IHJhbmdlLnN0YXJ0IHx8IDAsXG4gICAgZW5kOiByYW5nZS5lbmQgfHwgLTEsXG4gICAgbGluZWFyOiAhIXJhbmdlLmxpbmVhcixcbiAgICBjYWxsYmFjazogY2IgfHwgbm9vcFxuICB9XG5cbiAgdGhpcy5fc2VsZWN0aW9ucy5wdXNoKHNlbClcbiAgdGhpcy5fdXBkYXRlUGVlcnMoKVxuXG4gIHJldHVybiBzZWxcbn1cblxuRmVlZC5wcm90b3R5cGUudW5kb3dubG9hZCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICBpZiAodHlwZW9mIHJhbmdlID09PSAnbnVtYmVyJykgcmFuZ2UgPSB7c3RhcnQ6IHJhbmdlLCBlbmQ6IHJhbmdlICsgMX1cbiAgaWYgKCFyYW5nZSkgcmFuZ2UgPSB7fVxuXG4gIGlmIChyYW5nZS5jYWxsYmFjayAmJiByYW5nZS5faW5kZXggPiAtMSkge1xuICAgIHNldC5yZW1vdmUodGhpcy5fc2VsZWN0aW9ucywgcmFuZ2UpXG4gICAgbmV4dFRpY2socmFuZ2UuY2FsbGJhY2ssIG5ldyBFcnJvcignRG93bmxvYWQgd2FzIGNhbmNlbGxlZCcpKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQgfHwgMFxuICB2YXIgZW5kID0gcmFuZ2UuZW5kIHx8IC0xXG4gIHZhciBoYXNoID0gISFyYW5nZS5oYXNoXG4gIHZhciBsaW5lYXIgPSAhIXJhbmdlLmxpbmVhclxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gdGhpcy5fc2VsZWN0aW9uc1tpXVxuXG4gICAgaWYgKHMuc3RhcnQgPT09IHN0YXJ0ICYmIHMuZW5kID09PSBlbmQgJiYgcy5oYXNoID09PSBoYXNoICYmIHMubGluZWFyID09PSBsaW5lYXIpIHtcbiAgICAgIHNldC5yZW1vdmUodGhpcy5fc2VsZWN0aW9ucywgcylcbiAgICAgIG5leHRUaWNrKHMuY2FsbGJhY2ssIG5ldyBFcnJvcignRG93bmxvYWQgd2FzIGNhbmNlbGxlZCcpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICByZXR1cm4gdGhpcy50cmVlLmRpZ2VzdCgyICogaW5kZXgpXG59XG5cbkZlZWQucHJvdG90eXBlLnByb29mID0gZnVuY3Rpb24gKGluZGV4LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLnByb29mKGluZGV4LCBudWxsLCBvcHRzKVxuICBpZiAoIXRoaXMub3BlbmVkKSByZXR1cm4gdGhpcy5fcmVhZHlBbmRQcm9vZihpbmRleCwgb3B0cywgY2IpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgdmFyIHByb29mID0gdGhpcy50cmVlLnByb29mKDIgKiBpbmRleCwgb3B0cylcbiAgaWYgKCFwcm9vZikgcmV0dXJuIGNiKG5ldyBFcnJvcignTm8gcHJvb2YgYXZhaWxhYmxlIGZvciB0aGlzIGluZGV4JykpXG5cbiAgdmFyIG5lZWRzU2lnID0gdGhpcy5saXZlICYmICEhcHJvb2YudmVyaWZpZWRCeVxuICB2YXIgcGVuZGluZyA9IHByb29mLm5vZGVzLmxlbmd0aCArIChuZWVkc1NpZyA/IDEgOiAwKVxuICB2YXIgZXJyb3IgPSBudWxsXG4gIHZhciBzaWduYXR1cmUgPSBudWxsXG4gIHZhciBub2RlcyA9IG5ldyBBcnJheShwcm9vZi5ub2Rlcy5sZW5ndGgpXG5cbiAgaWYgKCFwZW5kaW5nKSByZXR1cm4gY2IobnVsbCwge25vZGVzOiBub2Rlcywgc2lnbmF0dXJlOiBudWxsfSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb29mLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fc3RvcmFnZS5nZXROb2RlKHByb29mLm5vZGVzW2ldLCBvbm5vZGUpXG4gIH1cbiAgaWYgKG5lZWRzU2lnKSB7XG4gICAgdGhpcy5fc3RvcmFnZS5nZXRTaWduYXR1cmUocHJvb2YudmVyaWZpZWRCeSAvIDIgLSAxLCBvbnNpZ25hdHVyZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uc2lnbmF0dXJlIChlcnIsIHNpZykge1xuICAgIGlmIChzaWcpIHNpZ25hdHVyZSA9IHNpZ1xuICAgIG9ubm9kZShlcnIsIG51bGwpXG4gIH1cblxuICBmdW5jdGlvbiBvbm5vZGUgKGVyciwgbm9kZSkge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZXNbcHJvb2Yubm9kZXMuaW5kZXhPZihub2RlLmluZGV4KV0gPSBub2RlXG4gICAgfVxuXG4gICAgaWYgKC0tcGVuZGluZykgcmV0dXJuXG4gICAgaWYgKGVycm9yKSByZXR1cm4gY2IoZXJyb3IpXG4gICAgY2IobnVsbCwge25vZGVzOiBub2Rlcywgc2lnbmF0dXJlOiBzaWduYXR1cmV9KVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9yZWFkeUFuZFByb29mID0gZnVuY3Rpb24gKGluZGV4LCBvcHRzLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5wcm9vZihpbmRleCwgb3B0cywgY2IpXG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChpbmRleCwgZGF0YSwgcHJvb2YsIGNiKSB7XG4gIGlmICghdGhpcy5vcGVuZWQpIHJldHVybiB0aGlzLl9yZWFkeUFuZFB1dChpbmRleCwgZGF0YSwgcHJvb2YsIGNiKVxuICB0aGlzLl9wdXRCdWZmZXIoaW5kZXgsIHRoaXMuX2NvZGVjLmVuY29kZShkYXRhKSwgcHJvb2YsIG51bGwsIGNiKVxufVxuXG5GZWVkLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkgeyAgLy8gVE9ETzogdXNlIHNhbWUgYXJndW1lbnQgc2NoZW1lIGFzIGRvd25sb2FkXG4gIGlmICghZW5kKSBlbmQgPSBzdGFydCArIDFcblxuICAvLyBjYW5jZWwgdGhlc2UgcmlnaHQgYXdheSBhcyAuZG93bmxvYWQgZG9lcyBub3Qgd2FpdCBmb3IgcmVhZHlcbiAgZm9yICh2YXIgaSA9IHRoaXMuX3NlbGVjdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2VsID0gdGhpcy5fc2VsZWN0aW9uc1tpXVxuICAgIGlmIChzdGFydCA8PSBzZWwuc3RhcnQgJiYgc2VsLmVuZCA8PSBlbmQpIHtcbiAgICAgIHRoaXMudW5kb3dubG9hZChzZWwpXG4gICAgfVxuICB9XG5cbiAgLy8gZGVmZXIgdGhlIGxhc3QgcGFydCB1bnRpbCBhZnRlciByZWFkeSBhcyAuZ2V0IGRvZXMgdGhhdCBhcyB3ZWxsXG4gIGlmICh0aGlzLm9wZW5lZCkgdGhpcy5fY2FuY2VsKHN0YXJ0LCBlbmQpXG4gIGVsc2UgdGhpcy5fcmVhZHlBbmRDYW5jZWwoc3RhcnQsIGVuZClcbn1cblxuRmVlZC5wcm90b3R5cGUuX2NhbmNlbCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBpID0gMFxuXG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzLl9yZXNlcnZlZC5zZXQoaSwgZmFsc2UpIC8vIFRPRE86IHNlbmQgY2FuY2VsIG1lc3NhZ2UgaWYgc2V0IHJldHVybnMgdHJ1ZVxuICB9XG5cbiAgZm9yIChpID0gdGhpcy5fd2FpdGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciB3ID0gdGhpcy5fd2FpdGluZ1tpXVxuICAgIGlmICgoc3RhcnQgPD0gdy5zdGFydCAmJiB3LmVuZCA8PSBlbmQpIHx8IChzdGFydCA8PSB3LmluZGV4ICYmIHcuaW5kZXggPCBlbmQpKSB7XG4gICAgICByZW1vdmUodGhpcy5fd2FpdGluZywgaSlcbiAgICAgIGlmICh3LmNhbGxiYWNrKSBuZXh0VGljayh3LmNhbGxiYWNrLCBuZXcgRXJyb3IoJ1JlcXVlc3QgY2FuY2VsbGVkJykpXG4gICAgfVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG9wdHMsIGNiKSB7IC8vIFRPRE86IHVzZSBzYW1lIGFyZ3VtZW50IHNjaGVtZSBhcyBkb3dubG9hZFxuICBpZiAodHlwZW9mIGVuZCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuY2xlYXIoc3RhcnQsIHN0YXJ0ICsgMSwgbnVsbCwgZW5kKVxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmNsZWFyKHN0YXJ0LCBlbmQsIG51bGwsIG9wdHMpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIGlmICghZW5kKSBlbmQgPSBzdGFydCArIDFcbiAgaWYgKCFjYikgY2IgPSBub29wXG5cbiAgLy8gVE9ETzogdGhpcyBuZWVkcyBzb21lIHdvcmsuIGZ4IHdlIGNhbiBvbmx5IGNhbGMgYnl0ZSBvZmZzZXQgZm9yIGJsb2NrcyB3ZSBrbm93IGFib3V0XG4gIC8vIHNvIGludGVybmFsbHkgd2Ugc2hvdWxkIG1ha2Ugc3VyZSB0byBvbmx5IGRvIHRoYXQuIFdlIHNob3VsZCB1c2UgdGhlIG1lcmtsZSB0cmVlIGZvciB0aGlzXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBieXRlT2Zmc2V0ID0gc3RhcnQgPT09IDAgPyAwIDogKHR5cGVvZiBvcHRzLmJ5dGVPZmZzZXQgPT09ICdudW1iZXInID8gb3B0cy5ieXRlT2Zmc2V0IDogLTEpXG4gIHZhciBieXRlTGVuZ3RoID0gdHlwZW9mIG9wdHMuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicgPyBvcHRzLmJ5dGVMZW5ndGggOiAtMVxuXG4gIHRoaXMuX3JlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgdmFyIG1vZGlmaWVkID0gZmFsc2VcblxuICAgIC8vIFRPRE86IHVzZSBhIGJ1ZmZlci5maWxsIHRoaW5nIGhlcmUgdG8gc3BlZWQgdGhpcyB1cCFcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBpZiAoc2VsZi5iaXRmaWVsZC5zZXQoaSwgZmFsc2UpKSBtb2RpZmllZCA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoIW1vZGlmaWVkKSByZXR1cm4gbmV4dFRpY2soY2IpXG5cbiAgICAvLyBUT0RPOiB3cml0ZSB0byBhIHRtcC91cGRhdGUgZmlsZSB0aGF0IHdlIHdhbnQgdG8gZGVsIHRoaXMgaW5jYXNlIGl0IGNyYXNoZXMgd2lsbCBkZWwnaW5nXG5cbiAgICBzZWxmLl91bmFubm91bmNlKHtzdGFydDogc3RhcnQsIGxlbmd0aDogZW5kIC0gc3RhcnR9KVxuICAgIGlmIChvcHRzLmRlbGV0ZSA9PT0gZmFsc2UgfHwgc2VsZi5faW5kZXhpbmcpIHJldHVybiBzeW5jKClcbiAgICBpZiAoYnl0ZU9mZnNldCA+IC0xKSByZXR1cm4gb25zdGFydGJ5dGVzKG51bGwsIGJ5dGVPZmZzZXQpXG4gICAgc2VsZi5fc3RvcmFnZS5kYXRhT2Zmc2V0KHN0YXJ0LCBbXSwgb25zdGFydGJ5dGVzKVxuXG4gICAgZnVuY3Rpb24gc3luYyAoKSB7XG4gICAgICBzZWxmLmVtaXQoJ2NsZWFyJywgc3RhcnQsIGVuZClcbiAgICAgIHNlbGYuX3N5bmMobnVsbCwgY2IpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25zdGFydGJ5dGVzIChlcnIsIG9mZnNldCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGJ5dGVPZmZzZXQgPSBvZmZzZXRcbiAgICAgIGlmIChieXRlTGVuZ3RoID4gLTEpIHJldHVybiBvbmVuZGJ5dGVzKG51bGwsIGJ5dGVMZW5ndGggKyBieXRlT2Zmc2V0KVxuICAgICAgaWYgKGVuZCA9PT0gc2VsZi5sZW5ndGgpIHJldHVybiBvbmVuZGJ5dGVzKG51bGwsIHNlbGYuYnl0ZUxlbmd0aClcbiAgICAgIHNlbGYuX3N0b3JhZ2UuZGF0YU9mZnNldChlbmQsIFtdLCBvbmVuZGJ5dGVzKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uZW5kYnl0ZXMgKGVyciwgZW5kKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgaWYgKCFzZWxmLl9zdG9yYWdlLmRhdGEuZGVsKSByZXR1cm4gc3luYygpIC8vIE5vdCBhbGwgZGF0YSBzdG9yYWdlIGltcGxzIGRlbFxuICAgICAgc2VsZi5fc3RvcmFnZS5kYXRhLmRlbChieXRlT2Zmc2V0LCBlbmQgLSBieXRlT2Zmc2V0LCBzeW5jKVxuICAgIH1cbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUuc2lnbmF0dXJlID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICBpZiAodHlwZW9mIGluZGV4ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5zaWduYXR1cmUodGhpcy5sZW5ndGggLSAxLCBpbmRleClcblxuICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSByZXR1cm4gY2IobmV3IEVycm9yKCdObyBzaWduYXR1cmUgYXZhaWxhYmxlIGZvciB0aGlzIGluZGV4JykpXG5cbiAgdGhpcy5fc3RvcmFnZS5uZXh0U2lnbmF0dXJlKGluZGV4LCBjYilcbn1cblxuRmVlZC5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKGluZGV4LCBzaWduYXR1cmUsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMucm9vdEhhc2hlcyhpbmRleCwgZnVuY3Rpb24gKGVyciwgcm9vdHMpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgdmFyIGNoZWNrc3VtID0gY3J5cHRvLnRyZWUocm9vdHMpXG5cbiAgICBpZiAoIWNyeXB0by52ZXJpZnkoY2hlY2tzdW0sIHNpZ25hdHVyZSwgc2VsZi5rZXkpKSB7XG4gICAgICBjYihuZXcgRXJyb3IoJ1NpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwsIHRydWUpXG4gICAgfVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5yb290SGFzaGVzID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB0aGlzLl9nZXRSb290c1RvVmVyaWZ5KGluZGV4ICogMiArIDIsIHt9LCBbXSwgY2IpXG59XG5cbkZlZWQucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbiAoYnl0ZXMsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuc2VlayhieXRlcywgbnVsbCwgb3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgaWYgKCF0aGlzLm9wZW5lZCkgcmV0dXJuIHRoaXMuX3JlYWR5QW5kU2VlayhieXRlcywgb3B0cywgY2IpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5fc2VlayhieXRlcywgZnVuY3Rpb24gKGVyciwgaW5kZXgsIG9mZnNldCkge1xuICAgIGlmICghZXJyICYmIGlzQmxvY2soaW5kZXgpKSByZXR1cm4gZG9uZShpbmRleCAvIDIsIG9mZnNldClcbiAgICBpZiAob3B0cy53YWl0ID09PSBmYWxzZSkgcmV0dXJuIGNiKGVyciB8fCBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZWVrIHRvIHRoaXMgb2Zmc2V0JykpXG5cbiAgICB2YXIgc3RhcnQgPSBvcHRzLnN0YXJ0IHx8IDBcbiAgICB2YXIgZW5kID0gb3B0cy5lbmQgfHwgLTFcblxuICAgIGlmICghZXJyKSB7XG4gICAgICB2YXIgbGVmdCA9IGZsYXQubGVmdFNwYW4oaW5kZXgpIC8gMlxuICAgICAgdmFyIHJpZ2h0ID0gZmxhdC5yaWdodFNwYW4oaW5kZXgpIC8gMiArIDFcblxuICAgICAgaWYgKGxlZnQgPiBzdGFydCkgc3RhcnQgPSBsZWZ0XG4gICAgICBpZiAocmlnaHQgPCBlbmQgfHwgZW5kID09PSAtMSkgZW5kID0gcmlnaHRcbiAgICB9XG5cbiAgICBpZiAoZW5kID4gLTEgJiYgZW5kIDw9IHN0YXJ0KSByZXR1cm4gY2IobmV3IEVycm9yKCdVbmFibGUgdG8gc2VlayB0byB0aGlzIG9mZnNldCcpKVxuXG4gICAgc2VsZi5fd2FpdGluZy5wdXNoKHtcbiAgICAgIGhhc2g6IG9wdHMuaGFzaCAhPT0gZmFsc2UsXG4gICAgICBieXRlczogYnl0ZXMsXG4gICAgICBpbmRleDogLTEsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZCxcbiAgICAgIGNhbGxiYWNrOiBjYiB8fCBub29wXG4gICAgfSlcblxuICAgIHNlbGYuX3VwZGF0ZVBlZXJzKClcbiAgfSlcblxuICBmdW5jdGlvbiBkb25lIChpbmRleCwgb2Zmc2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnBlZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxmLnBlZXJzW2ldLmhhdmVCeXRlcyhieXRlcylcbiAgICB9XG4gICAgY2IobnVsbCwgaW5kZXgsIG9mZnNldClcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fc2VlayA9IGZ1bmN0aW9uIChvZmZzZXQsIGNiKSB7XG4gIGlmIChvZmZzZXQgPT09IDApIHJldHVybiBjYihudWxsLCAwLCAwKVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcm9vdHMgPSBmbGF0LmZ1bGxSb290cyh0aGlzLmxlbmd0aCAqIDIpXG4gIHZhciBuZWFyZXN0Um9vdCA9IDBcblxuICBsb29wKG51bGwsIG51bGwpXG5cbiAgZnVuY3Rpb24gb25yb290ICh0b3ApIHtcbiAgICBpZiAoaXNCbG9jayh0b3ApKSByZXR1cm4gY2IobnVsbCwgdG9wLCBvZmZzZXQpXG5cbiAgICB2YXIgbGVmdCA9IGZsYXQubGVmdENoaWxkKHRvcClcbiAgICB3aGlsZSAoIXNlbGYudHJlZS5nZXQobGVmdCkpIHtcbiAgICAgIGlmIChpc0Jsb2NrKGxlZnQpKSByZXR1cm4gY2IobnVsbCwgbmVhcmVzdFJvb3QsIG9mZnNldClcbiAgICAgIGxlZnQgPSBmbGF0LmxlZnRDaGlsZChsZWZ0KVxuICAgIH1cblxuICAgIHNlbGYuX3N0b3JhZ2UuZ2V0Tm9kZShsZWZ0LCBvbmxlZnRjaGlsZClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubGVmdGNoaWxkIChlcnIsIG5vZGUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgaWYgKG5vZGUuc2l6ZSA+IG9mZnNldCkge1xuICAgICAgbmVhcmVzdFJvb3QgPSBub2RlLmluZGV4XG4gICAgICBvbnJvb3Qobm9kZS5pbmRleClcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0IC09IG5vZGUuc2l6ZVxuICAgICAgb25yb290KGZsYXQuc2libGluZyhub2RlLmluZGV4KSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb29wIChlcnIsIG5vZGUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnNpemUgPiBvZmZzZXQpIHtcbiAgICAgICAgbmVhcmVzdFJvb3QgPSBub2RlLmluZGV4XG4gICAgICAgIHJldHVybiBvbnJvb3Qobm9kZS5pbmRleClcbiAgICAgIH1cbiAgICAgIG9mZnNldCAtPSBub2RlLnNpemVcbiAgICB9XG5cbiAgICBpZiAoIXJvb3RzLmxlbmd0aCkgcmV0dXJuIGNiKG5ldyBFcnJvcignT3V0IG9mIGJvdW5kcycpKVxuICAgIHNlbGYuX3N0b3JhZ2UuZ2V0Tm9kZShyb290cy5zaGlmdCgpLCBsb29wKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9yZWFkeUFuZFNlZWsgPSBmdW5jdGlvbiAoYnl0ZXMsIG9wdHMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBzZWxmLnNlZWsoYnl0ZXMsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5fZ2V0QnVmZmVyID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB0aGlzLl9zdG9yYWdlLmdldERhdGEoaW5kZXgsIGNiKVxufVxuXG5GZWVkLnByb3RvdHlwZS5fcHV0QnVmZmVyID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhLCBwcm9vZiwgZnJvbSwgY2IpIHtcbiAgLy8gVE9ETzogdGhpcyBub2RlcyBpbiBwcm9vZiBhcmUgbm90IGluc3RhbmNlcyBvZiBvdXIgTm9kZSBwcm90b3R5cGVcbiAgLy8gYnV0IGp1c3Qgc2ltaWxhci4gQ2hlY2sgaWYgdGhpcyBoYXMgYW55IHY4IHBlcmYgaW1wbGljYXRpb25zLlxuXG4gIC8vIFRPRE86IGlmIHRoZSBwcm9vZiBjb250YWlucyBhIHZhbGlkIHNpZ25hdHVyZSBCVVQgZmFpbHMsIGVtaXQgYSBjcml0aWNhbCBlcnJvclxuICAvLyAtLT4gZmVlZCBzaG91bGQgYmUgY29uc2lkZXJlZCBkZWFkXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciB0cnVzdGVkID0gLTFcbiAgdmFyIG1pc3NpbmcgPSBbXVxuICB2YXIgbmV4dCA9IDIgKiBpbmRleFxuICB2YXIgaSA9IGRhdGEgPyAwIDogMVxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHRoaXMudHJlZS5nZXQobmV4dCkpIHtcbiAgICAgIHRydXN0ZWQgPSBuZXh0XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIHZhciBzaWIgPSBmbGF0LnNpYmxpbmcobmV4dClcbiAgICBuZXh0ID0gZmxhdC5wYXJlbnQobmV4dClcblxuICAgIGlmIChpIDwgcHJvb2Yubm9kZXMubGVuZ3RoICYmIHByb29mLm5vZGVzW2ldLmluZGV4ID09PSBzaWIpIHtcbiAgICAgIGkrK1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudHJlZS5nZXQoc2liKSkgYnJlYWtcbiAgICBtaXNzaW5nLnB1c2goc2liKVxuICB9XG5cbiAgaWYgKHRydXN0ZWQgPT09IC0xICYmIHRoaXMudHJlZS5nZXQobmV4dCkpIHRydXN0ZWQgPSBuZXh0XG5cbiAgdmFyIGVycm9yID0gbnVsbFxuICB2YXIgdHJ1c3RlZE5vZGUgPSBudWxsXG4gIHZhciBtaXNzaW5nTm9kZXMgPSBuZXcgQXJyYXkobWlzc2luZy5sZW5ndGgpXG4gIHZhciBwZW5kaW5nID0gbWlzc2luZy5sZW5ndGggKyAodHJ1c3RlZCA+IC0xID8gMSA6IDApXG5cbiAgZm9yIChpID0gMDsgaSA8IG1pc3NpbmcubGVuZ3RoOyBpKyspIHRoaXMuX3N0b3JhZ2UuZ2V0Tm9kZShtaXNzaW5nW2ldLCBvbm1pc3NpbmcpXG4gIGlmICh0cnVzdGVkID4gLTEpIHRoaXMuX3N0b3JhZ2UuZ2V0Tm9kZSh0cnVzdGVkLCBvbnRydXN0ZWQpXG4gIGlmICghbWlzc2luZy5sZW5ndGggJiYgdHJ1c3RlZCA9PT0gLTEpIG9ubWlzc2luZ2xvYWRlZChudWxsKVxuXG4gIGZ1bmN0aW9uIG9udHJ1c3RlZCAoZXJyLCBub2RlKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAobm9kZSkgdHJ1c3RlZE5vZGUgPSBub2RlXG4gICAgaWYgKCEtLXBlbmRpbmcpIG9ubWlzc2luZ2xvYWRlZChlcnJvcilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubWlzc2luZyAoZXJyLCBub2RlKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAobm9kZSkgbWlzc2luZ05vZGVzW21pc3NpbmcuaW5kZXhPZihub2RlLmluZGV4KV0gPSBub2RlXG4gICAgaWYgKCEtLXBlbmRpbmcpIG9ubWlzc2luZ2xvYWRlZChlcnJvcilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubWlzc2luZ2xvYWRlZCAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBzZWxmLl92ZXJpZnlBbmRXcml0ZShpbmRleCwgZGF0YSwgcHJvb2YsIG1pc3NpbmdOb2RlcywgdHJ1c3RlZE5vZGUsIGZyb20sIGNiKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9yZWFkeUFuZFB1dCA9IGZ1bmN0aW9uIChpbmRleCwgZGF0YSwgcHJvb2YsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBzZWxmLnB1dChpbmRleCwgZGF0YSwgcHJvb2YsIGNiKVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoaW5kZXgsIGRhdGEsIG5vZGVzLCBzaWcsIGZyb20sIGNiKSB7XG4gIGlmICghdGhpcy5fb253cml0ZSkgcmV0dXJuIHRoaXMuX3dyaXRlQWZ0ZXJIb29rKGluZGV4LCBkYXRhLCBub2Rlcywgc2lnLCBmcm9tLCBjYilcbiAgdGhpcy5fb253cml0ZShpbmRleCwgZGF0YSwgZnJvbSwgd3JpdGVIb29rRG9uZSh0aGlzLCBpbmRleCwgZGF0YSwgbm9kZXMsIHNpZywgZnJvbSwgY2IpKVxufVxuXG5mdW5jdGlvbiB3cml0ZUhvb2tEb25lIChzZWxmLCBpbmRleCwgZGF0YSwgbm9kZXMsIHNpZywgZnJvbSwgY2IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHNlbGYuX3dyaXRlQWZ0ZXJIb29rKGluZGV4LCBkYXRhLCBub2Rlcywgc2lnLCBmcm9tLCBjYilcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fd3JpdGVBZnRlckhvb2sgPSBmdW5jdGlvbiAoaW5kZXgsIGRhdGEsIG5vZGVzLCBzaWcsIGZyb20sIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcGVuZGluZyA9IG5vZGVzLmxlbmd0aCArIDEgKyAoc2lnID8gMSA6IDApXG4gIHZhciBlcnJvciA9IG51bGxcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB0aGlzLl9zdG9yYWdlLnB1dE5vZGUobm9kZXNbaV0uaW5kZXgsIG5vZGVzW2ldLCBvbmRvbmUpXG4gIGlmIChkYXRhKSB0aGlzLl9zdG9yYWdlLnB1dERhdGEoaW5kZXgsIGRhdGEsIG5vZGVzLCBvbmRvbmUpXG4gIGVsc2Ugb25kb25lKClcbiAgaWYgKHNpZykgdGhpcy5fc3RvcmFnZS5wdXRTaWduYXR1cmUoc2lnLmluZGV4LCBzaWcuc2lnbmF0dXJlLCBvbmRvbmUpXG5cbiAgZnVuY3Rpb24gb25kb25lIChlcnIpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmICgtLXBlbmRpbmcpIHJldHVyblxuICAgIGlmIChlcnJvcikgcmV0dXJuIGNiKGVycm9yKVxuICAgIHNlbGYuX3dyaXRlRG9uZShpbmRleCwgZGF0YSwgbm9kZXMsIGZyb20sIGNiKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl93cml0ZURvbmUgPSBmdW5jdGlvbiAoaW5kZXgsIGRhdGEsIG5vZGVzLCBmcm9tLCBjYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB0aGlzLnRyZWUuc2V0KG5vZGVzW2ldLmluZGV4KVxuICB0aGlzLnRyZWUuc2V0KDIgKiBpbmRleClcblxuICBpZiAoZGF0YSkge1xuICAgIGlmICh0aGlzLmJpdGZpZWxkLnNldChpbmRleCwgdHJ1ZSkpIHRoaXMuZW1pdCgnZG93bmxvYWQnLCBpbmRleCwgZGF0YSwgZnJvbSlcbiAgICBpZiAodGhpcy5wZWVycy5sZW5ndGgpIHRoaXMuX2Fubm91bmNlKHtzdGFydDogaW5kZXh9LCBmcm9tKVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBpZiAoIXRoaXMuX3N5bmNlZCkgdGhpcy5fc3luY2VkID0gdGhpcy5iaXRmaWVsZC5pdGVyYXRvcigwLCB0aGlzLmxlbmd0aClcbiAgICAgIGlmICh0aGlzLl9zeW5jZWQubmV4dCgpID09PSAtMSkge1xuICAgICAgICB0aGlzLl9zeW5jZWQucmFuZ2UoMCwgdGhpcy5sZW5ndGgpXG4gICAgICAgIHRoaXMuX3N5bmNlZC5zZWVrKDApXG4gICAgICAgIGlmICh0aGlzLl9zeW5jZWQubmV4dCgpID09PSAtMSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnc3luYycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLl9zeW5jKG51bGwsIGNiKVxufVxuXG5GZWVkLnByb3RvdHlwZS5fdmVyaWZ5QW5kV3JpdGUgPSBmdW5jdGlvbiAoaW5kZXgsIGRhdGEsIHByb29mLCBsb2NhbE5vZGVzLCB0cnVzdGVkTm9kZSwgZnJvbSwgY2IpIHtcbiAgdmFyIHZpc2l0ZWQgPSBbXVxuICB2YXIgcmVtb3RlTm9kZXMgPSBwcm9vZi5ub2Rlc1xuICB2YXIgdG9wID0gZGF0YSA/IG5ldyBzdG9yYWdlLk5vZGUoMiAqIGluZGV4LCBjcnlwdG8uZGF0YShkYXRhKSwgZGF0YS5sZW5ndGgpIDogcmVtb3RlTm9kZXMuc2hpZnQoKVxuXG4gIC8vIGNoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGUgaGFzaCBmb3IgdGhpcyBub2RlXG4gIGlmICh2ZXJpZnlOb2RlKHRydXN0ZWROb2RlLCB0b3ApKSB7XG4gICAgdGhpcy5fd3JpdGUoaW5kZXgsIGRhdGEsIHZpc2l0ZWQsIG51bGwsIGZyb20sIGNiKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8ga2VlcCBoYXNoaW5nIHdpdGggc2libGluZ3MgdW50aWwgd2UgcmVhY2ggb3IgdHJ1c3RlZCBub2RlXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5vZGUgPSBudWxsXG4gICAgdmFyIG5leHQgPSBmbGF0LnNpYmxpbmcodG9wLmluZGV4KVxuXG4gICAgaWYgKHJlbW90ZU5vZGVzLmxlbmd0aCAmJiByZW1vdGVOb2Rlc1swXS5pbmRleCA9PT0gbmV4dCkge1xuICAgICAgbm9kZSA9IHJlbW90ZU5vZGVzLnNoaWZ0KClcbiAgICAgIHZpc2l0ZWQucHVzaChub2RlKVxuICAgIH0gZWxzZSBpZiAobG9jYWxOb2Rlcy5sZW5ndGggJiYgbG9jYWxOb2Rlc1swXS5pbmRleCA9PT0gbmV4dCkge1xuICAgICAgbm9kZSA9IGxvY2FsTm9kZXMuc2hpZnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSBjYW5ub3QgY3JlYXRlIGFub3RoZXIgcGFyZW50LCBpLmUuIHRoZXNlIG5vZGVzIG11c3QgYmUgcm9vdHMgaW4gdGhlIHRyZWVcbiAgICAgIHRoaXMuX3ZlcmlmeVJvb3RzQW5kV3JpdGUoaW5kZXgsIGRhdGEsIHRvcCwgcHJvb2YsIHZpc2l0ZWQsIGZyb20sIGNiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmlzaXRlZC5wdXNoKHRvcClcbiAgICB0b3AgPSBuZXcgc3RvcmFnZS5Ob2RlKGZsYXQucGFyZW50KHRvcC5pbmRleCksIGNyeXB0by5wYXJlbnQodG9wLCBub2RlKSwgdG9wLnNpemUgKyBub2RlLnNpemUpXG5cbiAgICAvLyB0aGUgdHJlZSBjaGVja3Mgb3V0LCB3cml0ZSB0aGUgZGF0YSBhbmQgdGhlIHZpc2l0ZWQgbm9kZXNcbiAgICBpZiAodmVyaWZ5Tm9kZSh0cnVzdGVkTm9kZSwgdG9wKSkge1xuICAgICAgdGhpcy5fd3JpdGUoaW5kZXgsIGRhdGEsIHZpc2l0ZWQsIG51bGwsIGZyb20sIGNiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl92ZXJpZnlSb290c0FuZFdyaXRlID0gZnVuY3Rpb24gKGluZGV4LCBkYXRhLCB0b3AsIHByb29mLCBub2RlcywgZnJvbSwgY2IpIHtcbiAgdmFyIHJlbW90ZU5vZGVzID0gcHJvb2Yubm9kZXNcbiAgdmFyIGxhc3ROb2RlID0gcmVtb3RlTm9kZXMubGVuZ3RoID8gcmVtb3RlTm9kZXNbcmVtb3RlTm9kZXMubGVuZ3RoIC0gMV0uaW5kZXggOiB0b3AuaW5kZXhcbiAgdmFyIHZlcmlmaWVkQnkgPSBNYXRoLm1heChmbGF0LnJpZ2h0U3Bhbih0b3AuaW5kZXgpLCBmbGF0LnJpZ2h0U3BhbihsYXN0Tm9kZSkpICsgMlxuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLl9nZXRSb290c1RvVmVyaWZ5KHZlcmlmaWVkQnksIHRvcCwgcmVtb3RlTm9kZXMsIGZ1bmN0aW9uIChlcnIsIHJvb3RzLCBleHRyYU5vZGVzKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIHZhciBjaGVja3N1bSA9IGNyeXB0by50cmVlKHJvb3RzKVxuICAgIHZhciBzaWduYXR1cmUgPSBudWxsXG5cbiAgICBpZiAoc2VsZi5sZW5ndGggJiYgc2VsZi5saXZlICYmICFwcm9vZi5zaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1JlbW90ZSBkaWQgbm90IGluY2x1ZGUgYSBzaWduYXR1cmUnKSlcbiAgICB9XG5cbiAgICBpZiAocHJvb2Yuc2lnbmF0dXJlKSB7IC8vIGNoZWNrIHNpZ25hdHVyZXhcbiAgICAgIGlmICghY3J5cHRvLnZlcmlmeShjaGVja3N1bSwgcHJvb2Yuc2lnbmF0dXJlLCBzZWxmLmtleSkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignUmVtb3RlIHNpZ25hdHVyZSBjb3VsZCBub3QgYmUgdmVyaWZpZWQnKSlcbiAgICAgIH1cblxuICAgICAgc2lnbmF0dXJlID0ge2luZGV4OiB2ZXJpZmllZEJ5IC8gMiAtIDEsIHNpZ25hdHVyZTogcHJvb2Yuc2lnbmF0dXJlfVxuICAgIH0gZWxzZSB7IC8vIGNoZWNrIHRyZWUgcm9vdFxuICAgICAgaWYgKCFlcXVhbHMoY2hlY2tzdW0sIHNlbGYua2V5KSkge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdSZW1vdGUgY2hlY2tzdW0gZmFpbGVkJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5saXZlID0gISFzaWduYXR1cmVcblxuICAgIHZhciBsZW5ndGggPSB2ZXJpZmllZEJ5IC8gMlxuICAgIGlmIChsZW5ndGggPiBzZWxmLmxlbmd0aCkge1xuICAgICAgLy8gVE9ETzogb25seSBlbWl0IHRoaXMgYWZ0ZXIgdGhlIGluZm8gaGFzIGJlZW4gZmx1c2hlZCB0byBzdG9yYWdlXG4gICAgICBzZWxmLmxlbmd0aCA9IGxlbmd0aFxuICAgICAgc2VsZi5ieXRlTGVuZ3RoID0gcm9vdHMucmVkdWNlKGFkZFNpemUsIDApXG4gICAgICBpZiAoc2VsZi5fc3luY2VkKSBzZWxmLl9zeW5jZWQuc2VlaygwLCBzZWxmLmxlbmd0aClcbiAgICAgIHNlbGYuZW1pdCgnYXBwZW5kJylcbiAgICB9XG5cbiAgICBzZWxmLl93cml0ZShpbmRleCwgZGF0YSwgbm9kZXMuY29uY2F0KGV4dHJhTm9kZXMpLCBzaWduYXR1cmUsIGZyb20sIGNiKVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5fZ2V0Um9vdHNUb1ZlcmlmeSA9IGZ1bmN0aW9uICh2ZXJpZmllZEJ5LCB0b3AsIHJlbW90ZU5vZGVzLCBjYikge1xuICB2YXIgaW5kZXhlcyA9IGZsYXQuZnVsbFJvb3RzKHZlcmlmaWVkQnkpXG4gIHZhciByb290cyA9IG5ldyBBcnJheShpbmRleGVzLmxlbmd0aClcbiAgdmFyIG5vZGVzID0gW11cbiAgdmFyIGVycm9yID0gbnVsbFxuICB2YXIgcGVuZGluZyA9IHJvb3RzLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpbmRleGVzW2ldID09PSB0b3AuaW5kZXgpIHtcbiAgICAgIG5vZGVzLnB1c2godG9wKVxuICAgICAgb25ub2RlKG51bGwsIHRvcClcbiAgICB9IGVsc2UgaWYgKHJlbW90ZU5vZGVzLmxlbmd0aCAmJiBpbmRleGVzW2ldID09PSByZW1vdGVOb2Rlc1swXS5pbmRleCkge1xuICAgICAgbm9kZXMucHVzaChyZW1vdGVOb2Rlc1swXSlcbiAgICAgIG9ubm9kZShudWxsLCByZW1vdGVOb2Rlcy5zaGlmdCgpKVxuICAgIH0gZWxzZSBpZiAodGhpcy50cmVlLmdldChpbmRleGVzW2ldKSkge1xuICAgICAgdGhpcy5fc3RvcmFnZS5nZXROb2RlKGluZGV4ZXNbaV0sIG9ubm9kZSlcbiAgICB9IGVsc2Uge1xuICAgICAgb25ub2RlKG5ldyBFcnJvcignTWlzc2luZyB0cmVlIHJvb3RzIG5lZWRlZCBmb3IgdmVyaWZ5JykpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25ub2RlIChlcnIsIG5vZGUpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmIChub2RlKSByb290c1tpbmRleGVzLmluZGV4T2Yobm9kZS5pbmRleCldID0gbm9kZVxuICAgIGlmICghLS1wZW5kaW5nKSBkb25lKGVycm9yKVxuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIGNiKG51bGwsIHJvb3RzLCBub2RlcylcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5fYW5ub3VuY2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgZnJvbSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGVlciA9IHRoaXMucGVlcnNbaV1cbiAgICBpZiAocGVlciAhPT0gZnJvbSkgcGVlci5oYXZlKG1lc3NhZ2UpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3VuYW5ub3VuY2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVlcnMubGVuZ3RoOyBpKyspIHRoaXMucGVlcnNbaV0udW5oYXZlKG1lc3NhZ2UpXG59XG5cbkZlZWQucHJvdG90eXBlLmRvd25sb2FkZWQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5iaXRmaWVsZC50b3RhbChzdGFydCwgZW5kKVxufVxuXG5GZWVkLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmJpdGZpZWxkLmdldChzdGFydClcbiAgdmFyIHRvdGFsID0gZW5kIC0gc3RhcnRcbiAgcmV0dXJuIHRvdGFsID09PSB0aGlzLmJpdGZpZWxkLnRvdGFsKHN0YXJ0LCBlbmQpXG59XG5cbkZlZWQucHJvdG90eXBlLmhlYWQgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5oZWFkKHt9LCBvcHRzKVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSBjYihuZXcgRXJyb3IoJ2ZlZWQgaXMgZW1wdHknKSlcbiAgICBlbHNlIHNlbGYuZ2V0KHNlbGYubGVuZ3RoIC0gMSwgY2IpXG4gIH0pXG59XG5cbkZlZWQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5nZXQoaW5kZXgsIG51bGwsIG9wdHMpXG4gIGlmICghdGhpcy5vcGVuZWQpIHJldHVybiB0aGlzLl9yZWFkeUFuZEdldChpbmRleCwgb3B0cywgY2IpXG5cbiAgaWYgKG9wdHMgJiYgb3B0cy50aW1lb3V0KSBjYiA9IHRpbWVvdXRDYWxsYmFjayhjYiwgb3B0cy50aW1lb3V0KVxuXG4gIGlmICghdGhpcy5iaXRmaWVsZC5nZXQoaW5kZXgpKSB7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy53YWl0ID09PSBmYWxzZSkgcmV0dXJuIGNiKG5ldyBFcnJvcignQmxvY2sgbm90IGRvd25sb2FkZWQnKSlcblxuICAgIHRoaXMuX3dhaXRpbmcucHVzaCh7Ynl0ZXM6IDAsIGhhc2g6IGZhbHNlLCBpbmRleDogaW5kZXgsIG9wdGlvbnM6IG9wdHMsIGNhbGxiYWNrOiBjYn0pXG4gICAgdGhpcy5fdXBkYXRlUGVlcnMoKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG9wdHMgJiYgb3B0cy52YWx1ZUVuY29kaW5nKSBjYiA9IHdyYXBDb2RlYyh0b0NvZGVjKG9wdHMudmFsdWVFbmNvZGluZyksIGNiKVxuICBlbHNlIGlmICh0aGlzLl9jb2RlYyAhPT0gY29kZWNzLmJpbmFyeSkgY2IgPSB3cmFwQ29kZWModGhpcy5fY29kZWMsIGNiKVxuXG4gIHRoaXMuX2dldEJ1ZmZlcihpbmRleCwgY2IpXG59XG5cbkZlZWQucHJvdG90eXBlLl9yZWFkeUFuZEdldCA9IGZ1bmN0aW9uIChpbmRleCwgb3B0cywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHNlbGYuZ2V0KGluZGV4LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUuX3VwZGF0ZVBlZXJzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVlcnMubGVuZ3RoOyBpKyspIHRoaXMucGVlcnNbaV0udXBkYXRlKClcbn1cblxuRmVlZC5wcm90b3R5cGUuY3JlYXRlV3JpdGVTdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICByZXR1cm4gYnVsay5vYmood3JpdGUpXG5cbiAgZnVuY3Rpb24gd3JpdGUgKGJhdGNoLCBjYikge1xuICAgIHNlbGYuX2JhdGNoKGJhdGNoLCBjYilcbiAgfVxufVxuXG5GZWVkLnByb3RvdHlwZS5jcmVhdGVSZWFkU3RyZWFtID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHN0YXJ0ID0gb3B0cy5zdGFydCB8fCAwXG4gIHZhciBlbmQgPSB0eXBlb2Ygb3B0cy5lbmQgPT09ICdudW1iZXInID8gb3B0cy5lbmQgOiAtMVxuICB2YXIgbGl2ZSA9ICEhb3B0cy5saXZlXG4gIHZhciBzbmFwc2hvdCA9IG9wdHMuc25hcHNob3QgIT09IGZhbHNlXG4gIHZhciBmaXJzdCA9IHRydWVcbiAgdmFyIHJhbmdlID0gdGhpcy5kb3dubG9hZCh7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgbGluZWFyOiB0cnVlfSlcblxuICByZXR1cm4gZnJvbS5vYmoocmVhZCkub24oJ2VuZCcsIGNsZWFudXApLm9uKCdjbG9zZScsIGNsZWFudXApXG5cbiAgZnVuY3Rpb24gcmVhZCAoc2l6ZSwgY2IpIHtcbiAgICBpZiAoIXNlbGYub3BlbmVkKSByZXR1cm4gb3BlbihzaXplLCBjYilcblxuICAgIGlmIChmaXJzdCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGxpdmUpIGVuZCA9IEluZmluaXR5XG4gICAgICAgIGVsc2UgaWYgKHNuYXBzaG90KSBlbmQgPSBzZWxmLmxlbmd0aFxuICAgICAgfVxuICAgICAgaWYgKG9wdHMudGFpbCkgc3RhcnQgPSBzZWxmLmxlbmd0aFxuICAgICAgZmlyc3QgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmIChzdGFydCA9PT0gZW5kIHx8IChlbmQgPT09IC0xICYmIHN0YXJ0ID09PSBzZWxmLmxlbmd0aCkpIHJldHVybiBjYihudWxsLCBudWxsKVxuICAgIHNlbGYuZ2V0KHN0YXJ0KyssIG9wdHMsIGNiKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgaWYgKCFyYW5nZSkgcmV0dXJuXG4gICAgc2VsZi51bmRvd25sb2FkKHJhbmdlKVxuICAgIHJhbmdlID0gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gb3BlbiAoc2l6ZSwgY2IpIHtcbiAgICBzZWxmLl9yZWFkeShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmVhZChzaXplLCBjYilcbiAgICB9KVxuICB9XG59XG5cbi8vIFRPRE86IHdoZW4gY2FsbGluZyBmaW5hbGl6ZSBvbiBhIGxpdmUgZmVlZCB3cml0ZSBhbiBFTkRfT0ZfRkVFRCBibG9jayAobGVuZ3RoID09PSAwPylcbkZlZWQucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICghdGhpcy5rZXkpIHtcbiAgICB0aGlzLmtleSA9IGNyeXB0by50cmVlKHRoaXMuX21lcmtsZS5yb290cylcbiAgICB0aGlzLmRpc2NvdmVyeUtleSA9IGNyeXB0by5kaXNjb3ZlcnlLZXkodGhpcy5rZXkpXG4gIH1cbiAgdGhpcy5fc3RvcmFnZS5rZXkud3JpdGUoMCwgdGhpcy5rZXksIGNiKVxufVxuXG5GZWVkLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoYmF0Y2gsIGNiKSB7XG4gIHRoaXMuX2JhdGNoKEFycmF5LmlzQXJyYXkoYmF0Y2gpID8gYmF0Y2ggOiBbYmF0Y2hdLCBjYiB8fCBub29wKVxufVxuXG5GZWVkLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChjYikge1xuICB0aGlzLl9iYXRjaChbXSwgY2IpXG59XG5cbkZlZWQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMuX3JlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gZmFsc2VcbiAgICBzZWxmLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzZWxmLl9zdG9yYWdlLmNsb3NlKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghc2VsZi5jbG9zZWQgJiYgIWVycikge1xuICAgICAgICBzZWxmLmNsb3NlZCA9IHRydWVcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gICAgICB9XG4gICAgICBpZiAoY2IpIGNiKGVycilcbiAgICB9KVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5fYXBwZW5kSG9vayA9IGZ1bmN0aW9uIChiYXRjaCwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBtaXNzaW5nID0gYmF0Y2gubGVuZ3RoXG4gIHZhciBlcnJvciA9IG51bGxcblxuICBpZiAoIW1pc3NpbmcpIHJldHVybiB0aGlzLl9hcHBlbmQoYmF0Y2gsIGNiKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fb253cml0ZShpICsgdGhpcy5sZW5ndGgsIGJhdGNoW2ldLCBudWxsLCBkb25lKVxuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgaWYgKGVycikgZXJyb3IgPSBlcnJcbiAgICBpZiAoLS1taXNzaW5nKSByZXR1cm5cbiAgICBpZiAoZXJyb3IpIHJldHVybiBjYihlcnJvcilcbiAgICBzZWxmLl9hcHBlbmQoYmF0Y2gsIGNiKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9hcHBlbmQgPSBmdW5jdGlvbiAoYmF0Y2gsIGNiKSB7XG4gIGlmICghdGhpcy5vcGVuZWQpIHJldHVybiB0aGlzLl9yZWFkeUFuZEFwcGVuZChiYXRjaCwgY2IpXG4gIGlmICghdGhpcy53cml0YWJsZSkgcmV0dXJuIGNiKG5ldyBFcnJvcignVGhpcyBmZWVkIGlzIG5vdCB3cml0YWJsZS4gRGlkIHlvdSBjcmVhdGUgaXQ/JykpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwZW5kaW5nID0gdGhpcy5saXZlICYmIGJhdGNoLmxlbmd0aCA/IDEgKyBiYXRjaC5sZW5ndGggOiBiYXRjaC5sZW5ndGhcbiAgdmFyIG9mZnNldCA9IDBcbiAgdmFyIGVycm9yID0gbnVsbFxuXG4gIGlmICghcGVuZGluZykgcmV0dXJuIGNiKClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9jb2RlYy5lbmNvZGUoYmF0Y2hbaV0pXG4gICAgdmFyIG5vZGVzID0gdGhpcy5fbWVya2xlLm5leHQoZGF0YSlcblxuICAgIGlmICh0aGlzLl9pbmRleGluZykgZG9uZShudWxsKVxuICAgIGVsc2UgdGhpcy5fc3RvcmFnZS5kYXRhLndyaXRlKHRoaXMuYnl0ZUxlbmd0aCArIG9mZnNldCwgZGF0YSwgZG9uZSlcblxuICAgIGlmICh0aGlzLmxpdmUgJiYgaSA9PT0gYmF0Y2gubGVuZ3RoIC0gMSkge1xuICAgICAgdmFyIHNpZyA9IGNyeXB0by5zaWduKGNyeXB0by50cmVlKHRoaXMuX21lcmtsZS5yb290cyksIHRoaXMuc2VjcmV0S2V5KVxuICAgICAgdGhpcy5fc3RvcmFnZS5wdXRTaWduYXR1cmUodGhpcy5sZW5ndGggKyBpLCBzaWcsIGRvbmUpXG4gICAgfVxuXG4gICAgcGVuZGluZyArPSBub2Rlcy5sZW5ndGhcbiAgICBvZmZzZXQgKz0gZGF0YS5sZW5ndGhcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbal1cbiAgICAgIHRoaXMuX3N0b3JhZ2UucHV0Tm9kZShub2RlLmluZGV4LCBub2RlLCBkb25lKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKC0tcGVuZGluZykgcmV0dXJuXG4gICAgaWYgKGVycm9yKSByZXR1cm4gY2IoZXJyb3IpXG5cbiAgICB2YXIgc3RhcnQgPSBzZWxmLmxlbmd0aFxuXG4gICAgLy8gVE9ETzogb25seSBlbWl0IGFwcGVuZCBhbmQgdXBkYXRlIGxlbmd0aCAvIGJ5dGVMZW5ndGggYWZ0ZXIgdGhlIGluZm8gaGFzIGJlZW4gZmx1c2hlZCB0byBzdG9yYWdlXG4gICAgc2VsZi5ieXRlTGVuZ3RoICs9IG9mZnNldFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGYuYml0ZmllbGQuc2V0KHNlbGYubGVuZ3RoLCB0cnVlKVxuICAgICAgc2VsZi50cmVlLnNldCgyICogc2VsZi5sZW5ndGgrKylcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdhcHBlbmQnKVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBzZWxmLmxlbmd0aCAtIHN0YXJ0ID4gMSA/IHtzdGFydDogc3RhcnQsIGxlbmd0aDogc2VsZi5sZW5ndGggLSBzdGFydH0gOiB7c3RhcnQ6IHN0YXJ0fVxuICAgIGlmIChzZWxmLnBlZXJzLmxlbmd0aCkgc2VsZi5fYW5ub3VuY2UobWVzc2FnZSlcblxuICAgIHNlbGYuX3N5bmMobnVsbCwgY2IpXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3JlYWR5QW5kQXBwZW5kID0gZnVuY3Rpb24gKGJhdGNoLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5fYXBwZW5kKGJhdGNoLCBjYilcbiAgfSlcbn1cblxuRmVlZC5wcm90b3R5cGUuX3JlYWR5QW5kQ2FuY2VsID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2NhbmNlbChzdGFydCwgZW5kKVxuICB9KVxufVxuXG5GZWVkLnByb3RvdHlwZS5fcG9sbFdhaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLl93YWl0aW5nLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLl93YWl0aW5nW2ldXG4gICAgaWYgKCFuZXh0LmJ5dGVzICYmICF0aGlzLmJpdGZpZWxkLmdldChuZXh0LmluZGV4KSkgY29udGludWVcblxuICAgIHJlbW92ZSh0aGlzLl93YWl0aW5nLCBpLS0pXG4gICAgbGVuLS1cblxuICAgIGlmIChuZXh0LmJ5dGVzKSB0aGlzLnNlZWsobmV4dC5ieXRlcywgbmV4dCwgbmV4dC5jYWxsYmFjaylcbiAgICBlbHNlIGlmIChuZXh0LnVwZGF0ZSkgdGhpcy51cGRhdGUobmV4dC5pbmRleCArIDEsIG5leHQuY2FsbGJhY2spXG4gICAgZWxzZSB0aGlzLmdldChuZXh0LmluZGV4LCBuZXh0Lm9wdGlvbnMsIG5leHQuY2FsbGJhY2spXG4gIH1cbn1cblxuRmVlZC5wcm90b3R5cGUuX3N5bmNCaXRmaWVsZCA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgbWlzc2luZyA9IHRoaXMuYml0ZmllbGQucGFnZXMudXBkYXRlcy5sZW5ndGhcbiAgdmFyIG5leHQgPSBudWxsXG4gIHZhciBlcnJvciA9IG51bGxcblxuICAvLyBBbGwgZGF0YSAvIG5vZGVzIGhhdmUgYmVlbiB3cml0dGVuIG5vdy4gV2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGJpdGZpZWxkcyB0aG91Z2hcblxuICAvLyBUT0RPIDE6IGlmIHRoZSBwcm9ncmFtIGZhaWxzIGR1cmluZyB0aGlzIHdyaXRlIHRoZSBiaXRmaWVsZCBtaWdodCBub3QgaGF2ZSBiZWVuIGZ1bGx5IHdyaXR0ZW5cbiAgLy8gSE9XRVZFUiwgd2UgY2FuIGVhc2lseSByZWNvdmVyIGZyb20gdGhpcyBieSB0cmF2ZXJzaW5nIHRoZSB0cmVlIGFuZCBjaGVja2luZyBpZiB0aGUgbm9kZXMgZXhpc3RzXG4gIC8vIG9uIGRpc2suIFNvIGlmIGEgZ2V0IGZhaWxzLCBpdCBzaG91bGQgdHJ5IGFuZCByZWNvdmVyIG9uY2UuXG5cbiAgLy8gVE9ETyAyOiBpZiAud3JpdGFibGUgYXBwZW5kIGJpdGZpZWxkIHVwZGF0ZXMgaW50byBhIHNpbmdsZSBidWZmZXIgZm9yIGV4dHJhIHBlcmZcbiAgLy8gQWRkZWQgYmVuZWZpdCBpcyB0aGF0IGlmIHRoZSBwcm9ncmFtIGV4aXRzIHdoaWxlIGZsdXNoaW5nIHRoZSBiaXRmaWVsZCB0aGUgZmVlZCB3aWxsIG9ubHkgZ2V0XG4gIC8vIHRydW5jYXRlZCBhbmQgbm90IGhhdmUgbWlzc2luZyBjaHVua3Mgd2hpY2ggaXMgd2hhdCB5b3UgZXhwZWN0LlxuXG4gIGlmICghbWlzc2luZykge1xuICAgIHRoaXMuX3BvbGxXYWl0aW5nKClcbiAgICByZXR1cm4gY2IobnVsbClcbiAgfVxuXG4gIHdoaWxlICgobmV4dCA9IHRoaXMuYml0ZmllbGQucGFnZXMubGFzdFVwZGF0ZSgpKSAhPT0gbnVsbCkge1xuICAgIHRoaXMuX3N0b3JhZ2UucHV0Qml0ZmllbGQobmV4dC5vZmZzZXQsIG5leHQuYnVmZmVyLCBvbmRvbmUpXG4gIH1cblxuICB0aGlzLl9wb2xsV2FpdGluZygpXG5cbiAgZnVuY3Rpb24gb25kb25lIChlcnIpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmICgtLW1pc3NpbmcpIHJldHVyblxuICAgIGNiKGVycm9yKVxuICB9XG59XG5cbkZlZWQucHJvdG90eXBlLl9yb290cyA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgdmFyIHJvb3RzID0gZmxhdC5mdWxsUm9vdHMoMiAqIGluZGV4KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHJvb3RzLmxlbmd0aClcbiAgdmFyIHBlbmRpbmcgPSByb290cy5sZW5ndGhcbiAgdmFyIGVycm9yID0gbnVsbFxuXG4gIGlmICghcGVuZGluZykgcmV0dXJuIGNiKG51bGwsIHJlc3VsdClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fc3RvcmFnZS5nZXROb2RlKHJvb3RzW2ldLCBvbm5vZGUpXG4gIH1cblxuICBmdW5jdGlvbiBvbm5vZGUgKGVyciwgbm9kZSkge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKG5vZGUpIHJlc3VsdFtyb290cy5pbmRleE9mKG5vZGUuaW5kZXgpXSA9IG5vZGVcbiAgICBpZiAoLS1wZW5kaW5nKSByZXR1cm5cbiAgICBpZiAoZXJyb3IpIHJldHVybiBjYihlcnJvcilcbiAgICBjYihudWxsLCByZXN1bHQpXG4gIH1cbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiB2ZXJpZnlOb2RlICh0cnVzdGVkLCBub2RlKSB7XG4gIHJldHVybiB0cnVzdGVkICYmIHRydXN0ZWQuaW5kZXggPT09IG5vZGUuaW5kZXggJiYgZXF1YWxzKHRydXN0ZWQuaGFzaCwgbm9kZS5oYXNoKVxufVxuXG5mdW5jdGlvbiBhZGRTaXplIChzaXplLCBub2RlKSB7XG4gIHJldHVybiBzaXplICsgbm9kZS5zaXplXG59XG5cbmZ1bmN0aW9uIGlzQmxvY2sgKGluZGV4KSB7XG4gIHJldHVybiAoaW5kZXggJiAxKSA9PT0gMFxufVxuXG5mdW5jdGlvbiBkZWZhdWx0U3RvcmFnZSAoZGlyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiByYWYobmFtZSwge2RpcmVjdG9yeTogZGlyfSlcbiAgfVxufVxuXG5mdW5jdGlvbiB0b0NvZGVjIChlbmMpIHtcbiAgLy8gU3dpdGNoIHRvIG5kanNvbiBlbmNvZGluZyBpZiBKU09OIGlzIHVzZWQuIFRoYXQgd2F5IGRhdGEgZmlsZXMgcGFyc2UgbGlrZSBuZGpzb24gXFxvL1xuICByZXR1cm4gY29kZWNzKGVuYyA9PT0gJ2pzb24nID8gJ25kanNvbicgOiBlbmMpXG59XG5cbmZ1bmN0aW9uIHdyYXBDb2RlYyAoZW5jLCBjYikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVyciwgYnVmKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICB0cnkge1xuICAgICAgYnVmID0gZW5jLmRlY29kZShidWYpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKVxuICAgIH1cbiAgICBjYihudWxsLCBidWYpXG4gIH1cbn1cblxuZnVuY3Rpb24gdGltZW91dENhbGxiYWNrIChjYiwgdGltZW91dCkge1xuICB2YXIgZmFpbGVkID0gZmFsc2VcbiAgdmFyIGlkID0gc2V0VGltZW91dChvbnRpbWVvdXQsIHRpbWVvdXQpXG4gIHJldHVybiBkb25lXG5cbiAgZnVuY3Rpb24gb250aW1lb3V0ICgpIHtcbiAgICBmYWlsZWQgPSB0cnVlXG4gICAgLy8gVE9ETzogbWFrZSBsaWJzL2Vycm9ycyBmb3IgYWxsIHRoaXMgc3R1ZmZcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdFVElNRURPVVQnKVxuICAgIGVyci5jb2RlID0gJ0VUSU1FRE9VVCdcbiAgICBjYihlcnIpXG4gIH1cblxuICBmdW5jdGlvbiBkb25lIChlcnIsIHZhbCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVyblxuICAgIGNsZWFyVGltZW91dChpZClcbiAgICBjYihlcnIsIHZhbClcbiAgfVxufVxuXG4vLyBidWZmZXItZXF1YWxzLCBidXQgaGFuZGxlICdudWxsJyBidWZmZXIgcGFyYW1ldGVycy5cbmZ1bmN0aW9uIHNhZmVCdWZmZXJFcXVhbHMgKGEsIGIpIHtcbiAgaWYgKCFhKSByZXR1cm4gIWJcbiAgaWYgKCFiKSByZXR1cm4gIWFcbiAgcmV0dXJuIGVxdWFscyhhLCBiKVxufVxuIiwidmFyIGZsYXQgPSByZXF1aXJlKCdmbGF0LXRyZWUnKVxudmFyIHJsZSA9IHJlcXVpcmUoJ2JpdGZpZWxkLXJsZScpXG52YXIgcGFnZXIgPSByZXF1aXJlKCdtZW1vcnktcGFnZXInKVxudmFyIGJpdGZpZWxkID0gcmVxdWlyZSgnc3BhcnNlLWJpdGZpZWxkJylcblxudmFyIElOREVYX1VQREFURV9NQVNLID0gWzYzLCAyMDcsIDI0MywgMjUyXVxudmFyIElOREVYX0lURVJBVEVfTUFTSyA9IFswLCAxOTIsIDI0MCwgMjUyXVxudmFyIERBVEFfSVRFUkFURV9NQVNLID0gWzEyOCwgMTkyLCAyMjQsIDI0MCwgMjQ4LCAyNTIsIDI1NCwgMjU1XVxudmFyIERBVEFfVVBEQVRFX01BU0sgPSBbMTI3LCAxOTEsIDIyMywgMjM5LCAyNDcsIDI1MSwgMjUzLCAyNTRdXG52YXIgTUFQX1BBUkVOVF9SSUdIVCA9IG5ldyBBcnJheSgyNTYpXG52YXIgTUFQX1BBUkVOVF9MRUZUID0gbmV3IEFycmF5KDI1NilcbnZhciBORVhUX0RBVEFfMF9CSVQgPSBuZXcgQXJyYXkoMjU2KVxudmFyIE5FWFRfSU5ERVhfMF9CSVQgPSBuZXcgQXJyYXkoMjU2KVxudmFyIFRPVEFMXzFfQklUUyA9IG5ldyBBcnJheSgyNTYpXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgdmFyIGEgPSAoaSAmICgxNSA8PCA0KSkgPj4gNFxuICB2YXIgYiA9IGkgJiAxNVxuICB2YXIgbmliYmxlID0gWzAsIDEsIDEsIDIsIDEsIDIsIDIsIDMsIDEsIDIsIDIsIDMsIDIsIDMsIDMsIDRdXG4gIE1BUF9QQVJFTlRfUklHSFRbaV0gPSAoKGEgPT09IDE1ID8gMyA6IGEgPT09IDAgPyAwIDogMSkgPDwgMikgfCAoYiA9PT0gMTUgPyAzIDogYiA9PT0gMCA/IDAgOiAxKVxuICBNQVBfUEFSRU5UX0xFRlRbaV0gPSBNQVBfUEFSRU5UX1JJR0hUW2ldIDw8IDRcbiAgTkVYVF9EQVRBXzBfQklUW2ldID0gaSA9PT0gMjU1ID8gLTEgOiAoOCAtIE1hdGguY2VpbChNYXRoLmxvZygyNTYgLSBpKSAvIE1hdGgubG9nKDIpKSlcbiAgTkVYVF9JTkRFWF8wX0JJVFtpXSA9IGkgPT09IDI1NSA/IC0xIDogTWF0aC5mbG9vcihORVhUX0RBVEFfMF9CSVRbaV0gLyAyKVxuICBUT1RBTF8xX0JJVFNbaV0gPSBuaWJibGVbaSA+PiA0XSArIG5pYmJsZVtpICYgMHgwRl1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCaXRmaWVsZFxuXG5mdW5jdGlvbiBCaXRmaWVsZCAoYnVmZmVyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCaXRmaWVsZCkpIHJldHVybiBuZXcgQml0ZmllbGQoYnVmZmVyKVxuXG4gIHRoaXMucGFnZXMgPSBwYWdlcigzMzI4KVxuXG4gIGlmIChidWZmZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMzMyOCkge1xuICAgICAgdGhpcy5wYWdlcy5zZXQoaSAvIDMzMjgsIGJ1ZmZlci5zbGljZShpLCBpICsgMzMyOCkpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5kYXRhID0gYml0ZmllbGQoe1xuICAgIHBhZ2VTaXplOiAxMDI0LFxuICAgIHBhZ2VPZmZzZXQ6IDAsXG4gICAgcGFnZXM6IHRoaXMucGFnZXMsXG4gICAgdHJhY2tVcGRhdGVzOiB0cnVlXG4gIH0pXG5cbiAgdGhpcy50cmVlID0gYml0ZmllbGQoe1xuICAgIHBhZ2VTaXplOiAyMDQ4LFxuICAgIHBhZ2VPZmZzZXQ6IDEwMjQsXG4gICAgcGFnZXM6IHRoaXMucGFnZXMsXG4gICAgdHJhY2tVcGRhdGVzOiB0cnVlXG4gIH0pXG5cbiAgdGhpcy5pbmRleCA9IGJpdGZpZWxkKHtcbiAgICBwYWdlU2l6ZTogMjU2LFxuICAgIHBhZ2VPZmZzZXQ6IDEwMjQgKyAyMDQ4LFxuICAgIHBhZ2VzOiB0aGlzLnBhZ2VzLFxuICAgIHRyYWNrVXBkYXRlczogdHJ1ZVxuICB9KVxuXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aFxuICB0aGlzLl9pdGVyYXRvciA9IGZsYXQuaXRlcmF0b3IoMClcbn1cblxuQml0ZmllbGQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpLCB2YWx1ZSkge1xuICB2YXIgbyA9IGkgJiA3XG4gIGkgPSAoaSAtIG8pIC8gOFxuICB2YXIgdiA9IHZhbHVlID8gdGhpcy5kYXRhLmdldEJ5dGUoaSkgfCAoMTI4ID4+IG8pIDogdGhpcy5kYXRhLmdldEJ5dGUoaSkgJiBEQVRBX1VQREFURV9NQVNLW29dXG5cbiAgaWYgKCF0aGlzLmRhdGEuc2V0Qnl0ZShpLCB2KSkgcmV0dXJuIGZhbHNlXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aFxuICB0aGlzLl9zZXRJbmRleChpLCB2KVxuICByZXR1cm4gdHJ1ZVxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5nZXQoaSlcbn1cblxuQml0ZmllbGQucHJvdG90eXBlLnRvdGFsID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5kYXRhLmxlbmd0aFxuICBpZiAoZW5kIDwgc3RhcnQpIHJldHVybiAwXG4gIGlmIChlbmQgPiB0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgdGhpcy5fZXhwYW5kKGVuZClcbiAgfVxuICB2YXIgbyA9IHN0YXJ0ICYgN1xuICB2YXIgZSA9IGVuZCAmIDdcbiAgdmFyIHBvcyA9IChzdGFydCAtIG8pIC8gOFxuICB2YXIgbGFzdCA9IChlbmQgLSBlKSAvIDhcbiAgdmFyIGxlZnRNYXNrID0gKDI1NSAtIChvID8gREFUQV9JVEVSQVRFX01BU0tbbyAtIDFdIDogMCkpXG4gIHZhciByaWdodE1hc2sgPSAoZSA/IERBVEFfSVRFUkFURV9NQVNLW2UgLSAxXSA6IDApXG4gIHZhciBieXRlID0gdGhpcy5kYXRhLmdldEJ5dGUocG9zKVxuICBpZiAocG9zID09PSBsYXN0KSB7XG4gICAgcmV0dXJuIFRPVEFMXzFfQklUU1tieXRlICYgbGVmdE1hc2sgJiByaWdodE1hc2tdXG4gIH1cbiAgdmFyIHRvdGFsID0gVE9UQUxfMV9CSVRTW2J5dGUgJiBsZWZ0TWFza11cbiAgZm9yICh2YXIgaSA9IHBvcyArIDE7IGkgPCBsYXN0OyBpKyspIHtcbiAgICB0b3RhbCArPSBUT1RBTF8xX0JJVFNbdGhpcy5kYXRhLmdldEJ5dGUoaSldXG4gIH1cbiAgdG90YWwgKz0gVE9UQUxfMV9CSVRTW3RoaXMuZGF0YS5nZXRCeXRlKGxhc3QpICYgcmlnaHRNYXNrXVxuICByZXR1cm4gdG90YWxcbn1cblxuLy8gVE9ETzogdXNlIHRoZSBpbmRleCB0byBzcGVlZCB0aGlzIHVwICphIGxvdCpcbkJpdGZpZWxkLnByb3RvdHlwZS5jb21wcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJsZS5lbmNvZGUodGhpcy5kYXRhLnRvQnVmZmVyKCkpXG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS5fc2V0SW5kZXggPSBmdW5jdGlvbiAoaSwgdmFsdWUpIHtcbiAgLy8gICAgICAgICAgICAgICAgICAgIChhICsgYiB8IGMgKyBkIHwgZSArIGYgfCBnICsgaClcbiAgLy8gLT4gKGEgfCBiIHwgYyB8IGQpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZSB8IGYgfCBnIHwgaClcbiAgLy9cblxuICB2YXIgbyA9IGkgJiAzXG4gIGkgPSAoaSAtIG8pIC8gNFxuXG4gIHZhciBiaXRmaWVsZCA9IHRoaXMuaW5kZXhcbiAgdmFyIGl0ZSA9IHRoaXMuX2l0ZXJhdG9yXG4gIHZhciBzdGFydCA9IDIgKiBpXG4gIHZhciBieXRlID0gKGJpdGZpZWxkLmdldEJ5dGUoc3RhcnQpICYgSU5ERVhfVVBEQVRFX01BU0tbb10pIHwgKGdldEluZGV4VmFsdWUodmFsdWUpID4+ICgyICogbykpXG4gIHZhciBsZW4gPSBiaXRmaWVsZC5sZW5ndGhcbiAgdmFyIG1heExlbmd0aCA9IHRoaXMucGFnZXMubGVuZ3RoICogMjU2XG5cbiAgaXRlLnNlZWsoc3RhcnQpXG5cbiAgd2hpbGUgKGl0ZS5pbmRleCA8IG1heExlbmd0aCAmJiBiaXRmaWVsZC5zZXRCeXRlKGl0ZS5pbmRleCwgYnl0ZSkpIHtcbiAgICBpZiAoaXRlLmlzTGVmdCgpKSB7XG4gICAgICBieXRlID0gTUFQX1BBUkVOVF9MRUZUW2J5dGVdIHwgTUFQX1BBUkVOVF9SSUdIVFtiaXRmaWVsZC5nZXRCeXRlKGl0ZS5zaWJsaW5nKCkpXVxuICAgIH0gZWxzZSB7XG4gICAgICBieXRlID0gTUFQX1BBUkVOVF9SSUdIVFtieXRlXSB8IE1BUF9QQVJFTlRfTEVGVFtiaXRmaWVsZC5nZXRCeXRlKGl0ZS5zaWJsaW5nKCkpXVxuICAgIH1cbiAgICBpdGUucGFyZW50KClcbiAgfVxuXG4gIGlmIChsZW4gIT09IGJpdGZpZWxkLmxlbmd0aCkgdGhpcy5fZXhwYW5kKGxlbilcblxuICByZXR1cm4gaXRlLmluZGV4ICE9PSBzdGFydFxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgdmFyIHJvb3RzID0gZmxhdC5mdWxsUm9vdHMoMiAqIGxlbilcbiAgdmFyIGJpdGZpZWxkID0gdGhpcy5pbmRleFxuICB2YXIgaXRlID0gdGhpcy5faXRlcmF0b3JcbiAgdmFyIGJ5dGUgPSAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290cy5sZW5ndGg7IGkrKykge1xuICAgIGl0ZS5zZWVrKHJvb3RzW2ldKVxuICAgIGJ5dGUgPSBiaXRmaWVsZC5nZXRCeXRlKGl0ZS5pbmRleClcblxuICAgIGRvIHtcbiAgICAgIGlmIChpdGUuaXNMZWZ0KCkpIHtcbiAgICAgICAgYnl0ZSA9IE1BUF9QQVJFTlRfTEVGVFtieXRlXSB8IE1BUF9QQVJFTlRfUklHSFRbYml0ZmllbGQuZ2V0Qnl0ZShpdGUuc2libGluZygpKV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ5dGUgPSBNQVBfUEFSRU5UX1JJR0hUW2J5dGVdIHwgTUFQX1BBUkVOVF9MRUZUW2JpdGZpZWxkLmdldEJ5dGUoaXRlLnNpYmxpbmcoKSldXG4gICAgICB9XG4gICAgfSB3aGlsZSAoc2V0Qnl0ZU5vQWxsb2MoYml0ZmllbGQsIGl0ZS5wYXJlbnQoKSwgYnl0ZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Qnl0ZU5vQWxsb2MgKGJpdGZpZWxkLCBpLCBiKSB7XG4gIGlmICg4ICogaSA+PSBiaXRmaWVsZC5sZW5ndGgpIHJldHVybiBmYWxzZVxuICByZXR1cm4gYml0ZmllbGQuc2V0Qnl0ZShpLCBiKVxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgaXRlID0gbmV3IEl0ZXJhdG9yKHRoaXMpXG5cbiAgaXRlLnJhbmdlKHN0YXJ0IHx8IDAsIGVuZCB8fCB0aGlzLmxlbmd0aClcbiAgaXRlLnNlZWsoMClcblxuICByZXR1cm4gaXRlXG59XG5cbmZ1bmN0aW9uIEl0ZXJhdG9yIChiaXRmaWVsZCkge1xuICB0aGlzLnN0YXJ0ID0gMFxuICB0aGlzLmVuZCA9IDBcblxuICB0aGlzLl9pbmRleEVuZCA9IDBcbiAgdGhpcy5fcG9zID0gMFxuICB0aGlzLl9ieXRlID0gMFxuICB0aGlzLl9iaXRmaWVsZCA9IGJpdGZpZWxkXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHRoaXMuc3RhcnQgPSBzdGFydFxuICB0aGlzLmVuZCA9IGVuZFxuICB0aGlzLl9pbmRleEVuZCA9IDIgKiBNYXRoLmNlaWwoZW5kIC8gMzIpXG5cbiAgaWYgKHRoaXMuZW5kID4gdGhpcy5fYml0ZmllbGQubGVuZ3RoKSB7XG4gICAgdGhpcy5fYml0ZmllbGQuX2V4cGFuZCh0aGlzLmVuZClcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBvZmZzZXQgKz0gdGhpcy5zdGFydFxuICBpZiAob2Zmc2V0IDwgdGhpcy5zdGFydCkgb2Zmc2V0ID0gdGhpcy5zdGFydFxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5lbmQpIHtcbiAgICB0aGlzLl9wb3MgPSAtMVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgbyA9IG9mZnNldCAmIDdcblxuICB0aGlzLl9wb3MgPSAob2Zmc2V0IC0gbykgLyA4XG4gIHRoaXMuX2J5dGUgPSB0aGlzLl9iaXRmaWVsZC5kYXRhLmdldEJ5dGUodGhpcy5fcG9zKSB8IChvID8gREFUQV9JVEVSQVRFX01BU0tbbyAtIDFdIDogMClcblxuICByZXR1cm4gdGhpc1xufVxuXG5JdGVyYXRvci5wcm90b3R5cGUucmFuZG9tID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IHRoaXMuc2VlayhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSkpLm5leHQoKVxuICByZXR1cm4gaSA9PT0gLTEgPyB0aGlzLnNlZWsoMCkubmV4dCgpIDogaVxufVxuXG5JdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3BvcyA9PT0gLTEpIHJldHVybiAtMVxuXG4gIHZhciBkYXRhQml0ZmllbGQgPSB0aGlzLl9iaXRmaWVsZC5kYXRhXG4gIHZhciBmcmVlID0gTkVYVF9EQVRBXzBfQklUW3RoaXMuX2J5dGVdXG5cbiAgd2hpbGUgKGZyZWUgPT09IC0xKSB7XG4gICAgdGhpcy5fYnl0ZSA9IGRhdGFCaXRmaWVsZC5nZXRCeXRlKCsrdGhpcy5fcG9zKVxuICAgIGZyZWUgPSBORVhUX0RBVEFfMF9CSVRbdGhpcy5fYnl0ZV1cblxuICAgIGlmIChmcmVlID09PSAtMSkge1xuICAgICAgdGhpcy5fcG9zID0gdGhpcy5fc2tpcEFoZWFkKHRoaXMuX3BvcylcbiAgICAgIGlmICh0aGlzLl9wb3MgPT09IC0xKSByZXR1cm4gLTFcblxuICAgICAgdGhpcy5fYnl0ZSA9IGRhdGFCaXRmaWVsZC5nZXRCeXRlKHRoaXMuX3BvcylcbiAgICAgIGZyZWUgPSBORVhUX0RBVEFfMF9CSVRbdGhpcy5fYnl0ZV1cbiAgICB9XG4gIH1cblxuICB0aGlzLl9ieXRlIHw9IERBVEFfSVRFUkFURV9NQVNLW2ZyZWVdXG5cbiAgdmFyIG4gPSA4ICogdGhpcy5fcG9zICsgZnJlZVxuICByZXR1cm4gbiA8IHRoaXMuZW5kID8gbiA6IC0xXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcG9zID09PSAtMSkgcmV0dXJuIC0xXG5cbiAgdmFyIGZyZWUgPSBORVhUX0RBVEFfMF9CSVRbdGhpcy5fYnl0ZV1cbiAgdmFyIG4gPSA4ICogdGhpcy5fcG9zICsgZnJlZVxuICByZXR1cm4gbiA8IHRoaXMuZW5kID8gbiA6IC0xXG59XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5fc2tpcEFoZWFkID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gIHZhciBpbmRleEJpdGZpZWxkID0gdGhpcy5fYml0ZmllbGQuaW5kZXhcbiAgdmFyIHRyZWVFbmQgPSB0aGlzLl9pbmRleEVuZFxuICB2YXIgaXRlID0gdGhpcy5fYml0ZmllbGQuX2l0ZXJhdG9yXG4gIHZhciBvID0gc3RhcnQgJiAzXG5cbiAgaXRlLnNlZWsoMiAqICgoc3RhcnQgLSBvKSAvIDQpKVxuXG4gIHZhciB0cmVlQnl0ZSA9IGluZGV4Qml0ZmllbGQuZ2V0Qnl0ZShpdGUuaW5kZXgpIHwgSU5ERVhfSVRFUkFURV9NQVNLW29dXG5cbiAgd2hpbGUgKE5FWFRfSU5ERVhfMF9CSVRbdHJlZUJ5dGVdID09PSAtMSkge1xuICAgIGlmIChpdGUuaXNMZWZ0KCkpIHtcbiAgICAgIGl0ZS5uZXh0KClcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlLm5leHQoKVxuICAgICAgaXRlLnBhcmVudCgpXG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0U3BhbihpdGUpID49IHRyZWVFbmQpIHtcbiAgICAgIHdoaWxlIChyaWdodFNwYW4oaXRlKSA+PSB0cmVlRW5kICYmIGlzUGFyZW50KGl0ZSkpIGl0ZS5sZWZ0Q2hpbGQoKVxuICAgICAgaWYgKHJpZ2h0U3BhbihpdGUpID49IHRyZWVFbmQpIHJldHVybiAtMVxuICAgIH1cblxuICAgIHRyZWVCeXRlID0gaW5kZXhCaXRmaWVsZC5nZXRCeXRlKGl0ZS5pbmRleClcbiAgfVxuXG4gIHdoaWxlIChpdGUuZmFjdG9yID4gMikge1xuICAgIGlmIChORVhUX0lOREVYXzBfQklUW3RyZWVCeXRlXSA8IDIpIGl0ZS5sZWZ0Q2hpbGQoKVxuICAgIGVsc2UgaXRlLnJpZ2h0Q2hpbGQoKVxuXG4gICAgdHJlZUJ5dGUgPSBpbmRleEJpdGZpZWxkLmdldEJ5dGUoaXRlLmluZGV4KVxuICB9XG5cbiAgdmFyIGZyZWUgPSBORVhUX0lOREVYXzBfQklUW3RyZWVCeXRlXVxuICBpZiAoZnJlZSA9PT0gLTEpIGZyZWUgPSA0XG5cbiAgdmFyIG5leHQgPSBpdGUuaW5kZXggKiAyICsgZnJlZVxuXG4gIHJldHVybiBuZXh0IDw9IHN0YXJ0ID8gc3RhcnQgKyAxIDogbmV4dFxufVxuXG5mdW5jdGlvbiByaWdodFNwYW4gKGl0ZSkge1xuICByZXR1cm4gaXRlLmluZGV4ICsgaXRlLmZhY3RvciAvIDIgLSAxXG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50IChpdGUpIHtcbiAgcmV0dXJuIGl0ZS5pbmRleCAmIDFcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhWYWx1ZSAobikge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIDI1NTogcmV0dXJuIDE5MlxuICAgIGNhc2UgMDogcmV0dXJuIDBcbiAgICBkZWZhdWx0OiByZXR1cm4gNjRcbiAgfVxufVxuIiwidmFyIHNvZGl1bSA9IHJlcXVpcmUoJ3NvZGl1bS11bml2ZXJzYWwnKVxudmFyIHVpbnQ2NGJlID0gcmVxdWlyZSgndWludDY0YmUnKVxudmFyIGJ1ZmZlckZyb20gPSByZXF1aXJlKCdidWZmZXItZnJvbScpXG52YXIgYnVmZmVyQWxsb2MgPSByZXF1aXJlKCdidWZmZXItYWxsb2MtdW5zYWZlJylcblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVya2xlX3RyZWUjU2Vjb25kX3ByZWltYWdlX2F0dGFja1xudmFyIExFQUZfVFlQRSA9IGJ1ZmZlckZyb20oWzBdKVxudmFyIFBBUkVOVF9UWVBFID0gYnVmZmVyRnJvbShbMV0pXG52YXIgUk9PVF9UWVBFID0gYnVmZmVyRnJvbShbMl0pXG52YXIgSFlQRVJDT1JFID0gYnVmZmVyRnJvbSgnaHlwZXJjb3JlJylcblxuZXhwb3J0cy5rZXlQYWlyID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgdmFyIHB1YmxpY0tleSA9IGJ1ZmZlckFsbG9jKHNvZGl1bS5jcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgdmFyIHNlY3JldEtleSA9IGJ1ZmZlckFsbG9jKHNvZGl1bS5jcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUylcblxuICBpZiAoc2VlZCkgc29kaXVtLmNyeXB0b19zaWduX3NlZWRfa2V5cGFpcihwdWJsaWNLZXksIHNlY3JldEtleSwgc2VlZClcbiAgZWxzZSBzb2RpdW0uY3J5cHRvX3NpZ25fa2V5cGFpcihwdWJsaWNLZXksIHNlY3JldEtleSlcblxuICByZXR1cm4ge1xuICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgIHNlY3JldEtleTogc2VjcmV0S2V5XG4gIH1cbn1cblxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNlY3JldEtleSkge1xuICB2YXIgc2lnbmF0dXJlID0gYnVmZmVyQWxsb2Moc29kaXVtLmNyeXB0b19zaWduX0JZVEVTKVxuICBzb2RpdW0uY3J5cHRvX3NpZ25fZGV0YWNoZWQoc2lnbmF0dXJlLCBtZXNzYWdlLCBzZWNyZXRLZXkpXG4gIHJldHVybiBzaWduYXR1cmVcbn1cblxuZXhwb3J0cy52ZXJpZnkgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgcmV0dXJuIHNvZGl1bS5jcnlwdG9fc2lnbl92ZXJpZnlfZGV0YWNoZWQoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpXG59XG5cbmV4cG9ydHMuZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiBibGFrZTJiKFtcbiAgICBMRUFGX1RZUEUsXG4gICAgZW5jb2RlVUludDY0KGRhdGEubGVuZ3RoKSxcbiAgICBkYXRhXG4gIF0pXG59XG5cbmV4cG9ydHMubGVhZiA9IGZ1bmN0aW9uIChsZWFmKSB7XG4gIHJldHVybiBleHBvcnRzLmRhdGEobGVhZi5kYXRhKVxufVxuXG5leHBvcnRzLnBhcmVudCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmIChhLmluZGV4ID4gYi5pbmRleCkge1xuICAgIHZhciB0bXAgPSBhXG4gICAgYSA9IGJcbiAgICBiID0gdG1wXG4gIH1cblxuICByZXR1cm4gYmxha2UyYihbXG4gICAgUEFSRU5UX1RZUEUsXG4gICAgZW5jb2RlVUludDY0KGEuc2l6ZSArIGIuc2l6ZSksXG4gICAgYS5oYXNoLFxuICAgIGIuaGFzaFxuICBdKVxufVxuXG5leHBvcnRzLnRyZWUgPSBmdW5jdGlvbiAocm9vdHMpIHtcbiAgdmFyIGJ1ZmZlcnMgPSBuZXcgQXJyYXkoMyAqIHJvb3RzLmxlbmd0aCArIDEpXG4gIHZhciBqID0gMFxuXG4gIGJ1ZmZlcnNbaisrXSA9IFJPT1RfVFlQRVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgciA9IHJvb3RzW2ldXG4gICAgYnVmZmVyc1tqKytdID0gci5oYXNoXG4gICAgYnVmZmVyc1tqKytdID0gZW5jb2RlVUludDY0KHIuaW5kZXgpXG4gICAgYnVmZmVyc1tqKytdID0gZW5jb2RlVUludDY0KHIuc2l6ZSlcbiAgfVxuXG4gIHJldHVybiBibGFrZTJiKGJ1ZmZlcnMpXG59XG5cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbiAobikge1xuICB2YXIgYnVmID0gYnVmZmVyQWxsb2MobilcbiAgc29kaXVtLnJhbmRvbWJ5dGVzX2J1ZihidWYpXG4gIHJldHVybiBidWZcbn1cblxuZXhwb3J0cy5kaXNjb3ZlcnlLZXkgPSBmdW5jdGlvbiAodHJlZSkge1xuICB2YXIgZGlnZXN0ID0gYnVmZmVyQWxsb2MoMzIpXG4gIHNvZGl1bS5jcnlwdG9fZ2VuZXJpY2hhc2goZGlnZXN0LCBIWVBFUkNPUkUsIHRyZWUpXG4gIHJldHVybiBkaWdlc3Rcbn1cblxuZnVuY3Rpb24gZW5jb2RlVUludDY0IChuKSB7XG4gIHJldHVybiB1aW50NjRiZS5lbmNvZGUobiwgYnVmZmVyQWxsb2MoOCkpXG59XG5cbmZ1bmN0aW9uIGJsYWtlMmIgKGJ1ZmZlcnMpIHtcbiAgdmFyIGRpZ2VzdCA9IGJ1ZmZlckFsbG9jKDMyKVxuICBzb2RpdW0uY3J5cHRvX2dlbmVyaWNoYXNoX2JhdGNoKGRpZ2VzdCwgYnVmZmVycylcbiAgcmV0dXJuIGRpZ2VzdFxufVxuIiwidmFyIHByb3RvY29sID0gcmVxdWlyZSgnaHlwZXJjb3JlLXByb3RvY29sJylcbnZhciBiaXRmaWVsZCA9IHJlcXVpcmUoJ3NwYXJzZS1iaXRmaWVsZCcpXG52YXIgc2V0ID0gcmVxdWlyZSgndW5vcmRlcmVkLXNldCcpXG52YXIgcmxlID0gcmVxdWlyZSgnYml0ZmllbGQtcmxlJylcblxubW9kdWxlLmV4cG9ydHMgPSByZXBsaWNhdGVcblxuZnVuY3Rpb24gcmVwbGljYXRlIChmZWVkLCBvcHRzKSB7XG4gIHZhciBzdHJlYW0gPSBvcHRzLnN0cmVhbVxuXG4gIGlmICghc3RyZWFtKSB7XG4gICAgaWYgKCFvcHRzLmV4cGVjdGVkRmVlZHMpIG9wdHMuZXhwZWN0ZWRGZWVkcyA9IDFcbiAgICBpZiAoIW9wdHMuaWQpIG9wdHMuaWQgPSBmZWVkLmlkXG4gICAgc3RyZWFtID0gcHJvdG9jb2wob3B0cylcbiAgfVxuXG4gIGZlZWQucmVhZHkoZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBzdHJlYW0uZGVzdHJveShlcnIpXG4gICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgdmFyIHBlZXIgPSBuZXcgUGVlcihmZWVkLCBvcHRzKVxuICAgIHBlZXIuZmVlZCA9IGZlZWRcbiAgICBwZWVyLnN0cmVhbSA9IHN0cmVhbS5mZWVkKGZlZWQua2V5LCB7cGVlcjogcGVlcn0pXG5cbiAgICBwZWVyLnJlbW90ZUlkID0gc3RyZWFtLnJlbW90ZUlkXG4gICAgc3RyZWFtLnNldE1heExpc3RlbmVycygwKVxuICAgIHN0cmVhbS5vbignaGFuZHNoYWtlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcGVlci5yZW1vdGVJZCA9IHN0cmVhbS5yZW1vdGVJZFxuICAgIH0pXG5cbiAgICAvLyBzdHJlYW0gbWlnaHQgZ2V0IGRlc3Ryb3llZCBvbiBmZWVkIGluaXQgaW4gY2FzZSBvZiBjb25mIGVycm9yc1xuICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSByZXR1cm5cblxuICAgIHBlZXIucmVhZHkoKVxuICB9KVxuXG4gIHJldHVybiBzdHJlYW1cbn1cblxuZnVuY3Rpb24gUGVlciAoZmVlZCwgb3B0cykge1xuICB0aGlzLmZlZWQgPSBmZWVkXG4gIHRoaXMuc3RyZWFtID0gbnVsbCAvLyBzZXQgYnkgcmVwbGljYXRlIGp1c3QgYWZ0ZXIgY3JlYXRpb25cbiAgdGhpcy5yZW1vdGVJZCA9IG51bGxcbiAgdGhpcy5yZW1vdGVCaXRmaWVsZCA9IG51bGxcbiAgdGhpcy5yZW1vdGVMZW5ndGggPSAwXG4gIHRoaXMucmVtb3RlV2FudCA9IGZhbHNlXG4gIHRoaXMubGl2ZSA9ICEhb3B0cy5saXZlXG4gIHRoaXMuc3BhcnNlID0gZmVlZC5zcGFyc2VcblxuICB0aGlzLnJlbW90ZURvd25sb2FkaW5nID0gdHJ1ZVxuICB0aGlzLmRvd25sb2FkaW5nID0gdHlwZW9mIG9wdHMuZG93bmxvYWQgPT09ICdib29sZWFuJyA/IG9wdHMuZG93bmxvYWQgOiAhZmVlZC53cml0YWJsZVxuICB0aGlzLnVwbG9hZGluZyA9IHRydWVcblxuICB0aGlzLm1heFJlcXVlc3RzID0gb3B0cy5tYXhSZXF1ZXN0cyB8fCBmZWVkLm1heFJlcXVlc3RzIHx8IDE2XG4gIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cyA9IFtdXG5cbiAgdGhpcy5faW5kZXggPSAtMVxuICB0aGlzLl9sYXN0Qnl0ZXMgPSAwXG4gIHRoaXMuX2ZpcnN0ID0gdHJ1ZVxuICB0aGlzLl9jbG9zZWQgPSBmYWxzZVxuICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZVxuICB0aGlzLl9kZWZhdWx0RG93bmxvYWRpbmcgPSB0aGlzLmRvd25sb2FkaW5nXG59XG5cblBlZXIucHJvdG90eXBlLm9ud2FudCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVE9ETzogcmVwbHkgdG8gdGhlIGFjdHVhbCB3YW50IGNvbnRleHRcbiAgdGhpcy5yZW1vdGVXYW50ID0gdHJ1ZVxuICB2YXIgcmxlID0gdGhpcy5mZWVkLmJpdGZpZWxkLmNvbXByZXNzKClcbiAgdGhpcy5zdHJlYW0uaGF2ZSh7c3RhcnQ6IDAsIGJpdGZpZWxkOiBybGV9KVxufVxuXG5QZWVyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICAvLyBJZ25vcmUgdW5yZXF1ZXN0ZWQgbWVzc2FnZXMgdW5sZXNzIHdlIGFsbG93IHB1c2hcbiAgLy8gVE9ETzogd291bGQgYmUgYmV0dGVyIHRvIGNoZWNrIGlmIHRoZSBieXRlIHJhbmdlIHdhcyByZXF1ZXN0ZWQgaW5zdGVhZCwgYnV0IHRoaXMgd29ya3MgZmluZVxuICB2YXIgYWxsb3dQdXNoID0gdGhpcy5mZWVkLmFsbG93UHVzaCB8fCAhZGF0YS52YWx1ZVxuICBpZiAoIWFsbG93UHVzaCAmJiAhdGhpcy5mZWVkLl9yZXNlcnZlZC5nZXQoZGF0YS5pbmRleCkpIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSB0aGlzIGJsb2NrLCBzZW5kIGJhY2sgdW5oYXZlIG1lc3NhZ2UgZm9yIHRoaXMgaW5kZXgsXG4gICAgLy8gdG8gbGV0IHRoZSByZW1vdGUga25vdyB3ZSByZWplY3RlZCBpdC5cbiAgICAvLyBUT0RPOiB3ZSBtaWdodCB3YW50IHRvIGhhdmUgc29tZSBcInVud2FudGVkIHB1c2hcIiB0aHJlc2hvbGQgdG8gcHVuaXNoIHNwYW1tZXJzXG4gICAgaWYgKCFzZWxmLmZlZWQuYml0ZmllbGQuZ2V0KGRhdGEuaW5kZXgpKSBzZWxmLnVuaGF2ZSh7c3RhcnQ6IGRhdGEuaW5kZXh9KVxuICAgIHNlbGYuX2NsZWFyKGRhdGEuaW5kZXgsICFkYXRhLnZhbHVlKVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5mZWVkLl9wdXRCdWZmZXIoZGF0YS5pbmRleCwgZGF0YS52YWx1ZSwgZGF0YSwgdGhpcywgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBzZWxmLmRlc3Ryb3koZXJyKVxuICAgIHNlbGYuX2NsZWFyKGRhdGEuaW5kZXgsICFkYXRhLnZhbHVlKVxuICB9KVxufVxuXG5QZWVyLnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbiAoaW5kZXgsIGhhc2gpIHtcbiAgLy8gVE9ETzogb3B0aW1pemUgbWUgKG5vIHNwbGljZSBhbmQgZG8gbm90IHJ1biB0aHJvdWdoIGFsbCAuLi4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuaW5mbGlnaHRSZXF1ZXN0c1tpXS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5zcGxpY2UoaSwgMSlcbiAgICAgIGktLVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZmVlZC5fcmVzZXJ2ZWQuc2V0KGluZGV4LCBmYWxzZSlcbiAgLy8gVE9ETzogb25seSB1cGRhdGUgYWxsIGlmIHdlIGhhdmUgb3ZlcmxhcHBpbmcgc2VsZWN0aW9uc1xuICB0aGlzLmZlZWQuX3VwZGF0ZVBlZXJzKClcbn1cblxuUGVlci5wcm90b3R5cGUub25yZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3QuYnl0ZXMpIHJldHVybiB0aGlzLl9vbmJ5dGVzKHJlcXVlc3QpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBvcHRzID0ge2RpZ2VzdDogcmVxdWVzdC5ub2RlcywgaGFzaDogcmVxdWVzdC5oYXNofVxuXG4gIHRoaXMuZmVlZC5wcm9vZihyZXF1ZXN0LmluZGV4LCBvcHRzLCBvbnByb29mKVxuXG4gIGZ1bmN0aW9uIG9ucHJvb2YgKGVyciwgcHJvb2YpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5kZXN0cm95KGVycilcbiAgICBpZiAocmVxdWVzdC5oYXNoKSBvbnZhbHVlKG51bGwsIG51bGwpXG4gICAgZWxzZSBpZiAoc2VsZi5mZWVkLmJpdGZpZWxkLmdldChyZXF1ZXN0LmluZGV4KSkgc2VsZi5mZWVkLl9nZXRCdWZmZXIocmVxdWVzdC5pbmRleCwgb252YWx1ZSlcblxuICAgIGZ1bmN0aW9uIG9udmFsdWUgKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBzZWxmLmRlc3Ryb3koZXJyKVxuXG4gICAgICBpZiAoIXNlbGYucmVtb3RlQml0ZmllbGQpIHNlbGYucmVtb3RlQml0ZmllbGQgPSBiaXRmaWVsZCgpXG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXNlbGYucmVtb3RlQml0ZmllbGQuc2V0KHJlcXVlc3QuaW5kZXgsIHRydWUpKSByZXR1cm5cbiAgICAgICAgc2VsZi5mZWVkLmVtaXQoJ3VwbG9hZCcsIHJlcXVlc3QuaW5kZXgsIHZhbHVlLCBzZWxmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNlbGYucmVtb3RlQml0ZmllbGQuZ2V0KHJlcXVlc3QuaW5kZXgpKSByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3QuaW5kZXggKyAxID4gc2VsZi5yZW1vdGVMZW5ndGgpIHtcbiAgICAgICAgc2VsZi5yZW1vdGVMZW5ndGggPSByZXF1ZXN0LmluZGV4ICsgMVxuICAgICAgICBzZWxmLl91cGRhdGVFbmQoKVxuICAgICAgfVxuXG4gICAgICBzZWxmLnN0cmVhbS5kYXRhKHtcbiAgICAgICAgaW5kZXg6IHJlcXVlc3QuaW5kZXgsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbm9kZXM6IHByb29mLm5vZGVzLFxuICAgICAgICBzaWduYXR1cmU6IHByb29mLnNpZ25hdHVyZVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX29uYnl0ZXMgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLmZlZWQuc2VlayhyZXF1ZXN0LmJ5dGVzLCB7d2FpdDogZmFsc2V9LCBmdW5jdGlvbiAoZXJyLCBpbmRleCkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJlcXVlc3QuYnl0ZXMgPSAwXG4gICAgICBzZWxmLm9ucmVxdWVzdChyZXF1ZXN0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcXVpY2snbidkaXJ0eSBmaWx0ZXIgZm9yIHBhcmFsbGVsIGJ5dGVzIHJlcXVlc3RzXG4gICAgLy8gaXQgZG9lcyBub3QgbWF0dGVyIHRoYXQgdGhpcyBkb2Vzbid0IGNhdGNoIEFMTCBwYXJhbGxlbCByZXF1ZXN0cyAtIGp1c3QgYSBiYW5kd2lkdGggb3B0aW1pemF0aW9uXG4gICAgaWYgKHNlbGYuX2xhc3RCeXRlcyA9PT0gcmVxdWVzdC5ieXRlcykgcmV0dXJuXG4gICAgc2VsZi5fbGFzdEJ5dGVzID0gcmVxdWVzdC5ieXRlc1xuXG4gICAgcmVxdWVzdC5ieXRlcyA9IDBcbiAgICByZXF1ZXN0LmluZGV4ID0gaW5kZXhcbiAgICByZXF1ZXN0Lm5vZGVzID0gMFxuXG4gICAgc2VsZi5vbnJlcXVlc3QocmVxdWVzdClcbiAgfSlcbn1cblxuUGVlci5wcm90b3R5cGUub250aWNrID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGgpIHJldHVyblxuXG4gIHZhciBmaXJzdCA9IHRoaXMuaW5mbGlnaHRSZXF1ZXN0c1swXVxuICBpZiAoLS1maXJzdC50aWNrKSByZXR1cm5cblxuICBpZiAoZmlyc3QuaGFzaCA/IHRoaXMuZmVlZC50cmVlLmdldCgyICogZmlyc3QuaW5kZXgpIDogdGhpcy5mZWVkLmJpdGZpZWxkLmdldChmaXJzdC5pbmRleCkpIHtcbiAgICAvLyBwcm9iIGEgYnl0ZXMgcmVzcG9uc2VcbiAgICB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuc2hpZnQoKVxuICAgIHRoaXMuZmVlZC5fcmVzZXJ2ZWQuc2V0KGZpcnN0LmluZGV4LCBmYWxzZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZW91dCcpKVxufVxuXG5QZWVyLnByb3RvdHlwZS5vbmhhdmUgPSBmdW5jdGlvbiAoaGF2ZSkge1xuICB2YXIgdXBkYXRlZCA9IHRoaXMuX2ZpcnN0XG4gIGlmICh0aGlzLl9maXJzdCkgdGhpcy5fZmlyc3QgPSBmYWxzZVxuXG4gIGlmIChoYXZlLmJpdGZpZWxkKSB7IC8vIFRPRE86IGhhbmRsZSBzdGFydCAhPT0gMFxuICAgIHRoaXMucmVtb3RlQml0ZmllbGQgPSBiaXRmaWVsZChybGUuZGVjb2RlKGhhdmUuYml0ZmllbGQpKVxuICAgIGlmICh0aGlzLnJlbW90ZUJpdGZpZWxkLmxlbmd0aCA+IHRoaXMucmVtb3RlTGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlbW90ZUxlbmd0aCA9IHRoaXMucmVtb3RlQml0ZmllbGQubGVuZ3RoXG4gICAgICB3aGlsZSAodGhpcy5yZW1vdGVMZW5ndGggJiYgIXRoaXMucmVtb3RlQml0ZmllbGQuZ2V0KHRoaXMucmVtb3RlTGVuZ3RoIC0gMSkpIHRoaXMucmVtb3RlTGVuZ3RoLS1cbiAgICAgIHVwZGF0ZWQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghdGhpcy5yZW1vdGVCaXRmaWVsZCkgdGhpcy5yZW1vdGVCaXRmaWVsZCA9IGJpdGZpZWxkKClcbiAgICAvLyBUT0RPOiBpZiBsZW4gPiBzb21ldGhpbmcgc2ltcGx5IGNvcHkgYSAwYjExMTEuLi4gYnVmZmVyIHRvIHRoZSBiaXRmaWVsZFxuXG4gICAgdmFyIHN0YXJ0ID0gaGF2ZS5zdGFydFxuICAgIHZhciBsZW4gPSBoYXZlLmxlbmd0aCB8fCAxXG5cbiAgICB3aGlsZSAobGVuLS0pIHRoaXMucmVtb3RlQml0ZmllbGQuc2V0KHN0YXJ0KyssIHRydWUpXG4gICAgaWYgKHN0YXJ0ID4gdGhpcy5yZW1vdGVMZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtb3RlTGVuZ3RoID0gc3RhcnRcbiAgICAgIHVwZGF0ZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgaWYgKHVwZGF0ZWQpIHtcbiAgICB0aGlzLmZlZWQuZW1pdCgncmVtb3RlLXVwZGF0ZScsIHRoaXMpXG4gIH1cblxuICB0aGlzLl91cGRhdGVFbmQoKVxuICB0aGlzLnVwZGF0ZSgpXG59XG5cblBlZXIucHJvdG90eXBlLl91cGRhdGVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxpdmUgfHwgdGhpcy5mZWVkLnNwYXJzZSB8fCAhdGhpcy5mZWVkLl9zZWxlY3Rpb25zLmxlbmd0aCkgcmV0dXJuXG5cbiAgdmFyIHNlbCA9IHRoaXMuZmVlZC5fc2VsZWN0aW9uc1swXVxuICB2YXIgcmVtb3RlTGVuZ3RoID0gdGhpcy5mZWVkLmxlbmd0aCB8fCAtMVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mZWVkLnBlZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuZmVlZC5wZWVyc1tpXS5yZW1vdGVMZW5ndGggPiByZW1vdGVMZW5ndGgpIHtcbiAgICAgIHJlbW90ZUxlbmd0aCA9IHRoaXMuZmVlZC5wZWVyc1tpXS5yZW1vdGVMZW5ndGhcbiAgICB9XG4gIH1cblxuICBzZWwuZW5kID0gcmVtb3RlTGVuZ3RoXG59XG5cblBlZXIucHJvdG90eXBlLm9uaW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gIHRoaXMucmVtb3RlRG93bmxvYWRpbmcgPSBpbmZvLmRvd25sb2FkaW5nXG4gIGlmIChpbmZvLmRvd25sb2FkaW5nIHx8IHRoaXMubGl2ZSkgcmV0dXJuXG4gIHRoaXMudXBkYXRlKClcbiAgaWYgKHRoaXMuZmVlZC5fc2VsZWN0aW9ucy5sZW5ndGggJiYgdGhpcy5kb3dubG9hZGluZykgcmV0dXJuXG4gIHRoaXMuZW5kKClcbn1cblxuUGVlci5wcm90b3R5cGUub251bmhhdmUgPSBmdW5jdGlvbiAodW5oYXZlKSB7XG4gIGlmICghdGhpcy5yZW1vdGVCaXRmaWVsZCkgcmV0dXJuXG5cbiAgdmFyIHN0YXJ0ID0gdW5oYXZlLnN0YXJ0XG4gIHZhciBsZW4gPSB1bmhhdmUubGVuZ3RoIHx8IDFcblxuICB3aGlsZSAobGVuLS0pIHRoaXMucmVtb3RlQml0ZmllbGQuc2V0KHN0YXJ0KyssIGZhbHNlKVxufVxuXG5QZWVyLnByb3RvdHlwZS5vbnVud2FudCA9XG5QZWVyLnByb3RvdHlwZS5vbmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVE9ETzogaW1wbCBhbGwgb2YgbWVcbn1cblxuUGVlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kZXN0cm95KClcbn1cblxuUGVlci5wcm90b3R5cGUuaGF2ZSA9IGZ1bmN0aW9uIChoYXZlKSB7IC8vIGNhbGxlZCBieSBmZWVkXG4gIGlmICh0aGlzLnN0cmVhbSAmJiB0aGlzLnJlbW90ZVdhbnQpIHRoaXMuc3RyZWFtLmhhdmUoaGF2ZSlcbn1cblxuUGVlci5wcm90b3R5cGUudW5oYXZlID0gZnVuY3Rpb24gKHVuaGF2ZSkgeyAvLyBjYWxsZWQgYnkgZmVlZFxuICBpZiAodGhpcy5zdHJlYW0gJiYgdGhpcy5yZW1vdGVXYW50KSB0aGlzLnN0cmVhbS51bmhhdmUodW5oYXZlKVxufVxuXG5QZWVyLnByb3RvdHlwZS5oYXZlQnl0ZXMgPSBmdW5jdGlvbiAoYnl0ZXMpIHsgLy8gY2FsbGVkIGJ5IGZlZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5pbmZsaWdodFJlcXVlc3RzW2ldLmJ5dGVzID09PSBieXRlcykge1xuICAgICAgdGhpcy5mZWVkLl9yZXNlcnZlZC5zZXQodGhpcy5pbmZsaWdodFJlcXVlc3RzW2ldLmluZGV4LCBmYWxzZSlcbiAgICAgIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5zcGxpY2UoaSwgMSlcbiAgICAgIGktLVxuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlKClcbn1cblxuUGVlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyBkbyBub3RoaW5nXG4gIHdoaWxlICh0aGlzLl91cGRhdGUoKSkge31cbn1cblxuUGVlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gc2hvdWxkIHJldHVybiB0cnVlIGlmIG11dGF0ZWQgZmFsc2UgaWYgbm90XG4gIGlmICghdGhpcy5kb3dubG9hZGluZyB8fCAhdGhpcy5yZW1vdGVCaXRmaWVsZCkgcmV0dXJuIGZhbHNlXG5cbiAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmZlZWQuX3NlbGVjdGlvbnNcbiAgdmFyIHdhaXRpbmcgPSB0aGlzLmZlZWQuX3dhaXRpbmdcbiAgdmFyIHdsZW4gPSB3YWl0aW5nLmxlbmd0aFxuICB2YXIgc2xlbiA9IHNlbGVjdGlvbnMubGVuZ3RoXG4gIHZhciBpbmZsaWdodCA9IHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGhcbiAgdmFyIG9mZnNldCA9IDBcbiAgdmFyIGkgPSAwXG5cbiAgLy8gVE9ETzogbGVzcyBkdXBsaWNhdGUgY29kZSBoZXJlXG4gIC8vIFRPRE86IHJlLWFkZCBwcmlvcml0eSBsZXZlbHNcblxuICB3aGlsZSAoaW5mbGlnaHQgPCB0aGlzLm1heFJlcXVlc3RzKSB7XG4gICAgb2Zmc2V0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogd2FpdGluZy5sZW5ndGgpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgd2FpdGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB3YWl0aW5nW29mZnNldCsrXVxuICAgICAgaWYgKG9mZnNldCA9PT0gd2FpdGluZy5sZW5ndGgpIG9mZnNldCA9IDBcblxuICAgICAgdGhpcy5fZG93bmxvYWRXYWl0aW5nKHcpXG4gICAgICBpZiAod2FpdGluZy5sZW5ndGggIT09IHdsZW4pIHJldHVybiB0cnVlIC8vIG11dGF0ZWRcbiAgICAgIGlmICh0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoID49IHRoaXMubWF4UmVxdWVzdHMpIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoaW5mbGlnaHQgPT09IHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGgpIGJyZWFrXG4gICAgaW5mbGlnaHQgPSB0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoXG4gIH1cblxuICB3aGlsZSAoaW5mbGlnaHQgPCB0aGlzLm1heFJlcXVlc3RzKSB7XG4gICAgb2Zmc2V0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2VsZWN0aW9ucy5sZW5ndGgpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHMgPSBzZWxlY3Rpb25zW29mZnNldCsrXVxuICAgICAgaWYgKG9mZnNldCA9PT0gc2VsZWN0aW9ucy5sZW5ndGgpIG9mZnNldCA9IDBcblxuICAgICAgaWYgKCFzLml0ZXJhdG9yKSBzLml0ZXJhdG9yID0gdGhpcy5mZWVkLmJpdGZpZWxkLml0ZXJhdG9yKHMuc3RhcnQsIHMuZW5kKVxuICAgICAgdGhpcy5fZG93bmxvYWRSYW5nZShzKVxuICAgICAgaWYgKHNlbGVjdGlvbnMubGVuZ3RoICE9PSBzbGVuKSByZXR1cm4gdHJ1ZSAvLyBtdXRhdGVkXG4gICAgICBpZiAodGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aCA+PSB0aGlzLm1heFJlcXVlc3RzKSByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoaW5mbGlnaHQgPT09IHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgIGluZmxpZ2h0ID0gdGhpcy5pbmZsaWdodFJlcXVlc3RzLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cblBlZXIucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICBzZXQuYWRkKHRoaXMuZmVlZC5wZWVycywgdGhpcylcbiAgdGhpcy5zdHJlYW0ud2FudCh7c3RhcnQ6IDB9KSAvLyBUT0RPOiBkb24ndCBqdXN0IHN1YnNjcmliZSB0byAqRVZFUllUSElORyogaGVoZVxuICB0aGlzLmZlZWQuZW1pdCgncGVlci1hZGQnLCB0aGlzKVxufVxuXG5QZWVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5kb3dubG9hZGluZyAmJiAhdGhpcy5yZW1vdGVEb3dubG9hZGluZyAmJiAhdGhpcy5saXZlKSB7XG4gICAgaWYgKCF0aGlzLl9kZWZhdWx0RG93bmxvYWRpbmcpIHtcbiAgICAgIHRoaXMuc3RyZWFtLmluZm8oe2Rvd25sb2FkaW5nOiBmYWxzZSwgdXBsb2FkaW5nOiBmYWxzZX0pXG4gICAgfVxuICAgIHRoaXMuX2Nsb3NlKClcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIXRoaXMuX2Nsb3NlZCkge1xuICAgIHRoaXMuX2Nsb3NlZCA9IHRydWVcbiAgICB0aGlzLmRvd25sb2FkaW5nID0gZmFsc2VcbiAgICB0aGlzLnN0cmVhbS5pbmZvKHtkb3dubG9hZGluZzogZmFsc2UsIHVwbG9hZGluZzogdHJ1ZX0pXG4gIH0gZWxzZSB7XG4gICAgaWYgKCF0aGlzLmxpdmUpIHRoaXMuX2Nsb3NlKClcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9pbmRleCA9PT0gLTEpIHJldHVyblxuICBpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgIHRoaXMuc3RyZWFtLmNsb3NlKClcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIH1cbiAgc2V0LnJlbW92ZSh0aGlzLmZlZWQucGVlcnMsIHRoaXMpXG4gIHRoaXMuX2luZGV4ID0gLTFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZmxpZ2h0UmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmZlZWQuX3Jlc2VydmVkLnNldCh0aGlzLmluZmxpZ2h0UmVxdWVzdHNbaV0uaW5kZXgsIGZhbHNlKVxuICB9XG4gIHRoaXMuX3VwZGF0ZUVuZCgpXG4gIHRoaXMucmVtb3RlV2FudCA9IGZhbHNlXG4gIHRoaXMuZmVlZC5fdXBkYXRlUGVlcnMoKVxuICB0aGlzLmZlZWQuZW1pdCgncGVlci1yZW1vdmUnLCB0aGlzKVxufVxuXG5QZWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5faW5kZXggPT09IC0xIHx8IHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX2Nsb3NlKClcbn1cblxuUGVlci5wcm90b3R5cGUuX2Rvd25sb2FkV2FpdGluZyA9IGZ1bmN0aW9uICh3YWl0KSB7XG4gIGlmICghd2FpdC5ieXRlcykge1xuICAgIGlmICghdGhpcy5yZW1vdGVCaXRmaWVsZC5nZXQod2FpdC5pbmRleCkgfHwgIXRoaXMuZmVlZC5fcmVzZXJ2ZWQuc2V0KHdhaXQuaW5kZXgsIHRydWUpKSByZXR1cm5cbiAgICB0aGlzLl9yZXF1ZXN0KHdhaXQuaW5kZXgsIDAsIGZhbHNlKVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5fZG93bmxvYWRSYW5nZSh3YWl0KVxufVxuXG5QZWVyLnByb3RvdHlwZS5fZG93bmxvYWRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICBpZiAoIXJhbmdlLml0ZXJhdG9yKSByYW5nZS5pdGVyYXRvciA9IHRoaXMuZmVlZC5iaXRmaWVsZC5pdGVyYXRvcihyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKVxuXG4gIHZhciByZXNlcnZlZCA9IHRoaXMuZmVlZC5fcmVzZXJ2ZWRcbiAgdmFyIGl0ZSA9IHJhbmdlLml0ZXJhdG9yXG4gIHZhciB3YW50ZWRFbmQgPSBNYXRoLm1pbihyYW5nZS5lbmQgPT09IC0xID8gdGhpcy5yZW1vdGVMZW5ndGggOiByYW5nZS5lbmQsIHRoaXMucmVtb3RlTGVuZ3RoKVxuXG4gIGlmIChpdGUuZW5kICE9PSB3YW50ZWRFbmQpIGl0ZS5yYW5nZShyYW5nZS5zdGFydCwgd2FudGVkRW5kKVxuXG4gIHZhciBpID0gcmFuZ2UubGluZWFyID8gaXRlLm5leHQoKSA6IGl0ZS5yYW5kb20oKVxuICB2YXIgcmVzZXQgPSBmYWxzZVxuICB2YXIgc3RhcnQgPSBpXG5cbiAgaWYgKGkgPT09IC0xKSB7XG4gICAgaWYgKCFyYW5nZS5ieXRlcyAmJiBpdGUuc2VlaygwKS5uZXh0KCkgPT09IC0xICYmIChyYW5nZS5lbmQgPiAtMSAmJiB0aGlzLnJlbW90ZUxlbmd0aCA+PSByYW5nZS5lbmQpKSB7XG4gICAgICBzZXQucmVtb3ZlKHRoaXMuZmVlZC5fc2VsZWN0aW9ucywgcmFuZ2UpXG4gICAgICByYW5nZS5jYWxsYmFjayhudWxsKVxuICAgICAgaWYgKCF0aGlzLmxpdmUgJiYgIXRoaXMuc3BhcnNlICYmICF0aGlzLmZlZWQuX3NlbGVjdGlvbnMubGVuZ3RoKSB0aGlzLmVuZCgpXG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgd2hpbGUgKCF0aGlzLnJlbW90ZUJpdGZpZWxkLmdldChpKSB8fCAocmFuZ2UuaGFzaCAmJiB0aGlzLmZlZWQudHJlZS5nZXQoMiAqIGkpKSB8fCAhcmVzZXJ2ZWQuc2V0KGksIHRydWUpKSB7XG4gICAgaSA9IGl0ZS5uZXh0KClcbiAgICByZXNldCA9IHRydWVcblxuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIC8vIGNoZWNrIHRoaXMgaW5kZXhcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKCFyYW5nZS5saW5lYXIgJiYgc3RhcnQgIT09IDApIHtcbiAgICAgIC8vIHJldHJ5IGZyb20gdGhlIGJlZ2lubmluZyBzaW5jZSB3ZSBhcmUgaXRlcmF0aW5nIHJhbmRvbWx5IGFuZCBzdGFydGVkICE9PSAwXG4gICAgICBpID0gaXRlLnNlZWsoMCkubmV4dCgpXG4gICAgICBzdGFydCA9IDBcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gd2UgaGF2ZSBjaGVja2VkIGFsbCBpbmRleGVzLlxuICAgIC8vIGlmIHdlIGFyZSBsb29raW5nIGZvciBoYXNoZXMgd2Ugc2hvdWxkIGNoZWNrIGlmIHdlIGhhdmUgYWxsIG5vdyAoZmlyc3QgY2hlY2sgb25seSBjaGVja3MgYmxvY2tzKVxuICAgIGlmIChyYW5nZS5oYXNoKSB7XG4gICAgICAvLyBxdWljayduJ2RpcnR5IGNoZWNrIGlmIGhhdmUgYWxsIGhhc2hlcyAtIGNhbiBiZSBvcHRpbWl6ZWQgYmUgY2hlY2tpbmcgb25seSB0cmVlIHJvb3RzXG4gICAgICAvLyBidXQgd2UgZG9uJ3QgcmVhbGx5IHJlcXVlc3QgbG9uZyByYW5nZXMgb2YgaGFzaGVzIHNvIHlvbG9cbiAgICAgIGZvciAodmFyIGogPSByYW5nZS5zdGFydDsgaiA8IHdhbnRlZEVuZDsgaisrKSB7XG4gICAgICAgIGlmICghdGhpcy5mZWVkLnRyZWUuZ2V0KDIgKiBqKSkgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoIXJhbmdlLmJ5dGVzKSB7XG4gICAgICAgIHNldC5yZW1vdmUodGhpcy5mZWVkLl9zZWxlY3Rpb25zLCByYW5nZSlcbiAgICAgICAgcmFuZ2UuY2FsbGJhY2sobnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBleGl0IHRoZSB1cGRhdGUgbG9vcCAtIG5vdGhpbmcgdG8gZG9cbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChyZXNldCkgaXRlLnNlZWsoMClcblxuICB0aGlzLl9yZXF1ZXN0KGksIHJhbmdlLmJ5dGVzIHx8IDAsIHJhbmdlLmhhc2gpXG59XG5cblBlZXIucHJvdG90eXBlLl9yZXF1ZXN0ID0gZnVuY3Rpb24gKGluZGV4LCBieXRlcywgaGFzaCkge1xuICB2YXIgcmVxdWVzdCA9IHtcbiAgICB0aWNrOiA2LFxuICAgIGJ5dGVzOiBieXRlcyxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgaGFzaDogaGFzaCxcbiAgICBub2RlczogdGhpcy5mZWVkLmRpZ2VzdChpbmRleClcbiAgfVxuXG4gIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpXG4gIHRoaXMuc3RyZWFtLnJlcXVlc3QocmVxdWVzdClcbn1cbiIsInZhciB1aW50NjRiZSA9IHJlcXVpcmUoJ3VpbnQ2NGJlJylcbnZhciBmbGF0ID0gcmVxdWlyZSgnZmxhdC10cmVlJylcbnZhciBhbHJ1ID0gcmVxdWlyZSgnYXJyYXktbHJ1JylcbnZhciBidWZmZXJBbGxvYyA9IHJlcXVpcmUoJ2J1ZmZlci1hbGxvYy11bnNhZmUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3JhZ2VcblxudmFyIG5vYXJyID0gW11cblxuZnVuY3Rpb24gU3RvcmFnZSAoY3JlYXRlLCBjYWNoZVNpemUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0b3JhZ2UpKSByZXR1cm4gbmV3IFN0b3JhZ2UoY3JlYXRlLCBjYWNoZVNpemUpXG4gIGNhY2hlU2l6ZSA9IHR5cGVvZiBjYWNoZVNpemUgPT09ICd1bmRlZmluZWQnID8gNjU1MzYgOiBjYWNoZVNpemVcblxuICB0aGlzLmNhY2hlID0gY2FjaGVTaXplID4gMCA/IGFscnUoY2FjaGVTaXplLCB7aW5kZXhlZFZhbHVlczogdHJ1ZX0pIDogbnVsbFxuICB0aGlzLmtleSA9IG51bGxcbiAgdGhpcy5zZWNyZXRLZXkgPSBudWxsXG4gIHRoaXMudHJlZSA9IG51bGxcbiAgdGhpcy5kYXRhID0gbnVsbFxuICB0aGlzLmJpdGZpZWxkID0gbnVsbFxuICB0aGlzLnNpZ25hdHVyZXMgPSBudWxsXG4gIHRoaXMuY3JlYXRlID0gY3JlYXRlXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLnB1dERhdGEgPSBmdW5jdGlvbiAoaW5kZXgsIGRhdGEsIG5vZGVzLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybiBjYihudWxsKVxuICB0aGlzLmRhdGFPZmZzZXQoaW5kZXgsIG5vZGVzLCBmdW5jdGlvbiAoZXJyLCBvZmZzZXQsIHNpemUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChzaXplICE9PSBkYXRhLmxlbmd0aCkgcmV0dXJuIGNiKG5ldyBFcnJvcignVW5leHBlY3RlZCBkYXRhIHNpemUnKSlcbiAgICBzZWxmLmRhdGEud3JpdGUob2Zmc2V0LCBkYXRhLCBjYilcbiAgfSlcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuZGF0YU9mZnNldChpbmRleCwgbm9hcnIsIGZ1bmN0aW9uIChlcnIsIG9mZnNldCwgc2l6ZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5kYXRhLnJlYWQob2Zmc2V0LCBzaXplLCBjYilcbiAgfSlcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUubmV4dFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5fZ2V0U2lnbmF0dXJlKGluZGV4LCBmdW5jdGlvbiAoZXJyLCBzaWduYXR1cmUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChpc0JsYW5rKHNpZ25hdHVyZSkpIHJldHVybiBzZWxmLm5leHRTaWduYXR1cmUoaW5kZXggKyAxLCBjYilcbiAgICBjYihudWxsLCB7IGluZGV4OiBpbmRleCwgc2lnbmF0dXJlOiBzaWduYXR1cmUgfSlcbiAgfSlcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUuZ2V0U2lnbmF0dXJlID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB0aGlzLl9nZXRTaWduYXR1cmUoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIHNpZ25hdHVyZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKGlzQmxhbmsoc2lnbmF0dXJlKSkgcmV0dXJuIGNiKG5ldyBFcnJvcignTm8gc2lnbmF0dXJlIGZvdW5kJykpXG4gICAgY2IobnVsbCwgc2lnbmF0dXJlKVxuICB9KVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5fZ2V0U2lnbmF0dXJlID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB0aGlzLnNpZ25hdHVyZXMucmVhZCgzMiArIDY0ICogaW5kZXgsIDY0LCBjYilcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUucHV0U2lnbmF0dXJlID0gZnVuY3Rpb24gKGluZGV4LCBzaWduYXR1cmUsIGNiKSB7XG4gIHRoaXMuc2lnbmF0dXJlcy53cml0ZSgzMiArIDY0ICogaW5kZXgsIHNpZ25hdHVyZSwgY2IpXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLmRhdGFPZmZzZXQgPSBmdW5jdGlvbiAoaW5kZXgsIGNhY2hlZE5vZGVzLCBjYikge1xuICB2YXIgcm9vdHMgPSBmbGF0LmZ1bGxSb290cygyICogaW5kZXgpXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgb2Zmc2V0ID0gMFxuICB2YXIgcGVuZGluZyA9IHJvb3RzLmxlbmd0aFxuICB2YXIgZXJyb3IgPSBudWxsXG4gIHZhciBibGsgPSAyICogaW5kZXhcblxuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gMVxuICAgIG9ubm9kZShudWxsLCBudWxsKVxuICAgIHJldHVyblxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gZmluZE5vZGUoY2FjaGVkTm9kZXMsIHJvb3RzW2ldKVxuICAgIGlmIChub2RlKSBvbm5vZGUobnVsbCwgbm9kZSlcbiAgICBlbHNlIHRoaXMuZ2V0Tm9kZShyb290c1tpXSwgb25ub2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gb25sYXN0IChlcnIsIG5vZGUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNiKG51bGwsIG9mZnNldCwgbm9kZS5zaXplKVxuICB9XG5cbiAgZnVuY3Rpb24gb25ub2RlIChlcnIsIG5vZGUpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmIChub2RlKSBvZmZzZXQgKz0gbm9kZS5zaXplXG4gICAgaWYgKC0tcGVuZGluZykgcmV0dXJuXG5cbiAgICBpZiAoZXJyb3IpIHJldHVybiBjYihlcnJvcilcblxuICAgIHZhciBsYXN0ID0gZmluZE5vZGUoY2FjaGVkTm9kZXMsIGJsaylcbiAgICBpZiAobGFzdCkgb25sYXN0KG51bGwsIGxhc3QpXG4gICAgZWxzZSBzZWxmLmdldE5vZGUoYmxrLCBvbmxhc3QpXG4gIH1cbn1cblxuU3RvcmFnZS5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgaWYgKHRoaXMuY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5jYWNoZS5nZXQoaW5kZXgpXG4gICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNiKG51bGwsIGNhY2hlZClcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMudHJlZS5yZWFkKDMyICsgNDAgKiBpbmRleCwgNDAsIGZ1bmN0aW9uIChlcnIsIGJ1Zikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICB2YXIgaGFzaCA9IGJ1Zi5zbGljZSgwLCAzMilcbiAgICB2YXIgc2l6ZSA9IHVpbnQ2NGJlLmRlY29kZShidWYsIDMyKVxuXG4gICAgaWYgKCFzaXplICYmIGlzQmxhbmsoaGFzaCkpIHJldHVybiBjYihuZXcgRXJyb3IoJ05vIG5vZGUgZm91bmQnKSlcblxuICAgIHZhciB2YWwgPSBuZXcgTm9kZShpbmRleCwgaGFzaCwgc2l6ZSwgbnVsbClcbiAgICBpZiAoc2VsZi5jYWNoZSkgc2VsZi5jYWNoZS5zZXQoaW5kZXgsIHZhbClcbiAgICBjYihudWxsLCB2YWwpXG4gIH0pXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLnB1dE5vZGUgPSBmdW5jdGlvbiAoaW5kZXgsIG5vZGUsIGNiKSB7XG4gIGlmICghY2IpIGNiID0gbm9vcFxuXG4gIC8vIFRPRE86IHJlLWVuYWJsZSBwdXQgY2FjaGUuIGN1cnJlbnRseSB0aGlzIGNhdXNlcyBhIG1lbWxlYWtcbiAgLy8gYmVjYXVzZSBub2RlLmhhc2ggaXMgYSBzbGljZSBvZiB0aGUgYmlnIGRhdGEgYnVmZmVyIG9uIHJlcGxpY2F0ZVxuICAvLyBpZiAodGhpcy5jYWNoZSkgdGhpcy5jYWNoZS5zZXQoaW5kZXgsIG5vZGUpXG5cbiAgdmFyIGJ1ZiA9IGJ1ZmZlckFsbG9jKDQwKVxuXG4gIG5vZGUuaGFzaC5jb3B5KGJ1ZiwgMClcbiAgdWludDY0YmUuZW5jb2RlKG5vZGUuc2l6ZSwgYnVmLCAzMilcbiAgdGhpcy50cmVlLndyaXRlKDMyICsgNDAgKiBpbmRleCwgYnVmLCBjYilcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUucHV0Qml0ZmllbGQgPSBmdW5jdGlvbiAob2Zmc2V0LCBkYXRhLCBjYikge1xuICB0aGlzLmJpdGZpZWxkLndyaXRlKDMyICsgb2Zmc2V0LCBkYXRhLCBjYilcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBub29wXG4gIHZhciBtaXNzaW5nID0gNlxuICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgY2xvc2UodGhpcy5iaXRmaWVsZCwgZG9uZSlcbiAgY2xvc2UodGhpcy50cmVlLCBkb25lKVxuICBjbG9zZSh0aGlzLmRhdGEsIGRvbmUpXG4gIGNsb3NlKHRoaXMua2V5LCBkb25lKVxuICBjbG9zZSh0aGlzLnNlY3JldEtleSwgZG9uZSlcbiAgY2xvc2UodGhpcy5zaWduYXR1cmVzLCBkb25lKVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xuICAgIGlmIChlcnIpIGVycm9yID0gZXJyXG4gICAgaWYgKC0tbWlzc2luZykgcmV0dXJuXG4gICAgY2IoZXJyb3IpXG4gIH1cbn1cblxuU3RvcmFnZS5wcm90b3R5cGUub3BlbktleSA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLm9wZW5LZXkoe30sIG9wdHMpXG4gIGlmICghdGhpcy5rZXkpIHRoaXMua2V5ID0gdGhpcy5jcmVhdGUoJ2tleScsIG9wdHMpXG4gIHRoaXMua2V5LnJlYWQoMCwgMzIsIGNiKVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMub3Blbih7fSwgb3B0cylcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGVycm9yID0gbnVsbFxuICB2YXIgbWlzc2luZyA9IDVcblxuICBpZiAoIXRoaXMua2V5KSB0aGlzLmtleSA9IHRoaXMuY3JlYXRlKCdrZXknLCBvcHRzKVxuICBpZiAoIXRoaXMuc2VjcmV0S2V5KSB0aGlzLnNlY3JldEtleSA9IHRoaXMuY3JlYXRlKCdzZWNyZXRfa2V5Jywgb3B0cylcbiAgaWYgKCF0aGlzLnRyZWUpIHRoaXMudHJlZSA9IHRoaXMuY3JlYXRlKCd0cmVlJywgb3B0cylcbiAgaWYgKCF0aGlzLmRhdGEpIHRoaXMuZGF0YSA9IHRoaXMuY3JlYXRlKCdkYXRhJywgb3B0cylcbiAgaWYgKCF0aGlzLmJpdGZpZWxkKSB0aGlzLmJpdGZpZWxkID0gdGhpcy5jcmVhdGUoJ2JpdGZpZWxkJywgb3B0cylcbiAgaWYgKCF0aGlzLnNpZ25hdHVyZXMpIHRoaXMuc2lnbmF0dXJlcyA9IHRoaXMuY3JlYXRlKCdzaWduYXR1cmVzJywgb3B0cylcblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGJpdGZpZWxkOiBidWZmZXJBbGxvYygwKSxcbiAgICBzZWNyZXRLZXk6IG51bGwsXG4gICAga2V5OiBudWxsXG4gIH1cblxuICB0aGlzLmJpdGZpZWxkLndyaXRlKDAsIGhlYWRlcigwLCAzMzI4LCBudWxsKSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmVhZEFsbChzZWxmLmJpdGZpZWxkLCAzMiwgMzMyOCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGRhdGEpIHJlc3VsdC5iaXRmaWVsZCA9IGRhdGFcbiAgICAgIGRvbmUoZXJyKVxuICAgIH0pXG4gIH0pXG5cbiAgdGhpcy5zaWduYXR1cmVzLndyaXRlKDAsIGhlYWRlcigxLCA2NCwgJ0VkMjU1MTknKSwgZG9uZSlcbiAgdGhpcy50cmVlLndyaXRlKDAsIGhlYWRlcigyLCA0MCwgJ0JMQUtFMmInKSwgZG9uZSlcblxuICAvLyBUT0RPOiBJbXByb3ZlIHRoZSBlcnJvciBoYW5kbGluZyBoZXJlLlxuICAvLyBJLmUuIGlmIHNlY3JldEtleSBsZW5ndGggPT09IDY0IGFuZCBpdCBmYWlscywgZXJyb3JcblxuICB0aGlzLnNlY3JldEtleS5yZWFkKDAsIDY0LCBmdW5jdGlvbiAoXywgZGF0YSkge1xuICAgIGlmIChkYXRhKSByZXN1bHQuc2VjcmV0S2V5ID0gZGF0YVxuICAgIGRvbmUobnVsbClcbiAgfSlcblxuICB0aGlzLmtleS5yZWFkKDAsIDMyLCBmdW5jdGlvbiAoXywgZGF0YSkge1xuICAgIGlmIChkYXRhKSByZXN1bHQua2V5ID0gZGF0YVxuICAgIGRvbmUobnVsbClcbiAgfSlcblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBpZiAoZXJyKSBlcnJvciA9IGVyclxuICAgIGlmICgtLW1pc3NpbmcpIHJldHVyblxuICAgIGlmIChlcnJvcikgY2IoZXJyb3IpXG4gICAgZWxzZSBjYihudWxsLCByZXN1bHQpXG4gIH1cbn1cblxuU3RvcmFnZS5Ob2RlID0gTm9kZVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIGhlYWRlciAodHlwZSwgc2l6ZSwgbmFtZSkge1xuICB2YXIgYnVmID0gYnVmZmVyQWxsb2MoMzIpXG4gIGJ1Zi5maWxsKDApXG5cbiAgLy8gbWFnaWMgbnVtYmVyXG4gIGJ1ZlswXSA9IDVcbiAgYnVmWzFdID0gMlxuICBidWZbMl0gPSA4N1xuICBidWZbM10gPSB0eXBlXG5cbiAgLy8gdmVyc2lvblxuICBidWZbNF0gPSAwXG5cbiAgLy8gYmxvY2sgc2l6ZVxuICBidWYud3JpdGVVSW50MTZCRShzaXplLCA1KVxuXG4gIGlmIChuYW1lKSB7XG4gICAgLy8gYWxnbyBuYW1lXG4gICAgYnVmWzddID0gbmFtZS5sZW5ndGhcbiAgICBidWYud3JpdGUobmFtZSwgOClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gTm9kZSAoaW5kZXgsIGhhc2gsIHNpemUpIHtcbiAgdGhpcy5pbmRleCA9IGluZGV4XG4gIHRoaXMuaGFzaCA9IGhhc2hcbiAgdGhpcy5zaXplID0gc2l6ZVxufVxuXG5mdW5jdGlvbiBmaW5kTm9kZSAobm9kZXMsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0uaW5kZXggPT09IGluZGV4KSByZXR1cm4gbm9kZXNbaV1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0JsYW5rIChidWYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldKSByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjbG9zZSAoc3QsIGNiKSB7XG4gIGlmIChzdC5jbG9zZSkgc3QuY2xvc2UoY2IpXG4gIGVsc2UgY2IoKVxufVxuXG5mdW5jdGlvbiBzdGF0QW5kUmVhZEFsbCAoc3QsIG9mZnNldCwgY2IpIHtcbiAgc3Quc3RhdChmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKG51bGwsIGJ1ZmZlckFsbG9jKDApKVxuICAgIHN0LnJlYWQob2Zmc2V0LCBzdGF0LnNpemUgLSBvZmZzZXQsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWFkQWxsIChzdCwgb2Zmc2V0LCBwYWdlU2l6ZSwgY2IpIHtcbiAgaWYgKHR5cGVvZiBzdC5sZW5ndGggPT09ICdudW1iZXInICYmIHN0Lmxlbmd0aCA+IC0xKSByZXR1cm4gc3QucmVhZChvZmZzZXQsIHN0Lmxlbmd0aCAtIG9mZnNldCwgY2IpXG4gIGlmIChzdC5zdGF0YWJsZSA9PT0gdHJ1ZSkgcmV0dXJuIHN0YXRBbmRSZWFkQWxsKHN0LCBvZmZzZXQsIGNiKVxuXG4gIHZhciBidWZzID0gW11cblxuICBzdC5yZWFkKG9mZnNldCwgcGFnZVNpemUsIGxvb3ApXG5cbiAgZnVuY3Rpb24gbG9vcCAoZXJyLCBidWYpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IobnVsbCwgQnVmZmVyLmNvbmNhdChidWZzKSlcbiAgICBidWZzLnB1c2goYnVmKVxuICAgIHN0LnJlYWQob2Zmc2V0ICsgYnVmcy5sZW5ndGggKiBwYWdlU2l6ZSwgcGFnZVNpemUsIGxvb3ApXG4gIH1cbn1cbiIsInZhciBmbGF0ID0gcmVxdWlyZSgnZmxhdC10cmVlJylcbnZhciBiaXRmaWVsZCA9IHJlcXVpcmUoJ3NwYXJzZS1iaXRmaWVsZCcpXG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZUluZGV4XG5cbmZ1bmN0aW9uIFRyZWVJbmRleCAoYml0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJlZUluZGV4KSkgcmV0dXJuIG5ldyBUcmVlSW5kZXgoYml0cylcbiAgdGhpcy5iaXRmaWVsZCA9IGJpdHMgfHwgYml0ZmllbGQoKVxufVxuXG5UcmVlSW5kZXgucHJvdG90eXBlLnByb29mID0gZnVuY3Rpb24gKGluZGV4LCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgdmFyIG5vZGVzID0gW11cbiAgdmFyIHJlbW90ZVRyZWUgPSBvcHRzLnRyZWUgfHwgbmV3IFRyZWVJbmRleCgpXG4gIHZhciBkaWdlc3QgPSBvcHRzLmRpZ2VzdCB8fCAwXG5cbiAgaWYgKCF0aGlzLmdldChpbmRleCkpIHJldHVybiBudWxsXG4gIGlmIChvcHRzLmhhc2gpIG5vZGVzLnB1c2goaW5kZXgpIC8vIGFsd2F5cyByZXR1cm4gaGFzaCAtIG5vIG1hdHRlciB3aGF0IHRoZSBkaWdlc3Qgc2F5c1xuICBpZiAoZGlnZXN0ID09PSAxKSByZXR1cm4ge25vZGVzOiBub2RlcywgdmVyaWZpZWRCeTogMH1cblxuICB2YXIgcm9vdHMgPSBudWxsXG4gIHZhciBzaWJsaW5nID0gaW5kZXhcbiAgdmFyIG5leHQgPSBpbmRleFxuICB2YXIgaGFzUm9vdCA9IGRpZ2VzdCAmIDFcbiAgZGlnZXN0ID0gcmlnaHRTaGlmdChkaWdlc3QpXG5cbiAgd2hpbGUgKGRpZ2VzdCkge1xuICAgIGlmIChkaWdlc3QgPT09IDEgJiYgaGFzUm9vdCkge1xuICAgICAgaWYgKHRoaXMuZ2V0KG5leHQpKSByZW1vdGVUcmVlLnNldChuZXh0KVxuXG4gICAgICAvLyBoYXZpbmcgYSByb290IGltcGxpZXMgaGF2aW5nIHByZXYgcm9vdHMgYXMgd2VsbFxuICAgICAgLy8gVE9ETzogdGhpcyBjYW4gYmUgb3B0aW1pemVkIGF3YXkgYmUgb25seSBzZW5kaW5nIFwibmV3ZXJcIiByb290cyxcbiAgICAgIC8vIHdoZW4gc2VuZGluZyByb290c1xuICAgICAgaWYgKGZsYXQuc2libGluZyhuZXh0KSA8IG5leHQpIG5leHQgPSBmbGF0LnNpYmxpbmcobmV4dClcbiAgICAgIHJvb3RzID0gZmxhdC5mdWxsUm9vdHMoZmxhdC5yaWdodFNwYW4obmV4dCkgKyAyKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5nZXQocm9vdHNbaV0pKSByZW1vdGVUcmVlLnNldChyb290c1tpXSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgc2libGluZyA9IGZsYXQuc2libGluZyhuZXh0KVxuICAgIGlmIChkaWdlc3QgJiAxKSB7XG4gICAgICBpZiAodGhpcy5nZXQoc2libGluZykpIHJlbW90ZVRyZWUuc2V0KHNpYmxpbmcpXG4gICAgfVxuICAgIG5leHQgPSBmbGF0LnBhcmVudChuZXh0KVxuICAgIGRpZ2VzdCA9IHJpZ2h0U2hpZnQoZGlnZXN0KVxuICB9XG5cbiAgbmV4dCA9IGluZGV4XG5cbiAgd2hpbGUgKCFyZW1vdGVUcmVlLmdldChuZXh0KSkge1xuICAgIHNpYmxpbmcgPSBmbGF0LnNpYmxpbmcobmV4dClcbiAgICBpZiAoIXRoaXMuZ2V0KHNpYmxpbmcpKSB7XG4gICAgICAvLyBuZXh0IGlzIGEgbG9jYWwgcm9vdFxuICAgICAgdmFyIHZlcmlmaWVkQnkgPSB0aGlzLnZlcmlmaWVkQnkobmV4dClcbiAgICAgIGFkZEZ1bGxSb290cyh2ZXJpZmllZEJ5LCBub2RlcywgbmV4dCwgcmVtb3RlVHJlZSlcbiAgICAgIHJldHVybiB7bm9kZXM6IG5vZGVzLCB2ZXJpZmllZEJ5OiB2ZXJpZmllZEJ5fVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJlbW90ZVRyZWUuZ2V0KHNpYmxpbmcpKSBub2Rlcy5wdXNoKHNpYmxpbmcpXG4gICAgfVxuXG4gICAgbmV4dCA9IGZsYXQucGFyZW50KG5leHQpXG4gIH1cblxuICByZXR1cm4ge25vZGVzOiBub2RlcywgdmVyaWZpZWRCeTogMH1cbn1cblxuVHJlZUluZGV4LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgaWYgKHRoaXMuZ2V0KGluZGV4KSkgcmV0dXJuIDFcblxuICB2YXIgZGlnZXN0ID0gMFxuICB2YXIgbmV4dCA9IGZsYXQuc2libGluZyhpbmRleClcbiAgdmFyIG1heCA9IE1hdGgubWF4KG5leHQgKyAyLCB0aGlzLmJpdGZpZWxkLmxlbmd0aCkgLy8gVE9ETzogbWFrZSB0aGlzIGxlc3MgLi4uIGhhY2t5XG5cbiAgdmFyIGJpdCA9IDJcbiAgdmFyIGRlcHRoID0gZmxhdC5kZXB0aChpbmRleClcbiAgdmFyIHBhcmVudCA9IGZsYXQucGFyZW50KG5leHQsIGRlcHRoKyspXG5cbiAgd2hpbGUgKGZsYXQucmlnaHRTcGFuKG5leHQpIDwgbWF4IHx8IGZsYXQubGVmdFNwYW4ocGFyZW50KSA+IDApIHtcbiAgICBpZiAodGhpcy5nZXQobmV4dCkpIHtcbiAgICAgIGRpZ2VzdCB8PSBiaXRcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0KHBhcmVudCkpIHtcbiAgICAgIGRpZ2VzdCB8PSAoMiAqIGJpdCArIDEpXG4gICAgICBpZiAoZGlnZXN0ICsgMSA9PT0gNCAqIGJpdCkgcmV0dXJuIDFcbiAgICAgIHJldHVybiBkaWdlc3RcbiAgICB9XG4gICAgbmV4dCA9IGZsYXQuc2libGluZyhwYXJlbnQpXG4gICAgcGFyZW50ID0gZmxhdC5wYXJlbnQobmV4dCwgZGVwdGgrKylcbiAgICBiaXQgKj0gMlxuICB9XG5cbiAgcmV0dXJuIGRpZ2VzdFxufVxuXG5UcmVlSW5kZXgucHJvdG90eXBlLmJsb2NrcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRvcCA9IDBcbiAgdmFyIG5leHQgPSAwXG4gIHZhciBtYXggPSB0aGlzLmJpdGZpZWxkLmxlbmd0aFxuXG4gIHdoaWxlIChmbGF0LnJpZ2h0U3BhbihuZXh0KSA8IG1heCkge1xuICAgIG5leHQgPSBmbGF0LnBhcmVudChuZXh0KVxuICAgIGlmICh0aGlzLmdldChuZXh0KSkgdG9wID0gbmV4dFxuICB9XG5cbiAgcmV0dXJuICh0aGlzLmdldCh0b3ApID8gdGhpcy52ZXJpZmllZEJ5KHRvcCkgOiAwKSAvIDJcbn1cblxuVHJlZUluZGV4LnByb3RvdHlwZS5yb290cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZsYXQuZnVsbFJvb3RzKDIgKiB0aGlzLmJsb2NrcygpKVxufVxuXG5UcmVlSW5kZXgucHJvdG90eXBlLnZlcmlmaWVkQnkgPSBmdW5jdGlvbiAoaW5kZXgsIG5vZGVzKSB7XG4gIHZhciBoYXNJbmRleCA9IHRoaXMuZ2V0KGluZGV4KVxuICBpZiAoIWhhc0luZGV4KSByZXR1cm4gMFxuXG4gIC8vIGZpbmQgcm9vdCBvZiBjdXJyZW50IHRyZWVcblxuICB2YXIgZGVwdGggPSBmbGF0LmRlcHRoKGluZGV4KVxuICB2YXIgdG9wID0gaW5kZXhcbiAgdmFyIHBhcmVudCA9IGZsYXQucGFyZW50KHRvcCwgZGVwdGgrKylcbiAgd2hpbGUgKHRoaXMuZ2V0KHBhcmVudCkgJiYgdGhpcy5nZXQoZmxhdC5zaWJsaW5nKHRvcCkpKSB7XG4gICAgdG9wID0gcGFyZW50XG4gICAgcGFyZW50ID0gZmxhdC5wYXJlbnQodG9wLCBkZXB0aCsrKVxuICB9XG5cbiAgLy8gZXhwYW5kIHJpZ2h0IGRvd25cblxuICBkZXB0aC0tXG4gIHdoaWxlIChkZXB0aCkge1xuICAgIHRvcCA9IGZsYXQubGVmdENoaWxkKGZsYXQuaW5kZXgoZGVwdGgsIGZsYXQub2Zmc2V0KHRvcCwgZGVwdGgpICsgMSksIGRlcHRoKVxuICAgIGRlcHRoLS1cblxuICAgIHdoaWxlICghdGhpcy5nZXQodG9wKSAmJiBkZXB0aCkgdG9wID0gZmxhdC5sZWZ0Q2hpbGQodG9wLCBkZXB0aC0tKVxuICAgIGlmIChub2RlcyAmJiB0aGlzLmdldCh0b3ApKSBub2Rlcy5wdXNoKHRvcClcbiAgfVxuXG4gIHJldHVybiB0aGlzLmdldCh0b3ApID8gdG9wICsgMiA6IHRvcFxufVxuXG5UcmVlSW5kZXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICByZXR1cm4gdGhpcy5iaXRmaWVsZC5nZXQoaW5kZXgpXG59XG5cblRyZWVJbmRleC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIGlmICghdGhpcy5iaXRmaWVsZC5zZXQoaW5kZXgsIHRydWUpKSByZXR1cm4gZmFsc2VcbiAgd2hpbGUgKHRoaXMuYml0ZmllbGQuZ2V0KGZsYXQuc2libGluZyhpbmRleCkpKSB7XG4gICAgaW5kZXggPSBmbGF0LnBhcmVudChpbmRleClcbiAgICBpZiAoIXRoaXMuYml0ZmllbGQuc2V0KGluZGV4LCB0cnVlKSkgYnJlYWtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiByaWdodFNoaWZ0IChuKSB7XG4gIHJldHVybiAobiAtIChuICYgMSkpIC8gMlxufVxuXG5mdW5jdGlvbiBhZGRGdWxsUm9vdHMgKHZlcmlmaWVkQnksIG5vZGVzLCByb290LCByZW1vdGVUcmVlKSB7XG4gIHZhciByb290cyA9IGZsYXQuZnVsbFJvb3RzKHZlcmlmaWVkQnkpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocm9vdHNbaV0gIT09IHJvb3QgJiYgIXJlbW90ZVRyZWUuZ2V0KHJvb3RzW2ldKSkgbm9kZXMucHVzaChyb290c1tpXSlcbiAgfVxufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHdvcmspIHtcbiAgdmFyIHBlbmRpbmcgPSBudWxsXG4gIHZhciBjYWxsYmFjayA9IG51bGxcbiAgdmFyIGNhbGxiYWNrcyA9IG51bGxcbiAgdmFyIG5leHQgPSBudWxsXG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIGNiKSB7XG4gICAgbmV4dCA9IHZhbFxuICAgIHVwZGF0ZShjYiB8fCBub29wKVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlIChjYikge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgaWYgKCFwZW5kaW5nKSBwZW5kaW5nID0gW11cbiAgICAgIHBlbmRpbmcucHVzaChjYilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB2YWwgPSBuZXh0XG4gICAgbmV4dCA9IG51bGxcbiAgICBjYWxsYmFjayA9IGNiXG4gICAgd29yayh2YWwsIGRvbmUpXG4gIH1cblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICB2YXIgY2IgPSBjYWxsYmFja1xuICAgIHZhciBjYnMgPSBjYWxsYmFja3NcbiAgICBjYWxsYmFja3MgPSBudWxsXG4gICAgY2FsbGJhY2sgPSBudWxsXG5cbiAgICBpZiAocGVuZGluZykge1xuICAgICAgY2FsbGJhY2tzID0gcGVuZGluZ1xuICAgICAgcGVuZGluZyA9IG51bGxcbiAgICAgIHVwZGF0ZShub29wKVxuICAgIH1cblxuICAgIGlmIChjYnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSBjYnNbaV0oZXJyKVxuICAgIH1cbiAgICBjYihlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gbm9vcCAoXykge31cbiIsIm1vZHVsZS5leHBvcnRzID0gUGFnZXJcblxuZnVuY3Rpb24gUGFnZXIgKHBhZ2VTaXplKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYWdlcikpIHJldHVybiBuZXcgUGFnZXIocGFnZVNpemUpXG5cbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMudXBkYXRlcyA9IFtdXG4gIHRoaXMucGFnZXMgPSBuZXcgQXJyYXkoMTYpXG4gIHRoaXMucGFnZVNpemUgPSBwYWdlU2l6ZSB8fCAxMDI0XG59XG5cblBhZ2VyLnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKHBhZ2UpIHtcbiAgaWYgKHBhZ2UudXBkYXRlZCB8fCAhdGhpcy51cGRhdGVzKSByZXR1cm5cbiAgcGFnZS51cGRhdGVkID0gdHJ1ZVxuICB0aGlzLnVwZGF0ZXMucHVzaChwYWdlKVxufVxuXG5QYWdlci5wcm90b3R5cGUubGFzdFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnVwZGF0ZXMgfHwgIXRoaXMudXBkYXRlcy5sZW5ndGgpIHJldHVybiBudWxsXG4gIHZhciBwYWdlID0gdGhpcy51cGRhdGVzLnBvcCgpXG4gIHBhZ2UudXBkYXRlZCA9IGZhbHNlXG4gIHJldHVybiBwYWdlXG59XG5cblBhZ2VyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSwgbm9BbGxvY2F0ZSkge1xuICBpZiAoaSA+PSB0aGlzLnBhZ2VzLmxlbmd0aCkge1xuICAgIGlmIChub0FsbG9jYXRlKSByZXR1cm5cbiAgICB0aGlzLnBhZ2VzID0gZ3Jvdyh0aGlzLnBhZ2VzLCBpLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciBwYWdlID0gdGhpcy5wYWdlc1tpXVxuXG4gIGlmICghcGFnZSAmJiAhbm9BbGxvY2F0ZSkge1xuICAgIHBhZ2UgPSB0aGlzLnBhZ2VzW2ldID0gbmV3IFBhZ2UoaSwgYWxsb2ModGhpcy5wYWdlU2l6ZSkpXG4gICAgaWYgKGkgPj0gdGhpcy5sZW5ndGgpIHRoaXMubGVuZ3RoID0gaSArIDFcbiAgfVxuXG4gIHJldHVybiBwYWdlXG59XG5cblBhZ2VyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaSwgYnVmKSB7XG4gIGlmIChpID49IHRoaXMucGFnZXMubGVuZ3RoKSB0aGlzLnBhZ2VzID0gZ3Jvdyh0aGlzLnBhZ2VzLCBpLCB0aGlzLmxlbmd0aClcbiAgaWYgKGkgPj0gdGhpcy5sZW5ndGgpIHRoaXMubGVuZ3RoID0gaSArIDFcblxuICBpZiAoIWJ1Zikge1xuICAgIHRoaXMucGFnZXNbaV0gPSB1bmRlZmluZWRcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBwYWdlID0gdGhpcy5wYWdlc1tpXVxuICB2YXIgYiA9IHRydW5jYXRlKGJ1ZiwgdGhpcy5wYWdlU2l6ZSlcblxuICBpZiAocGFnZSkgcGFnZS5idWZmZXIgPSBiXG4gIGVsc2UgdGhpcy5wYWdlc1tpXSA9IG5ldyBQYWdlKGksIGIpXG59XG5cblBhZ2VyLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxpc3QgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIHZhciBlbXB0eSA9IGFsbG9jKHRoaXMucGFnZVNpemUpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdFtpXSA9IHRoaXMucGFnZXNbaV0gPyB0aGlzLnBhZ2VzW2ldLmJ1ZmZlciA6IGVtcHR5XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChsaXN0KVxufVxuXG5mdW5jdGlvbiBncm93IChsaXN0LCBpbmRleCwgbGVuKSB7XG4gIHZhciBubGVuID0gbGlzdC5sZW5ndGggKiAyXG4gIHdoaWxlIChubGVuIDw9IGluZGV4KSBubGVuICo9IDJcblxuICB2YXIgdHdpY2UgPSBuZXcgQXJyYXkobmxlbilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgdHdpY2VbaV0gPSBsaXN0W2ldXG4gIHJldHVybiB0d2ljZVxufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZSAoYnVmLCBsZW4pIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IGxlbikgcmV0dXJuIGJ1ZlxuICBpZiAoYnVmLmxlbmd0aCA+IGxlbikgcmV0dXJuIGJ1Zi5zbGljZSgwLCBsZW4pXG4gIHZhciBjcHkgPSBhbGxvYyhsZW4pXG4gIGJ1Zi5jb3B5KGNweSlcbiAgcmV0dXJuIGNweVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSkge1xuICBpZiAoQnVmZmVyLmFsbG9jKSByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpXG4gIGJ1Zi5maWxsKDApXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gUGFnZSAoaSwgYnVmKSB7XG4gIHRoaXMub2Zmc2V0ID0gaSAqIGJ1Zi5sZW5ndGhcbiAgdGhpcy5idWZmZXIgPSBidWZcbiAgdGhpcy51cGRhdGVkID0gZmFsc2Vcbn1cbiIsIi8vIGEgbW9yZSBsb3cgbGV2ZWwgaW50ZXJmYWNlIHRvIHRoZSBtZXJrbGUgdHJlZSBzdHJlYW0uXG4vLyB1c2VmdWwgZm9yIGNlcnRhaW4gYXBwbGljYXRpb25zIHRoZSByZXF1aXJlIG5vbi1zdHJlYW15IGFjY2VzcyB0byB0aGUgYWxnb3MuXG4vLyB2ZXJzaW9uZWQgYnkgdGhlIHNhbWUgc2VtdmVyIGFzIHRoZSBzdHJlYW0gaW50ZXJmYWNlLlxuXG52YXIgZmxhdCA9IHJlcXVpcmUoJ2ZsYXQtdHJlZScpXG5cbm1vZHVsZS5leHBvcnRzID0gTWVya2xlR2VuZXJhdG9yXG5cbmZ1bmN0aW9uIE1lcmtsZUdlbmVyYXRvciAob3B0cywgcm9vdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1lcmtsZUdlbmVyYXRvcikpIHJldHVybiBuZXcgTWVya2xlR2VuZXJhdG9yKG9wdHMsIHJvb3RzKVxuICBpZiAoIW9wdHMgfHwgIW9wdHMubGVhZiB8fCAhb3B0cy5wYXJlbnQpIHRocm93IG5ldyBFcnJvcignb3B0cy5sZWFmIGFuZCBvcHRzLnBhcmVudCByZXF1aXJlZCcpXG5cbiAgdGhpcy5yb290cyA9IHJvb3RzIHx8IG9wdHMucm9vdHMgfHwgW11cbiAgdGhpcy5ibG9ja3MgPSB0aGlzLnJvb3RzLmxlbmd0aCA/IDEgKyBmbGF0LnJpZ2h0U3Bhbih0aGlzLnJvb3RzW3RoaXMucm9vdHMubGVuZ3RoIC0gMV0uaW5kZXgpIC8gMiA6IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgciA9IHRoaXMucm9vdHNbaV1cbiAgICBpZiAociAmJiAhci5wYXJlbnQpIHIucGFyZW50ID0gZmxhdC5wYXJlbnQoci5pbmRleClcbiAgfVxuXG4gIHRoaXMuX2xlYWYgPSBvcHRzLmxlYWZcbiAgdGhpcy5fcGFyZW50ID0gb3B0cy5wYXJlbnRcbn1cblxuTWVya2xlR2VuZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGRhdGEsIG5vZGVzKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhKVxuICBpZiAoIW5vZGVzKSBub2RlcyA9IFtdXG5cbiAgdmFyIGluZGV4ID0gMiAqIHRoaXMuYmxvY2tzKytcblxuICB2YXIgbGVhZiA9IHtcbiAgICBpbmRleDogaW5kZXgsXG4gICAgcGFyZW50OiBmbGF0LnBhcmVudChpbmRleCksXG4gICAgaGFzaDogbnVsbCxcbiAgICBzaXplOiBkYXRhLmxlbmd0aCxcbiAgICBkYXRhOiBkYXRhXG4gIH1cblxuICBsZWFmLmhhc2ggPSB0aGlzLl9sZWFmKGxlYWYsIHRoaXMucm9vdHMpXG4gIHRoaXMucm9vdHMucHVzaChsZWFmKVxuICBub2Rlcy5wdXNoKGxlYWYpXG5cbiAgd2hpbGUgKHRoaXMucm9vdHMubGVuZ3RoID4gMSkge1xuICAgIHZhciBsZWZ0ID0gdGhpcy5yb290c1t0aGlzLnJvb3RzLmxlbmd0aCAtIDJdXG4gICAgdmFyIHJpZ2h0ID0gdGhpcy5yb290c1t0aGlzLnJvb3RzLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAobGVmdC5wYXJlbnQgIT09IHJpZ2h0LnBhcmVudCkgYnJlYWtcblxuICAgIHRoaXMucm9vdHMucG9wKClcbiAgICB0aGlzLnJvb3RzW3RoaXMucm9vdHMubGVuZ3RoIC0gMV0gPSBsZWFmID0ge1xuICAgICAgaW5kZXg6IGxlZnQucGFyZW50LFxuICAgICAgcGFyZW50OiBmbGF0LnBhcmVudChsZWZ0LnBhcmVudCksXG4gICAgICBoYXNoOiB0aGlzLl9wYXJlbnQobGVmdCwgcmlnaHQpLFxuICAgICAgc2l6ZTogbGVmdC5zaXplICsgcmlnaHQuc2l6ZSxcbiAgICAgIGRhdGE6IG51bGxcbiAgICB9XG4gICAgbm9kZXMucHVzaChsZWFmKVxuICB9XG5cbiAgcmV0dXJuIG5vZGVzXG59XG4iLCJhc3NlcnQubm90RXF1YWwgPSBub3RFcXVhbFxuYXNzZXJ0Lm5vdE9rID0gbm90T2tcbmFzc2VydC5lcXVhbCA9IGVxdWFsXG5hc3NlcnQub2sgPSBhc3NlcnRcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NlcnRcblxuZnVuY3Rpb24gZXF1YWwgKGEsIGIsIG0pIHtcbiAgYXNzZXJ0KGEgPT0gYiwgbSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbn1cblxuZnVuY3Rpb24gbm90RXF1YWwgKGEsIGIsIG0pIHtcbiAgYXNzZXJ0KGEgIT0gYiwgbSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbn1cblxuZnVuY3Rpb24gbm90T2sgKHQsIG0pIHtcbiAgYXNzZXJ0KCF0LCBtKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHQsIG0pIHtcbiAgaWYgKCF0KSB0aHJvdyBuZXcgRXJyb3IobSB8fCAnQXNzZXJ0aW9uRXJyb3InKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG52YXIgc3ZhcmludCA9IHJlcXVpcmUoJ3NpZ25lZC12YXJpbnQnKVxuXG5leHBvcnRzLm1ha2UgPSBlbmNvZGVyXG5cbmV4cG9ydHMubmFtZSA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0c1trZXlzW2ldXSA9PT0gZW5jKSByZXR1cm4ga2V5c1tpXVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydHMuc2tpcCA9IGZ1bmN0aW9uICh0eXBlLCBidWZmZXIsIG9mZnNldCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIDA6XG4gICAgICB2YXJpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KVxuICAgICAgcmV0dXJuIG9mZnNldCArIHZhcmludC5kZWNvZGUuYnl0ZXNcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBvZmZzZXQgKyA4XG5cbiAgICBjYXNlIDI6XG4gICAgICB2YXIgbGVuID0gdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICAgIHJldHVybiBvZmZzZXQgKyB2YXJpbnQuZGVjb2RlLmJ5dGVzICsgbGVuXG5cbiAgICBjYXNlIDM6XG4gICAgY2FzZSA0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHcm91cHMgYXJlIG5vdCBzdXBwb3J0ZWQnKVxuXG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIG9mZnNldCArIDRcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biB3aXJlIHR5cGU6ICcgKyB0eXBlKVxufVxuXG5leHBvcnRzLmJ5dGVzID0gZW5jb2RlcigyLFxuICBmdW5jdGlvbiBlbmNvZGUgKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG4gICAgdmFyIGxlbiA9IGJ1ZmZlckxlbmd0aCh2YWwpXG5cbiAgICB2YXJpbnQuZW5jb2RlKGxlbiwgYnVmZmVyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IHZhcmludC5lbmNvZGUuYnl0ZXNcblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpXG4gICAgZWxzZSBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIGxlbilcbiAgICBvZmZzZXQgKz0gbGVuXG5cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmZmVyXG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgICB2YXIgbGVuID0gdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gICAgdmFyIHZhbCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbilcbiAgICBvZmZzZXQgKz0gdmFsLmxlbmd0aFxuXG4gICAgZGVjb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0XG4gICAgcmV0dXJuIHZhbFxuICB9LFxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAodmFsKSB7XG4gICAgdmFyIGxlbiA9IGJ1ZmZlckxlbmd0aCh2YWwpXG4gICAgcmV0dXJuIHZhcmludC5lbmNvZGluZ0xlbmd0aChsZW4pICsgbGVuXG4gIH1cbilcblxuZXhwb3J0cy5zdHJpbmcgPSBlbmNvZGVyKDIsXG4gIGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcbiAgICB2YXIgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsKVxuXG4gICAgdmFyaW50LmVuY29kZShsZW4sIGJ1ZmZlciwgb2Zmc2V0LCAndXRmLTgnKVxuICAgIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG5cbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIGxlbilcbiAgICBvZmZzZXQgKz0gbGVuXG5cbiAgICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gYnVmZmVyXG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgICB2YXIgbGVuID0gdmFyaW50LmRlY29kZShidWZmZXIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gICAgdmFyIHZhbCA9IGJ1ZmZlci50b1N0cmluZygndXRmLTgnLCBvZmZzZXQsIG9mZnNldCArIGxlbilcbiAgICBvZmZzZXQgKz0gbGVuXG5cbiAgICBkZWNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXRcbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoICh2YWwpIHtcbiAgICB2YXIgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsKVxuICAgIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgobGVuKSArIGxlblxuICB9XG4pXG5cbmV4cG9ydHMuYm9vbCA9IGVuY29kZXIoMCxcbiAgZnVuY3Rpb24gZW5jb2RlICh2YWwsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgYnVmZmVyW29mZnNldF0gPSB2YWwgPyAxIDogMFxuICAgIGVuY29kZS5ieXRlcyA9IDFcbiAgICByZXR1cm4gYnVmZmVyXG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgYm9vbCA9IGJ1ZmZlcltvZmZzZXRdID4gMFxuICAgIGRlY29kZS5ieXRlcyA9IDFcbiAgICByZXR1cm4gYm9vbFxuICB9LFxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuKVxuXG5leHBvcnRzLmludDMyID0gZW5jb2RlcigwLFxuICBmdW5jdGlvbiBlbmNvZGUgKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXJpbnQuZW5jb2RlKHZhbCA8IDAgPyB2YWwgKyA0Mjk0OTY3Mjk2IDogdmFsLCBidWZmZXIsIG9mZnNldClcbiAgICBlbmNvZGUuYnl0ZXMgPSB2YXJpbnQuZW5jb2RlLmJ5dGVzXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbCA9IHZhcmludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpXG4gICAgZGVjb2RlLmJ5dGVzID0gdmFyaW50LmRlY29kZS5ieXRlc1xuICAgIHJldHVybiB2YWwgPiAyMTQ3NDgzNjQ3ID8gdmFsIC0gNDI5NDk2NzI5NiA6IHZhbFxuICB9LFxuICBmdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAodmFsKSB7XG4gICAgcmV0dXJuIHZhcmludC5lbmNvZGluZ0xlbmd0aCh2YWwgPCAwID8gdmFsICsgNDI5NDk2NzI5NiA6IHZhbClcbiAgfVxuKVxuXG5leHBvcnRzLmludDY0ID0gZW5jb2RlcigwLFxuICBmdW5jdGlvbiBlbmNvZGUgKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBpZiAodmFsIDwgMCkge1xuICAgICAgdmFyIGxhc3QgPSBvZmZzZXQgKyA5XG4gICAgICB2YXJpbnQuZW5jb2RlKHZhbCAqIC0xLCBidWZmZXIsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSB2YXJpbnQuZW5jb2RlLmJ5dGVzIC0gMVxuICAgICAgYnVmZmVyW29mZnNldF0gPSBidWZmZXJbb2Zmc2V0XSB8IDB4ODBcbiAgICAgIHdoaWxlIChvZmZzZXQgPCBsYXN0IC0gMSkge1xuICAgICAgICBvZmZzZXQrK1xuICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IDB4ZmZcbiAgICAgIH1cbiAgICAgIGJ1ZmZlcltsYXN0XSA9IDB4MDFcbiAgICAgIGVuY29kZS5ieXRlcyA9IDEwXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcmludC5lbmNvZGUodmFsLCBidWZmZXIsIG9mZnNldClcbiAgICAgIGVuY29kZS5ieXRlcyA9IHZhcmludC5lbmNvZGUuYnl0ZXNcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbCA9IHZhcmludC5kZWNvZGUoYnVmZmVyLCBvZmZzZXQpXG4gICAgaWYgKHZhbCA+PSBNYXRoLnBvdygyLCA2MykpIHtcbiAgICAgIHZhciBsaW1pdCA9IDlcbiAgICAgIHdoaWxlIChidWZmZXJbb2Zmc2V0ICsgbGltaXQgLSAxXSA9PT0gMHhmZikgbGltaXQtLVxuICAgICAgbGltaXQgPSBsaW1pdCB8fCA5XG4gICAgICB2YXIgc3Vic2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxpbWl0KVxuICAgICAgYnVmZmVyLmNvcHkoc3Vic2V0LCAwLCBvZmZzZXQsIG9mZnNldCArIGxpbWl0KVxuICAgICAgc3Vic2V0W2xpbWl0IC0gMV0gPSBzdWJzZXRbbGltaXQgLSAxXSAmIDB4N2ZcbiAgICAgIHZhbCA9IC0xICogdmFyaW50LmRlY29kZShzdWJzZXQsIDApXG4gICAgICBkZWNvZGUuYnl0ZXMgPSAxMFxuICAgIH0gZWxzZSB7XG4gICAgICBkZWNvZGUuYnl0ZXMgPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gICAgfVxuICAgIHJldHVybiB2YWxcbiAgfSxcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKHZhbCkge1xuICAgIHJldHVybiB2YWwgPCAwID8gMTAgOiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgodmFsKVxuICB9XG4pXG5cbmV4cG9ydHMuc2ludDMyID1cbmV4cG9ydHMuc2ludDY0ID0gZW5jb2RlcigwLFxuICBzdmFyaW50LmVuY29kZSxcbiAgc3ZhcmludC5kZWNvZGUsXG4gIHN2YXJpbnQuZW5jb2RpbmdMZW5ndGhcbilcblxuZXhwb3J0cy51aW50MzIgPVxuZXhwb3J0cy51aW50NjQgPVxuZXhwb3J0cy5lbnVtID1cbmV4cG9ydHMudmFyaW50ID0gZW5jb2RlcigwLFxuICB2YXJpbnQuZW5jb2RlLFxuICB2YXJpbnQuZGVjb2RlLFxuICB2YXJpbnQuZW5jb2RpbmdMZW5ndGhcbilcblxuLy8gd2UgY2Fubm90IHJlcHJlc2VudCB0aGVzZSBpbiBqYXZhc2NyaXB0IHNvIHdlIGp1c3QgdXNlIGJ1ZmZlcnNcbmV4cG9ydHMuZml4ZWQ2NCA9XG5leHBvcnRzLnNmaXhlZDY0ID0gZW5jb2RlcigxLFxuICBmdW5jdGlvbiBlbmNvZGUgKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YWwuY29weShidWZmZXIsIG9mZnNldClcbiAgICBlbmNvZGUuYnl0ZXMgPSA4XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIDgpXG4gICAgZGVjb2RlLmJ5dGVzID0gOFxuICAgIHJldHVybiB2YWxcbiAgfSxcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKCkge1xuICAgIHJldHVybiA4XG4gIH1cbilcblxuZXhwb3J0cy5kb3VibGUgPSBlbmNvZGVyKDEsXG4gIGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKHZhbCwgb2Zmc2V0KVxuICAgIGVuY29kZS5ieXRlcyA9IDhcbiAgICByZXR1cm4gYnVmZmVyXG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZSAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gYnVmZmVyLnJlYWREb3VibGVMRShvZmZzZXQpXG4gICAgZGVjb2RlLmJ5dGVzID0gOFxuICAgIHJldHVybiB2YWxcbiAgfSxcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKCkge1xuICAgIHJldHVybiA4XG4gIH1cbilcblxuZXhwb3J0cy5maXhlZDMyID0gZW5jb2Rlcig1LFxuICBmdW5jdGlvbiBlbmNvZGUgKHZhbCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRSh2YWwsIG9mZnNldClcbiAgICBlbmNvZGUuYnl0ZXMgPSA0XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbCA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KVxuICAgIGRlY29kZS5ieXRlcyA9IDRcbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gNFxuICB9XG4pXG5cbmV4cG9ydHMuc2ZpeGVkMzIgPSBlbmNvZGVyKDUsXG4gIGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIGJ1ZmZlci53cml0ZUludDMyTEUodmFsLCBvZmZzZXQpXG4gICAgZW5jb2RlLmJ5dGVzID0gNFxuICAgIHJldHVybiBidWZmZXJcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciB2YWwgPSBidWZmZXIucmVhZEludDMyTEUob2Zmc2V0KVxuICAgIGRlY29kZS5ieXRlcyA9IDRcbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gNFxuICB9XG4pXG5cbmV4cG9ydHMuZmxvYXQgPSBlbmNvZGVyKDUsXG4gIGZ1bmN0aW9uIGVuY29kZSAodmFsLCBidWZmZXIsIG9mZnNldCkge1xuICAgIGJ1ZmZlci53cml0ZUZsb2F0TEUodmFsLCBvZmZzZXQpXG4gICAgZW5jb2RlLmJ5dGVzID0gNFxuICAgIHJldHVybiBidWZmZXJcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICAgIHZhciB2YWwgPSBidWZmZXIucmVhZEZsb2F0TEUob2Zmc2V0KVxuICAgIGRlY29kZS5ieXRlcyA9IDRcbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gNFxuICB9XG4pXG5cbmZ1bmN0aW9uIGVuY29kZXIgKHR5cGUsIGVuY29kZSwgZGVjb2RlLCBlbmNvZGluZ0xlbmd0aCkge1xuICBlbmNvZGUuYnl0ZXMgPSBkZWNvZGUuYnl0ZXMgPSAwXG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGVuY29kaW5nTGVuZ3RoOiBlbmNvZGluZ0xlbmd0aFxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlckxlbmd0aCAodmFsKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsKSA/IHZhbC5sZW5ndGggOiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdyYW5kb20tYWNjZXNzLWZpbGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlcicpXG59XG4iLCJ2YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxudmFyIE5PVF9SRUFEQUJMRSA9IGRlZmF1bHRJbXBsKG5ldyBFcnJvcignTm90IHJlYWRhYmxlJykpXG52YXIgTk9UX1dSSVRBQkxFID0gZGVmYXVsdEltcGwobmV3IEVycm9yKCdOb3Qgd3JpdGFibGUnKSlcbnZhciBOT1RfREVMRVRBQkxFID0gZGVmYXVsdEltcGwobmV3IEVycm9yKCdOb3QgZGVsZXRhYmxlJykpXG52YXIgTk9UX1NUQVRBQkxFID0gZGVmYXVsdEltcGwobmV3IEVycm9yKCdOb3Qgc3RhdGFibGUnKSlcbnZhciBOT19PUEVOX1JFQURBQkxFID0gZGVmYXVsdEltcGwobmV3IEVycm9yKCdObyByZWFkb25seSBvcGVuJykpXG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tQWNjZXNzXG5cbmZ1bmN0aW9uIFJhbmRvbUFjY2VzcyAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZG9tQWNjZXNzKSkgcmV0dXJuIG5ldyBSYW5kb21BY2Nlc3Mob3B0cylcbiAgZXZlbnRzLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fcXVldWVkID0gW11cbiAgdGhpcy5fcGVuZGluZyA9IDBcbiAgdGhpcy5fbmVlZHNPcGVuID0gdHJ1ZVxuXG4gIHRoaXMub3BlbmVkID0gZmFsc2VcbiAgdGhpcy5jbG9zZWQgPSBmYWxzZVxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgaWYgKG9wdHMpIHtcbiAgICBpZiAob3B0cy5vcGVuUmVhZG9ubHkpIHRoaXMuX29wZW5SZWFkb25seSA9IG9wdHMub3BlblJlYWRvbmx5XG4gICAgaWYgKG9wdHMub3BlbikgdGhpcy5fb3BlbiA9IG9wdHMub3BlblxuICAgIGlmIChvcHRzLnJlYWQpIHRoaXMuX3JlYWQgPSBvcHRzLnJlYWRcbiAgICBpZiAob3B0cy53cml0ZSkgdGhpcy5fd3JpdGUgPSBvcHRzLndyaXRlXG4gICAgaWYgKG9wdHMuZGVsKSB0aGlzLl9kZWwgPSBvcHRzLmRlbFxuICAgIGlmIChvcHRzLnN0YXQpIHRoaXMuX3N0YXQgPSBvcHRzLnN0YXRcbiAgICBpZiAob3B0cy5jbG9zZSkgdGhpcy5fY2xvc2UgPSBvcHRzLmNsb3NlXG4gICAgaWYgKG9wdHMuZGVzdHJveSkgdGhpcy5fZGVzdHJveSA9IG9wdHMuZGVzdHJveVxuICB9XG5cbiAgdGhpcy5wcmVmZXJSZWFkb25seSA9IHRoaXMuX29wZW5SZWFkb25seSAhPT0gTk9fT1BFTl9SRUFEQUJMRVxuICB0aGlzLnJlYWRhYmxlID0gdGhpcy5fcmVhZCAhPT0gTk9UX1JFQURBQkxFXG4gIHRoaXMud3JpdGFibGUgPSB0aGlzLl93cml0ZSAhPT0gTk9UX1dSSVRBQkxFXG4gIHRoaXMuZGVsZXRhYmxlID0gdGhpcy5fZGVsICE9PSBOT1RfREVMRVRBQkxFXG4gIHRoaXMuc3RhdGFibGUgPSB0aGlzLl9zdGF0ICE9PSBOT1RfU1RBVEFCTEVcbn1cblxuaW5oZXJpdHMoUmFuZG9tQWNjZXNzLCBldmVudHMuRXZlbnRFbWl0dGVyKVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBub29wXG4gIGlmICh0aGlzLm9wZW5lZCAmJiAhdGhpcy5fbmVlZHNPcGVuKSByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYiwgbnVsbClcbiAgcXVldWVBbmRSdW4odGhpcywgbmV3IFJlcXVlc3QodGhpcywgMCwgMCwgMCwgbnVsbCwgY2IpKVxufVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLl9vcGVuID0gZGVmYXVsdEltcGwobnVsbClcblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuX29wZW5SZWFkb25seSA9IE5PX09QRU5fUkVBREFCTEVcblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG9mZnNldCwgc2l6ZSwgY2IpIHtcbiAgdGhpcy5ydW4obmV3IFJlcXVlc3QodGhpcywgMSwgb2Zmc2V0LCBzaXplLCBudWxsLCBjYikpXG59XG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuX3JlYWQgPSBOT1RfUkVBREFCTEVcblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChvZmZzZXQsIGRhdGEsIGNiKSB7XG4gIGlmICghY2IpIGNiID0gbm9vcFxuICBvcGVuV3JpdGFibGUodGhpcylcbiAgdGhpcy5ydW4obmV3IFJlcXVlc3QodGhpcywgMiwgb2Zmc2V0LCBkYXRhLmxlbmd0aCwgZGF0YSwgY2IpKVxufVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLl93cml0ZSA9IE5PVF9XUklUQUJMRVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChvZmZzZXQsIHNpemUsIGNiKSB7XG4gIGlmICghY2IpIGNiID0gbm9vcFxuICBvcGVuV3JpdGFibGUodGhpcylcbiAgdGhpcy5ydW4obmV3IFJlcXVlc3QodGhpcywgMywgb2Zmc2V0LCBzaXplLCBudWxsLCBjYikpXG59XG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuX2RlbCA9IE5PVF9ERUxFVEFCTEVcblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24gKGNiKSB7XG4gIHRoaXMucnVuKG5ldyBSZXF1ZXN0KHRoaXMsIDQsIDAsIDAsIG51bGwsIGNiKSlcbn1cblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5fc3RhdCA9IE5PVF9TVEFUQUJMRVxuXG5SYW5kb21BY2Nlc3MucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICghY2IpIGNiID0gbm9vcFxuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsKVxuICBxdWV1ZUFuZFJ1bih0aGlzLCBuZXcgUmVxdWVzdCh0aGlzLCA1LCAwLCAwLCBudWxsLCBjYikpXG59XG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUuX2Nsb3NlID0gZGVmYXVsdEltcGwobnVsbClcblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICghY2IpIGNiID0gbm9vcFxuICBpZiAoIXRoaXMuY2xvc2VkKSB0aGlzLmNsb3NlKG5vb3ApXG4gIHF1ZXVlQW5kUnVuKHRoaXMsIG5ldyBSZXF1ZXN0KHRoaXMsIDYsIDAsIDAsIG51bGwsIGNiKSlcbn1cblxuUmFuZG9tQWNjZXNzLnByb3RvdHlwZS5fZGVzdHJveSA9IGRlZmF1bHRJbXBsKG51bGwpXG5cblJhbmRvbUFjY2Vzcy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHJlcSkge1xuICBpZiAodGhpcy5fbmVlZHNPcGVuKSB0aGlzLm9wZW4obm9vcClcbiAgaWYgKHRoaXMuX3F1ZXVlZC5sZW5ndGgpIHRoaXMuX3F1ZXVlZC5wdXNoKHJlcSlcbiAgZWxzZSByZXEuX3J1bigpXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gUmVxdWVzdCAoc2VsZiwgdHlwZSwgb2Zmc2V0LCBzaXplLCBkYXRhLCBjYikge1xuICB0aGlzLnR5cGUgPSB0eXBlXG4gIHRoaXMub2Zmc2V0ID0gb2Zmc2V0XG4gIHRoaXMuZGF0YSA9IGRhdGFcbiAgdGhpcy5zaXplID0gc2l6ZVxuICB0aGlzLnN0b3JhZ2UgPSBzZWxmXG5cbiAgdGhpcy5fc3luYyA9IGZhbHNlXG4gIHRoaXMuX2NhbGxiYWNrID0gY2Jcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuX3VucXVldWUgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciByYSA9IHRoaXMuc3RvcmFnZVxuICB2YXIgcXVldWVkID0gcmEuX3F1ZXVlZFxuXG4gIGlmICghZXJyKSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgaWYgKCFyYS5vcGVuZWQpIHtcbiAgICAgICAgICByYS5vcGVuZWQgPSB0cnVlXG4gICAgICAgICAgcmEuZW1pdCgnb3BlbicpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSA1OlxuICAgICAgICBpZiAoIXJhLmNsb3NlZCkge1xuICAgICAgICAgIHJhLmNsb3NlZCA9IHRydWVcbiAgICAgICAgICByYS5lbWl0KCdjbG9zZScpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSA2OlxuICAgICAgICBpZiAoIXJhLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJhLmRlc3Ryb3llZCA9IHRydWVcbiAgICAgICAgICByYS5lbWl0KCdkZXN0cm95JylcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChxdWV1ZWQubGVuZ3RoICYmIHF1ZXVlZFswXSA9PT0gdGhpcykgcXVldWVkLnNoaWZ0KClcbiAgaWYgKCEtLXJhLl9wZW5kaW5nICYmIHF1ZXVlZC5sZW5ndGgpIHF1ZXVlZFswXS5fcnVuKClcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyLCB2YWwpIHtcbiAgaWYgKHRoaXMuX3N5bmMpIHJldHVybiBuZXh0VGljayh0aGlzLCBlcnIsIHZhbClcbiAgdGhpcy5fdW5xdWV1ZShlcnIpXG4gIHRoaXMuX2NhbGxiYWNrKGVyciwgdmFsKVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5fb3BlbkFuZE5vdENsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhID0gdGhpcy5zdG9yYWdlXG4gIGlmIChyYS5vcGVuZWQgJiYgIXJhLmNsb3NlZCkgcmV0dXJuIHRydWVcbiAgaWYgKCFyYS5vcGVuZWQpIG5leHRUaWNrKHRoaXMsIG5ldyBFcnJvcignTm90IG9wZW5lZCcpKVxuICBlbHNlIGlmIChyYS5jbG9zZWQpIG5leHRUaWNrKHRoaXMsIG5ldyBFcnJvcignQ2xvc2VkJykpXG4gIHJldHVybiBmYWxzZVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhID0gdGhpcy5zdG9yYWdlXG5cbiAgaWYgKHJhLm9wZW5lZCAmJiAhcmEuX25lZWRzT3BlbikgcmV0dXJuIG5leHRUaWNrKHRoaXMsIG51bGwpXG4gIGlmIChyYS5jbG9zZWQpIHJldHVybiBuZXh0VGljayh0aGlzLCBuZXcgRXJyb3IoJ0Nsb3NlZCcpKVxuXG4gIHJhLl9uZWVkc09wZW4gPSBmYWxzZVxuICBpZiAocmEucHJlZmVyUmVhZG9ubHkpIHJhLl9vcGVuUmVhZG9ubHkodGhpcylcbiAgZWxzZSByYS5fb3Blbih0aGlzKVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5fcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmEgPSB0aGlzLnN0b3JhZ2VcbiAgcmEuX3BlbmRpbmcrK1xuXG4gIHRoaXMuX3N5bmMgPSB0cnVlXG5cbiAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICBjYXNlIDA6XG4gICAgICB0aGlzLl9vcGVuKClcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIDE6XG4gICAgICBpZiAodGhpcy5fb3BlbkFuZE5vdENsb3NlZCgpKSByYS5fcmVhZCh0aGlzKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgMjpcbiAgICAgIGlmICh0aGlzLl9vcGVuQW5kTm90Q2xvc2VkKCkpIHJhLl93cml0ZSh0aGlzKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgMzpcbiAgICAgIGlmICh0aGlzLl9vcGVuQW5kTm90Q2xvc2VkKCkpIHJhLl9kZWwodGhpcylcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIDQ6XG4gICAgICBpZiAodGhpcy5fb3BlbkFuZE5vdENsb3NlZCgpKSByYS5fc3RhdCh0aGlzKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgNTpcbiAgICAgIGlmIChyYS5jbG9zZWQgfHwgIXJhLm9wZW5lZCkgbmV4dFRpY2sodGhpcywgbnVsbClcbiAgICAgIGVsc2UgcmEuX2Nsb3NlKHRoaXMpXG4gICAgICBicmVha1xuXG4gICAgY2FzZSA2OlxuICAgICAgaWYgKHJhLmRlc3Ryb3llZCkgbmV4dFRpY2sodGhpcywgbnVsbClcbiAgICAgIGVsc2UgcmEuX2Rlc3Ryb3kodGhpcylcbiAgICAgIGJyZWFrXG4gIH1cblxuICB0aGlzLl9zeW5jID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcXVldWVBbmRSdW4gKHNlbGYsIHJlcSkge1xuICBzZWxmLl9xdWV1ZWQucHVzaChyZXEpXG4gIGlmICghc2VsZi5fcGVuZGluZykgcmVxLl9ydW4oKVxufVxuXG5mdW5jdGlvbiBvcGVuV3JpdGFibGUgKHNlbGYpIHtcbiAgaWYgKHNlbGYucHJlZmVyUmVhZG9ubHkpIHtcbiAgICBzZWxmLl9uZWVkc09wZW4gPSB0cnVlXG4gICAgc2VsZi5wcmVmZXJSZWFkb25seSA9IGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdEltcGwgKGVycikge1xuICByZXR1cm4gb3ZlcnJpZGFibGVcblxuICBmdW5jdGlvbiBvdmVycmlkYWJsZSAocmVxKSB7XG4gICAgbmV4dFRpY2socmVxLCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKHJlcSwgZXJyLCB2YWwpIHtcbiAgcHJvY2Vzcy5uZXh0VGljayhuZXh0VGlja0NhbGxiYWNrLCByZXEsIGVyciwgdmFsKVxufVxuXG5mdW5jdGlvbiBuZXh0VGlja0NhbGxiYWNrIChyZXEsIGVyciwgdmFsKSB7XG4gIHJlcS5jYWxsYmFjayhlcnIsIHZhbClcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwidmFyIHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSAodiwgYiwgbykge1xuICB2ID0gdiA+PSAwID8gdioyIDogdiotMiAtIDFcbiAgdmFyIHIgPSB2YXJpbnQuZW5jb2RlKHYsIGIsIG8pXG4gIGVuY29kZS5ieXRlcyA9IHZhcmludC5lbmNvZGUuYnl0ZXNcbiAgcmV0dXJuIHJcbn1cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlIChiLCBvKSB7XG4gIHZhciB2ID0gdmFyaW50LmRlY29kZShiLCBvKVxuICBkZWNvZGUuYnl0ZXMgPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gIHJldHVybiB2ICYgMSA/ICh2KzEpIC8gLTIgOiB2IC8gMlxufVxuXG5leHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIHZhcmludC5lbmNvZGluZ0xlbmd0aCh2ID49IDAgPyB2KjIgOiB2Ki0yIC0gMSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsbGJhY2tcblxuZnVuY3Rpb24gX2FkZCAoYSwgYikge1xuICB2YXIgcmwgPSBhLmwgKyBiLmxcbiAgdmFyIGEyID0ge1xuICAgIGg6IGEuaCArIGIuaCArIChybCAvIDIgPj4+IDMxKSA+Pj4gMCxcbiAgICBsOiBybCA+Pj4gMFxuICB9XG4gIGEuaCA9IGEyLmhcbiAgYS5sID0gYTIubFxufVxuXG5mdW5jdGlvbiBfeG9yIChhLCBiKSB7XG4gIGEuaCBePSBiLmhcbiAgYS5oID4+Pj0gMFxuICBhLmwgXj0gYi5sXG4gIGEubCA+Pj49IDBcbn1cblxuZnVuY3Rpb24gX3JvdGwgKGEsIG4pIHtcbiAgdmFyIGEyID0ge1xuICAgIGg6IGEuaCA8PCBuIHwgYS5sID4+PiAoMzIgLSBuKSxcbiAgICBsOiBhLmwgPDwgbiB8IGEuaCA+Pj4gKDMyIC0gbilcbiAgfVxuICBhLmggPSBhMi5oXG4gIGEubCA9IGEyLmxcbn1cblxuZnVuY3Rpb24gX3JvdGwzMiAoYSkge1xuICB2YXIgYWwgPSBhLmxcbiAgYS5sID0gYS5oXG4gIGEuaCA9IGFsXG59XG5cbmZ1bmN0aW9uIF9jb21wcmVzcyAodjAsIHYxLCB2MiwgdjMpIHtcbiAgX2FkZCh2MCwgdjEpXG4gIF9hZGQodjIsIHYzKVxuICBfcm90bCh2MSwgMTMpXG4gIF9yb3RsKHYzLCAxNilcbiAgX3hvcih2MSwgdjApXG4gIF94b3IodjMsIHYyKVxuICBfcm90bDMyKHYwKVxuICBfYWRkKHYyLCB2MSlcbiAgX2FkZCh2MCwgdjMpXG4gIF9yb3RsKHYxLCAxNylcbiAgX3JvdGwodjMsIDIxKVxuICBfeG9yKHYxLCB2MilcbiAgX3hvcih2MywgdjApXG4gIF9yb3RsMzIodjIpXG59XG5cbmZ1bmN0aW9uIF9nZXRfaW50IChhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIChhW29mZnNldCArIDNdIDw8IDI0KSB8IChhW29mZnNldCArIDJdIDw8IDE2KSB8IChhW29mZnNldCArIDFdIDw8IDgpIHwgYVtvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIGZhbGxiYWNrIChvdXQsIG0sIGtleSkgeyAvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qZWRpc2N0MS9zaXBoYXNoLWpzIHRvIHVzZSB1aW50OGFycmF5c1xuICB2YXIgazAgPSB7aDogX2dldF9pbnQoa2V5LCA0KSwgbDogX2dldF9pbnQoa2V5LCAwKX1cbiAgdmFyIGsxID0ge2g6IF9nZXRfaW50KGtleSwgMTIpLCBsOiBfZ2V0X2ludChrZXksIDgpfVxuICB2YXIgdjAgPSB7aDogazAuaCwgbDogazAubH1cbiAgdmFyIHYyID0gazBcbiAgdmFyIHYxID0ge2g6IGsxLmgsIGw6IGsxLmx9XG4gIHZhciB2MyA9IGsxXG4gIHZhciBtaVxuICB2YXIgbXAgPSAwXG4gIHZhciBtbCA9IG0ubGVuZ3RoXG4gIHZhciBtbDcgPSBtbCAtIDdcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcig4KSlcblxuICBfeG9yKHYwLCB7aDogMHg3MzZmNmQ2NSwgbDogMHg3MDczNjU3NX0pXG4gIF94b3IodjEsIHtoOiAweDY0NmY3MjYxLCBsOiAweDZlNjQ2ZjZkfSlcbiAgX3hvcih2Miwge2g6IDB4NmM3OTY3NjUsIGw6IDB4NmU2NTcyNjF9KVxuICBfeG9yKHYzLCB7aDogMHg3NDY1NjQ2MiwgbDogMHg3OTc0NjU3M30pXG5cbiAgd2hpbGUgKG1wIDwgbWw3KSB7XG4gICAgbWkgPSB7aDogX2dldF9pbnQobSwgbXAgKyA0KSwgbDogX2dldF9pbnQobSwgbXApfVxuICAgIF94b3IodjMsIG1pKVxuICAgIF9jb21wcmVzcyh2MCwgdjEsIHYyLCB2MylcbiAgICBfY29tcHJlc3ModjAsIHYxLCB2MiwgdjMpXG4gICAgX3hvcih2MCwgbWkpXG4gICAgbXAgKz0gOFxuICB9XG5cbiAgYnVmWzddID0gbWxcbiAgdmFyIGljID0gMFxuICB3aGlsZSAobXAgPCBtbCkge1xuICAgIGJ1ZltpYysrXSA9IG1bbXArK11cbiAgfVxuICB3aGlsZSAoaWMgPCA3KSB7XG4gICAgYnVmW2ljKytdID0gMFxuICB9XG5cbiAgbWkgPSB7XG4gICAgaDogYnVmWzddIDw8IDI0IHwgYnVmWzZdIDw8IDE2IHwgYnVmWzVdIDw8IDggfCBidWZbNF0sXG4gICAgbDogYnVmWzNdIDw8IDI0IHwgYnVmWzJdIDw8IDE2IHwgYnVmWzFdIDw8IDggfCBidWZbMF1cbiAgfVxuXG4gIF94b3IodjMsIG1pKVxuICBfY29tcHJlc3ModjAsIHYxLCB2MiwgdjMpXG4gIF9jb21wcmVzcyh2MCwgdjEsIHYyLCB2MylcbiAgX3hvcih2MCwgbWkpXG4gIF94b3IodjIsIHsgaDogMCwgbDogMHhmZiB9KVxuICBfY29tcHJlc3ModjAsIHYxLCB2MiwgdjMpXG4gIF9jb21wcmVzcyh2MCwgdjEsIHYyLCB2MylcbiAgX2NvbXByZXNzKHYwLCB2MSwgdjIsIHYzKVxuICBfY29tcHJlc3ModjAsIHYxLCB2MiwgdjMpXG5cbiAgdmFyIGggPSB2MFxuICBfeG9yKGgsIHYxKVxuICBfeG9yKGgsIHYyKVxuICBfeG9yKGgsIHYzKVxuXG4gIG91dFswXSA9IGgubCAmIDB4ZmZcbiAgb3V0WzFdID0gKGgubCA+PiA4KSAmIDB4ZmZcbiAgb3V0WzJdID0gKGgubCA+PiAxNikgJiAweGZmXG4gIG91dFszXSA9IChoLmwgPj4gMjQpICYgMHhmZlxuICBvdXRbNF0gPSBoLmggJiAweGZmXG4gIG91dFs1XSA9IChoLmggPj4gOCkgJiAweGZmXG4gIG91dFs2XSA9IChoLmggPj4gMTYpICYgMHhmZlxuICBvdXRbN10gPSAoaC5oID4+IDI0KSAmIDB4ZmZcbn1cbiIsInZhciB3YXNtID0gcmVxdWlyZSgnLi9zaXBoYXNoMjQnKVxudmFyIGZhbGxiYWNrID0gcmVxdWlyZSgnLi9mYWxsYmFjaycpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbmFub2Fzc2VydCcpXG5cbm1vZHVsZS5leHBvcnRzID0gc2lwaGFzaDI0XG5cbnZhciBCWVRFUyA9IHNpcGhhc2gyNC5CWVRFUyA9IDhcbnZhciBLRVlCWVRFUyA9IHNpcGhhc2gyNC5LRVlCWVRFUyA9IDE2XG52YXIgbW9kID0gd2FzbSgpXG5cbnNpcGhhc2gyNC5XQVNNX1NVUFBPUlRFRCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ3VuZGVmaW5lZCdcbnNpcGhhc2gyNC5XQVNNX0xPQURFRCA9IGZhbHNlXG5cbmlmIChtb2QpIHtcbiAgbW9kLm9ubG9hZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2lwaGFzaDI0LldBU01fTE9BREVEID0gIWVyclxuICB9KVxufVxuXG5mdW5jdGlvbiBzaXBoYXNoMjQgKGRhdGEsIGtleSwgb3V0LCBub0Fzc2VydCkge1xuICBpZiAoIW91dCkgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoOClcblxuICBpZiAobm9Bc3NlcnQgIT09IHRydWUpIHtcbiAgICBhc3NlcnQob3V0Lmxlbmd0aCA+PSBCWVRFUywgJ291dHB1dCBtdXN0IGJlIGF0IGxlYXN0ICcgKyBCWVRFUylcbiAgICBhc3NlcnQoa2V5Lmxlbmd0aCA+PSBLRVlCWVRFUywgJ2tleSBtdXN0IGJlIGF0IGxlYXN0ICcgKyBLRVlCWVRFUylcbiAgfVxuXG4gIGlmIChtb2QgJiYgbW9kLmV4cG9ydHMpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggKyAyNCA+IG1vZC5tZW1vcnkubGVuZ3RoKSBtb2QucmVhbGxvYyhkYXRhLmxlbmd0aCArIDI0KVxuICAgIG1vZC5tZW1vcnkuc2V0KGtleSwgOClcbiAgICBtb2QubWVtb3J5LnNldChkYXRhLCAyNClcbiAgICBtb2QuZXhwb3J0cy5zaXBoYXNoKDI0LCBkYXRhLmxlbmd0aClcbiAgICBvdXQuc2V0KG1vZC5tZW1vcnkuc3ViYXJyYXkoMCwgOCkpXG4gIH0gZWxzZSB7XG4gICAgZmFsbGJhY2sob3V0LCBkYXRhLCBrZXkpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gbG9hZFdlYkFzc2VtYmx5XG5cbmxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICd1bmRlZmluZWQnXG5cbmZ1bmN0aW9uIGxvYWRXZWJBc3NlbWJseSAob3B0cykge1xuICBpZiAoIWxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQpIHJldHVybiBudWxsXG5cbiAgdmFyIGltcCA9IG9wdHMgJiYgb3B0cy5pbXBvcnRzXG4gIHZhciB3YXNtID0gdG9VaW50OEFycmF5KCdBR0Z6YlFFQUFBQUJCZ0ZnQW45L0FBTUNBUUFGQlFFQkNwQk9CeFFDQm0xbGJXOXllUUlBQjNOcGNHaGhjMmdBQUFyZENBSGFDQUlJZmdKL1F2WEt6WVBYck51Mzh3QWhBa0x0M3BIemxzemN0K1FBSVFOQzRlU1Y4OWJzMmJ6c0FDRUVRdlBLMGN1bmpObXk5QUFoQlVFSUtRTUFJUWRCRUNrREFDRUlJQUd0UWppR0lRWWdBVUVIY1NFTElBQWdBV29nQzJzaENpQUZJQWlGSVFVZ0JDQUhoU0VFSUFNZ0NJVWhBeUFDSUFlRklRSUNRQU5BSUFBZ0NrWU5BU0FBS1FNQUlRa2dCU0FKaFNFRklBSWdBM3doQWlBRFFnMkpJUU1nQXlBQ2hTRURJQUpDSUlraEFpQUVJQVY4SVFRZ0JVSVFpU0VGSUFVZ0JJVWhCU0FDSUFWOElRSWdCVUlWaVNFRklBVWdBb1VoQlNBRUlBTjhJUVFnQTBJUmlTRURJQU1nQklVaEF5QUVRaUNKSVFRZ0FpQURmQ0VDSUFOQ0RZa2hBeUFESUFLRklRTWdBa0lnaVNFQ0lBUWdCWHdoQkNBRlFoQ0pJUVVnQlNBRWhTRUZJQUlnQlh3aEFpQUZRaFdKSVFVZ0JTQUNoU0VGSUFRZ0Ezd2hCQ0FEUWhHSklRTWdBeUFFaFNFRElBUkNJSWtoQkNBQ0lBbUZJUUlnQUVFSWFpRUFEQUFMQ3dKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQ3c0SEJ3WUZCQU1DQVFBTElBWWdBREVBQmtJd2hvUWhCZ3NnQmlBQU1RQUZRaWlHaENFR0N5QUdJQUF4QUFSQ0lJYUVJUVlMSUFZZ0FERUFBMElZaG9RaEJnc2dCaUFBTVFBQ1FoQ0doQ0VHQ3lBR0lBQXhBQUZDQ0lhRUlRWUxJQVlnQURFQUFJUWhCZ3NnQlNBR2hTRUZJQUlnQTN3aEFpQURRZzJKSVFNZ0F5QUNoU0VESUFKQ0lJa2hBaUFFSUFWOElRUWdCVUlRaVNFRklBVWdCSVVoQlNBQ0lBVjhJUUlnQlVJVmlTRUZJQVVnQW9VaEJTQUVJQU44SVFRZ0EwSVJpU0VESUFNZ0JJVWhBeUFFUWlDSklRUWdBaUFEZkNFQ0lBTkNEWWtoQXlBRElBS0ZJUU1nQWtJZ2lTRUNJQVFnQlh3aEJDQUZRaENKSVFVZ0JTQUVoU0VGSUFJZ0JYd2hBaUFGUWhXSklRVWdCU0FDaFNFRklBUWdBM3doQkNBRFFoR0pJUU1nQXlBRWhTRURJQVJDSUlraEJDQUNJQWFGSVFJZ0JFTC9BWVVoQkNBQ0lBTjhJUUlnQTBJTmlTRURJQU1nQW9VaEF5QUNRaUNKSVFJZ0JDQUZmQ0VFSUFWQ0VJa2hCU0FGSUFTRklRVWdBaUFGZkNFQ0lBVkNGWWtoQlNBRklBS0ZJUVVnQkNBRGZDRUVJQU5DRVlraEF5QURJQVNGSVFNZ0JFSWdpU0VFSUFJZ0Ezd2hBaUFEUWcySklRTWdBeUFDaFNFRElBSkNJSWtoQWlBRUlBVjhJUVFnQlVJUWlTRUZJQVVnQklVaEJTQUNJQVY4SVFJZ0JVSVZpU0VGSUFVZ0FvVWhCU0FFSUFOOElRUWdBMElSaVNFRElBTWdCSVVoQXlBRVFpQ0pJUVFnQWlBRGZDRUNJQU5DRFlraEF5QURJQUtGSVFNZ0FrSWdpU0VDSUFRZ0JYd2hCQ0FGUWhDSklRVWdCU0FFaFNFRklBSWdCWHdoQWlBRlFoV0pJUVVnQlNBQ2hTRUZJQVFnQTN3aEJDQURRaEdKSVFNZ0F5QUVoU0VESUFSQ0lJa2hCQ0FDSUFOOElRSWdBMElOaVNFRElBTWdBb1VoQXlBQ1FpQ0pJUUlnQkNBRmZDRUVJQVZDRUlraEJTQUZJQVNGSVFVZ0FpQUZmQ0VDSUFWQ0ZZa2hCU0FGSUFLRklRVWdCQ0FEZkNFRUlBTkNFWWtoQXlBRElBU0ZJUU1nQkVJZ2lTRUVRUUFnQWlBRElBUWdCWVdGaFRjREFBcz0nKVxuICB2YXIgcmVhZHkgPSBudWxsXG5cbiAgdmFyIG1vZCA9IHtcbiAgICBidWZmZXI6IHdhc20sXG4gICAgbWVtb3J5OiBudWxsLFxuICAgIGV4cG9ydHM6IG51bGwsXG4gICAgcmVhbGxvYzogcmVhbGxvYyxcbiAgICBvbmxvYWQ6IG9ubG9hZFxuICB9XG5cbiAgb25sb2FkKGZ1bmN0aW9uICgpIHt9KVxuXG4gIHJldHVybiBtb2RcblxuICBmdW5jdGlvbiByZWFsbG9jIChzaXplKSB7XG4gICAgbW9kLmV4cG9ydHMubWVtb3J5Lmdyb3coTWF0aC5tYXgoMCwgTWF0aC5jZWlsKE1hdGguYWJzKHNpemUgLSBtb2QubWVtb3J5Lmxlbmd0aCkgLyA2NTUzNikpKVxuICAgIG1vZC5tZW1vcnkgPSBuZXcgVWludDhBcnJheShtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25sb2FkIChjYikge1xuICAgIGlmIChtb2QuZXhwb3J0cykgcmV0dXJuIGNiKClcblxuICAgIGlmIChyZWFkeSkge1xuICAgICAgcmVhZHkudGhlbihjYi5iaW5kKG51bGwsIG51bGwpKS5jYXRjaChjYilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLmFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jJylcbiAgICAgIHNldHVwKHtpbnN0YW5jZTogbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUod2FzbSksIGltcCl9KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVhZHkgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3YXNtLCBpbXApLnRoZW4oc2V0dXApXG4gICAgfVxuXG4gICAgb25sb2FkKGNiKVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXAgKHcpIHtcbiAgICBtb2QuZXhwb3J0cyA9IHcuaW5zdGFuY2UuZXhwb3J0c1xuICAgIG1vZC5tZW1vcnkgPSBtb2QuZXhwb3J0cy5tZW1vcnkgJiYgbW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlciAmJiBuZXcgVWludDhBcnJheShtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvVWludDhBcnJheSAocykge1xuICBpZiAodHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicpIHJldHVybiBuZXcgVWludDhBcnJheShhdG9iKHMpLnNwbGl0KCcnKS5tYXAoY2hhckNvZGVBdCkpXG4gIHJldHVybiBuZXcgKHJlcXVpcmUoJ2J1ZicgKyAnZmVyJykuQnVmZmVyKShzLCAnYmFzZTY0Jylcbn1cblxuZnVuY3Rpb24gY2hhckNvZGVBdCAoYykge1xuICByZXR1cm4gYy5jaGFyQ29kZUF0KDApXG59XG4iLCJ2YXIgYmxha2UyYiA9IHJlcXVpcmUoJ2JsYWtlMmInKVxuXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfUFJJTUlUSVZFID0gJ2JsYWtlMmInXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfQllURVNfTUlOID0gYmxha2UyYi5CWVRFU19NSU5cbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9CWVRFU19NQVggPSBibGFrZTJiLkJZVEVTX01BWFxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX0JZVEVTID0gYmxha2UyYi5CWVRFU1xubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2dlbmVyaWNoYXNoX0tFWUJZVEVTX01JTiA9IGJsYWtlMmIuS0VZQllURVNfTUlOXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfS0VZQllURVNfTUFYID0gYmxha2UyYi5LRVlCWVRFU19NQVhcbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9LRVlCWVRFUyA9IGJsYWtlMmIuS0VZQllURVNcbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9XQVNNX1NVUFBPUlRFRCA9IGJsYWtlMmIuV0FTTV9TVVBQT1JURURcbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9XQVNNX0xPQURFRCA9IGZhbHNlXG5cbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCBrZXkpIHtcbiAgYmxha2UyYihvdXRwdXQubGVuZ3RoLCBrZXkpLnVwZGF0ZShpbnB1dCkuZmluYWwob3V0cHV0KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfcmVhZHkgPSBibGFrZTJiLnJlYWR5XG5cbm1vZHVsZS5leHBvcnRzLmNyeXB0b19nZW5lcmljaGFzaF9iYXRjaCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0QXJyYXksIGtleSkge1xuICB2YXIgY3R4ID0gYmxha2UyYihvdXRwdXQubGVuZ3RoLCBrZXkpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGN0eC51cGRhdGUoaW5wdXRBcnJheVtpXSlcbiAgfVxuICBjdHguZmluYWwob3V0cHV0KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfaW5zdGFuY2UgPSBmdW5jdGlvbiAoa2V5LCBvdXRsZW4pIHtcbiAgaWYgKG91dGxlbiA9PSBudWxsKSBvdXRsZW4gPSBtb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfQllURVNcbiAgcmV0dXJuIGJsYWtlMmIob3V0bGVuLCBrZXkpXG59XG5cbmJsYWtlMmIucmVhZHkoZnVuY3Rpb24gKGVycikge1xuICBtb2R1bGUuZXhwb3J0cy5jcnlwdG9fZ2VuZXJpY2hhc2hfV0FTTV9MT0FERUQgPSBibGFrZTJiLldBU01fTE9BREVEXG59KVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ25hbm9hc3NlcnQnKVxudmFyIHJhbmRvbWJ5dGVzX2J1ZiA9IHJlcXVpcmUoJy4vcmFuZG9tYnl0ZXMnKS5yYW5kb21ieXRlc19idWZcbnZhciBibGFrZTJiID0gcmVxdWlyZSgnYmxha2UyYicpXG5cbm1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfUFJJTUlUSVZFID0gJ2JsYWtlMmInXG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0JZVEVTX01JTiA9IDE2XG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0JZVEVTX01BWCA9IDY0XG5tb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0NPTlRFWFRCWVRFUyA9IDhcbm1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfS0VZQllURVMgPSAzMlxuXG5mdW5jdGlvbiBTVE9SRTY0X0xFKGRlc3QsIGludCkge1xuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgZGVzdFswXSA9IGludCAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IDggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBkZXN0W2ldID0gKGludCAvIG11bCkgJiAweEZGXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuY3J5cHRvX2tkZl9kZXJpdmVfZnJvbV9rZXkgPSBmdW5jdGlvbiBjcnlwdG9fa2RmX2Rlcml2ZV9mcm9tX2tleSAoc3Via2V5LCBzdWJrZXlfaWQsIGN0eCwga2V5KSB7XG4gIGFzc2VydChzdWJrZXkubGVuZ3RoID49IG1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfQllURVNfTUlOLCAnc3Via2V5IG11c3QgYmUgYXQgbGVhc3QgY3J5cHRvX2tkZl9CWVRFU19NSU4nKVxuICBhc3NlcnQoc3Via2V5X2lkID49IDAgJiYgc3Via2V5X2lkIDw9IDB4MWZmZmZmZmZmZmZmZmYsICdzdWJrZXlfaWQgbXVzdCBiZSBzYWZlIGludGVnZXInKVxuICBhc3NlcnQoY3R4Lmxlbmd0aCA+PSBtb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0NPTlRFWFRCWVRFUywgJ2NvbnRleHQgbXVzdCBiZSBhdCBsZWFzdCBjcnlwdG9fa2RmX0NPTlRFWFRCWVRFUycpXG5cbiAgdmFyIGN0eF9wYWRkZWQgPSBuZXcgVWludDhBcnJheShibGFrZTJiLlBFUlNPTkFMQllURVMpXG4gIHZhciBzYWx0ID0gbmV3IFVpbnQ4QXJyYXkoYmxha2UyYi5TQUxUQllURVMpXG5cbiAgY3R4X3BhZGRlZC5zZXQoY3R4LCAwLCBtb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0NPTlRFWFRCWVRFUylcbiAgU1RPUkU2NF9MRShzYWx0LCBzdWJrZXlfaWQpXG5cbiAgdmFyIG91dGxlbiA9IE1hdGgubWluKHN1YmtleS5sZW5ndGgsIG1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfQllURVNfTUFYKVxuICBibGFrZTJiKG91dGxlbiwga2V5LnN1YmFycmF5KDAsIG1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfS0VZQllURVMpLCBzYWx0LCBjdHhfcGFkZGVkLCB0cnVlKVxuICAgIC5maW5hbChzdWJrZXkpXG59XG5cbm1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfa2V5Z2VuID0gZnVuY3Rpb24gY3J5cHRvX2tkZl9rZXlnZW4gKG91dCkge1xuICBhc3NlcnQob3V0Lmxlbmd0aCA+PSBtb2R1bGUuZXhwb3J0cy5jcnlwdG9fa2RmX0tFWUJZVEVTLCAnb3V0Lmxlbmd0aCBtdXN0IGJlIGNyeXB0b19rZGZfS0VZQllURVMnKVxuICByYW5kb21ieXRlc19idWYob3V0LnN1YmFycmF5KDAsIG1vZHVsZS5leHBvcnRzLmNyeXB0b19rZGZfS0VZQllURVMpKVxufVxuIiwidmFyIHNpcGhhc2ggPSByZXF1aXJlKCdzaXBoYXNoMjQnKVxuXG5leHBvcnRzLmNyeXB0b19zaG9ydGhhc2hfUFJJTUlUSVZFID0gJ3NpcGhhc2gyNCdcbmV4cG9ydHMuY3J5cHRvX3Nob3J0aGFzaF9CWVRFUyA9IHNpcGhhc2guQllURVNcbmV4cG9ydHMuY3J5cHRvX3Nob3J0aGFzaF9LRVlCWVRFUyA9IHNpcGhhc2guS0VZQllURVNcbmV4cG9ydHMuY3J5cHRvX3Nob3J0aGFzaF9XQVNNX1NVUFBPUlRFRCA9IHNpcGhhc2guV0FTTV9TVVBQT1JURURcbmV4cG9ydHMuY3J5cHRvX3Nob3J0aGFzaF9XQVNNX0xPQURFRCA9IHNpcGhhc2guV0FTTV9MT0FERURcbmV4cG9ydHMuY3J5cHRvX3Nob3J0aGFzaCA9IHNob3J0aGFzaFxuXG5mdW5jdGlvbiBzaG9ydGhhc2ggKG91dCwgZGF0YSwga2V5LCBub0Fzc2VydCkge1xuICBzaXBoYXNoKGRhdGEsIGtleSwgb3V0LCBub0Fzc2VydClcbn1cbiIsInZhciB4c2Fsc2EyMCA9IHJlcXVpcmUoJ3hzYWxzYTIwJylcblxuZXhwb3J0cy5jcnlwdG9fc3RyZWFtX0tFWUJZVEVTID0gMzJcbmV4cG9ydHMuY3J5cHRvX3N0cmVhbV9OT05DRUJZVEVTID0gMjRcbmV4cG9ydHMuY3J5cHRvX3N0cmVhbV9QUklNSVRJVkUgPSAneHNhbHNhMjAnXG5cbmV4cG9ydHMuY3J5cHRvX3N0cmVhbSA9IGZ1bmN0aW9uIChvdXQsIG5vbmNlLCBrZXkpIHtcbiAgb3V0LmZpbGwoMClcbiAgZXhwb3J0cy5jcnlwdG9fc3RyZWFtX3hvcihvdXQsIG91dCwgbm9uY2UsIGtleSlcbn1cblxuZXhwb3J0cy5jcnlwdG9fc3RyZWFtX3hvciA9IGZ1bmN0aW9uIChvdXQsIGlucCwgbm9uY2UsIGtleSkge1xuICB2YXIgeG9yID0geHNhbHNhMjAobm9uY2UsIGtleSlcbiAgeG9yLnVwZGF0ZShpbnAsIG91dClcbiAgeG9yLmZpbmFsKClcbn1cblxuZXhwb3J0cy5jcnlwdG9fc3RyZWFtX3hvcl9pbnN0YW5jZSA9IGZ1bmN0aW9uIChub25jZSwga2V5KSB7XG4gIHJldHVybiBuZXcgWE9SKG5vbmNlLCBrZXkpXG59XG5cbmZ1bmN0aW9uIFhPUiAobm9uY2UsIGtleSkge1xuICB0aGlzLl9pbnN0YW5jZSA9IHhzYWxzYTIwKG5vbmNlLCBrZXkpXG59XG5cblhPUi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG91dCwgaW5wKSB7XG4gIHRoaXMuX2luc3RhbmNlLnVwZGF0ZShpbnAsIG91dClcbn1cblxuWE9SLnByb3RvdHlwZS5maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faW5zdGFuY2UuZmluYWxpemUoKVxuICB0aGlzLl9pbnN0YW5jZSA9IG51bGxcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2RjaGVzdC90d2VldG5hY2wtanMvYmxvYi82ZGNiY2FmNWY1Y2JmZDMxM2YyZGNmZTc2M2RiMzVjODI4YzhmZjViL25hY2wtZmFzdC5qcy5cblxudmFyIHNvZGl1bSA9IG1vZHVsZS5leHBvcnRzXG52YXIgY3MgPSByZXF1aXJlKCcuL2NyeXB0b19zdHJlYW0nKVxuXG4vLyBQb3J0ZWQgaW4gMjAxNCBieSBEbWl0cnkgQ2hlc3RueWtoIGFuZCBEZXZpIE1hbmRpcmkuXG4vLyBQdWJsaWMgZG9tYWluLlxuLy9cbi8vIEltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBUd2VldE5hQ2wgdmVyc2lvbiAyMDE0MDQyNy5cbi8vIFNlZSBmb3IgZGV0YWlsczogaHR0cDovL3R3ZWV0bmFjbC5jci55cC50by9cblxudmFyIGdmID0gZnVuY3Rpb24oaW5pdCkge1xuICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICBpZiAoaW5pdCkgZm9yIChpID0gMDsgaSA8IGluaXQubGVuZ3RoOyBpKyspIHJbaV0gPSBpbml0W2ldO1xuICByZXR1cm4gcjtcbn07XG5cbi8vIGFsc28gZm9yd2FyZGVkIGF0IHRoZSBib3R0b20gYnV0IHJhbmRvbWJ5dGVzIGlzIG5vbi1lbnVtZXJhYmxlXG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKCcuL3JhbmRvbWJ5dGVzJykucmFuZG9tYnl0ZXNcblxudmFyIF8wID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xudmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpOyBfOVswXSA9IDk7XG5cbnZhciBnZjAgPSBnZigpLFxuICAgIGdmMSA9IGdmKFsxXSksXG4gICAgXzEyMTY2NSA9IGdmKFsweGRiNDEsIDFdKSxcbiAgICBEID0gZ2YoWzB4NzhhMywgMHgxMzU5LCAweDRkY2EsIDB4NzVlYiwgMHhkOGFiLCAweDQxNDEsIDB4MGE0ZCwgMHgwMDcwLCAweGU4OTgsIDB4Nzc3OSwgMHg0MDc5LCAweDhjYzcsIDB4ZmU3MywgMHgyYjZmLCAweDZjZWUsIDB4NTIwM10pLFxuICAgIEQyID0gZ2YoWzB4ZjE1OSwgMHgyNmIyLCAweDliOTQsIDB4ZWJkNiwgMHhiMTU2LCAweDgyODMsIDB4MTQ5YSwgMHgwMGUwLCAweGQxMzAsIDB4ZWVmMywgMHg4MGYyLCAweDE5OGUsIDB4ZmNlNywgMHg1NmRmLCAweGQ5ZGMsIDB4MjQwNl0pLFxuICAgIFggPSBnZihbMHhkNTFhLCAweDhmMjUsIDB4MmQ2MCwgMHhjOTU2LCAweGE3YjIsIDB4OTUyNSwgMHhjNzYwLCAweDY5MmMsIDB4ZGM1YywgMHhmZGQ2LCAweGUyMzEsIDB4YzBhNCwgMHg1M2ZlLCAweGNkNmUsIDB4MzZkMywgMHgyMTY5XSksXG4gICAgWSA9IGdmKFsweDY2NTgsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjZdKSxcbiAgICBJID0gZ2YoWzB4YTBiMCwgMHg0YTBlLCAweDFiMjcsIDB4YzRlZSwgMHhlNDc4LCAweGFkMmYsIDB4MTgwNiwgMHgyZjQzLCAweGQ3YTcsIDB4M2RmYiwgMHgwMDk5LCAweDJiNGQsIDB4ZGYwYiwgMHg0ZmMxLCAweDI0ODAsIDB4MmI4M10pO1xuXG5mdW5jdGlvbiB0czY0KHgsIGksIGgsIGwpIHtcbiAgeFtpXSAgID0gKGggPj4gMjQpICYgMHhmZjtcbiAgeFtpKzFdID0gKGggPj4gMTYpICYgMHhmZjtcbiAgeFtpKzJdID0gKGggPj4gIDgpICYgMHhmZjtcbiAgeFtpKzNdID0gaCAmIDB4ZmY7XG4gIHhbaSs0XSA9IChsID4+IDI0KSAgJiAweGZmO1xuICB4W2krNV0gPSAobCA+PiAxNikgICYgMHhmZjtcbiAgeFtpKzZdID0gKGwgPj4gIDgpICAmIDB4ZmY7XG4gIHhbaSs3XSA9IGwgJiAweGZmO1xufVxuXG5mdW5jdGlvbiB2bih4LCB4aSwgeSwgeWksIG4pIHtcbiAgdmFyIGksZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGQgfD0geFt4aStpXV55W3lpK2ldO1xuICByZXR1cm4gKDEgJiAoKGQgLSAxKSA+Pj4gOCkpIC0gMTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8xNih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwxNik7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMzIpO1xufVxuXG4vKlxuKiBQb3J0IG9mIEFuZHJldyBNb29uJ3MgUG9seTEzMDUtZG9ubmEtMTYuIFB1YmxpYyBkb21haW4uXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYVxuKi9cblxudmFyIHBvbHkxMzA1ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICB0aGlzLnIgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB0aGlzLmggPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB0aGlzLnBhZCA9IG5ldyBVaW50MTZBcnJheSg4KTtcbiAgdGhpcy5sZWZ0b3ZlciA9IDA7XG4gIHRoaXMuZmluID0gMDtcblxuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3O1xuXG4gIHQwID0ga2V5WyAwXSAmIDB4ZmYgfCAoa2V5WyAxXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclswXSA9ICggdDAgICAgICAgICAgICAgICAgICAgICApICYgMHgxZmZmO1xuICB0MSA9IGtleVsgMl0gJiAweGZmIHwgKGtleVsgM10gJiAweGZmKSA8PCA4OyB0aGlzLnJbMV0gPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgdDIgPSBrZXlbIDRdICYgMHhmZiB8IChrZXlbIDVdICYgMHhmZikgPDwgODsgdGhpcy5yWzJdID0gKCh0MSA+Pj4gMTApIHwgKHQyIDw8ICA2KSkgJiAweDFmMDM7XG4gIHQzID0ga2V5WyA2XSAmIDB4ZmYgfCAoa2V5WyA3XSAmIDB4ZmYpIDw8IDg7IHRoaXMuclszXSA9ICgodDIgPj4+ICA3KSB8ICh0MyA8PCAgOSkpICYgMHgxZmZmO1xuICB0NCA9IGtleVsgOF0gJiAweGZmIHwgKGtleVsgOV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNF0gPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MDBmZjtcbiAgdGhpcy5yWzVdID0gKCh0NCA+Pj4gIDEpKSAmIDB4MWZmZTtcbiAgdDUgPSBrZXlbMTBdICYgMHhmZiB8IChrZXlbMTFdICYgMHhmZikgPDwgODsgdGhpcy5yWzZdID0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8ICAyKSkgJiAweDFmZmY7XG4gIHQ2ID0ga2V5WzEyXSAmIDB4ZmYgfCAoa2V5WzEzXSAmIDB4ZmYpIDw8IDg7IHRoaXMucls3XSA9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZjgxO1xuICB0NyA9IGtleVsxNF0gJiAweGZmIHwgKGtleVsxNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbOF0gPSAoKHQ2ID4+PiAgOCkgfCAodDcgPDwgIDgpKSAmIDB4MWZmZjtcbiAgdGhpcy5yWzldID0gKCh0NyA+Pj4gIDUpKSAmIDB4MDA3ZjtcblxuICB0aGlzLnBhZFswXSA9IGtleVsxNl0gJiAweGZmIHwgKGtleVsxN10gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFsxXSA9IGtleVsxOF0gJiAweGZmIHwgKGtleVsxOV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFsyXSA9IGtleVsyMF0gJiAweGZmIHwgKGtleVsyMV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFszXSA9IGtleVsyMl0gJiAweGZmIHwgKGtleVsyM10gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs0XSA9IGtleVsyNF0gJiAweGZmIHwgKGtleVsyNV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs1XSA9IGtleVsyNl0gJiAweGZmIHwgKGtleVsyN10gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs2XSA9IGtleVsyOF0gJiAweGZmIHwgKGtleVsyOV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs3XSA9IGtleVszMF0gJiAweGZmIHwgKGtleVszMV0gJiAweGZmKSA8PCA4O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmJsb2NrcyA9IGZ1bmN0aW9uKG0sIG1wb3MsIGJ5dGVzKSB7XG4gIHZhciBoaWJpdCA9IHRoaXMuZmluID8gMCA6ICgxIDw8IDExKTtcbiAgdmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDUsIHQ2LCB0NywgYztcbiAgdmFyIGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5O1xuXG4gIHZhciBoMCA9IHRoaXMuaFswXSxcbiAgICAgIGgxID0gdGhpcy5oWzFdLFxuICAgICAgaDIgPSB0aGlzLmhbMl0sXG4gICAgICBoMyA9IHRoaXMuaFszXSxcbiAgICAgIGg0ID0gdGhpcy5oWzRdLFxuICAgICAgaDUgPSB0aGlzLmhbNV0sXG4gICAgICBoNiA9IHRoaXMuaFs2XSxcbiAgICAgIGg3ID0gdGhpcy5oWzddLFxuICAgICAgaDggPSB0aGlzLmhbOF0sXG4gICAgICBoOSA9IHRoaXMuaFs5XTtcblxuICB2YXIgcjAgPSB0aGlzLnJbMF0sXG4gICAgICByMSA9IHRoaXMuclsxXSxcbiAgICAgIHIyID0gdGhpcy5yWzJdLFxuICAgICAgcjMgPSB0aGlzLnJbM10sXG4gICAgICByNCA9IHRoaXMucls0XSxcbiAgICAgIHI1ID0gdGhpcy5yWzVdLFxuICAgICAgcjYgPSB0aGlzLnJbNl0sXG4gICAgICByNyA9IHRoaXMucls3XSxcbiAgICAgIHI4ID0gdGhpcy5yWzhdLFxuICAgICAgcjkgPSB0aGlzLnJbOV07XG5cbiAgd2hpbGUgKGJ5dGVzID49IDE2KSB7XG4gICAgdDAgPSBtW21wb3MrIDBdICYgMHhmZiB8IChtW21wb3MrIDFdICYgMHhmZikgPDwgODsgaDAgKz0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gICAgdDEgPSBtW21wb3MrIDJdICYgMHhmZiB8IChtW21wb3MrIDNdICYgMHhmZikgPDwgODsgaDEgKz0gKCh0MCA+Pj4gMTMpIHwgKHQxIDw8ICAzKSkgJiAweDFmZmY7XG4gICAgdDIgPSBtW21wb3MrIDRdICYgMHhmZiB8IChtW21wb3MrIDVdICYgMHhmZikgPDwgODsgaDIgKz0gKCh0MSA+Pj4gMTApIHwgKHQyIDw8ICA2KSkgJiAweDFmZmY7XG4gICAgdDMgPSBtW21wb3MrIDZdICYgMHhmZiB8IChtW21wb3MrIDddICYgMHhmZikgPDwgODsgaDMgKz0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gICAgdDQgPSBtW21wb3MrIDhdICYgMHhmZiB8IChtW21wb3MrIDldICYgMHhmZikgPDwgODsgaDQgKz0gKCh0MyA+Pj4gIDQpIHwgKHQ0IDw8IDEyKSkgJiAweDFmZmY7XG4gICAgaDUgKz0gKCh0NCA+Pj4gIDEpKSAmIDB4MWZmZjtcbiAgICB0NSA9IG1bbXBvcysxMF0gJiAweGZmIHwgKG1bbXBvcysxMV0gJiAweGZmKSA8PCA4OyBoNiArPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgICB0NiA9IG1bbXBvcysxMl0gJiAweGZmIHwgKG1bbXBvcysxM10gJiAweGZmKSA8PCA4OyBoNyArPSAoKHQ1ID4+PiAxMSkgfCAodDYgPDwgIDUpKSAmIDB4MWZmZjtcbiAgICB0NyA9IG1bbXBvcysxNF0gJiAweGZmIHwgKG1bbXBvcysxNV0gJiAweGZmKSA8PCA4OyBoOCArPSAoKHQ2ID4+PiAgOCkgfCAodDcgPDwgIDgpKSAmIDB4MWZmZjtcbiAgICBoOSArPSAoKHQ3ID4+PiA1KSkgfCBoaWJpdDtcblxuICAgIGMgPSAwO1xuXG4gICAgZDAgPSBjO1xuICAgIGQwICs9IGgwICogcjA7XG4gICAgZDAgKz0gaDEgKiAoNSAqIHI5KTtcbiAgICBkMCArPSBoMiAqICg1ICogcjgpO1xuICAgIGQwICs9IGgzICogKDUgKiByNyk7XG4gICAgZDAgKz0gaDQgKiAoNSAqIHI2KTtcbiAgICBjID0gKGQwID4+PiAxMyk7IGQwICY9IDB4MWZmZjtcbiAgICBkMCArPSBoNSAqICg1ICogcjUpO1xuICAgIGQwICs9IGg2ICogKDUgKiByNCk7XG4gICAgZDAgKz0gaDcgKiAoNSAqIHIzKTtcbiAgICBkMCArPSBoOCAqICg1ICogcjIpO1xuICAgIGQwICs9IGg5ICogKDUgKiByMSk7XG4gICAgYyArPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuXG4gICAgZDEgPSBjO1xuICAgIGQxICs9IGgwICogcjE7XG4gICAgZDEgKz0gaDEgKiByMDtcbiAgICBkMSArPSBoMiAqICg1ICogcjkpO1xuICAgIGQxICs9IGgzICogKDUgKiByOCk7XG4gICAgZDEgKz0gaDQgKiAoNSAqIHI3KTtcbiAgICBjID0gKGQxID4+PiAxMyk7IGQxICY9IDB4MWZmZjtcbiAgICBkMSArPSBoNSAqICg1ICogcjYpO1xuICAgIGQxICs9IGg2ICogKDUgKiByNSk7XG4gICAgZDEgKz0gaDcgKiAoNSAqIHI0KTtcbiAgICBkMSArPSBoOCAqICg1ICogcjMpO1xuICAgIGQxICs9IGg5ICogKDUgKiByMik7XG4gICAgYyArPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuXG4gICAgZDIgPSBjO1xuICAgIGQyICs9IGgwICogcjI7XG4gICAgZDIgKz0gaDEgKiByMTtcbiAgICBkMiArPSBoMiAqIHIwO1xuICAgIGQyICs9IGgzICogKDUgKiByOSk7XG4gICAgZDIgKz0gaDQgKiAoNSAqIHI4KTtcbiAgICBjID0gKGQyID4+PiAxMyk7IGQyICY9IDB4MWZmZjtcbiAgICBkMiArPSBoNSAqICg1ICogcjcpO1xuICAgIGQyICs9IGg2ICogKDUgKiByNik7XG4gICAgZDIgKz0gaDcgKiAoNSAqIHI1KTtcbiAgICBkMiArPSBoOCAqICg1ICogcjQpO1xuICAgIGQyICs9IGg5ICogKDUgKiByMyk7XG4gICAgYyArPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuXG4gICAgZDMgPSBjO1xuICAgIGQzICs9IGgwICogcjM7XG4gICAgZDMgKz0gaDEgKiByMjtcbiAgICBkMyArPSBoMiAqIHIxO1xuICAgIGQzICs9IGgzICogcjA7XG4gICAgZDMgKz0gaDQgKiAoNSAqIHI5KTtcbiAgICBjID0gKGQzID4+PiAxMyk7IGQzICY9IDB4MWZmZjtcbiAgICBkMyArPSBoNSAqICg1ICogcjgpO1xuICAgIGQzICs9IGg2ICogKDUgKiByNyk7XG4gICAgZDMgKz0gaDcgKiAoNSAqIHI2KTtcbiAgICBkMyArPSBoOCAqICg1ICogcjUpO1xuICAgIGQzICs9IGg5ICogKDUgKiByNCk7XG4gICAgYyArPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuXG4gICAgZDQgPSBjO1xuICAgIGQ0ICs9IGgwICogcjQ7XG4gICAgZDQgKz0gaDEgKiByMztcbiAgICBkNCArPSBoMiAqIHIyO1xuICAgIGQ0ICs9IGgzICogcjE7XG4gICAgZDQgKz0gaDQgKiByMDtcbiAgICBjID0gKGQ0ID4+PiAxMyk7IGQ0ICY9IDB4MWZmZjtcbiAgICBkNCArPSBoNSAqICg1ICogcjkpO1xuICAgIGQ0ICs9IGg2ICogKDUgKiByOCk7XG4gICAgZDQgKz0gaDcgKiAoNSAqIHI3KTtcbiAgICBkNCArPSBoOCAqICg1ICogcjYpO1xuICAgIGQ0ICs9IGg5ICogKDUgKiByNSk7XG4gICAgYyArPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuXG4gICAgZDUgPSBjO1xuICAgIGQ1ICs9IGgwICogcjU7XG4gICAgZDUgKz0gaDEgKiByNDtcbiAgICBkNSArPSBoMiAqIHIzO1xuICAgIGQ1ICs9IGgzICogcjI7XG4gICAgZDUgKz0gaDQgKiByMTtcbiAgICBjID0gKGQ1ID4+PiAxMyk7IGQ1ICY9IDB4MWZmZjtcbiAgICBkNSArPSBoNSAqIHIwO1xuICAgIGQ1ICs9IGg2ICogKDUgKiByOSk7XG4gICAgZDUgKz0gaDcgKiAoNSAqIHI4KTtcbiAgICBkNSArPSBoOCAqICg1ICogcjcpO1xuICAgIGQ1ICs9IGg5ICogKDUgKiByNik7XG4gICAgYyArPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuXG4gICAgZDYgPSBjO1xuICAgIGQ2ICs9IGgwICogcjY7XG4gICAgZDYgKz0gaDEgKiByNTtcbiAgICBkNiArPSBoMiAqIHI0O1xuICAgIGQ2ICs9IGgzICogcjM7XG4gICAgZDYgKz0gaDQgKiByMjtcbiAgICBjID0gKGQ2ID4+PiAxMyk7IGQ2ICY9IDB4MWZmZjtcbiAgICBkNiArPSBoNSAqIHIxO1xuICAgIGQ2ICs9IGg2ICogcjA7XG4gICAgZDYgKz0gaDcgKiAoNSAqIHI5KTtcbiAgICBkNiArPSBoOCAqICg1ICogcjgpO1xuICAgIGQ2ICs9IGg5ICogKDUgKiByNyk7XG4gICAgYyArPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuXG4gICAgZDcgPSBjO1xuICAgIGQ3ICs9IGgwICogcjc7XG4gICAgZDcgKz0gaDEgKiByNjtcbiAgICBkNyArPSBoMiAqIHI1O1xuICAgIGQ3ICs9IGgzICogcjQ7XG4gICAgZDcgKz0gaDQgKiByMztcbiAgICBjID0gKGQ3ID4+PiAxMyk7IGQ3ICY9IDB4MWZmZjtcbiAgICBkNyArPSBoNSAqIHIyO1xuICAgIGQ3ICs9IGg2ICogcjE7XG4gICAgZDcgKz0gaDcgKiByMDtcbiAgICBkNyArPSBoOCAqICg1ICogcjkpO1xuICAgIGQ3ICs9IGg5ICogKDUgKiByOCk7XG4gICAgYyArPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuXG4gICAgZDggPSBjO1xuICAgIGQ4ICs9IGgwICogcjg7XG4gICAgZDggKz0gaDEgKiByNztcbiAgICBkOCArPSBoMiAqIHI2O1xuICAgIGQ4ICs9IGgzICogcjU7XG4gICAgZDggKz0gaDQgKiByNDtcbiAgICBjID0gKGQ4ID4+PiAxMyk7IGQ4ICY9IDB4MWZmZjtcbiAgICBkOCArPSBoNSAqIHIzO1xuICAgIGQ4ICs9IGg2ICogcjI7XG4gICAgZDggKz0gaDcgKiByMTtcbiAgICBkOCArPSBoOCAqIHIwO1xuICAgIGQ4ICs9IGg5ICogKDUgKiByOSk7XG4gICAgYyArPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuXG4gICAgZDkgPSBjO1xuICAgIGQ5ICs9IGgwICogcjk7XG4gICAgZDkgKz0gaDEgKiByODtcbiAgICBkOSArPSBoMiAqIHI3O1xuICAgIGQ5ICs9IGgzICogcjY7XG4gICAgZDkgKz0gaDQgKiByNTtcbiAgICBjID0gKGQ5ID4+PiAxMyk7IGQ5ICY9IDB4MWZmZjtcbiAgICBkOSArPSBoNSAqIHI0O1xuICAgIGQ5ICs9IGg2ICogcjM7XG4gICAgZDkgKz0gaDcgKiByMjtcbiAgICBkOSArPSBoOCAqIHIxO1xuICAgIGQ5ICs9IGg5ICogcjA7XG4gICAgYyArPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuXG4gICAgYyA9ICgoKGMgPDwgMikgKyBjKSkgfCAwO1xuICAgIGMgPSAoYyArIGQwKSB8IDA7XG4gICAgZDAgPSBjICYgMHgxZmZmO1xuICAgIGMgPSAoYyA+Pj4gMTMpO1xuICAgIGQxICs9IGM7XG5cbiAgICBoMCA9IGQwO1xuICAgIGgxID0gZDE7XG4gICAgaDIgPSBkMjtcbiAgICBoMyA9IGQzO1xuICAgIGg0ID0gZDQ7XG4gICAgaDUgPSBkNTtcbiAgICBoNiA9IGQ2O1xuICAgIGg3ID0gZDc7XG4gICAgaDggPSBkODtcbiAgICBoOSA9IGQ5O1xuXG4gICAgbXBvcyArPSAxNjtcbiAgICBieXRlcyAtPSAxNjtcbiAgfVxuICB0aGlzLmhbMF0gPSBoMDtcbiAgdGhpcy5oWzFdID0gaDE7XG4gIHRoaXMuaFsyXSA9IGgyO1xuICB0aGlzLmhbM10gPSBoMztcbiAgdGhpcy5oWzRdID0gaDQ7XG4gIHRoaXMuaFs1XSA9IGg1O1xuICB0aGlzLmhbNl0gPSBoNjtcbiAgdGhpcy5oWzddID0gaDc7XG4gIHRoaXMuaFs4XSA9IGg4O1xuICB0aGlzLmhbOV0gPSBoOTtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihtYWMsIG1hY3Bvcykge1xuICB2YXIgZyA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHZhciBjLCBtYXNrLCBmLCBpO1xuXG4gIGlmICh0aGlzLmxlZnRvdmVyKSB7XG4gICAgaSA9IHRoaXMubGVmdG92ZXI7XG4gICAgdGhpcy5idWZmZXJbaSsrXSA9IDE7XG4gICAgZm9yICg7IGkgPCAxNjsgaSsrKSB0aGlzLmJ1ZmZlcltpXSA9IDA7XG4gICAgdGhpcy5maW4gPSAxO1xuICAgIHRoaXMuYmxvY2tzKHRoaXMuYnVmZmVyLCAwLCAxNik7XG4gIH1cblxuICBjID0gdGhpcy5oWzFdID4+PiAxMztcbiAgdGhpcy5oWzFdICY9IDB4MWZmZjtcbiAgZm9yIChpID0gMjsgaSA8IDEwOyBpKyspIHtcbiAgICB0aGlzLmhbaV0gKz0gYztcbiAgICBjID0gdGhpcy5oW2ldID4+PiAxMztcbiAgICB0aGlzLmhbaV0gJj0gMHgxZmZmO1xuICB9XG4gIHRoaXMuaFswXSArPSAoYyAqIDUpO1xuICBjID0gdGhpcy5oWzBdID4+PiAxMztcbiAgdGhpcy5oWzBdICY9IDB4MWZmZjtcbiAgdGhpcy5oWzFdICs9IGM7XG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMl0gKz0gYztcblxuICBnWzBdID0gdGhpcy5oWzBdICsgNTtcbiAgYyA9IGdbMF0gPj4+IDEzO1xuICBnWzBdICY9IDB4MWZmZjtcbiAgZm9yIChpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICBnW2ldID0gdGhpcy5oW2ldICsgYztcbiAgICBjID0gZ1tpXSA+Pj4gMTM7XG4gICAgZ1tpXSAmPSAweDFmZmY7XG4gIH1cbiAgZ1s5XSAtPSAoMSA8PCAxMyk7XG5cbiAgbWFzayA9IChjIF4gMSkgLSAxO1xuICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykgZ1tpXSAmPSBtYXNrO1xuICBtYXNrID0gfm1hc2s7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSB0aGlzLmhbaV0gPSAodGhpcy5oW2ldICYgbWFzaykgfCBnW2ldO1xuXG4gIHRoaXMuaFswXSA9ICgodGhpcy5oWzBdICAgICAgICkgfCAodGhpcy5oWzFdIDw8IDEzKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzFdID0gKCh0aGlzLmhbMV0gPj4+ICAzKSB8ICh0aGlzLmhbMl0gPDwgMTApICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMl0gPSAoKHRoaXMuaFsyXSA+Pj4gIDYpIHwgKHRoaXMuaFszXSA8PCAgNykgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFszXSA9ICgodGhpcy5oWzNdID4+PiAgOSkgfCAodGhpcy5oWzRdIDw8ICA0KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzRdID0gKCh0aGlzLmhbNF0gPj4+IDEyKSB8ICh0aGlzLmhbNV0gPDwgIDEpIHwgKHRoaXMuaFs2XSA8PCAxNCkpICYgMHhmZmZmO1xuICB0aGlzLmhbNV0gPSAoKHRoaXMuaFs2XSA+Pj4gIDIpIHwgKHRoaXMuaFs3XSA8PCAxMSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs2XSA9ICgodGhpcy5oWzddID4+PiAgNSkgfCAodGhpcy5oWzhdIDw8ICA4KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzddID0gKCh0aGlzLmhbOF0gPj4+ICA4KSB8ICh0aGlzLmhbOV0gPDwgIDUpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuXG4gIGYgPSB0aGlzLmhbMF0gKyB0aGlzLnBhZFswXTtcbiAgdGhpcy5oWzBdID0gZiAmIDB4ZmZmZjtcbiAgZm9yIChpID0gMTsgaSA8IDg7IGkrKykge1xuICAgIGYgPSAoKCh0aGlzLmhbaV0gKyB0aGlzLnBhZFtpXSkgfCAwKSArIChmID4+PiAxNikpIHwgMDtcbiAgICB0aGlzLmhbaV0gPSBmICYgMHhmZmZmO1xuICB9XG5cbiAgbWFjW21hY3BvcysgMF0gPSAodGhpcy5oWzBdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDFdID0gKHRoaXMuaFswXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAyXSA9ICh0aGlzLmhbMV0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgM10gPSAodGhpcy5oWzFdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDRdID0gKHRoaXMuaFsyXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA1XSA9ICh0aGlzLmhbMl0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNl0gPSAodGhpcy5oWzNdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDddID0gKHRoaXMuaFszXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA4XSA9ICh0aGlzLmhbNF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgOV0gPSAodGhpcy5oWzRdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTBdID0gKHRoaXMuaFs1XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzExXSA9ICh0aGlzLmhbNV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMl0gPSAodGhpcy5oWzZdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTNdID0gKHRoaXMuaFs2XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE0XSA9ICh0aGlzLmhbN10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxNV0gPSAodGhpcy5oWzddID4+PiA4KSAmIDB4ZmY7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGksIHdhbnQ7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICB3YW50ID0gKDE2IC0gdGhpcy5sZWZ0b3Zlcik7XG4gICAgaWYgKHdhbnQgPiBieXRlcylcbiAgICAgIHdhbnQgPSBieXRlcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2FudDsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIGJ5dGVzIC09IHdhbnQ7XG4gICAgbXBvcyArPSB3YW50O1xuICAgIHRoaXMubGVmdG92ZXIgKz0gd2FudDtcbiAgICBpZiAodGhpcy5sZWZ0b3ZlciA8IDE2KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYmxvY2tzKHRoaXMuYnVmZmVyLCAwLCAxNik7XG4gICAgdGhpcy5sZWZ0b3ZlciA9IDA7XG4gIH1cblxuICBpZiAoYnl0ZXMgPj0gMTYpIHtcbiAgICB3YW50ID0gYnl0ZXMgLSAoYnl0ZXMgJSAxNik7XG4gICAgdGhpcy5ibG9ja3MobSwgbXBvcywgd2FudCk7XG4gICAgbXBvcyArPSB3YW50O1xuICAgIGJ5dGVzIC09IHdhbnQ7XG4gIH1cblxuICBpZiAoYnl0ZXMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZXM7IGkrKylcbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMubGVmdG92ZXIgKyBpXSA9IG1bbXBvcytpXTtcbiAgICB0aGlzLmxlZnRvdmVyICs9IGJ5dGVzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3hvciAoYywgY3BvcywgbSwgbXBvcywgY2xlbiwgbiwgaykge1xuICBjcy5jcnlwdG9fc3RyZWFtX3hvcihjLCBtLCBuLCBrKVxufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtIChjLCBjcG9zLCBjbGVuLCBuLCBrKSB7XG4gIGNzLmNyeXB0b19zdHJlYW0oYywgbiwgaylcbn1cblxuZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoKG91dCwgb3V0cG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gIHZhciBzID0gbmV3IHBvbHkxMzA1KGspO1xuICBzLnVwZGF0ZShtLCBtcG9zLCBuKTtcbiAgcy5maW5pc2gob3V0LCBvdXRwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShoLCBocG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBjcnlwdG9fb25ldGltZWF1dGgoeCwwLG0sbXBvcyxuLGspO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8xNihoLGhwb3MseCwwKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveChjLG0sZCxuLGspIHtcbiAgdmFyIGk7XG4gIGlmIChkIDwgMzIpIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IoYywwLG0sMCxkLG4sayk7XG4gIGNyeXB0b19vbmV0aW1lYXV0aChjLCAxNiwgYywgMzIsIGQgLSAzMiwgYyk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBjW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfb3BlbihtLGMsZCxuLGspIHtcbiAgdmFyIGk7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW0oeCwwLDMyLG4sayk7XG4gIGlmIChjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5KGMsIDE2LGMsIDMyLGQgLSAzMix4KSAhPT0gMCkgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtX3hvcihtLDAsYywwLGQsbixrKTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIG1baV0gPSAwO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gc2V0MjU1MTkociwgYSkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHJbaV0gPSBhW2ldfDA7XG59XG5cbmZ1bmN0aW9uIGNhcjI1NTE5KG8pIHtcbiAgdmFyIGksIHYsIGMgPSAxO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHYgPSBvW2ldICsgYyArIDY1NTM1O1xuICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgb1tpXSA9IHYgLSBjICogNjU1MzY7XG4gIH1cbiAgb1swXSArPSBjLTEgKyAzNyAqIChjLTEpO1xufVxuXG5mdW5jdGlvbiBzZWwyNTUxOShwLCBxLCBiKSB7XG4gIHZhciB0LCBjID0gfihiLTEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB0ID0gYyAmIChwW2ldIF4gcVtpXSk7XG4gICAgcFtpXSBePSB0O1xuICAgIHFbaV0gXj0gdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWNrMjU1MTkobywgbikge1xuICB2YXIgaSwgaiwgYjtcbiAgdmFyIG0gPSBnZigpLCB0ID0gZ2YoKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHRbaV0gPSBuW2ldO1xuICBjYXIyNTUxOSh0KTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBmb3IgKGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgbVswXSA9IHRbMF0gLSAweGZmZWQ7XG4gICAgZm9yIChpID0gMTsgaSA8IDE1OyBpKyspIHtcbiAgICAgIG1baV0gPSB0W2ldIC0gMHhmZmZmIC0gKChtW2ktMV0+PjE2KSAmIDEpO1xuICAgICAgbVtpLTFdICY9IDB4ZmZmZjtcbiAgICB9XG4gICAgbVsxNV0gPSB0WzE1XSAtIDB4N2ZmZiAtICgobVsxNF0+PjE2KSAmIDEpO1xuICAgIGIgPSAobVsxNV0+PjE2KSAmIDE7XG4gICAgbVsxNF0gJj0gMHhmZmZmO1xuICAgIHNlbDI1NTE5KHQsIG0sIDEtYik7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBvWzIqaV0gPSB0W2ldICYgMHhmZjtcbiAgICBvWzIqaSsxXSA9IHRbaV0+Pjg7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVxMjU1MTkoYSwgYikge1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KDMyKSwgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGMsIGEpO1xuICBwYWNrMjU1MTkoZCwgYik7XG4gIHJldHVybiBjcnlwdG9fdmVyaWZ5XzMyKGMsIDAsIGQsIDApO1xufVxuXG5mdW5jdGlvbiBwYXIyNTUxOShhKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBwYWNrMjU1MTkoZCwgYSk7XG4gIHJldHVybiBkWzBdICYgMTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrMjU1MTkobywgbikge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBuWzIqaV0gKyAoblsyKmkrMV0gPDwgOCk7XG4gIG9bMTVdICY9IDB4N2ZmZjtcbn1cblxuZnVuY3Rpb24gQShvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gKyBiW2ldO1xufVxuXG5mdW5jdGlvbiBaKG8sIGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gYVtpXSAtIGJbaV07XG59XG5cbmZ1bmN0aW9uIE0obywgYSwgYikge1xuICB2YXIgdiwgYyxcbiAgICAgdDAgPSAwLCAgdDEgPSAwLCAgdDIgPSAwLCAgdDMgPSAwLCAgdDQgPSAwLCAgdDUgPSAwLCAgdDYgPSAwLCAgdDcgPSAwLFxuICAgICB0OCA9IDAsICB0OSA9IDAsIHQxMCA9IDAsIHQxMSA9IDAsIHQxMiA9IDAsIHQxMyA9IDAsIHQxNCA9IDAsIHQxNSA9IDAsXG4gICAgdDE2ID0gMCwgdDE3ID0gMCwgdDE4ID0gMCwgdDE5ID0gMCwgdDIwID0gMCwgdDIxID0gMCwgdDIyID0gMCwgdDIzID0gMCxcbiAgICB0MjQgPSAwLCB0MjUgPSAwLCB0MjYgPSAwLCB0MjcgPSAwLCB0MjggPSAwLCB0MjkgPSAwLCB0MzAgPSAwLFxuICAgIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdLFxuICAgIGIzID0gYlszXSxcbiAgICBiNCA9IGJbNF0sXG4gICAgYjUgPSBiWzVdLFxuICAgIGI2ID0gYls2XSxcbiAgICBiNyA9IGJbN10sXG4gICAgYjggPSBiWzhdLFxuICAgIGI5ID0gYls5XSxcbiAgICBiMTAgPSBiWzEwXSxcbiAgICBiMTEgPSBiWzExXSxcbiAgICBiMTIgPSBiWzEyXSxcbiAgICBiMTMgPSBiWzEzXSxcbiAgICBiMTQgPSBiWzE0XSxcbiAgICBiMTUgPSBiWzE1XTtcblxuICB2ID0gYVswXTtcbiAgdDAgKz0gdiAqIGIwO1xuICB0MSArPSB2ICogYjE7XG4gIHQyICs9IHYgKiBiMjtcbiAgdDMgKz0gdiAqIGIzO1xuICB0NCArPSB2ICogYjQ7XG4gIHQ1ICs9IHYgKiBiNTtcbiAgdDYgKz0gdiAqIGI2O1xuICB0NyArPSB2ICogYjc7XG4gIHQ4ICs9IHYgKiBiODtcbiAgdDkgKz0gdiAqIGI5O1xuICB0MTAgKz0gdiAqIGIxMDtcbiAgdDExICs9IHYgKiBiMTE7XG4gIHQxMiArPSB2ICogYjEyO1xuICB0MTMgKz0gdiAqIGIxMztcbiAgdDE0ICs9IHYgKiBiMTQ7XG4gIHQxNSArPSB2ICogYjE1O1xuICB2ID0gYVsxXTtcbiAgdDEgKz0gdiAqIGIwO1xuICB0MiArPSB2ICogYjE7XG4gIHQzICs9IHYgKiBiMjtcbiAgdDQgKz0gdiAqIGIzO1xuICB0NSArPSB2ICogYjQ7XG4gIHQ2ICs9IHYgKiBiNTtcbiAgdDcgKz0gdiAqIGI2O1xuICB0OCArPSB2ICogYjc7XG4gIHQ5ICs9IHYgKiBiODtcbiAgdDEwICs9IHYgKiBiOTtcbiAgdDExICs9IHYgKiBiMTA7XG4gIHQxMiArPSB2ICogYjExO1xuICB0MTMgKz0gdiAqIGIxMjtcbiAgdDE0ICs9IHYgKiBiMTM7XG4gIHQxNSArPSB2ICogYjE0O1xuICB0MTYgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMl07XG4gIHQyICs9IHYgKiBiMDtcbiAgdDMgKz0gdiAqIGIxO1xuICB0NCArPSB2ICogYjI7XG4gIHQ1ICs9IHYgKiBiMztcbiAgdDYgKz0gdiAqIGI0O1xuICB0NyArPSB2ICogYjU7XG4gIHQ4ICs9IHYgKiBiNjtcbiAgdDkgKz0gdiAqIGI3O1xuICB0MTAgKz0gdiAqIGI4O1xuICB0MTEgKz0gdiAqIGI5O1xuICB0MTIgKz0gdiAqIGIxMDtcbiAgdDEzICs9IHYgKiBiMTE7XG4gIHQxNCArPSB2ICogYjEyO1xuICB0MTUgKz0gdiAqIGIxMztcbiAgdDE2ICs9IHYgKiBiMTQ7XG4gIHQxNyArPSB2ICogYjE1O1xuICB2ID0gYVszXTtcbiAgdDMgKz0gdiAqIGIwO1xuICB0NCArPSB2ICogYjE7XG4gIHQ1ICs9IHYgKiBiMjtcbiAgdDYgKz0gdiAqIGIzO1xuICB0NyArPSB2ICogYjQ7XG4gIHQ4ICs9IHYgKiBiNTtcbiAgdDkgKz0gdiAqIGI2O1xuICB0MTAgKz0gdiAqIGI3O1xuICB0MTEgKz0gdiAqIGI4O1xuICB0MTIgKz0gdiAqIGI5O1xuICB0MTMgKz0gdiAqIGIxMDtcbiAgdDE0ICs9IHYgKiBiMTE7XG4gIHQxNSArPSB2ICogYjEyO1xuICB0MTYgKz0gdiAqIGIxMztcbiAgdDE3ICs9IHYgKiBiMTQ7XG4gIHQxOCArPSB2ICogYjE1O1xuICB2ID0gYVs0XTtcbiAgdDQgKz0gdiAqIGIwO1xuICB0NSArPSB2ICogYjE7XG4gIHQ2ICs9IHYgKiBiMjtcbiAgdDcgKz0gdiAqIGIzO1xuICB0OCArPSB2ICogYjQ7XG4gIHQ5ICs9IHYgKiBiNTtcbiAgdDEwICs9IHYgKiBiNjtcbiAgdDExICs9IHYgKiBiNztcbiAgdDEyICs9IHYgKiBiODtcbiAgdDEzICs9IHYgKiBiOTtcbiAgdDE0ICs9IHYgKiBiMTA7XG4gIHQxNSArPSB2ICogYjExO1xuICB0MTYgKz0gdiAqIGIxMjtcbiAgdDE3ICs9IHYgKiBiMTM7XG4gIHQxOCArPSB2ICogYjE0O1xuICB0MTkgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNV07XG4gIHQ1ICs9IHYgKiBiMDtcbiAgdDYgKz0gdiAqIGIxO1xuICB0NyArPSB2ICogYjI7XG4gIHQ4ICs9IHYgKiBiMztcbiAgdDkgKz0gdiAqIGI0O1xuICB0MTAgKz0gdiAqIGI1O1xuICB0MTEgKz0gdiAqIGI2O1xuICB0MTIgKz0gdiAqIGI3O1xuICB0MTMgKz0gdiAqIGI4O1xuICB0MTQgKz0gdiAqIGI5O1xuICB0MTUgKz0gdiAqIGIxMDtcbiAgdDE2ICs9IHYgKiBiMTE7XG4gIHQxNyArPSB2ICogYjEyO1xuICB0MTggKz0gdiAqIGIxMztcbiAgdDE5ICs9IHYgKiBiMTQ7XG4gIHQyMCArPSB2ICogYjE1O1xuICB2ID0gYVs2XTtcbiAgdDYgKz0gdiAqIGIwO1xuICB0NyArPSB2ICogYjE7XG4gIHQ4ICs9IHYgKiBiMjtcbiAgdDkgKz0gdiAqIGIzO1xuICB0MTAgKz0gdiAqIGI0O1xuICB0MTEgKz0gdiAqIGI1O1xuICB0MTIgKz0gdiAqIGI2O1xuICB0MTMgKz0gdiAqIGI3O1xuICB0MTQgKz0gdiAqIGI4O1xuICB0MTUgKz0gdiAqIGI5O1xuICB0MTYgKz0gdiAqIGIxMDtcbiAgdDE3ICs9IHYgKiBiMTE7XG4gIHQxOCArPSB2ICogYjEyO1xuICB0MTkgKz0gdiAqIGIxMztcbiAgdDIwICs9IHYgKiBiMTQ7XG4gIHQyMSArPSB2ICogYjE1O1xuICB2ID0gYVs3XTtcbiAgdDcgKz0gdiAqIGIwO1xuICB0OCArPSB2ICogYjE7XG4gIHQ5ICs9IHYgKiBiMjtcbiAgdDEwICs9IHYgKiBiMztcbiAgdDExICs9IHYgKiBiNDtcbiAgdDEyICs9IHYgKiBiNTtcbiAgdDEzICs9IHYgKiBiNjtcbiAgdDE0ICs9IHYgKiBiNztcbiAgdDE1ICs9IHYgKiBiODtcbiAgdDE2ICs9IHYgKiBiOTtcbiAgdDE3ICs9IHYgKiBiMTA7XG4gIHQxOCArPSB2ICogYjExO1xuICB0MTkgKz0gdiAqIGIxMjtcbiAgdDIwICs9IHYgKiBiMTM7XG4gIHQyMSArPSB2ICogYjE0O1xuICB0MjIgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOF07XG4gIHQ4ICs9IHYgKiBiMDtcbiAgdDkgKz0gdiAqIGIxO1xuICB0MTAgKz0gdiAqIGIyO1xuICB0MTEgKz0gdiAqIGIzO1xuICB0MTIgKz0gdiAqIGI0O1xuICB0MTMgKz0gdiAqIGI1O1xuICB0MTQgKz0gdiAqIGI2O1xuICB0MTUgKz0gdiAqIGI3O1xuICB0MTYgKz0gdiAqIGI4O1xuICB0MTcgKz0gdiAqIGI5O1xuICB0MTggKz0gdiAqIGIxMDtcbiAgdDE5ICs9IHYgKiBiMTE7XG4gIHQyMCArPSB2ICogYjEyO1xuICB0MjEgKz0gdiAqIGIxMztcbiAgdDIyICs9IHYgKiBiMTQ7XG4gIHQyMyArPSB2ICogYjE1O1xuICB2ID0gYVs5XTtcbiAgdDkgKz0gdiAqIGIwO1xuICB0MTAgKz0gdiAqIGIxO1xuICB0MTEgKz0gdiAqIGIyO1xuICB0MTIgKz0gdiAqIGIzO1xuICB0MTMgKz0gdiAqIGI0O1xuICB0MTQgKz0gdiAqIGI1O1xuICB0MTUgKz0gdiAqIGI2O1xuICB0MTYgKz0gdiAqIGI3O1xuICB0MTcgKz0gdiAqIGI4O1xuICB0MTggKz0gdiAqIGI5O1xuICB0MTkgKz0gdiAqIGIxMDtcbiAgdDIwICs9IHYgKiBiMTE7XG4gIHQyMSArPSB2ICogYjEyO1xuICB0MjIgKz0gdiAqIGIxMztcbiAgdDIzICs9IHYgKiBiMTQ7XG4gIHQyNCArPSB2ICogYjE1O1xuICB2ID0gYVsxMF07XG4gIHQxMCArPSB2ICogYjA7XG4gIHQxMSArPSB2ICogYjE7XG4gIHQxMiArPSB2ICogYjI7XG4gIHQxMyArPSB2ICogYjM7XG4gIHQxNCArPSB2ICogYjQ7XG4gIHQxNSArPSB2ICogYjU7XG4gIHQxNiArPSB2ICogYjY7XG4gIHQxNyArPSB2ICogYjc7XG4gIHQxOCArPSB2ICogYjg7XG4gIHQxOSArPSB2ICogYjk7XG4gIHQyMCArPSB2ICogYjEwO1xuICB0MjEgKz0gdiAqIGIxMTtcbiAgdDIyICs9IHYgKiBiMTI7XG4gIHQyMyArPSB2ICogYjEzO1xuICB0MjQgKz0gdiAqIGIxNDtcbiAgdDI1ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzExXTtcbiAgdDExICs9IHYgKiBiMDtcbiAgdDEyICs9IHYgKiBiMTtcbiAgdDEzICs9IHYgKiBiMjtcbiAgdDE0ICs9IHYgKiBiMztcbiAgdDE1ICs9IHYgKiBiNDtcbiAgdDE2ICs9IHYgKiBiNTtcbiAgdDE3ICs9IHYgKiBiNjtcbiAgdDE4ICs9IHYgKiBiNztcbiAgdDE5ICs9IHYgKiBiODtcbiAgdDIwICs9IHYgKiBiOTtcbiAgdDIxICs9IHYgKiBiMTA7XG4gIHQyMiArPSB2ICogYjExO1xuICB0MjMgKz0gdiAqIGIxMjtcbiAgdDI0ICs9IHYgKiBiMTM7XG4gIHQyNSArPSB2ICogYjE0O1xuICB0MjYgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTJdO1xuICB0MTIgKz0gdiAqIGIwO1xuICB0MTMgKz0gdiAqIGIxO1xuICB0MTQgKz0gdiAqIGIyO1xuICB0MTUgKz0gdiAqIGIzO1xuICB0MTYgKz0gdiAqIGI0O1xuICB0MTcgKz0gdiAqIGI1O1xuICB0MTggKz0gdiAqIGI2O1xuICB0MTkgKz0gdiAqIGI3O1xuICB0MjAgKz0gdiAqIGI4O1xuICB0MjEgKz0gdiAqIGI5O1xuICB0MjIgKz0gdiAqIGIxMDtcbiAgdDIzICs9IHYgKiBiMTE7XG4gIHQyNCArPSB2ICogYjEyO1xuICB0MjUgKz0gdiAqIGIxMztcbiAgdDI2ICs9IHYgKiBiMTQ7XG4gIHQyNyArPSB2ICogYjE1O1xuICB2ID0gYVsxM107XG4gIHQxMyArPSB2ICogYjA7XG4gIHQxNCArPSB2ICogYjE7XG4gIHQxNSArPSB2ICogYjI7XG4gIHQxNiArPSB2ICogYjM7XG4gIHQxNyArPSB2ICogYjQ7XG4gIHQxOCArPSB2ICogYjU7XG4gIHQxOSArPSB2ICogYjY7XG4gIHQyMCArPSB2ICogYjc7XG4gIHQyMSArPSB2ICogYjg7XG4gIHQyMiArPSB2ICogYjk7XG4gIHQyMyArPSB2ICogYjEwO1xuICB0MjQgKz0gdiAqIGIxMTtcbiAgdDI1ICs9IHYgKiBiMTI7XG4gIHQyNiArPSB2ICogYjEzO1xuICB0MjcgKz0gdiAqIGIxNDtcbiAgdDI4ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE0XTtcbiAgdDE0ICs9IHYgKiBiMDtcbiAgdDE1ICs9IHYgKiBiMTtcbiAgdDE2ICs9IHYgKiBiMjtcbiAgdDE3ICs9IHYgKiBiMztcbiAgdDE4ICs9IHYgKiBiNDtcbiAgdDE5ICs9IHYgKiBiNTtcbiAgdDIwICs9IHYgKiBiNjtcbiAgdDIxICs9IHYgKiBiNztcbiAgdDIyICs9IHYgKiBiODtcbiAgdDIzICs9IHYgKiBiOTtcbiAgdDI0ICs9IHYgKiBiMTA7XG4gIHQyNSArPSB2ICogYjExO1xuICB0MjYgKz0gdiAqIGIxMjtcbiAgdDI3ICs9IHYgKiBiMTM7XG4gIHQyOCArPSB2ICogYjE0O1xuICB0MjkgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTVdO1xuICB0MTUgKz0gdiAqIGIwO1xuICB0MTYgKz0gdiAqIGIxO1xuICB0MTcgKz0gdiAqIGIyO1xuICB0MTggKz0gdiAqIGIzO1xuICB0MTkgKz0gdiAqIGI0O1xuICB0MjAgKz0gdiAqIGI1O1xuICB0MjEgKz0gdiAqIGI2O1xuICB0MjIgKz0gdiAqIGI3O1xuICB0MjMgKz0gdiAqIGI4O1xuICB0MjQgKz0gdiAqIGI5O1xuICB0MjUgKz0gdiAqIGIxMDtcbiAgdDI2ICs9IHYgKiBiMTE7XG4gIHQyNyArPSB2ICogYjEyO1xuICB0MjggKz0gdiAqIGIxMztcbiAgdDI5ICs9IHYgKiBiMTQ7XG4gIHQzMCArPSB2ICogYjE1O1xuXG4gIHQwICArPSAzOCAqIHQxNjtcbiAgdDEgICs9IDM4ICogdDE3O1xuICB0MiAgKz0gMzggKiB0MTg7XG4gIHQzICArPSAzOCAqIHQxOTtcbiAgdDQgICs9IDM4ICogdDIwO1xuICB0NSAgKz0gMzggKiB0MjE7XG4gIHQ2ICArPSAzOCAqIHQyMjtcbiAgdDcgICs9IDM4ICogdDIzO1xuICB0OCAgKz0gMzggKiB0MjQ7XG4gIHQ5ICArPSAzOCAqIHQyNTtcbiAgdDEwICs9IDM4ICogdDI2O1xuICB0MTEgKz0gMzggKiB0Mjc7XG4gIHQxMiArPSAzOCAqIHQyODtcbiAgdDEzICs9IDM4ICogdDI5O1xuICB0MTQgKz0gMzggKiB0MzA7XG4gIC8vIHQxNSBsZWZ0IGFzIGlzXG5cbiAgLy8gZmlyc3QgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIC8vIHNlY29uZCBjYXJcbiAgYyA9IDE7XG4gIHYgPSAgdDAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDYgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDcgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDggKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDkgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNSA9IHYgLSBjICogNjU1MzY7XG4gIHQwICs9IGMtMSArIDM3ICogKGMtMSk7XG5cbiAgb1sgMF0gPSB0MDtcbiAgb1sgMV0gPSB0MTtcbiAgb1sgMl0gPSB0MjtcbiAgb1sgM10gPSB0MztcbiAgb1sgNF0gPSB0NDtcbiAgb1sgNV0gPSB0NTtcbiAgb1sgNl0gPSB0NjtcbiAgb1sgN10gPSB0NztcbiAgb1sgOF0gPSB0ODtcbiAgb1sgOV0gPSB0OTtcbiAgb1sxMF0gPSB0MTA7XG4gIG9bMTFdID0gdDExO1xuICBvWzEyXSA9IHQxMjtcbiAgb1sxM10gPSB0MTM7XG4gIG9bMTRdID0gdDE0O1xuICBvWzE1XSA9IHQxNTtcbn1cblxuZnVuY3Rpb24gUyhvLCBhKSB7XG4gIE0obywgYSwgYSk7XG59XG5cbmZ1bmN0aW9uIGludjI1NTE5KG8sIGkpIHtcbiAgdmFyIGMgPSBnZigpO1xuICB2YXIgYTtcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIGNbYV0gPSBpW2FdO1xuICBmb3IgKGEgPSAyNTM7IGEgPj0gMDsgYS0tKSB7XG4gICAgUyhjLCBjKTtcbiAgICBpZihhICE9PSAyICYmIGEgIT09IDQpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBwb3cyNTIzKG8sIGkpIHtcbiAgdmFyIGMgPSBnZigpO1xuICB2YXIgYTtcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIGNbYV0gPSBpW2FdO1xuICBmb3IgKGEgPSAyNTA7IGEgPj0gMDsgYS0tKSB7XG4gICAgICBTKGMsIGMpO1xuICAgICAgaWYoYSAhPT0gMSkgTShjLCBjLCBpKTtcbiAgfVxuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgb1thXSA9IGNbYV07XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIHApIHtcbiAgY2hlY2socSwgY3J5cHRvX3NjYWxhcm11bHRfQllURVMpXG4gIGNoZWNrKG4sIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKVxuICBjaGVjayhwLCBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUylcbiAgdmFyIHogPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg4MCksIHIsIGk7XG4gIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLFxuICAgICAgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKTtcbiAgZm9yIChpID0gMDsgaSA8IDMxOyBpKyspIHpbaV0gPSBuW2ldO1xuICB6WzMxXT0oblszMV0mMTI3KXw2NDtcbiAgelswXSY9MjQ4O1xuICB1bnBhY2syNTUxOSh4LHApO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGJbaV09eFtpXTtcbiAgICBkW2ldPWFbaV09Y1tpXT0wO1xuICB9XG4gIGFbMF09ZFswXT0xO1xuICBmb3IgKGk9MjU0OyBpPj0wOyAtLWkpIHtcbiAgICByPSh6W2k+Pj4zXT4+PihpJjcpKSYxO1xuICAgIHNlbDI1NTE5KGEsYixyKTtcbiAgICBzZWwyNTUxOShjLGQscik7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgQShjLGIsZCk7XG4gICAgWihiLGIsZCk7XG4gICAgUyhkLGUpO1xuICAgIFMoZixhKTtcbiAgICBNKGEsYyxhKTtcbiAgICBNKGMsYixlKTtcbiAgICBBKGUsYSxjKTtcbiAgICBaKGEsYSxjKTtcbiAgICBTKGIsYSk7XG4gICAgWihjLGQsZik7XG4gICAgTShhLGMsXzEyMTY2NSk7XG4gICAgQShhLGEsZCk7XG4gICAgTShjLGMsYSk7XG4gICAgTShhLGQsZik7XG4gICAgTShkLGIseCk7XG4gICAgUyhiLGUpO1xuICAgIHNlbDI1NTE5KGEsYixyKTtcbiAgICBzZWwyNTUxOShjLGQscik7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB4W2krMTZdPWFbaV07XG4gICAgeFtpKzMyXT1jW2ldO1xuICAgIHhbaSs0OF09YltpXTtcbiAgICB4W2krNjRdPWRbaV07XG4gIH1cbiAgdmFyIHgzMiA9IHguc3ViYXJyYXkoMzIpO1xuICB2YXIgeDE2ID0geC5zdWJhcnJheSgxNik7XG4gIGludjI1NTE5KHgzMix4MzIpO1xuICBNKHgxNix4MTYseDMyKTtcbiAgcGFjazI1NTE5KHEseDE2KTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbikge1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgXzkpO1xufVxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxuZnVuY3Rpb24gY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCBtLCBuKSB7XG4gIHZhciB3aCA9IG5ldyBJbnQzMkFycmF5KDE2KSwgd2wgPSBuZXcgSW50MzJBcnJheSgxNiksXG4gICAgICBiaDAsIGJoMSwgYmgyLCBiaDMsIGJoNCwgYmg1LCBiaDYsIGJoNyxcbiAgICAgIGJsMCwgYmwxLCBibDIsIGJsMywgYmw0LCBibDUsIGJsNiwgYmw3LFxuICAgICAgdGgsIHRsLCBpLCBqLCBoLCBsLCBhLCBiLCBjLCBkO1xuXG4gIHZhciBhaDAgPSBoaFswXSxcbiAgICAgIGFoMSA9IGhoWzFdLFxuICAgICAgYWgyID0gaGhbMl0sXG4gICAgICBhaDMgPSBoaFszXSxcbiAgICAgIGFoNCA9IGhoWzRdLFxuICAgICAgYWg1ID0gaGhbNV0sXG4gICAgICBhaDYgPSBoaFs2XSxcbiAgICAgIGFoNyA9IGhoWzddLFxuXG4gICAgICBhbDAgPSBobFswXSxcbiAgICAgIGFsMSA9IGhsWzFdLFxuICAgICAgYWwyID0gaGxbMl0sXG4gICAgICBhbDMgPSBobFszXSxcbiAgICAgIGFsNCA9IGhsWzRdLFxuICAgICAgYWw1ID0gaGxbNV0sXG4gICAgICBhbDYgPSBobFs2XSxcbiAgICAgIGFsNyA9IGhsWzddO1xuXG4gIHZhciBwb3MgPSAwO1xuICB3aGlsZSAobiA+PSAxMjgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgaiA9IDggKiBpICsgcG9zO1xuICAgICAgd2hbaV0gPSAobVtqKzBdIDw8IDI0KSB8IChtW2orMV0gPDwgMTYpIHwgKG1baisyXSA8PCA4KSB8IG1baiszXTtcbiAgICAgIHdsW2ldID0gKG1bais0XSA8PCAyNCkgfCAobVtqKzVdIDw8IDE2KSB8IChtW2orNl0gPDwgOCkgfCBtW2orN107XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICBiaDAgPSBhaDA7XG4gICAgICBiaDEgPSBhaDE7XG4gICAgICBiaDIgPSBhaDI7XG4gICAgICBiaDMgPSBhaDM7XG4gICAgICBiaDQgPSBhaDQ7XG4gICAgICBiaDUgPSBhaDU7XG4gICAgICBiaDYgPSBhaDY7XG4gICAgICBiaDcgPSBhaDc7XG5cbiAgICAgIGJsMCA9IGFsMDtcbiAgICAgIGJsMSA9IGFsMTtcbiAgICAgIGJsMiA9IGFsMjtcbiAgICAgIGJsMyA9IGFsMztcbiAgICAgIGJsNCA9IGFsNDtcbiAgICAgIGJsNSA9IGFsNTtcbiAgICAgIGJsNiA9IGFsNjtcbiAgICAgIGJsNyA9IGFsNztcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gYWg3O1xuICAgICAgbCA9IGFsNztcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIFNpZ21hMVxuICAgICAgaCA9ICgoYWg0ID4+PiAxNCkgfCAoYWw0IDw8ICgzMi0xNCkpKSBeICgoYWg0ID4+PiAxOCkgfCAoYWw0IDw8ICgzMi0xOCkpKSBeICgoYWw0ID4+PiAoNDEtMzIpKSB8IChhaDQgPDwgKDMyLSg0MS0zMikpKSk7XG4gICAgICBsID0gKChhbDQgPj4+IDE0KSB8IChhaDQgPDwgKDMyLTE0KSkpIF4gKChhbDQgPj4+IDE4KSB8IChhaDQgPDwgKDMyLTE4KSkpIF4gKChhaDQgPj4+ICg0MS0zMikpIHwgKGFsNCA8PCAoMzItKDQxLTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBDaFxuICAgICAgaCA9IChhaDQgJiBhaDUpIF4gKH5haDQgJiBhaDYpO1xuICAgICAgbCA9IChhbDQgJiBhbDUpIF4gKH5hbDQgJiBhbDYpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIEtcbiAgICAgIGggPSBLW2kqMl07XG4gICAgICBsID0gS1tpKjIrMV07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gd1xuICAgICAgaCA9IHdoW2klMTZdO1xuICAgICAgbCA9IHdsW2klMTZdO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgdGggPSBjICYgMHhmZmZmIHwgZCA8PCAxNjtcbiAgICAgIHRsID0gYSAmIDB4ZmZmZiB8IGIgPDwgMTY7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWEwXG4gICAgICBoID0gKChhaDAgPj4+IDI4KSB8IChhbDAgPDwgKDMyLTI4KSkpIF4gKChhbDAgPj4+ICgzNC0zMikpIHwgKGFoMCA8PCAoMzItKDM0LTMyKSkpKSBeICgoYWwwID4+PiAoMzktMzIpKSB8IChhaDAgPDwgKDMyLSgzOS0zMikpKSk7XG4gICAgICBsID0gKChhbDAgPj4+IDI4KSB8IChhaDAgPDwgKDMyLTI4KSkpIF4gKChhaDAgPj4+ICgzNC0zMikpIHwgKGFsMCA8PCAoMzItKDM0LTMyKSkpKSBeICgoYWgwID4+PiAoMzktMzIpKSB8IChhbDAgPDwgKDMyLSgzOS0zMikpKSk7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gTWFqXG4gICAgICBoID0gKGFoMCAmIGFoMSkgXiAoYWgwICYgYWgyKSBeIChhaDEgJiBhaDIpO1xuICAgICAgbCA9IChhbDAgJiBhbDEpIF4gKGFsMCAmIGFsMikgXiAoYWwxICYgYWwyKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIGJoNyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICAgIGJsNyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gYmgzO1xuICAgICAgbCA9IGJsMztcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIGggPSB0aDtcbiAgICAgIGwgPSB0bDtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIGJoMyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICAgIGJsMyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgICAgYWgxID0gYmgwO1xuICAgICAgYWgyID0gYmgxO1xuICAgICAgYWgzID0gYmgyO1xuICAgICAgYWg0ID0gYmgzO1xuICAgICAgYWg1ID0gYmg0O1xuICAgICAgYWg2ID0gYmg1O1xuICAgICAgYWg3ID0gYmg2O1xuICAgICAgYWgwID0gYmg3O1xuXG4gICAgICBhbDEgPSBibDA7XG4gICAgICBhbDIgPSBibDE7XG4gICAgICBhbDMgPSBibDI7XG4gICAgICBhbDQgPSBibDM7XG4gICAgICBhbDUgPSBibDQ7XG4gICAgICBhbDYgPSBibDU7XG4gICAgICBhbDcgPSBibDY7XG4gICAgICBhbDAgPSBibDc7XG5cbiAgICAgIGlmIChpJTE2ID09PSAxNSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgICAgIC8vIGFkZFxuICAgICAgICAgIGggPSB3aFtqXTtcbiAgICAgICAgICBsID0gd2xbal07XG5cbiAgICAgICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBoID0gd2hbKGorOSklMTZdO1xuICAgICAgICAgIGwgPSB3bFsoais5KSUxNl07XG5cbiAgICAgICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAgICAgLy8gc2lnbWEwXG4gICAgICAgICAgdGggPSB3aFsoaisxKSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxKSUxNl07XG4gICAgICAgICAgaCA9ICgodGggPj4+IDEpIHwgKHRsIDw8ICgzMi0xKSkpIF4gKCh0aCA+Pj4gOCkgfCAodGwgPDwgKDMyLTgpKSkgXiAodGggPj4+IDcpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxKSB8ICh0aCA8PCAoMzItMSkpKSBeICgodGwgPj4+IDgpIHwgKHRoIDw8ICgzMi04KSkpIF4gKCh0bCA+Pj4gNykgfCAodGggPDwgKDMyLTcpKSk7XG5cbiAgICAgICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAgICAgLy8gc2lnbWExXG4gICAgICAgICAgdGggPSB3aFsoaisxNCklMTZdO1xuICAgICAgICAgIHRsID0gd2xbKGorMTQpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMTkpIHwgKHRsIDw8ICgzMi0xOSkpKSBeICgodGwgPj4+ICg2MS0zMikpIHwgKHRoIDw8ICgzMi0oNjEtMzIpKSkpIF4gKHRoID4+PiA2KTtcbiAgICAgICAgICBsID0gKCh0bCA+Pj4gMTkpIHwgKHRoIDw8ICgzMi0xOSkpKSBeICgodGggPj4+ICg2MS0zMikpIHwgKHRsIDw8ICgzMi0oNjEtMzIpKSkpIF4gKCh0bCA+Pj4gNikgfCAodGggPDwgKDMyLTYpKSk7XG5cbiAgICAgICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgICAgICB3aFtqXSA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICAgICAgICB3bFtqXSA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZFxuICAgIGggPSBhaDA7XG4gICAgbCA9IGFsMDtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFswXTtcbiAgICBsID0gaGxbMF07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFswXSA9IGFoMCA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFswXSA9IGFsMCA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDE7XG4gICAgbCA9IGFsMTtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFsxXTtcbiAgICBsID0gaGxbMV07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFsxXSA9IGFoMSA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFsxXSA9IGFsMSA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDI7XG4gICAgbCA9IGFsMjtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFsyXTtcbiAgICBsID0gaGxbMl07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFsyXSA9IGFoMiA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFsyXSA9IGFsMiA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDM7XG4gICAgbCA9IGFsMztcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFszXTtcbiAgICBsID0gaGxbM107XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFszXSA9IGFoMyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFszXSA9IGFsMyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDQ7XG4gICAgbCA9IGFsNDtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs0XTtcbiAgICBsID0gaGxbNF07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs0XSA9IGFoNCA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs0XSA9IGFsNCA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDU7XG4gICAgbCA9IGFsNTtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs1XTtcbiAgICBsID0gaGxbNV07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs1XSA9IGFoNSA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs1XSA9IGFsNSA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDY7XG4gICAgbCA9IGFsNjtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs2XTtcbiAgICBsID0gaGxbNl07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs2XSA9IGFoNiA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs2XSA9IGFsNiA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDc7XG4gICAgbCA9IGFsNztcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs3XTtcbiAgICBsID0gaGxbN107XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs3XSA9IGFoNyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs3XSA9IGFsNyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIHBvcyArPSAxMjg7XG4gICAgbiAtPSAxMjg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2hhc2gob3V0LCBtLCBuKSB7XG4gIHZhciBoaCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgaGwgPSBuZXcgSW50MzJBcnJheSg4KSxcbiAgICAgIHggPSBuZXcgVWludDhBcnJheSgyNTYpLFxuICAgICAgaSwgYiA9IG47XG5cbiAgaGhbMF0gPSAweDZhMDllNjY3O1xuICBoaFsxXSA9IDB4YmI2N2FlODU7XG4gIGhoWzJdID0gMHgzYzZlZjM3MjtcbiAgaGhbM10gPSAweGE1NGZmNTNhO1xuICBoaFs0XSA9IDB4NTEwZTUyN2Y7XG4gIGhoWzVdID0gMHg5YjA1Njg4YztcbiAgaGhbNl0gPSAweDFmODNkOWFiO1xuICBoaFs3XSA9IDB4NWJlMGNkMTk7XG5cbiAgaGxbMF0gPSAweGYzYmNjOTA4O1xuICBobFsxXSA9IDB4ODRjYWE3M2I7XG4gIGhsWzJdID0gMHhmZTk0ZjgyYjtcbiAgaGxbM10gPSAweDVmMWQzNmYxO1xuICBobFs0XSA9IDB4YWRlNjgyZDE7XG4gIGhsWzVdID0gMHgyYjNlNmMxZjtcbiAgaGxbNl0gPSAweGZiNDFiZDZiO1xuICBobFs3XSA9IDB4MTM3ZTIxNzk7XG5cbiAgY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCBtLCBuKTtcbiAgbiAlPSAxMjg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IG1bYi1uK2ldO1xuICB4W25dID0gMTI4O1xuXG4gIG4gPSAyNTYtMTI4KihuPDExMj8xOjApO1xuICB4W24tOV0gPSAwO1xuICB0czY0KHgsIG4tOCwgIChiIC8gMHgyMDAwMDAwMCkgfCAwLCBiIDw8IDMpO1xuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIHgsIG4pO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHRzNjQob3V0LCA4KmksIGhoW2ldLCBobFtpXSk7XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGFkZChwLCBxKSB7XG4gIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLFxuICAgICAgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKSxcbiAgICAgIGcgPSBnZigpLCBoID0gZ2YoKSwgdCA9IGdmKCk7XG5cbiAgWihhLCBwWzFdLCBwWzBdKTtcbiAgWih0LCBxWzFdLCBxWzBdKTtcbiAgTShhLCBhLCB0KTtcbiAgQShiLCBwWzBdLCBwWzFdKTtcbiAgQSh0LCBxWzBdLCBxWzFdKTtcbiAgTShiLCBiLCB0KTtcbiAgTShjLCBwWzNdLCBxWzNdKTtcbiAgTShjLCBjLCBEMik7XG4gIE0oZCwgcFsyXSwgcVsyXSk7XG4gIEEoZCwgZCwgZCk7XG4gIFooZSwgYiwgYSk7XG4gIFooZiwgZCwgYyk7XG4gIEEoZywgZCwgYyk7XG4gIEEoaCwgYiwgYSk7XG5cbiAgTShwWzBdLCBlLCBmKTtcbiAgTShwWzFdLCBoLCBnKTtcbiAgTShwWzJdLCBnLCBmKTtcbiAgTShwWzNdLCBlLCBoKTtcbn1cblxuZnVuY3Rpb24gY3N3YXAocCwgcSwgYikge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHNlbDI1NTE5KHBbaV0sIHFbaV0sIGIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhY2sociwgcCkge1xuICB2YXIgdHggPSBnZigpLCB0eSA9IGdmKCksIHppID0gZ2YoKTtcbiAgaW52MjU1MTkoemksIHBbMl0pO1xuICBNKHR4LCBwWzBdLCB6aSk7XG4gIE0odHksIHBbMV0sIHppKTtcbiAgcGFjazI1NTE5KHIsIHR5KTtcbiAgclszMV0gXj0gcGFyMjU1MTkodHgpIDw8IDc7XG59XG5cbmZ1bmN0aW9uIHNjYWxhcm11bHQocCwgcSwgcykge1xuICB2YXIgYiwgaTtcbiAgc2V0MjU1MTkocFswXSwgZ2YwKTtcbiAgc2V0MjU1MTkocFsxXSwgZ2YxKTtcbiAgc2V0MjU1MTkocFsyXSwgZ2YxKTtcbiAgc2V0MjU1MTkocFszXSwgZ2YwKTtcbiAgZm9yIChpID0gMjU1OyBpID49IDA7IC0taSkge1xuICAgIGIgPSAoc1soaS84KXwwXSA+PiAoaSY3KSkgJiAxO1xuICAgIGNzd2FwKHAsIHEsIGIpO1xuICAgIGFkZChxLCBwKTtcbiAgICBhZGQocCwgcCk7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbGFyYmFzZShwLCBzKSB7XG4gIHZhciBxID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuICBzZXQyNTUxOShxWzBdLCBYKTtcbiAgc2V0MjU1MTkocVsxXSwgWSk7XG4gIHNldDI1NTE5KHFbMl0sIGdmMSk7XG4gIE0ocVszXSwgWCwgWSk7XG4gIHNjYWxhcm11bHQocCwgcSwgcyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrLCBzZWVkZWQpIHtcbiAgY2hlY2socGssIHNvZGl1bS5jcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgY2hlY2soc2ssIHNvZGl1bS5jcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUylcblxuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG4gIHZhciBpO1xuXG4gIGlmICghc2VlZGVkKSByYW5kb21ieXRlcyhzaywgMzIpO1xuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICBzY2FsYXJiYXNlKHAsIGQpO1xuICBwYWNrKHBrLCBwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc2tbaSszMl0gPSBwa1tpXTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX3NlZWRfa2V5cGFpciAocGssIHNrLCBzZWVkKSB7XG4gIGNoZWNrKHNlZWQsIHNvZGl1bS5jcnlwdG9fc2lnbl9TRUVEQllURVMpXG4gIHNlZWQuY29weShzaylcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHRydWUpXG59XG5cbnZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbMHhlZCwgMHhkMywgMHhmNSwgMHg1YywgMHgxYSwgMHg2MywgMHgxMiwgMHg1OCwgMHhkNiwgMHg5YywgMHhmNywgMHhhMiwgMHhkZSwgMHhmOSwgMHhkZSwgMHgxNCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgxMF0pO1xuXG5mdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgdmFyIGNhcnJ5LCBpLCBqLCBrO1xuICBmb3IgKGkgPSA2MzsgaSA+PSAzMjsgLS1pKSB7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaiA9IGkgLSAzMiwgayA9IGkgLSAxMjsgaiA8IGs7ICsraikge1xuICAgICAgeFtqXSArPSBjYXJyeSAtIDE2ICogeFtpXSAqIExbaiAtIChpIC0gMzIpXTtcbiAgICAgIGNhcnJ5ID0gKHhbal0gKyAxMjgpID4+IDg7XG4gICAgICB4W2pdIC09IGNhcnJ5ICogMjU2O1xuICAgIH1cbiAgICB4W2pdICs9IGNhcnJ5O1xuICAgIHhbaV0gPSAwO1xuICB9XG4gIGNhcnJ5ID0gMDtcbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHtcbiAgICB4W2pdICs9IGNhcnJ5IC0gKHhbMzFdID4+IDQpICogTFtqXTtcbiAgICBjYXJyeSA9IHhbal0gPj4gODtcbiAgICB4W2pdICY9IDI1NTtcbiAgfVxuICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykgeFtqXSAtPSBjYXJyeSAqIExbal07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgeFtpKzFdICs9IHhbaV0gPj4gODtcbiAgICByW2ldID0geFtpXSAmIDI1NTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2Uocikge1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpLCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeFtpXSA9IHJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSByW2ldID0gMDtcbiAgbW9kTChyLCB4KTtcbn1cblxuLy8gTm90ZTogZGlmZmVyZW5jZSBmcm9tIEMgLSBzbWxlbiByZXR1cm5lZCwgbm90IHBhc3NlZCBhcyBhcmd1bWVudC5cbmZ1bmN0aW9uIGNyeXB0b19zaWduKHNtLCBtLCBzaykge1xuICBjaGVjayhzbSwgY3J5cHRvX3NpZ25fQllURVMgKyBtLmxlbmd0aClcbiAgY2hlY2sobSwgMClcbiAgY2hlY2soc2ssIGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICB2YXIgbiA9IG0ubGVuZ3RoXG5cbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBpLCBqLCB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHZhciBzbWxlbiA9IG4gKyA2NDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgc21bNjQgKyBpXSA9IG1baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBzbVszMiArIGldID0gZFszMiArIGldO1xuXG4gIGNyeXB0b19oYXNoKHIsIHNtLnN1YmFycmF5KDMyKSwgbiszMik7XG4gIHJlZHVjZShyKTtcbiAgc2NhbGFyYmFzZShwLCByKTtcbiAgcGFjayhzbSwgcCk7XG5cbiAgZm9yIChpID0gMzI7IGkgPCA2NDsgaSsrKSBzbVtpXSA9IHNrW2ldO1xuICBjcnlwdG9faGFzaChoLCBzbSwgbiArIDY0KTtcbiAgcmVkdWNlKGgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHhbaV0gPSByW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgICB4W2kral0gKz0gaFtpXSAqIGRbal07XG4gICAgfVxuICB9XG5cbiAgbW9kTChzbS5zdWJhcnJheSgzMiksIHgpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9kZXRhY2hlZChzaWcsIG0sIHNrKSB7XG4gIHZhciBzbSA9IG5ldyBVaW50OEFycmF5KG0ubGVuZ3RoICsgY3J5cHRvX3NpZ25fQllURVMpXG4gIGNyeXB0b19zaWduKHNtLCBtLCBzaylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjcnlwdG9fc2lnbl9CWVRFUzsgaSsrKSBzaWdbaV0gPSBzbVtpXVxufVxuXG5mdW5jdGlvbiB1bnBhY2tuZWcociwgcCkge1xuICB2YXIgdCA9IGdmKCksIGNoayA9IGdmKCksIG51bSA9IGdmKCksXG4gICAgICBkZW4gPSBnZigpLCBkZW4yID0gZ2YoKSwgZGVuNCA9IGdmKCksXG4gICAgICBkZW42ID0gZ2YoKTtcblxuICBzZXQyNTUxOShyWzJdLCBnZjEpO1xuICB1bnBhY2syNTUxOShyWzFdLCBwKTtcbiAgUyhudW0sIHJbMV0pO1xuICBNKGRlbiwgbnVtLCBEKTtcbiAgWihudW0sIG51bSwgclsyXSk7XG4gIEEoZGVuLCByWzJdLCBkZW4pO1xuXG4gIFMoZGVuMiwgZGVuKTtcbiAgUyhkZW40LCBkZW4yKTtcbiAgTShkZW42LCBkZW40LCBkZW4yKTtcbiAgTSh0LCBkZW42LCBudW0pO1xuICBNKHQsIHQsIGRlbik7XG5cbiAgcG93MjUyMyh0LCB0KTtcbiAgTSh0LCB0LCBudW0pO1xuICBNKHQsIHQsIGRlbik7XG4gIE0odCwgdCwgZGVuKTtcbiAgTShyWzBdLCB0LCBkZW4pO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgTShyWzBdLCByWzBdLCBJKTtcblxuICBTKGNoaywgclswXSk7XG4gIE0oY2hrLCBjaGssIGRlbik7XG4gIGlmIChuZXEyNTUxOShjaGssIG51bSkpIHJldHVybiAtMTtcblxuICBpZiAocGFyMjU1MTkoclswXSkgPT09IChwWzMxXT4+NykpIFooclswXSwgZ2YwLCByWzBdKTtcblxuICBNKHJbM10sIHJbMF0sIHJbMV0pO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fb3Blbihtc2csIHNtLCBwaykge1xuICBjaGVjayhtc2csIHNtLmxlbmd0aCAtIGNyeXB0b19zaWduX0JZVEVTKVxuICBjaGVjayhzbSwgY3J5cHRvX3NpZ25fQllURVMpXG4gIGNoZWNrKHBrLCBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUylcbiAgdmFyIG4gPSBzbS5sZW5ndGhcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShzbS5sZW5ndGgpXG5cbiAgdmFyIGksIG1sZW47XG4gIHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBoID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXSxcbiAgICAgIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgbWxlbiA9IC0xO1xuICBpZiAobiA8IDY0KSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHVucGFja25lZyhxLCBwaykpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2krMzJdID0gcGtbaV07XG4gIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICByZWR1Y2UoaCk7XG4gIHNjYWxhcm11bHQocCwgcSwgaCk7XG5cbiAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICBhZGQocCwgcSk7XG4gIHBhY2sodCwgcCk7XG5cbiAgbiAtPSA2NDtcbiAgaWYgKGNyeXB0b192ZXJpZnlfMzIoc20sIDAsIHQsIDApKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbXNnW2ldID0gc21baSArIDY0XTtcbiAgbWxlbiA9IG47XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl92ZXJpZnlfZGV0YWNoZWQgKHNpZywgbSwgcGspIHtcbiAgY2hlY2soc2lnLCBjcnlwdG9fc2lnbl9CWVRFUylcbiAgdmFyIHNtID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGggKyBjcnlwdG9fc2lnbl9CWVRFUylcbiAgdmFyIGkgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBjcnlwdG9fc2lnbl9CWVRFUzsgaSsrKSBzbVtpXSA9IHNpZ1tpXVxuICBmb3IgKGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgc21baSArIGNyeXB0b19zaWduX0JZVEVTXSA9IG1baV1cbiAgcmV0dXJuIGNyeXB0b19zaWduX29wZW4obSwgc20sIHBrKVxufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94X2RldGFjaGVkIChvLCBtYWMsIG1zZywgbiwgaykge1xuICBjaGVjayhtYWMsIHNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X01BQ0JZVEVTKVxuICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkobXNnLmxlbmd0aCArIG1hYy5sZW5ndGgpXG4gIGNyeXB0b19zZWNyZXRib3hfZWFzeSh0bXAsIG1zZywgbiwgaylcbiAgby5zZXQodG1wLnN1YmFycmF5KDAsIG1zZy5sZW5ndGgpKVxuICBtYWMuc2V0KHRtcC5zdWJhcnJheShtc2cubGVuZ3RoKSlcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveF9vcGVuX2RldGFjaGVkIChtc2csIG8sIG1hYywgbiwgaykge1xuICBjaGVjayhtYWMsIHNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X01BQ0JZVEVTKVxuICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoby5sZW5ndGggKyBtYWMubGVuZ3RoKVxuICB0bXAuc2V0KG8pXG4gIHRtcC5zZXQobWFjLCBtc2cubGVuZ3RoKVxuICByZXR1cm4gY3J5cHRvX3NlY3JldGJveF9vcGVuX2Vhc3kobXNnLCB0bXAsIG4sIGspXG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfZWFzeShvLCBtc2csIG4sIGspIHtcbiAgY2hlY2sobXNnLCAwKVxuICBjaGVjayhvLCBtc2cubGVuZ3RoICsgc29kaXVtLmNyeXB0b19zZWNyZXRib3hfTUFDQllURVMpXG4gIGNoZWNrKG4sIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUylcbiAgY2hlY2soaywgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUylcblxuICB2YXIgaVxuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBtW2krY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVNdID0gbXNnW2ldO1xuICBjcnlwdG9fc2VjcmV0Ym94KGMsIG0sIG0ubGVuZ3RoLCBuLCBrKTtcbiAgZm9yIChpID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVM7IGkgPCBjLmxlbmd0aDsgaSsrKSBvW2kgLSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFU10gPSBjW2ldXG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfb3Blbl9lYXN5KG1zZywgYm94LCBuLCBrKSB7XG4gIGNoZWNrKGJveCwgc29kaXVtLmNyeXB0b19zZWNyZXRib3hfTUFDQllURVMpXG4gIGNoZWNrKG1zZywgYm94Lmxlbmd0aCAtIHNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X01BQ0JZVEVTKVxuICBjaGVjayhuLCBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMpXG4gIGNoZWNrKGssIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMpXG5cbiAgdmFyIGlcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyArIGJveC5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGMubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IGJveC5sZW5ndGg7IGkrKykgY1tpK2NyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTXSA9IGJveFtpXTtcbiAgaWYgKGMubGVuZ3RoIDwgMzIpIHJldHVybiBmYWxzZTtcbiAgaWYgKGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBjLmxlbmd0aCwgbiwgaykgIT09IDApIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGkgPSBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUzsgaSA8IG0ubGVuZ3RoOyBpKyspIG1zZ1tpIC0gY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVNdID0gbVtpXVxuICByZXR1cm4gdHJ1ZVxufVxuXG52YXIgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyA9IDI0LFxuICAgIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgPSAxNixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X05PTkNFQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG4gICAgY3J5cHRvX2JveF9aRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyxcbiAgICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTLFxuICAgIGNyeXB0b19zaWduX0JZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1NFRURCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19oYXNoX0JZVEVTID0gNjQ7XG5cbnNvZGl1bS5tZW16ZXJvID0gZnVuY3Rpb24gKGxlbiwgb2Zmc2V0KSB7XG4gIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBsZW47IGkrKykgYXJyW2ldID0gMDtcbn1cblxuc29kaXVtLmNyeXB0b19zaWduX0JZVEVTID0gY3J5cHRvX3NpZ25fQllURVNcbnNvZGl1bS5jcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyA9IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTXG5zb2RpdW0uY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMgPSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFU1xuc29kaXVtLmNyeXB0b19zaWduX1NFRURCWVRFUyA9IGNyeXB0b19zaWduX1NFRURCWVRFU1xuc29kaXVtLmNyeXB0b19zaWduX2tleXBhaXIgPSBjcnlwdG9fc2lnbl9rZXlwYWlyXG5zb2RpdW0uY3J5cHRvX3NpZ25fc2VlZF9rZXlwYWlyID0gY3J5cHRvX3NpZ25fc2VlZF9rZXlwYWlyXG5zb2RpdW0uY3J5cHRvX3NpZ24gPSBjcnlwdG9fc2lnblxuc29kaXVtLmNyeXB0b19zaWduX29wZW4gPSBjcnlwdG9fc2lnbl9vcGVuXG5zb2RpdW0uY3J5cHRvX3NpZ25fZGV0YWNoZWQgPSBjcnlwdG9fc2lnbl9kZXRhY2hlZFxuc29kaXVtLmNyeXB0b19zaWduX3ZlcmlmeV9kZXRhY2hlZCA9IGNyeXB0b19zaWduX3ZlcmlmeV9kZXRhY2hlZFxuXG5mb3J3YXJkKHJlcXVpcmUoJy4vY3J5cHRvX2dlbmVyaWNoYXNoJykpXG5mb3J3YXJkKHJlcXVpcmUoJy4vY3J5cHRvX2tkZicpKVxuZm9yd2FyZChyZXF1aXJlKCcuL2NyeXB0b19zaG9ydGhhc2gnKSlcbmZvcndhcmQocmVxdWlyZSgnLi9yYW5kb21ieXRlcycpKVxuZm9yd2FyZChyZXF1aXJlKCcuL2NyeXB0b19zdHJlYW0nKSlcblxuc29kaXVtLmNyeXB0b19zY2FsYXJtdWx0X0JZVEVTID0gY3J5cHRvX3NjYWxhcm11bHRfQllURVNcbnNvZGl1bS5jcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUyA9IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTXG5zb2RpdW0uY3J5cHRvX3NjYWxhcm11bHRfYmFzZSA9IGNyeXB0b19zY2FsYXJtdWx0X2Jhc2VcbnNvZGl1bS5jcnlwdG9fc2NhbGFybXVsdCA9IGNyeXB0b19zY2FsYXJtdWx0XG5cbnNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTID0gY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyxcbnNvZGl1bS5jcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG5zb2RpdW0uY3J5cHRvX3NlY3JldGJveF9NQUNCWVRFUyA9IDE2XG5zb2RpdW0uY3J5cHRvX3NlY3JldGJveF9lYXN5ID0gY3J5cHRvX3NlY3JldGJveF9lYXN5XG5zb2RpdW0uY3J5cHRvX3NlY3JldGJveF9vcGVuX2Vhc3kgPSBjcnlwdG9fc2VjcmV0Ym94X29wZW5fZWFzeVxuc29kaXVtLmNyeXB0b19zZWNyZXRib3hfZGV0YWNoZWQgPSBjcnlwdG9fc2VjcmV0Ym94X2RldGFjaGVkXG5zb2RpdW0uY3J5cHRvX3NlY3JldGJveF9vcGVuX2RldGFjaGVkID0gY3J5cHRvX3NlY3JldGJveF9vcGVuX2RldGFjaGVkXG5cbmZ1bmN0aW9uIGNsZWFudXAoYXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnJbaV0gPSAwO1xufVxuXG5mdW5jdGlvbiBjaGVjayAoYnVmLCBsZW4pIHtcbiAgaWYgKCFidWYgfHwgKGxlbiAmJiBidWYubGVuZ3RoIDwgbGVuKSkgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgYnVmZmVyJyArIChsZW4gPyAnIG9mIGxlbmd0aCAnICsgbGVuIDogJycpKVxufVxuXG5mdW5jdGlvbiBmb3J3YXJkIChzdWJtb2R1bGUpIHtcbiAgT2JqZWN0LmtleXMoc3VibW9kdWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgbW9kdWxlLmV4cG9ydHNbcHJvcF0gPSBzdWJtb2R1bGVbcHJvcF1cbiAgfSlcbn1cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCduYW5vYXNzZXJ0JylcbnZhciByYW5kb21ieXRlcyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBRVU9UQSA9IDY1NTM2IC8vIGxpbWl0IGZvciBRdW90YUV4Y2VlZGVkRXhjZXB0aW9uXG4gIHZhciBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGNyeXB0byA9IChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykgOiBudWxsXG5cbiAgZnVuY3Rpb24gYnJvd3NlckJ5dGVzIChvdXQsIG4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkgKz0gUVVPVEEpIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMob3V0LnN1YmFycmF5KGksIGkgKyBNYXRoLm1pbihuIC0gaSwgUVVPVEEpKSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub2RlQnl0ZXMgKG91dCwgbikge1xuICAgIG91dC5zZXQoY3J5cHRvLnJhbmRvbUJ5dGVzKG4pKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9JbXBsICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBhdmFpbGFibGUnKVxuICB9XG5cbiAgaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgcmV0dXJuIGJyb3dzZXJCeXRlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vZGUuanMuXG4gICAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbiAgICBpZiAoY3J5cHRvICYmIGNyeXB0by5yYW5kb21CeXRlcykge1xuICAgICAgcmV0dXJuIG5vZGVCeXRlc1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub0ltcGxcbn0pKClcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAncmFuZG9tYnl0ZXMnLCB7XG4gIHZhbHVlOiByYW5kb21ieXRlc1xufSlcblxubW9kdWxlLmV4cG9ydHMucmFuZG9tYnl0ZXNfYnVmID0gZnVuY3Rpb24gKG91dCkge1xuICBhc3NlcnQob3V0LCAnb3V0IG11c3QgYmUgZ2l2ZW4nKVxuICByYW5kb21ieXRlcyhvdXQsIG91dC5sZW5ndGgpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3NvZGl1bS1qYXZhc2NyaXB0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZlxuXG5mdW5jdGlvbiBpbmRleE9mIChsZWZ0LCByaWdodCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHJpZ2h0Lmxlbmd0aClcbiAgdmFyIGkgPSAwXG4gIHZhciBqID0gMFxuXG4gIHdoaWxlIChpIDwgbGVmdC5sZW5ndGggJiYgaiA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgIHZhciBhID0gbGVmdFtpXVxuICAgIHZhciBiID0gcmlnaHRbal1cblxuICAgIGlmIChhID09PSBiKSB7XG4gICAgICByZXN1bHRbaisrXSA9IGlcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGEgPCBiKSB7XG4gICAgICBpKytcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgcmVzdWx0W2orK10gPSAtMVxuICAgIGNvbnRpbnVlXG4gIH1cblxuICBmb3IgKDsgaiA8IHJpZ2h0Lmxlbmd0aDsgaisrKSByZXN1bHRbal0gPSAtMVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsInZhciBwYWdlciA9IHJlcXVpcmUoJ21lbW9yeS1wYWdlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gQml0ZmllbGRcblxuZnVuY3Rpb24gQml0ZmllbGQgKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJpdGZpZWxkKSkgcmV0dXJuIG5ldyBCaXRmaWVsZChvcHRzKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9wdHMpKSBvcHRzID0ge2J1ZmZlcjogb3B0c31cblxuICB0aGlzLnBhZ2VPZmZzZXQgPSBvcHRzLnBhZ2VPZmZzZXQgfHwgMFxuICB0aGlzLnBhZ2VTaXplID0gb3B0cy5wYWdlU2l6ZSB8fCAxMDI0XG4gIHRoaXMucGFnZXMgPSBvcHRzLnBhZ2VzIHx8IHBhZ2VyKHRoaXMucGFnZVNpemUpXG5cbiAgdGhpcy5ieXRlTGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGggKiB0aGlzLnBhZ2VTaXplXG4gIHRoaXMubGVuZ3RoID0gOCAqIHRoaXMuYnl0ZUxlbmd0aFxuXG4gIGlmICghcG93ZXJPZlR3byh0aGlzLnBhZ2VTaXplKSkgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFnZSBzaXplIHNob3VsZCBiZSBhIHBvd2VyIG9mIHR3bycpXG5cbiAgdGhpcy5fdHJhY2tVcGRhdGVzID0gISFvcHRzLnRyYWNrVXBkYXRlc1xuICB0aGlzLl9wYWdlTWFzayA9IHRoaXMucGFnZVNpemUgLSAxXG5cbiAgaWYgKG9wdHMuYnVmZmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLmJ1ZmZlci5sZW5ndGg7IGkgKz0gdGhpcy5wYWdlU2l6ZSkge1xuICAgICAgdGhpcy5wYWdlcy5zZXQoaSAvIHRoaXMucGFnZVNpemUsIG9wdHMuYnVmZmVyLnNsaWNlKGksIGkgKyB0aGlzLnBhZ2VTaXplKSlcbiAgICB9XG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gb3B0cy5idWZmZXIubGVuZ3RoXG4gICAgdGhpcy5sZW5ndGggPSA4ICogdGhpcy5ieXRlTGVuZ3RoXG4gIH1cbn1cblxuQml0ZmllbGQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpKSB7XG4gIHZhciBvID0gaSAmIDdcbiAgdmFyIGogPSAoaSAtIG8pIC8gOFxuXG4gIHJldHVybiAhISh0aGlzLmdldEJ5dGUoaikgJiAoMTI4ID4+IG8pKVxufVxuXG5CaXRmaWVsZC5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uIChpKSB7XG4gIHZhciBvID0gaSAmIHRoaXMuX3BhZ2VNYXNrXG4gIHZhciBqID0gKGkgLSBvKSAvIHRoaXMucGFnZVNpemVcbiAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzLmdldChqLCB0cnVlKVxuXG4gIHJldHVybiBwYWdlID8gcGFnZS5idWZmZXJbbyArIHRoaXMucGFnZU9mZnNldF0gOiAwXG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaSwgdikge1xuICB2YXIgbyA9IGkgJiA3XG4gIHZhciBqID0gKGkgLSBvKSAvIDhcbiAgdmFyIGIgPSB0aGlzLmdldEJ5dGUoailcblxuICByZXR1cm4gdGhpcy5zZXRCeXRlKGosIHYgPyBiIHwgKDEyOCA+PiBvKSA6IGIgJiAoMjU1IF4gKDEyOCA+PiBvKSkpXG59XG5cbkJpdGZpZWxkLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFsbCA9IGFsbG9jKHRoaXMucGFnZXMubGVuZ3RoICogdGhpcy5wYWdlU2l6ZSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMucGFnZXMuZ2V0KGksIHRydWUpXG4gICAgdmFyIGFsbE9mZnNldCA9IGkgKiB0aGlzLnBhZ2VTaXplXG4gICAgaWYgKG5leHQpIG5leHQuYnVmZmVyLmNvcHkoYWxsLCBhbGxPZmZzZXQsIHRoaXMucGFnZU9mZnNldCwgdGhpcy5wYWdlT2Zmc2V0ICsgdGhpcy5wYWdlU2l6ZSlcbiAgfVxuXG4gIHJldHVybiBhbGxcbn1cblxuQml0ZmllbGQucHJvdG90eXBlLnNldEJ5dGUgPSBmdW5jdGlvbiAoaSwgYikge1xuICB2YXIgbyA9IGkgJiB0aGlzLl9wYWdlTWFza1xuICB2YXIgaiA9IChpIC0gbykgLyB0aGlzLnBhZ2VTaXplXG4gIHZhciBwYWdlID0gdGhpcy5wYWdlcy5nZXQoaiwgZmFsc2UpXG5cbiAgbyArPSB0aGlzLnBhZ2VPZmZzZXRcblxuICBpZiAocGFnZS5idWZmZXJbb10gPT09IGIpIHJldHVybiBmYWxzZVxuICBwYWdlLmJ1ZmZlcltvXSA9IGJcblxuICBpZiAoaSA+PSB0aGlzLmJ5dGVMZW5ndGgpIHtcbiAgICB0aGlzLmJ5dGVMZW5ndGggPSBpICsgMVxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoICogOFxuICB9XG5cbiAgaWYgKHRoaXMuX3RyYWNrVXBkYXRlcykgdGhpcy5wYWdlcy51cGRhdGVkKHBhZ2UpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gYWxsb2MgKG4pIHtcbiAgaWYgKEJ1ZmZlci5hbGxvYykgcmV0dXJuIEJ1ZmZlci5hbGxvYyhuKVxuICB2YXIgYiA9IG5ldyBCdWZmZXIobilcbiAgYi5maWxsKDApXG4gIHJldHVybiBiXG59XG5cbmZ1bmN0aW9uIHBvd2VyT2ZUd28gKHgpIHtcbiAgcmV0dXJuICEoeCAmICh4IC0gMSkpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCIndXNlIHN0cmljdCdcblxudmFyIG5leHRUaWNrID0gbmV4dFRpY2tBcmdzXG5wcm9jZXNzLm5leHRUaWNrKHVwZ3JhZGUsIDQyKSAvLyBwYXNzIDQyIGFuZCBzZWUgaWYgdXBncmFkZSBpcyBjYWxsZWQgd2l0aCBpdFxuXG5tb2R1bGUuZXhwb3J0cyA9IHRodW5reVxuXG5mdW5jdGlvbiB0aHVua3kgKGZuKSB7XG4gIHZhciBzdGF0ZSA9IHJ1blxuICByZXR1cm4gdGh1bmtcblxuICBmdW5jdGlvbiB0aHVuayAoY2FsbGJhY2spIHtcbiAgICBzdGF0ZShjYWxsYmFjayB8fCBub29wKVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuIChjYWxsYmFjaykge1xuICAgIHZhciBzdGFjayA9IFtjYWxsYmFja11cbiAgICBzdGF0ZSA9IHdhaXRcbiAgICBmbihkb25lKVxuXG4gICAgZnVuY3Rpb24gd2FpdCAoY2FsbGJhY2spIHtcbiAgICAgIHN0YWNrLnB1c2goY2FsbGJhY2spXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50c1xuICAgICAgc3RhdGUgPSBpc0Vycm9yKGVycikgPyBydW4gOiBmaW5pc2hlZFxuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkgZmluaXNoZWQoc3RhY2suc2hpZnQoKSlcblxuICAgICAgZnVuY3Rpb24gZmluaXNoZWQgKGNhbGxiYWNrKSB7XG4gICAgICAgIG5leHRUaWNrKGFwcGx5LCBjYWxsYmFjaywgYXJncylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFcnJvciAoZXJyKSB7IC8vIGlubGluZWQgZnJvbSB1dGlsIHNvIHRoaXMgd29ya3MgaW4gdGhlIGJyb3dzZXJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBFcnJvcl0nXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gYXBwbHkgKGNhbGxiYWNrLCBhcmdzKSB7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpXG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGUgKHZhbCkge1xuICBpZiAodmFsID09PSA0MikgbmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrQXJncyAoZm4sIGEsIGIpIHtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgZm4oYSwgYilcbiAgfSlcbn1cbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsInZhciBidWZmZXJBbGxvYyA9IHJlcXVpcmUoJ2J1ZmZlci1hbGxvYycpXG5cbnZhciBVSU5UXzMyX01BWCA9IE1hdGgucG93KDIsIDMyKVxuXG5leHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gOFxufVxuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW0sIGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmICghYnVmKSBidWYgPSBidWZmZXJBbGxvYyg4KVxuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuXG4gIHZhciB0b3AgPSBNYXRoLmZsb29yKG51bSAvIFVJTlRfMzJfTUFYKVxuICB2YXIgcmVtID0gbnVtIC0gdG9wICogVUlOVF8zMl9NQVhcblxuICBidWYud3JpdGVVSW50MzJCRSh0b3AsIG9mZnNldClcbiAgYnVmLndyaXRlVUludDMyQkUocmVtLCBvZmZzZXQgKyA0KVxuICByZXR1cm4gYnVmXG59XG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgdmFyIHRvcCA9IGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0KVxuICB2YXIgcmVtID0gYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KVxuXG4gIHJldHVybiB0b3AgKiBVSU5UXzMyX01BWCArIHJlbVxufVxuXG5leHBvcnRzLmVuY29kZS5ieXRlcyA9IDhcbmV4cG9ydHMuZGVjb2RlLmJ5dGVzID0gOFxuIiwibW9kdWxlLmV4cG9ydHMgPSByZW1vdmVcblxuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGkpIHtcbiAgaWYgKGkgPj0gYXJyLmxlbmd0aCB8fCBpIDwgMCkgcmV0dXJuXG4gIHZhciBsYXN0ID0gYXJyLnBvcCgpXG4gIGlmIChpIDwgYXJyLmxlbmd0aCkge1xuICAgIHZhciB0bXAgPSBhcnJbaV1cbiAgICBhcnJbaV0gPSBsYXN0XG4gICAgcmV0dXJuIHRtcFxuICB9XG4gIHJldHVybiBsYXN0XG59XG4iLCJleHBvcnRzLmFkZCA9IGFkZFxuZXhwb3J0cy5oYXMgPSBoYXNcbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlXG5leHBvcnRzLnN3YXAgPSBzd2FwXG5cbmZ1bmN0aW9uIGFkZCAobGlzdCwgaXRlbSkge1xuICBpZiAoaGFzKGxpc3QsIGl0ZW0pKSByZXR1cm4gaXRlbVxuICBpdGVtLl9pbmRleCA9IGxpc3QubGVuZ3RoXG4gIGxpc3QucHVzaChpdGVtKVxuICByZXR1cm4gaXRlbVxufVxuXG5mdW5jdGlvbiBoYXMgKGxpc3QsIGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0uX2luZGV4IDwgbGlzdC5sZW5ndGggJiYgbGlzdFtpdGVtLl9pbmRleF0gPT09IGl0ZW1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlIChsaXN0LCBpdGVtKSB7XG4gIGlmICghaGFzKGxpc3QsIGl0ZW0pKSByZXR1cm4gbnVsbFxuXG4gIHZhciBsYXN0ID0gbGlzdC5wb3AoKVxuICBpZiAobGFzdCAhPT0gaXRlbSkge1xuICAgIGxpc3RbaXRlbS5faW5kZXhdID0gbGFzdFxuICAgIGxhc3QuX2luZGV4ID0gaXRlbS5faW5kZXhcbiAgfVxuXG4gIHJldHVybiBpdGVtXG59XG5cbmZ1bmN0aW9uIHN3YXAgKGxpc3QsIGEsIGIpIHtcbiAgaWYgKCFoYXMobGlzdCwgYSkgfHwgIWhhcyhsaXN0LCBiKSkgcmV0dXJuXG4gIHZhciB0bXAgPSBhLl9pbmRleFxuICBhLl9pbmRleCA9IGIuX2luZGV4XG4gIGxpc3RbYS5faW5kZXhdID0gYVxuICBiLl9pbmRleCA9IHRtcFxuICBsaXN0W2IuX2luZGV4XSA9IGJcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVhZFxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyAgICA9IDBcbiAgICAsIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gICAgLCBzaGlmdCAgPSAwXG4gICAgLCBjb3VudGVyID0gb2Zmc2V0XG4gICAgLCBiXG4gICAgLCBsID0gYnVmLmxlbmd0aFxuXG4gIGRvIHtcbiAgICBpZiAoY291bnRlciA+PSBsKSB7XG4gICAgICByZWFkLmJ5dGVzID0gMFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50JylcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdXG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QpICogTWF0aC5wb3coMiwgc2hpZnQpXG4gICAgc2hpZnQgKz0gN1xuICB9IHdoaWxlIChiID49IE1TQilcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldFxuXG4gIHJldHVybiByZXNcbn1cbiIsInZhciB4c2Fsc2EyMCA9IHJlcXVpcmUoJy4veHNhbHNhMjAnKSgpXG5cbnZhciBTSUdNQSA9IG5ldyBVaW50OEFycmF5KFsxMDEsIDEyMCwgMTEyLCA5NywgMTEwLCAxMDAsIDMyLCA1MSwgNTAsIDQ1LCA5OCwgMTIxLCAxMTYsIDEwMSwgMzIsIDEwN10pXG52YXIgaGVhZCA9IDE0NFxudmFyIHRvcCA9IGhlYWRcbnZhciBmcmVlID0gW11cblxubW9kdWxlLmV4cG9ydHMgPSBYU2Fsc2EyMFxuXG5YU2Fsc2EyMC5OT05DRUJZVEVTID0gMjRcblhTYWxzYTIwLktFWUJZVEVTID0gMzJcblxuZnVuY3Rpb24gWFNhbHNhMjAgKG5vbmNlLCBrZXkpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFhTYWxzYTIwKSkgcmV0dXJuIG5ldyBYU2Fsc2EyMChub25jZSwga2V5KVxuICBpZiAoIW5vbmNlIHx8IG5vbmNlLmxlbmd0aCA8IDI0KSB0aHJvdyBuZXcgRXJyb3IoJ25vbmNlIG11c3QgYmUgYXQgbGVhc3QgMjQgYnl0ZXMnKVxuICBpZiAoIWtleSB8fCBrZXkubGVuZ3RoIDwgMzIpIHRocm93IG5ldyBFcnJvcigna2V5IG11c3QgYmUgYXQgbGVhc3QgMzIgYnl0ZXMnKVxuICB0aGlzLl94b3IgPSB4c2Fsc2EyMCAmJiB4c2Fsc2EyMC5leHBvcnRzID8gbmV3IFdBU00obm9uY2UsIGtleSkgOiBuZXcgRmFsbGJhY2sobm9uY2UsIGtleSlcbn1cblxuWFNhbHNhMjAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0KSB7XG4gIGlmICghaW5wdXQpIHRocm93IG5ldyBFcnJvcignaW5wdXQgbXVzdCBiZSBVaW50OEFycmF5IG9yIEJ1ZmZlcicpXG4gIGlmICghb3V0cHV0KSBvdXRwdXQgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpXG4gIGlmIChpbnB1dC5sZW5ndGgpIHRoaXMuX3hvci51cGRhdGUoaW5wdXQsIG91dHB1dClcbiAgcmV0dXJuIG91dHB1dFxufVxuXG5YU2Fsc2EyMC5wcm90b3R5cGUuZmluYWwgPVxuWFNhbHNhMjAucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl94b3IuZmluYWxpemUoKVxuICB0aGlzLl94b3IgPSBudWxsXG59XG5cbmZ1bmN0aW9uIFdBU00gKG5vbmNlLCBrZXkpIHtcbiAgaWYgKCFmcmVlLmxlbmd0aCkge1xuICAgIGZyZWUucHVzaChoZWFkKVxuICAgIGhlYWQgKz0gNjRcbiAgfVxuXG4gIHRoaXMuX3BvaW50ZXIgPSBmcmVlLnBvcCgpXG4gIHRoaXMuX25vbmNlID0gdGhpcy5fcG9pbnRlciArIDhcbiAgdGhpcy5fa2V5ID0gdGhpcy5fbm9uY2UgKyAyNFxuICB0aGlzLl9vdmVyZmxvdyA9IDBcblxuICB4c2Fsc2EyMC5tZW1vcnkuZmlsbCgwLCB0aGlzLl9wb2ludGVyLCB0aGlzLl9wb2ludGVyICsgOClcbiAgeHNhbHNhMjAubWVtb3J5LnNldChub25jZSwgdGhpcy5fbm9uY2UpXG4gIHhzYWxzYTIwLm1lbW9yeS5zZXQoa2V5LCB0aGlzLl9rZXkpXG59XG5cbldBU00ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0KSB7XG4gIHZhciBsZW4gPSB0aGlzLl9vdmVyZmxvdyArIGlucHV0Lmxlbmd0aFxuICB2YXIgc3RhcnQgPSBoZWFkICsgdGhpcy5fb3ZlcmZsb3dcblxuICB0b3AgPSBoZWFkICsgbGVuXG4gIGlmICh0b3AgPj0geHNhbHNhMjAubWVtb3J5Lmxlbmd0aCkgeHNhbHNhMjAucmVhbGxvYyh0b3ApXG5cbiAgeHNhbHNhMjAubWVtb3J5LnNldChpbnB1dCwgc3RhcnQpXG4gIHhzYWxzYTIwLmV4cG9ydHMueHNhbHNhMjBfeG9yKHRoaXMuX3BvaW50ZXIsIGhlYWQsIGhlYWQsIGxlbiwgdGhpcy5fbm9uY2UsIHRoaXMuX2tleSlcbiAgb3V0cHV0LnNldCh4c2Fsc2EyMC5tZW1vcnkuc3ViYXJyYXkoc3RhcnQsIGhlYWQgKyBsZW4pKVxuXG4gIHRoaXMuX292ZXJmbG93ID0gbGVuICYgNjNcbn1cblxuV0FTTS5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHhzYWxzYTIwLm1lbW9yeS5maWxsKDAsIHRoaXMuX3BvaW50ZXIsIHRoaXMuX2tleSArIDMyKVxuICBpZiAodG9wID4gaGVhZCkge1xuICAgIHhzYWxzYTIwLm1lbW9yeS5maWxsKDAsIGhlYWQsIHRvcClcbiAgICB0b3AgPSAwXG4gIH1cbiAgZnJlZS5wdXNoKHRoaXMuX3BvaW50ZXIpXG59XG5cbmZ1bmN0aW9uIEZhbGxiYWNrIChub25jZSwga2V5KSB7XG4gIHRoaXMuX3MgPSBuZXcgVWludDhBcnJheSgzMilcbiAgdGhpcy5feiA9IG5ldyBVaW50OEFycmF5KDE2KVxuICB0aGlzLl9vdmVyZmxvdyA9IDBcbiAgY29yZV9oc2Fsc2EyMCh0aGlzLl9zLCBub25jZSwga2V5LCBTSUdNQSlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHRoaXMuX3pbaV0gPSBub25jZVtpICsgMTZdXG59XG5cbkZhbGxiYWNrLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dCkge1xuICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDY0KVxuICB2YXIgdSA9IDBcbiAgdmFyIGkgPSB0aGlzLl9vdmVyZmxvd1xuICB2YXIgYiA9IGlucHV0Lmxlbmd0aCArIHRoaXMuX292ZXJmbG93XG4gIHZhciB6ID0gdGhpcy5felxuICB2YXIgbXBvcyA9IC10aGlzLl9vdmVyZmxvd1xuICB2YXIgY3BvcyA9IC10aGlzLl9vdmVyZmxvd1xuXG4gIHdoaWxlIChiID49IDY0KSB7XG4gICAgY29yZV9zYWxzYTIwKHgsIHosIHRoaXMuX3MsIFNJR01BKVxuICAgIGZvciAoOyBpIDwgNjQ7IGkrKykgb3V0cHV0W2Nwb3MgKyBpXSA9IGlucHV0W21wb3MgKyBpXSBeIHhbaV1cbiAgICB1ID0gMVxuICAgIGZvciAoaSA9IDg7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1ICs9ICh6W2ldICYgMHhmZikgfCAwXG4gICAgICB6W2ldID0gdSAmIDB4ZmZcbiAgICAgIHUgPj4+PSA4XG4gICAgfVxuICAgIGIgLT0gNjRcbiAgICBjcG9zICs9IDY0XG4gICAgbXBvcyArPSA2NFxuICAgIGkgPSAwXG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY29yZV9zYWxzYTIwKHgsIHosIHRoaXMuX3MsIFNJR01BKVxuICAgIGZvciAoOyBpIDwgYjsgaSsrKSBvdXRwdXRbY3BvcyArIGldID0gaW5wdXRbbXBvcyArIGldIF4geFtpXVxuICB9XG5cbiAgdGhpcy5fb3ZlcmZsb3cgPSBiICYgNjNcbn1cblxuRmFsbGJhY2sucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9zLmZpbGwoMClcbiAgdGhpcy5fei5maWxsKDApXG59XG5cbi8vIGJlbG93IG1ldGhvZHMgYXJlIHBvcnRlZCBmcm9tIHR3ZWV0IG5hY2xcblxuZnVuY3Rpb24gY29yZV9zYWxzYTIwKG8sIHAsIGssIGMpIHtcbiAgdmFyIGowICA9IGNbIDBdICYgMHhmZiB8IChjWyAxXSAmIDB4ZmYpIDw8IDggfCAoY1sgMl0gJiAweGZmKSA8PCAxNiB8IChjWyAzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEgID0ga1sgMF0gJiAweGZmIHwgKGtbIDFdICYgMHhmZikgPDwgOCB8IChrWyAyXSAmIDB4ZmYpIDw8IDE2IHwgKGtbIDNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMiAgPSBrWyA0XSAmIDB4ZmYgfCAoa1sgNV0gJiAweGZmKSA8PCA4IHwgKGtbIDZdICYgMHhmZikgPDwgMTYgfCAoa1sgN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGozICA9IGtbIDhdICYgMHhmZiB8IChrWyA5XSAmIDB4ZmYpIDw8IDggfCAoa1sxMF0gJiAweGZmKSA8PCAxNiB8IChrWzExXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajQgID0ga1sxMl0gJiAweGZmIHwgKGtbMTNdICYgMHhmZikgPDwgOCB8IChrWzE0XSAmIDB4ZmYpIDw8IDE2IHwgKGtbMTVdICYgMHhmZikgPDwgMjQsXG4gICAgICBqNSAgPSBjWyA0XSAmIDB4ZmYgfCAoY1sgNV0gJiAweGZmKSA8PCA4IHwgKGNbIDZdICYgMHhmZikgPDwgMTYgfCAoY1sgN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo2ICA9IHBbIDBdICYgMHhmZiB8IChwWyAxXSAmIDB4ZmYpIDw8IDggfCAocFsgMl0gJiAweGZmKSA8PCAxNiB8IChwWyAzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajcgID0gcFsgNF0gJiAweGZmIHwgKHBbIDVdICYgMHhmZikgPDwgOCB8IChwWyA2XSAmIDB4ZmYpIDw8IDE2IHwgKHBbIDddICYgMHhmZikgPDwgMjQsXG4gICAgICBqOCAgPSBwWyA4XSAmIDB4ZmYgfCAocFsgOV0gJiAweGZmKSA8PCA4IHwgKHBbMTBdICYgMHhmZikgPDwgMTYgfCAocFsxMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo5ICA9IHBbMTJdICYgMHhmZiB8IChwWzEzXSAmIDB4ZmYpIDw8IDggfCAocFsxNF0gJiAweGZmKSA8PCAxNiB8IChwWzE1XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEwID0gY1sgOF0gJiAweGZmIHwgKGNbIDldICYgMHhmZikgPDwgOCB8IChjWzEwXSAmIDB4ZmYpIDw8IDE2IHwgKGNbMTFdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTEgPSBrWzE2XSAmIDB4ZmYgfCAoa1sxN10gJiAweGZmKSA8PCA4IHwgKGtbMThdICYgMHhmZikgPDwgMTYgfCAoa1sxOV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxMiA9IGtbMjBdICYgMHhmZiB8IChrWzIxXSAmIDB4ZmYpIDw8IDggfCAoa1syMl0gJiAweGZmKSA8PCAxNiB8IChrWzIzXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEzID0ga1syNF0gJiAweGZmIHwgKGtbMjVdICYgMHhmZikgPDwgOCB8IChrWzI2XSAmIDB4ZmYpIDw8IDE2IHwgKGtbMjddICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTQgPSBrWzI4XSAmIDB4ZmYgfCAoa1syOV0gJiAweGZmKSA8PCA4IHwgKGtbMzBdICYgMHhmZikgPDwgMTYgfCAoa1szMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxNSA9IGNbMTJdICYgMHhmZiB8IChjWzEzXSAmIDB4ZmYpIDw8IDggfCAoY1sxNF0gJiAweGZmKSA8PCAxNiB8IChjWzE1XSAmIDB4ZmYpIDw8IDI0XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDBcbiAgICB4NCBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4NCArIHgwIHwgMFxuICAgIHg4IF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHg4ICsgeDQgfCAwXG4gICAgeDEyIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MTIgKyB4OCB8IDBcbiAgICB4MCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4NSArIHgxIHwgMFxuICAgIHg5IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHg5ICsgeDUgfCAwXG4gICAgeDEzIF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHgxMyArIHg5IHwgMFxuICAgIHgxIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MSArIHgxMyB8IDBcbiAgICB4NSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTAgKyB4NiB8IDBcbiAgICB4MTQgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDE0ICsgeDEwIHwgMFxuICAgIHgyIF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHgyICsgeDE0IHwgMFxuICAgIHg2IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4NiArIHgyIHwgMFxuICAgIHgxMCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwXG4gICAgeDMgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDMgKyB4MTUgfCAwXG4gICAgeDcgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDcgKyB4MyB8IDBcbiAgICB4MTEgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxMSArIHg3IHwgMFxuICAgIHgxNSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MCArIHgzIHwgMFxuICAgIHgxIF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgxICsgeDAgfCAwXG4gICAgeDIgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDIgKyB4MSB8IDBcbiAgICB4MyBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDMgKyB4MiB8IDBcbiAgICB4MCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4NSArIHg0IHwgMFxuICAgIHg2IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHg2ICsgeDUgfCAwXG4gICAgeDcgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDcgKyB4NiB8IDBcbiAgICB4NCBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDQgKyB4NyB8IDBcbiAgICB4NSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTAgKyB4OSB8IDBcbiAgICB4MTEgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDExICsgeDEwIHwgMFxuICAgIHg4IF49IHUgPDwgOSB8IHUgPj4+IDIzXG4gICAgdSA9IHg4ICsgeDExIHwgMFxuICAgIHg5IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4OSArIHg4IHwgMFxuICAgIHgxMCBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcblxuICAgIHUgPSB4MTUgKyB4MTQgfCAwXG4gICAgeDEyIF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHgxMiArIHgxNSB8IDBcbiAgICB4MTMgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDEzICsgeDEyIHwgMFxuICAgIHgxNCBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDE0ICsgeDEzIHwgMFxuICAgIHgxNSBePSB1IDw8IDE4IHwgdSA+Pj4gMTRcbiAgfVxuICAgeDAgPSAgeDAgKyAgajAgfCAwXG4gICB4MSA9ICB4MSArICBqMSB8IDBcbiAgIHgyID0gIHgyICsgIGoyIHwgMFxuICAgeDMgPSAgeDMgKyAgajMgfCAwXG4gICB4NCA9ICB4NCArICBqNCB8IDBcbiAgIHg1ID0gIHg1ICsgIGo1IHwgMFxuICAgeDYgPSAgeDYgKyAgajYgfCAwXG4gICB4NyA9ICB4NyArICBqNyB8IDBcbiAgIHg4ID0gIHg4ICsgIGo4IHwgMFxuICAgeDkgPSAgeDkgKyAgajkgfCAwXG4gIHgxMCA9IHgxMCArIGoxMCB8IDBcbiAgeDExID0geDExICsgajExIHwgMFxuICB4MTIgPSB4MTIgKyBqMTIgfCAwXG4gIHgxMyA9IHgxMyArIGoxMyB8IDBcbiAgeDE0ID0geDE0ICsgajE0IHwgMFxuICB4MTUgPSB4MTUgKyBqMTUgfCAwXG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmXG4gIG9bIDFdID0geDAgPj4+ICA4ICYgMHhmZlxuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmZcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmXG5cbiAgb1sgNF0gPSB4MSA+Pj4gIDAgJiAweGZmXG4gIG9bIDVdID0geDEgPj4+ICA4ICYgMHhmZlxuICBvWyA2XSA9IHgxID4+PiAxNiAmIDB4ZmZcbiAgb1sgN10gPSB4MSA+Pj4gMjQgJiAweGZmXG5cbiAgb1sgOF0gPSB4MiA+Pj4gIDAgJiAweGZmXG4gIG9bIDldID0geDIgPj4+ICA4ICYgMHhmZlxuICBvWzEwXSA9IHgyID4+PiAxNiAmIDB4ZmZcbiAgb1sxMV0gPSB4MiA+Pj4gMjQgJiAweGZmXG5cbiAgb1sxMl0gPSB4MyA+Pj4gIDAgJiAweGZmXG4gIG9bMTNdID0geDMgPj4+ICA4ICYgMHhmZlxuICBvWzE0XSA9IHgzID4+PiAxNiAmIDB4ZmZcbiAgb1sxNV0gPSB4MyA+Pj4gMjQgJiAweGZmXG5cbiAgb1sxNl0gPSB4NCA+Pj4gIDAgJiAweGZmXG4gIG9bMTddID0geDQgPj4+ICA4ICYgMHhmZlxuICBvWzE4XSA9IHg0ID4+PiAxNiAmIDB4ZmZcbiAgb1sxOV0gPSB4NCA+Pj4gMjQgJiAweGZmXG5cbiAgb1syMF0gPSB4NSA+Pj4gIDAgJiAweGZmXG4gIG9bMjFdID0geDUgPj4+ICA4ICYgMHhmZlxuICBvWzIyXSA9IHg1ID4+PiAxNiAmIDB4ZmZcbiAgb1syM10gPSB4NSA+Pj4gMjQgJiAweGZmXG5cbiAgb1syNF0gPSB4NiA+Pj4gIDAgJiAweGZmXG4gIG9bMjVdID0geDYgPj4+ICA4ICYgMHhmZlxuICBvWzI2XSA9IHg2ID4+PiAxNiAmIDB4ZmZcbiAgb1syN10gPSB4NiA+Pj4gMjQgJiAweGZmXG5cbiAgb1syOF0gPSB4NyA+Pj4gIDAgJiAweGZmXG4gIG9bMjldID0geDcgPj4+ICA4ICYgMHhmZlxuICBvWzMwXSA9IHg3ID4+PiAxNiAmIDB4ZmZcbiAgb1szMV0gPSB4NyA+Pj4gMjQgJiAweGZmXG5cbiAgb1szMl0gPSB4OCA+Pj4gIDAgJiAweGZmXG4gIG9bMzNdID0geDggPj4+ICA4ICYgMHhmZlxuICBvWzM0XSA9IHg4ID4+PiAxNiAmIDB4ZmZcbiAgb1szNV0gPSB4OCA+Pj4gMjQgJiAweGZmXG5cbiAgb1szNl0gPSB4OSA+Pj4gIDAgJiAweGZmXG4gIG9bMzddID0geDkgPj4+ICA4ICYgMHhmZlxuICBvWzM4XSA9IHg5ID4+PiAxNiAmIDB4ZmZcbiAgb1szOV0gPSB4OSA+Pj4gMjQgJiAweGZmXG5cbiAgb1s0MF0gPSB4MTAgPj4+ICAwICYgMHhmZlxuICBvWzQxXSA9IHgxMCA+Pj4gIDggJiAweGZmXG4gIG9bNDJdID0geDEwID4+PiAxNiAmIDB4ZmZcbiAgb1s0M10gPSB4MTAgPj4+IDI0ICYgMHhmZlxuXG4gIG9bNDRdID0geDExID4+PiAgMCAmIDB4ZmZcbiAgb1s0NV0gPSB4MTEgPj4+ICA4ICYgMHhmZlxuICBvWzQ2XSA9IHgxMSA+Pj4gMTYgJiAweGZmXG4gIG9bNDddID0geDExID4+PiAyNCAmIDB4ZmZcblxuICBvWzQ4XSA9IHgxMiA+Pj4gIDAgJiAweGZmXG4gIG9bNDldID0geDEyID4+PiAgOCAmIDB4ZmZcbiAgb1s1MF0gPSB4MTIgPj4+IDE2ICYgMHhmZlxuICBvWzUxXSA9IHgxMiA+Pj4gMjQgJiAweGZmXG5cbiAgb1s1Ml0gPSB4MTMgPj4+ICAwICYgMHhmZlxuICBvWzUzXSA9IHgxMyA+Pj4gIDggJiAweGZmXG4gIG9bNTRdID0geDEzID4+PiAxNiAmIDB4ZmZcbiAgb1s1NV0gPSB4MTMgPj4+IDI0ICYgMHhmZlxuXG4gIG9bNTZdID0geDE0ID4+PiAgMCAmIDB4ZmZcbiAgb1s1N10gPSB4MTQgPj4+ICA4ICYgMHhmZlxuICBvWzU4XSA9IHgxNCA+Pj4gMTYgJiAweGZmXG4gIG9bNTldID0geDE0ID4+PiAyNCAmIDB4ZmZcblxuICBvWzYwXSA9IHgxNSA+Pj4gIDAgJiAweGZmXG4gIG9bNjFdID0geDE1ID4+PiAgOCAmIDB4ZmZcbiAgb1s2Ml0gPSB4MTUgPj4+IDE2ICYgMHhmZlxuICBvWzYzXSA9IHgxNSA+Pj4gMjQgJiAweGZmXG59XG5cbmZ1bmN0aW9uIGNvcmVfaHNhbHNhMjAobyxwLGssYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZikgPDwgOCB8IChjWyAyXSAmIDB4ZmYpIDw8IDE2IHwgKGNbIDNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKSA8PCA4IHwgKGtbIDJdICYgMHhmZikgPDwgMTYgfCAoa1sgM10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpIDw8IDggfCAoa1sgNl0gJiAweGZmKSA8PCAxNiB8IChrWyA3XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZikgPDwgOCB8IChrWzEwXSAmIDB4ZmYpIDw8IDE2IHwgKGtbMTFdICYgMHhmZikgPDwgMjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKSA8PCA4IHwgKGtbMTRdICYgMHhmZikgPDwgMTYgfCAoa1sxNV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpIDw8IDggfCAoY1sgNl0gJiAweGZmKSA8PCAxNiB8IChjWyA3XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZikgPDwgOCB8IChwWyAyXSAmIDB4ZmYpIDw8IDE2IHwgKHBbIDNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKSA8PCA4IHwgKHBbIDZdICYgMHhmZikgPDwgMTYgfCAocFsgN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpIDw8IDggfCAocFsxMF0gJiAweGZmKSA8PCAxNiB8IChwWzExXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZikgPDwgOCB8IChwWzE0XSAmIDB4ZmYpIDw8IDE2IHwgKHBbMTVdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKSA8PCA4IHwgKGNbMTBdICYgMHhmZikgPDwgMTYgfCAoY1sxMV0gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpIDw8IDggfCAoa1sxOF0gJiAweGZmKSA8PCAxNiB8IChrWzE5XSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZikgPDwgOCB8IChrWzIyXSAmIDB4ZmYpIDw8IDE2IHwgKGtbMjNdICYgMHhmZikgPDwgMjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKSA8PCA4IHwgKGtbMjZdICYgMHhmZikgPDwgMTYgfCAoa1syN10gJiAweGZmKSA8PCAyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpIDw8IDggfCAoa1szMF0gJiAweGZmKSA8PCAxNiB8IChrWzMxXSAmIDB4ZmYpIDw8IDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZikgPDwgOCB8IChjWzE0XSAmIDB4ZmYpIDw8IDE2IHwgKGNbMTVdICYgMHhmZikgPDwgMjRcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSArPSAyKSB7XG4gICAgdSA9IHgwICsgeDEyIHwgMFxuICAgIHg0IF49IHUgPDwgNyB8IHUgPj4+IDI1XG4gICAgdSA9IHg0ICsgeDAgfCAwXG4gICAgeDggXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDggKyB4NCB8IDBcbiAgICB4MTIgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxMiArIHg4IHwgMFxuICAgIHgwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHg1ICsgeDEgfCAwXG4gICAgeDkgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDkgKyB4NSB8IDBcbiAgICB4MTMgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDEzICsgeDkgfCAwXG4gICAgeDEgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHgxICsgeDEzIHwgMFxuICAgIHg1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxMCArIHg2IHwgMFxuICAgIHgxNCBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MTQgKyB4MTAgfCAwXG4gICAgeDIgXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDIgKyB4MTQgfCAwXG4gICAgeDYgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHg2ICsgeDIgfCAwXG4gICAgeDEwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxNSArIHgxMSB8IDBcbiAgICB4MyBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MyArIHgxNSB8IDBcbiAgICB4NyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4NyArIHgzIHwgMFxuICAgIHgxMSBePSB1IDw8IDEzIHwgdSA+Pj4gMTlcbiAgICB1ID0geDExICsgeDcgfCAwXG4gICAgeDE1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgwICsgeDMgfCAwXG4gICAgeDEgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDEgKyB4MCB8IDBcbiAgICB4MiBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4MiArIHgxIHwgMFxuICAgIHgzIF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MyArIHgyIHwgMFxuICAgIHgwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHg1ICsgeDQgfCAwXG4gICAgeDYgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDYgKyB4NSB8IDBcbiAgICB4NyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4NyArIHg2IHwgMFxuICAgIHg0IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4NCArIHg3IHwgMFxuICAgIHg1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxMCArIHg5IHwgMFxuICAgIHgxMSBePSB1IDw8IDcgfCB1ID4+PiAyNVxuICAgIHUgPSB4MTEgKyB4MTAgfCAwXG4gICAgeDggXj0gdSA8PCA5IHwgdSA+Pj4gMjNcbiAgICB1ID0geDggKyB4MTEgfCAwXG4gICAgeDkgXj0gdSA8PCAxMyB8IHUgPj4+IDE5XG4gICAgdSA9IHg5ICsgeDggfCAwXG4gICAgeDEwIF49IHUgPDwgMTggfCB1ID4+PiAxNFxuXG4gICAgdSA9IHgxNSArIHgxNCB8IDBcbiAgICB4MTIgXj0gdSA8PCA3IHwgdSA+Pj4gMjVcbiAgICB1ID0geDEyICsgeDE1IHwgMFxuICAgIHgxMyBePSB1IDw8IDkgfCB1ID4+PiAyM1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwXG4gICAgeDE0IF49IHUgPDwgMTMgfCB1ID4+PiAxOVxuICAgIHUgPSB4MTQgKyB4MTMgfCAwXG4gICAgeDE1IF49IHUgPDwgMTggfCB1ID4+PiAxNFxuICB9XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmXG4gIG9bIDFdID0geDAgPj4+ICA4ICYgMHhmZlxuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmZcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmXG5cbiAgb1sgNF0gPSB4NSA+Pj4gIDAgJiAweGZmXG4gIG9bIDVdID0geDUgPj4+ICA4ICYgMHhmZlxuICBvWyA2XSA9IHg1ID4+PiAxNiAmIDB4ZmZcbiAgb1sgN10gPSB4NSA+Pj4gMjQgJiAweGZmXG5cbiAgb1sgOF0gPSB4MTAgPj4+ICAwICYgMHhmZlxuICBvWyA5XSA9IHgxMCA+Pj4gIDggJiAweGZmXG4gIG9bMTBdID0geDEwID4+PiAxNiAmIDB4ZmZcbiAgb1sxMV0gPSB4MTAgPj4+IDI0ICYgMHhmZlxuXG4gIG9bMTJdID0geDE1ID4+PiAgMCAmIDB4ZmZcbiAgb1sxM10gPSB4MTUgPj4+ICA4ICYgMHhmZlxuICBvWzE0XSA9IHgxNSA+Pj4gMTYgJiAweGZmXG4gIG9bMTVdID0geDE1ID4+PiAyNCAmIDB4ZmZcblxuICBvWzE2XSA9IHg2ID4+PiAgMCAmIDB4ZmZcbiAgb1sxN10gPSB4NiA+Pj4gIDggJiAweGZmXG4gIG9bMThdID0geDYgPj4+IDE2ICYgMHhmZlxuICBvWzE5XSA9IHg2ID4+PiAyNCAmIDB4ZmZcblxuICBvWzIwXSA9IHg3ID4+PiAgMCAmIDB4ZmZcbiAgb1syMV0gPSB4NyA+Pj4gIDggJiAweGZmXG4gIG9bMjJdID0geDcgPj4+IDE2ICYgMHhmZlxuICBvWzIzXSA9IHg3ID4+PiAyNCAmIDB4ZmZcblxuICBvWzI0XSA9IHg4ID4+PiAgMCAmIDB4ZmZcbiAgb1syNV0gPSB4OCA+Pj4gIDggJiAweGZmXG4gIG9bMjZdID0geDggPj4+IDE2ICYgMHhmZlxuICBvWzI3XSA9IHg4ID4+PiAyNCAmIDB4ZmZcblxuICBvWzI4XSA9IHg5ID4+PiAgMCAmIDB4ZmZcbiAgb1syOV0gPSB4OSA+Pj4gIDggJiAweGZmXG4gIG9bMzBdID0geDkgPj4+IDE2ICYgMHhmZlxuICBvWzMxXSA9IHg5ID4+PiAyNCAmIDB4ZmZcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBsb2FkV2ViQXNzZW1ibHlcblxubG9hZFdlYkFzc2VtYmx5LnN1cHBvcnRlZCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ3VuZGVmaW5lZCdcblxuZnVuY3Rpb24gbG9hZFdlYkFzc2VtYmx5IChvcHRzKSB7XG4gIGlmICghbG9hZFdlYkFzc2VtYmx5LnN1cHBvcnRlZCkgcmV0dXJuIG51bGxcblxuICB2YXIgaW1wID0gb3B0cyAmJiBvcHRzLmltcG9ydHNcbiAgdmFyIHdhc20gPSB0b1VpbnQ4QXJyYXkoJ0FHRnpiUUVBQUFBQkdnTmdCbjkvZjM5L2Z3QmdCbjkvZjM5K2Z3RitZQU4vZjM4QUF3Y0dBQUVCQWdJQ0JRVUJBUXJvQndjb0F3WnRaVzF2Y25rQ0FBeDRjMkZzYzJFeU1GOTRiM0lBQUF4amIzSmxYM05oYkhOaE1qQUFCQXJxRVFZWUFDQUFJQUVnQWlBRElBUWdBQ2tEQUNBRkVBRTNBd0FMUFFCQjhBQWdBeUFGRUFNZ0FDQUJJQUlnQTBFUWFpQUVRZkFBRUFKQjhBQkNBRGNEQUVINEFFSUFOd01BUVlBQlFnQTNBd0JCaUFGQ0FEY0RBQXVIQlFFQmZ5QUNRUUJHQkVCQ0FBOExRZEFBSUFVcEF3QTNBd0JCMkFBZ0JVRUlhaWtEQURjREFFSGdBQ0FGUVJCcUtRTUFOd01BUWVnQUlBVkJHR29wQXdBM0F3QkJBQ0FES1FNQU53TUFRUWdnQkRjREFBSkFBMEFnQWtIQUFFa05BVUVRUVFCQjBBQVFCU0FBSUFFcEF3QkJFQ2tEQUlVM0F3QWdBRUVJYWlBQlFRaHFLUU1BUVJncEF3Q0ZOd01BSUFCQkVHb2dBVUVRYWlrREFFRWdLUU1BaFRjREFDQUFRUmhxSUFGQkdHb3BBd0JCS0NrREFJVTNBd0FnQUVFZ2FpQUJRU0JxS1FNQVFUQXBBd0NGTndNQUlBQkJLR29nQVVFb2Fpa0RBRUU0S1FNQWhUY0RBQ0FBUVRCcUlBRkJNR29wQXdCQndBQXBBd0NGTndNQUlBQkJPR29nQVVFNGFpa0RBRUhJQUNrREFJVTNBd0JCQ0VFSUtRTUFRZ0Y4TndNQUlBQkJ3QUJxSVFBZ0FVSEFBR29oQVNBQ1FjQUFheUVDREFBTEMwRUlLUU1BSVFRZ0FrRUFTd1JBUVJCQkFFSFFBQkFGQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FDUVFodURnY0hCZ1VFQXdJQkFBc2dBRUU0YWlBQlFUaHFLUU1BUWNnQUtRTUFoVGNEQUFzZ0FFRXdhaUFCUVRCcUtRTUFRY0FBS1FNQWhUY0RBQXNnQUVFb2FpQUJRU2hxS1FNQVFUZ3BBd0NGTndNQUN5QUFRU0JxSUFGQklHb3BBd0JCTUNrREFJVTNBd0FMSUFCQkdHb2dBVUVZYWlrREFFRW9LUU1BaFRjREFBc2dBRUVRYWlBQlFSQnFLUU1BUVNBcEF3Q0ZOd01BQ3lBQVFRaHFJQUZCQ0dvcEF3QkJHQ2tEQUlVM0F3QUxJQUFnQVNrREFFRVFLUU1BaFRjREFBdEJFRUlBTndNQVFSaENBRGNEQUVFZ1FnQTNBd0JCS0VJQU53TUFRVEJDQURjREFFRTRRZ0EzQXdCQndBQkNBRGNEQUVISUFFSUFOd01BUWRBQVFnQTNBd0JCMkFCQ0FEY0RBRUhnQUVJQU53TUFRZWdBUWdBM0F3QWdCQThMblFVQkVYOUI1ZkRCaXdZaEEwSHV5SUdaQXlFSVFiTGFpTXNISVExQjlNcUIyUVloRWlBQ0tBSUFJUVFnQWtFRWFpZ0NBQ0VGSUFKQkNHb29BZ0FoQmlBQ1FReHFLQUlBSVFjZ0FrRVFhaWdDQUNFT0lBSkJGR29vQWdBaER5QUNRUmhxS0FJQUlSQWdBa0VjYWlnQ0FDRVJJQUVvQWdBaENTQUJRUVJxS0FJQUlRb2dBVUVJYWlnQ0FDRUxJQUZCREdvb0FnQWhERUVVSVJNQ1FBTkFJQk5CQUVZTkFTQUhJQU1nRDJwQkIzZHpJUWNnQ3lBSElBTnFRUWwzY3lFTElBOGdDeUFIYWtFTmQzTWhEeUFESUE4Z0MycEJFbmR6SVFNZ0RDQUlJQVJxUVFkM2N5RU1JQkFnRENBSWFrRUpkM01oRUNBRUlCQWdER3BCRFhkeklRUWdDQ0FFSUJCcVFSSjNjeUVJSUJFZ0RTQUpha0VIZDNNaEVTQUZJQkVnRFdwQkNYZHpJUVVnQ1NBRklCRnFRUTEzY3lFSklBMGdDU0FGYWtFU2QzTWhEU0FHSUJJZ0RtcEJCM2R6SVFZZ0NpQUdJQkpxUVFsM2N5RUtJQTRnQ2lBR2FrRU5kM01oRGlBU0lBNGdDbXBCRW5keklSSWdCQ0FESUFacVFRZDNjeUVFSUFVZ0JDQURha0VKZDNNaEJTQUdJQVVnQkdwQkRYZHpJUVlnQXlBR0lBVnFRUkozY3lFRElBa2dDQ0FIYWtFSGQzTWhDU0FLSUFrZ0NHcEJDWGR6SVFvZ0J5QUtJQWxxUVExM2N5RUhJQWdnQnlBS2FrRVNkM01oQ0NBT0lBMGdER3BCQjNkeklRNGdDeUFPSUExcVFRbDNjeUVMSUF3Z0N5QU9ha0VOZDNNaERDQU5JQXdnQzJwQkVuZHpJUTBnRHlBU0lCRnFRUWQzY3lFUElCQWdEeUFTYWtFSmQzTWhFQ0FSSUJBZ0QycEJEWGR6SVJFZ0VpQVJJQkJxUVJKM2N5RVNJQk5CQW1zaEV3d0FDd3NnQUNBRE5nSUFJQUJCQkdvZ0NEWUNBQ0FBUVFocUlBMDJBZ0FnQUVFTWFpQVNOZ0lBSUFCQkVHb2dDVFlDQUNBQVFSUnFJQW8yQWdBZ0FFRVlhaUFMTmdJQUlBQkJIR29nRERZQ0FBc0tBQ0FBSUFFZ0FoQUZDOTBHQVNGL1FlWHd3WXNHSVFOQjdzaUJtUU1oQ0VHeTJvakxCeUVOUWZUS2dka0dJUklnQWlnQ0FDRUVJQUpCQkdvb0FnQWhCU0FDUVFocUtBSUFJUVlnQWtFTWFpZ0NBQ0VISUFKQkVHb29BZ0FoRGlBQ1FSUnFLQUlBSVE4Z0FrRVlhaWdDQUNFUUlBSkJIR29vQWdBaEVTQUJLQUlBSVFrZ0FVRUVhaWdDQUNFS0lBRkJDR29vQWdBaEN5QUJRUXhxS0FJQUlRd2dBeUVUSUFRaEZDQUZJUlVnQmlFV0lBY2hGeUFJSVJnZ0NTRVpJQW9oR2lBTElSc2dEQ0VjSUEwaEhTQU9JUjRnRHlFZklCQWhJQ0FSSVNFZ0VpRWlRUlFoSXdKQUEwQWdJMEVBUmcwQklBY2dBeUFQYWtFSGQzTWhCeUFMSUFjZ0EycEJDWGR6SVFzZ0R5QUxJQWRxUVExM2N5RVBJQU1nRHlBTGFrRVNkM01oQXlBTUlBZ2dCR3BCQjNkeklRd2dFQ0FNSUFocVFRbDNjeUVRSUFRZ0VDQU1ha0VOZDNNaEJDQUlJQVFnRUdwQkVuZHpJUWdnRVNBTklBbHFRUWQzY3lFUklBVWdFU0FOYWtFSmQzTWhCU0FKSUFVZ0VXcEJEWGR6SVFrZ0RTQUpJQVZxUVJKM2N5RU5JQVlnRWlBT2FrRUhkM01oQmlBS0lBWWdFbXBCQ1hkeklRb2dEaUFLSUFacVFRMTNjeUVPSUJJZ0RpQUtha0VTZDNNaEVpQUVJQU1nQm1wQkIzZHpJUVFnQlNBRUlBTnFRUWwzY3lFRklBWWdCU0FFYWtFTmQzTWhCaUFESUFZZ0JXcEJFbmR6SVFNZ0NTQUlJQWRxUVFkM2N5RUpJQW9nQ1NBSWFrRUpkM01oQ2lBSElBb2dDV3BCRFhkeklRY2dDQ0FISUFwcVFSSjNjeUVJSUE0Z0RTQU1ha0VIZDNNaERpQUxJQTRnRFdwQkNYZHpJUXNnRENBTElBNXFRUTEzY3lFTUlBMGdEQ0FMYWtFU2QzTWhEU0FQSUJJZ0VXcEJCM2R6SVE4Z0VDQVBJQkpxUVFsM2N5RVFJQkVnRUNBUGFrRU5kM01oRVNBU0lCRWdFR3BCRW5keklSSWdJMEVDYXlFakRBQUxDeUFBSUFNZ0UybzJBZ0FnQUVFRWFpQUVJQlJxTmdJQUlBQkJDR29nQlNBVmFqWUNBQ0FBUVF4cUlBWWdGbW8yQWdBZ0FFRVFhaUFISUJkcU5nSUFJQUJCRkdvZ0NDQVlhallDQUNBQVFSaHFJQWtnR1dvMkFnQWdBRUVjYWlBS0lCcHFOZ0lBSUFCQklHb2dDeUFiYWpZQ0FDQUFRU1JxSUF3Z0hHbzJBZ0FnQUVFb2FpQU5JQjFxTmdJQUlBQkJMR29nRGlBZWFqWUNBQ0FBUVRCcUlBOGdIMm8yQWdBZ0FFRTBhaUFRSUNCcU5nSUFJQUJCT0dvZ0VTQWhhallDQUNBQVFUeHFJQklnSW1vMkFnQUwnKVxuICB2YXIgcmVhZHkgPSBudWxsXG5cbiAgdmFyIG1vZCA9IHtcbiAgICBidWZmZXI6IHdhc20sXG4gICAgbWVtb3J5OiBudWxsLFxuICAgIGV4cG9ydHM6IG51bGwsXG4gICAgcmVhbGxvYzogcmVhbGxvYyxcbiAgICBvbmxvYWQ6IG9ubG9hZFxuICB9XG5cbiAgb25sb2FkKGZ1bmN0aW9uICgpIHt9KVxuXG4gIHJldHVybiBtb2RcblxuICBmdW5jdGlvbiByZWFsbG9jIChzaXplKSB7XG4gICAgbW9kLmV4cG9ydHMubWVtb3J5Lmdyb3coTWF0aC5jZWlsKE1hdGguYWJzKHNpemUgLSBtb2QubWVtb3J5Lmxlbmd0aCkgLyA2NTUzNikpXG4gICAgbW9kLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBvbmxvYWQgKGNiKSB7XG4gICAgaWYgKG1vZC5leHBvcnRzKSByZXR1cm4gY2IoKVxuXG4gICAgaWYgKHJlYWR5KSB7XG4gICAgICByZWFkeS50aGVuKGNiLmJpbmQobnVsbCwgbnVsbCkpLmNhdGNoKGNiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMnKVxuICAgICAgc2V0dXAoe2luc3RhbmNlOiBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZSh3YXNtKSwgaW1wKX0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZWFkeSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc20sIGltcCkudGhlbihzZXR1cClcbiAgICB9XG5cbiAgICBvbmxvYWQoY2IpXG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cCAodykge1xuICAgIG1vZC5leHBvcnRzID0gdy5pbnN0YW5jZS5leHBvcnRzXG4gICAgbW9kLm1lbW9yeSA9IG1vZC5leHBvcnRzLm1lbW9yeSAmJiBtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyICYmIG5ldyBVaW50OEFycmF5KG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9VaW50OEFycmF5IChzKSB7XG4gIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF0b2Iocykuc3BsaXQoJycpLm1hcChjaGFyQ29kZUF0KSlcbiAgcmV0dXJuIG5ldyAocmVxdWlyZSgnYnVmJyArICdmZXInKS5CdWZmZXIpKHMsICdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiBjaGFyQ29kZUF0IChjKSB7XG4gIHJldHVybiBjLmNoYXJDb2RlQXQoMClcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBoeXBlcmNvcmUgPSByZXF1aXJlKFwiaHlwZXJjb3JlXCIpXG52YXIgUmFuZG9tQWNjZXNzRmlsZSA9IHJlcXVpcmUoXCIuL3JhbmRvbS1hY2Nlc3MtZmlsZVwiKVxuXG5jb25zdCBtYWluID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB2b2x1bWUgPSBhd2FpdCBSYW5kb21BY2Nlc3NGaWxlLm1vdW50KClcbiAgdmFyIGZlZWQgPSBoeXBlcmNvcmUodm9sdW1lLCB7IHZhbHVlRW5jb2Rpbmc6IFwianNvblwiIH0pXG5cbiAgZmVlZC5hcHBlbmQoe1xuICAgIGhlbGxvOiBcIndvcmxkXCJcbiAgfSlcblxuICBmZWVkLmFwcGVuZCh7XG4gICAgaGVqOiBcInZlcmRlblwiXG4gIH0pXG5cbiAgZmVlZC5hcHBlbmQoe1xuICAgIGhvbGE6IFwibXVuZG9cIlxuICB9KVxuXG4gIGZlZWQuZmx1c2goZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIkFwcGVuZGVkIDMgbW9yZSBibG9ja3MsICVkIGluIHRvdGFsICglZCBieXRlcylcXG5cIixcbiAgICAgIGZlZWQubGVuZ3RoLFxuICAgICAgZmVlZC5ieXRlTGVuZ3RoXG4gICAgKVxuXG4gICAgZmVlZFxuICAgICAgLmNyZWF0ZVJlYWRTdHJlYW0oKVxuICAgICAgLm9uKFwiZGF0YVwiLCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKVxuICAgICAgLm9uKFwiZW5kXCIsIGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSwgXCJcXG4oZW5kKVwiKSlcbiAgfSlcbn1cblxubWFpbigpXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5jb25zdCBSYW5kb21BY2Nlc3MgPSByZXF1aXJlKFwicmFuZG9tLWFjY2Vzcy1zdG9yYWdlXCIpXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZShcIkJ1ZmZlclwiKVxuXG5jb25zdCBNQVhfU0laRSA9ICgxIDw8IDMwKSAqIDIgLSAoMSA8PCAxMikgLSAxXG5cbmNsYXNzIFJhbmRvbUFjY2Vzc0ZpbGUgZXh0ZW5kcyBSYW5kb21BY2Nlc3Mge1xuICBjb25zdHJ1Y3Rvcih2b2x1bWUsIG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMudm9sdW1lID0gdm9sdW1lXG4gICAgdGhpcy51cmwgPSBgJHt2b2x1bWUudXJsfSR7bmFtZX1gXG4gICAgdGhpcy5maWxlID0gbnVsbFxuICB9XG4gIHN0YXRpYyBhc3luYyBtb3VudCh1cmwgPSBudWxsKSB7XG4gICAgY29uc3Qgdm9sdW1lID0gYXdhaXQgYnJvd3Nlci5GaWxlU3lzdGVtLm1vdW50KHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgcmVhZDogdHJ1ZSxcbiAgICAgIHdyaXRlOiB0cnVlXG4gICAgfSlcblxuICAgIHJldHVybiAobmFtZSwgb3B0aW9ucykgPT4gbmV3IFJhbmRvbUFjY2Vzc0ZpbGUodm9sdW1lLCBuYW1lLCBvcHRpb25zKVxuICB9XG4gIHN0YXRpYyBhc3luYyBvcGVuKHNlbGYsIG1vZGUpIHtcbiAgICBzZWxmLmZpbGUgPSBhd2FpdCBicm93c2VyLkZpbGVTeXN0ZW0ub3BlbihzZWxmLnVybCwge1xuICAgICAgcmVhZDogdHJ1ZSxcbiAgICAgIHdyaXRlOiB0cnVlXG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKFwib3BlbmVkXCIsIHNlbGYpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVsZXRlKHNlbGYsIHBvc2l0aW9uLCBzaXplKSB7XG4gICAgY29uc3Qgc3RhdCA9IGF3YWl0IGJyb3dzZXIuRmlsZS5zdGF0KHNlbGYuZmlsZSlcbiAgICBpZiAocG9zaXRpb24gKyBzaXplIDwgc3RhdC5zaXplKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkYXRhID1cbiAgICAgICAgcG9zaXRpb24gPiAwXG4gICAgICAgICAgPyBhd2FpdCBicm93c2VyLkZpbGUucmVhZChmaWxlLCB7IHBvc2l0aW9uOiAwLCBzaXplOiBwb3NpdGlvbiB9KVxuICAgICAgICAgIDogbnVsbFxuXG4gICAgICBzZWxmLmZpbGUgPSBhd2FpdCBicm93c2VyLkZpbGVTeXN0ZW0ub3BlbihzZWxmLmZpbGVVUkwsIHtcbiAgICAgICAgdHJ1bmNhdGU6IHRydWUsXG4gICAgICAgIHJlYWQ6IHRydWUsXG4gICAgICAgIHdyaXRlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBhd2FpdCBicm93c2VyLkZpbGUud3JpdGUoc2VsZi5maWxlLCBkYXRhLCB7IHBvc2l0aW9uOiAwIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9vcGVuKHJlcXVlc3QpIHtcbiAgICBjb25zb2xlLmxvZyhcIl9vcGVuXCIsIHJlcXVlc3QsIHRoaXMpXG4gICAgUmFuZG9tQWNjZXNzRmlsZS5vcGVuKHRoaXMsIHsgcmVhZDogdHJ1ZSwgd3JpdGU6IHRydWUgfSlcbiAgICAgIC50aGVuKHNlbGYgPT4gcmVxdWVzdC5jYWxsYmFjayhudWxsLCBzZWxmKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiByZXF1ZXN0LmNhbGxiYWNrKGVycm9yKSlcbiAgfVxuICAvLyBfb3BlblJlYWRvbmx5KHJlcXVlc3QpIHtcbiAgLy8gICBjb25zb2xlLmxvZyhcIl9vcGVuUmVhZG9ubHlcIiwgcmVxdWVzdClcbiAgLy8gICBSYW5kb21BY2Nlc3NGaWxlLm9wZW4odGhpcywgeyByZWFkOiB0cnVlIH0pXG4gIC8vICAgICAudGhlbihzZWxmID0+IHJlcXVlc3QuY2FsbGJhY2sobnVsbCwgc2VsZikpXG4gIC8vICAgICAuY2F0Y2goZXJyb3IgPT4gcmVxdWVzdC5jYWxsYmFjayhlcnJvcikpXG4gIC8vIH1cbiAgX3dyaXRlKHJlcXVlc3QpIHtcbiAgICBjb25zb2xlLmxvZyhcIl93cml0ZVwiLCByZXF1ZXN0LCB0aGlzLmZpbGUsIHRoaXMudXJsKVxuICAgIGNvbnN0IHsgb2Zmc2V0LCBzaXplLCBkYXRhIH0gPSByZXF1ZXN0XG4gICAgYnJvd3Nlci5GaWxlLndyaXRlKHRoaXMuZmlsZSwgZGF0YS5idWZmZXIsIHtcbiAgICAgIHBvc2l0aW9uOiBvZmZzZXQsXG4gICAgICBzaXplXG4gICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHJlcXVlc3QuY2FsbGJhY2sobnVsbCkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4gcmVxdWVzdC5jYWxsYmFjaylcbiAgfVxuICBzdGF0aWMgYXN5bmMgcmVhZChmaWxlLCBidWZmZXIsIHBvc2l0aW9uLCBzaXplKSB7XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IGJyb3dzZXIuRmlsZS5yZWFkKGZpbGUsIHtcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgIHNpemU6IE1BWF9TSVpFIDwgc2l6ZSA/IHVuZGVmaW5lZCA6IHNpemVcbiAgICB9KVxuICAgIEJ1ZmZlci5mcm9tKGNvbnRlbnQpLmNvcHkoYnVmZmVyKVxuICAgIHJldHVybiBidWZmZXJcblxuICAgIC8vIGlmIChkYXRhLmJ5dGVMZW5ndGggPCBvcHRpb25zLnNpemUpIHtcbiAgICAvLyAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KG9wdGlvbnMuc2l6ZSlcbiAgICAvLyAgIHJlc3VsdC5zZXQoZGF0YSlcbiAgICAvLyAgIHJldHVybiByZXN1bHRcbiAgICAvLyB9IGVsc2Uge1xuICAgIC8vICAgcmV0dXJuIGRhdGFcbiAgICAvLyB9XG4gIH1cbiAgX3JlYWQocmVxdWVzdCkge1xuICAgIGNvbnNvbGUubG9nKFwiX3JlYWRcIiwgcmVxdWVzdClcbiAgICBjb25zdCB7IG9mZnNldCwgc2l6ZSB9ID0gcmVxdWVzdFxuICAgIGNvbnN0IGJ1ZmZlciA9IHJlcXVlc3QuZGF0YSB8fCBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcbiAgICBSYW5kb21BY2Nlc3NGaWxlLnJlYWQodGhpcy5maWxlLCBidWZmZXIsIG9mZnNldCwgc2l6ZSlcbiAgICAgIC50aGVuKGRhdGEgPT4gcmVxdWVzdC5jYWxsYmFjayhudWxsLCBkYXRhKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiByZXF1ZXN0LmNhbGxiYWNrKGVycm9yKSlcbiAgfVxuICBfZGVsKHJlcXVlc3QpIHtcbiAgICBjb25zb2xlLmxvZyhcIl9kZWxcIiwgcmVxdWVzdClcbiAgICBSYW5kb21BY2Nlc3NGaWxlLmRlbGV0ZSh0aGlzLCByZXF1ZXN0Lm9mZnNldCwgcmVxdWVzdC5zaXplKVxuICAgICAgLnRoZW4oKCkgPT4gcmVxdWVzdC5jYWxsYmFjayhudWxsKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiByZXF1ZXN0LmNhbGxiYWNrKG51bGwpKVxuICB9XG4gIF9zdGF0KHJlcXVlc3QpIHtcbiAgICBjb25zb2xlLmxvZyhcIl9zdGF0XCIsIHJlcXVlc3QpXG4gICAgYnJvd3Nlci5GaWxlLnN0YXQodGhpcy5maWxlKVxuICAgICAgLnRoZW4oc3RhdCA9PiByZXF1ZXN0LmNhbGxiYWNrKG51bGwsIHN0YXQpKVxuICAgICAgLmNhdGNoKGVycm9yID0+IHJlcXVlc3QuY2FsbGJhY2soZXJyb3IpKVxuICB9XG4gIF9jbG9zZShyZXF1ZXN0KSB7XG4gICAgY29uc29sZS5sb2coXCJfY2xvc2VcIiwgcmVxdWVzdClcbiAgICBicm93c2VyLkZpbGUuY2xvc2UodGhpcy5maWxlKVxuICAgICAgLnRoZW4oKCkgPT4gcmVxdWVzdC5jYWxsYmFjaygodGhpcy5maWxlID0gbnVsbCkpKVxuICAgICAgLmNhdGNoKGVycm9yID0+IHJlcXVlc3QuY2FsbGJhY2soZXJyb3IpKVxuICB9XG4gIF9kZXN0cm95KHJlcXVlc3QpIHtcbiAgICBjb25zb2xlLmxvZyhcIl9kZXN0cm95XCIsIHJlcXVlc3QpXG4gICAgYnJvd3Nlci5GaWxlU3lzdGVtLnJlbW92ZUZpbGUodGhpcy5maWxlVVJMLCB7IGlnbm9yZUFic2VudDogdHJ1ZSB9KVxuICAgICAgLnRoZW4oKCkgPT4gcmVxdWVzdC5jYWxsYmFjayhudWxsKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiByZXF1ZXN0LmNhbGxiYWNrKGVycm9yKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbUFjY2Vzc0ZpbGVcbiJdfQ==
